; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_mat_mult_fast_q15.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_mat_mult_fast_q15.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_mat_mult_fast_q15.crf src\MatrixFunctions\arm_mat_mult_fast_q15.c]
                          THUMB

                          AREA ||i.arm_mat_mult_fast_q15||, CODE, READONLY, ALIGN=2

                  arm_mat_mult_fast_q15 PROC
;;;84     
;;;85     arm_status arm_mat_mult_fast_q15(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;86       const arm_matrix_instance_q15 * pSrcA,
;;;87       const arm_matrix_instance_q15 * pSrcB,
;;;88       arm_matrix_instance_q15 * pDst,
;;;89       q15_t * pState)
;;;90     {
000004  4696              MOV      lr,r2
;;;91       q31_t sum;                                     /* accumulator */
;;;92       q15_t *pSrcBT = pState;                        /* input data matrix pointer for transpose */
;;;93       q15_t *pInA = pSrcA->pData;                    /* input data matrix pointer A of Q15 type */
;;;94       q15_t *pInB = pSrcB->pData;                    /* input data matrix pointer B of Q15 type */
;;;95       q15_t *px;                                     /* Temporary output data matrix pointer */
;;;96       uint16_t numRowsA = pSrcA->numRows;            /* number of rows of input matrix A    */
;;;97       uint16_t numColsB = pSrcB->numCols;            /* number of columns of input matrix B */
000006  884e              LDRH     r6,[r1,#2]
;;;98       uint16_t numColsA = pSrcA->numCols;            /* number of columns of input matrix A */
;;;99       uint16_t numRowsB = pSrcB->numRows;            /* number of rows of input matrix A    */
000008  684a              LDR      r2,[r1,#4]
00000a  8809              LDRH     r1,[r1,#0]
00000c  f8b0a000          LDRH     r10,[r0,#0]           ;96
000010  f8b0b002          LDRH     r11,[r0,#2]           ;98
;;;100      uint16_t col, i = 0u, row = numRowsB, colCnt;  /* loop counters */
000014  2700              MOVS     r7,#0
000016  4689              MOV      r9,r1
;;;101      arm_status status;                             /* status of matrix multiplication */
;;;102    
;;;103    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;104    
;;;105      q31_t in;                                      /* Temporary variable to hold the input value */
;;;106      q31_t inA1, inA2, inB1, inB2;
;;;107    
;;;108    #else
;;;109    
;;;110      q15_t in;                                      /* Temporary variable to hold the input value */
;;;111      q15_t inA1, inA2, inB1, inB2;
;;;112    
;;;113    #endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE	*/
;;;114    
;;;115    #ifdef ARM_MATH_MATRIX_CHECK
;;;116      /* Check for matrix mismatch condition */
;;;117      if((pSrcA->numCols != pSrcB->numRows) ||
;;;118         (pSrcA->numRows != pDst->numRows) || (pSrcB->numCols != pDst->numCols))
;;;119      {
;;;120        /* Set status as ARM_MATH_SIZE_MISMATCH */
;;;121        status = ARM_MATH_SIZE_MISMATCH;
;;;122      }
;;;123      else
;;;124    #endif
;;;125      {
;;;126        /* Matrix transpose */
;;;127        do
;;;128        {
;;;129          /* Apply loop unrolling and exchange the columns with row elements */
;;;130          col = numColsB >> 2;
000018  ea4f0896          LSR      r8,r6,#2
                  |L1.28|
00001c  4645              MOV      r5,r8
;;;131    
;;;132          /* The pointer px is set to starting address of the column being processed */
;;;133          px = pSrcBT + i;
00001e  eb030447          ADD      r4,r3,r7,LSL #1
;;;134    
;;;135          /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.        
;;;136           ** a second loop below computes the remaining 1 to 3 samples. */
;;;137          while(col > 0u)
000022  e018              B        |L1.86|
                  |L1.36|
;;;138          {
;;;139    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;140            /* Read two elements from the row */
;;;141            in = *__SIMD32(pInB)++;
000024  f852cb04          LDR      r12,[r2],#4
;;;142    
;;;143            /* Unpack and store one element in the destination */
;;;144    #ifndef ARM_MATH_BIG_ENDIAN
;;;145    
;;;146            *px = (q15_t) in;
000028  f8a4c000          STRH     r12,[r4,#0]
;;;147    
;;;148    #else
;;;149    
;;;150            *px = (q15_t) ((in & (q31_t) 0xffff0000) >> 16);
;;;151    
;;;152    #endif /*    #ifndef ARM_MATH_BIG_ENDIAN    */
;;;153    
;;;154            /* Update the pointer px to point to the next row of the transposed matrix */
;;;155            px += numRowsB;
00002c  eb040441          ADD      r4,r4,r1,LSL #1
;;;156    
;;;157            /* Unpack and store the second element in the destination */
;;;158    #ifndef ARM_MATH_BIG_ENDIAN
;;;159    
;;;160            *px = (q15_t) ((in & (q31_t) 0xffff0000) >> 16);
000030  ea4f4c2c          ASR      r12,r12,#16
000034  f8a4c000          STRH     r12,[r4,#0]
;;;161    
;;;162    #else
;;;163    
;;;164            *px = (q15_t) in;
;;;165    
;;;166    #endif /*    #ifndef ARM_MATH_BIG_ENDIAN    */
;;;167    
;;;168            /* Update the pointer px to point to the next row of the transposed matrix */
;;;169            px += numRowsB;
000038  eb040c41          ADD      r12,r4,r1,LSL #1
;;;170    
;;;171            /* Read two elements from the row */
;;;172            in = *__SIMD32(pInB)++;
00003c  f8524b04          LDR      r4,[r2],#4
;;;173    
;;;174            /* Unpack and store one element in the destination */
;;;175    #ifndef ARM_MATH_BIG_ENDIAN
;;;176    
;;;177            *px = (q15_t) in;
000040  f8ac4000          STRH     r4,[r12,#0]
;;;178    
;;;179    #else
;;;180    
;;;181            *px = (q15_t) ((in & (q31_t) 0xffff0000) >> 16);
;;;182    
;;;183    #endif /*    #ifndef ARM_MATH_BIG_ENDIAN    */
;;;184    
;;;185            /* Update the pointer px to point to the next row of the transposed matrix */
;;;186            px += numRowsB;
;;;187    
;;;188            /* Unpack and store the second element in the destination */
;;;189    
;;;190    #ifndef ARM_MATH_BIG_ENDIAN
;;;191    
;;;192            *px = (q15_t) ((in & (q31_t) 0xffff0000) >> 16);
000044  1424              ASRS     r4,r4,#16
000046  eb0c0c41          ADD      r12,r12,r1,LSL #1     ;186
;;;193    
;;;194    #else
;;;195    
;;;196            *px = (q15_t) in;
;;;197    
;;;198    #endif /*    #ifndef ARM_MATH_BIG_ENDIAN    */
;;;199    
;;;200    #else
;;;201    
;;;202            /* Read one element from the row */
;;;203            in = *pInB++;
;;;204    
;;;205            /* Store one element in the destination */
;;;206            *px = in;
;;;207     
;;;208            /* Update the pointer px to point to the next row of the transposed matrix */
;;;209            px += numRowsB;
;;;210    
;;;211            /* Read one element from the row */
;;;212            in = *pInB++;
;;;213    
;;;214            /* Store one element in the destination */
;;;215            *px = in;
;;;216     
;;;217            /* Update the pointer px to point to the next row of the transposed matrix */
;;;218            px += numRowsB;
;;;219    
;;;220            /* Read one element from the row */
;;;221            in = *pInB++;
;;;222    
;;;223            /* Store one element in the destination */
;;;224            *px = in;
;;;225     
;;;226            /* Update the pointer px to point to the next row of the transposed matrix */
;;;227            px += numRowsB;
;;;228    
;;;229            /* Read one element from the row */
;;;230            in = *pInB++;
;;;231    
;;;232            /* Store one element in the destination */
;;;233            *px = in;
;;;234    
;;;235    #endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE	*/
;;;236            
;;;237    		/* Update the pointer px to point to the next row of the transposed matrix */
;;;238            px += numRowsB;
00004a  1e6d              SUBS     r5,r5,#1
00004c  f8ac4000          STRH     r4,[r12,#0]           ;192
000050  eb0c0441          ADD      r4,r12,r1,LSL #1
;;;239    
;;;240            /* Decrement the column loop counter */
;;;241            col--;
000054  b2ad              UXTH     r5,r5
                  |L1.86|
000056  2d00              CMP      r5,#0                 ;137
000058  d1e4              BNE      |L1.36|
;;;242          }
;;;243    
;;;244          /* If the columns of pSrcB is not a multiple of 4, compute any remaining output samples here.        
;;;245           ** No loop unrolling is used. */
;;;246          col = numColsB % 0x4u;
00005a  f0060503          AND      r5,r6,#3
;;;247    
;;;248          while(col > 0u)
00005e  e007              B        |L1.112|
                  |L1.96|
;;;249          {
;;;250            /* Read and store the input element in the destination */
;;;251            *px = *pInB++;
000060  f832cb02          LDRH     r12,[r2],#2
000064  f8a4c000          STRH     r12,[r4,#0]
;;;252    
;;;253            /* Update the pointer px to point to the next row of the transposed matrix */
;;;254            px += numRowsB;
000068  1e6d              SUBS     r5,r5,#1
00006a  eb040441          ADD      r4,r4,r1,LSL #1
;;;255    
;;;256            /* Decrement the column loop counter */
;;;257            col--;
00006e  b2ad              UXTH     r5,r5
                  |L1.112|
000070  2d00              CMP      r5,#0                 ;248
000072  d1f5              BNE      |L1.96|
000074  1c7f              ADDS     r7,r7,#1              ;248
;;;258          }
;;;259    
;;;260          i++;
;;;261    
;;;262          /* Decrement the row loop counter */
;;;263          row--;
000076  f1a90401          SUB      r4,r9,#1
00007a  b2a4              UXTH     r4,r4
00007c  b2bf              UXTH     r7,r7                 ;260
00007e  ea5f0904          MOVS     r9,r4
;;;264    
;;;265        } while(row > 0u);
000082  d1cb              BNE      |L1.28|
;;;266    
;;;267        /* Reset the variables for the usage in the following multiplication process */
;;;268        row = numRowsA;
;;;269        i = 0u;
;;;270        px = pDst->pData;
000084  f8cda000          STR      r10,[sp,#0]
000088  f8de1004          LDR      r1,[lr,#4]
;;;271    
;;;272        /* The following loop performs the dot-product of each row in pSrcA with each column in pSrcB */
;;;273        /* row loop */
;;;274        do
;;;275        {
;;;276          /* For every row wise process, the column loop counter is to be initiated */
;;;277          col = numColsB;
;;;278    
;;;279          /* For every row wise process, the pIn2 pointer is set        
;;;280           ** to the starting address of the transposed pSrcB data */
;;;281          pInB = pSrcBT;
;;;282    
;;;283          /* column loop */
;;;284          do
;;;285          {
;;;286            /* Set the variable sum, that acts as accumulator, to zero */
;;;287            sum = 0;
;;;288    
;;;289            /* Apply loop unrolling and compute 2 MACs simultaneously. */
;;;290            colCnt = numColsA >> 2;
00008c  9101              STR      r1,[sp,#4]
00008e  ea4f019b          LSR      r1,r11,#2
000092  2700              MOVS     r7,#0                 ;269
000094  9103              STR      r1,[sp,#0xc]
                  |L1.150|
000096  46b2              MOV      r10,r6                ;277
000098  4619              MOV      r1,r3                 ;281
                  |L1.154|
;;;291    
;;;292            /* Initiate the pointer pIn1 to point to the starting address of the column being processed */
;;;293            pInA = pSrcA->pData + i;
00009a  6842              LDR      r2,[r0,#4]
00009c  2400              MOVS     r4,#0                 ;287
00009e  9d03              LDR      r5,[sp,#0xc]
0000a0  eb020247          ADD      r2,r2,r7,LSL #1
;;;294    
;;;295            /* matrix multiplication */
;;;296            while(colCnt > 0u)
0000a4  e010              B        |L1.200|
;;;297            {
;;;298              /* c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n) */
;;;299    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;300    
;;;301              inA1 = *__SIMD32(pInA)++;
0000a6  bf00              NOP      
                  |L1.168|
0000a8  f8528b04          LDR      r8,[r2],#4
;;;302              inB1 = *__SIMD32(pInB)++;
0000ac  f8cd8008          STR      r8,[sp,#8]
0000b0  f851cb04          LDR      r12,[r1],#4
;;;303              inA2 = *__SIMD32(pInA)++;
0000b4  f852eb04          LDR      lr,[r2],#4
;;;304              inB2 = *__SIMD32(pInB)++;
0000b8  f8519b04          LDR      r9,[r1],#4
;;;305    
;;;306              sum = __SMLAD(inA1, inB1, sum);
0000bc  fb28440c          SMLAD    r4,r8,r12,r4
;;;307              sum = __SMLAD(inA2, inB2, sum);
0000c0  fb2e4409          SMLAD    r4,lr,r9,r4
0000c4  1e6d              SUBS     r5,r5,#1
;;;308    
;;;309    #else
;;;310    
;;;311              inA1 = *pInA++;
;;;312              inB1 = *pInB++;
;;;313              inA2 = *pInA++;
;;;314              sum += inA1 * inB1;
;;;315              inB2 = *pInB++;
;;;316    
;;;317              inA1 = *pInA++;
;;;318              inB1 = *pInB++;
;;;319              sum += inA2 * inB2;
;;;320              inA2 = *pInA++;
;;;321              inB2 = *pInB++;
;;;322    
;;;323              sum += inA1 * inB1;
;;;324              sum += inA2 * inB2;
;;;325    
;;;326    #endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE	*/
;;;327    
;;;328              /* Decrement the loop counter */
;;;329              colCnt--;
0000c6  b2ad              UXTH     r5,r5
                  |L1.200|
0000c8  2d00              CMP      r5,#0                 ;296
0000ca  d1ed              BNE      |L1.168|
;;;330            }
;;;331    
;;;332            /* process odd column samples */
;;;333            colCnt = numColsA % 0x4u;
0000cc  f00b0503          AND      r5,r11,#3
;;;334    
;;;335            while(colCnt > 0u)
0000d0  e008              B        |L1.228|
;;;336            {
;;;337              /* c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n) */
;;;338              sum += (q31_t) (*pInA++) * (*pInB++);
0000d2  bf00              NOP      
                  |L1.212|
0000d4  f832cb02          LDRH     r12,[r2],#2
0000d8  f8318b02          LDRH     r8,[r1],#2
0000dc  fb1c4408          SMLABB   r4,r12,r8,r4
0000e0  1e6d              SUBS     r5,r5,#1
;;;339    
;;;340              colCnt--;
0000e2  b2ad              UXTH     r5,r5
                  |L1.228|
0000e4  2d00              CMP      r5,#0                 ;335
0000e6  d1f5              BNE      |L1.212|
;;;341            }
;;;342    
;;;343            /* Saturate and store the result in the destination buffer */
;;;344            *px = (q15_t) (sum >> 15);
0000e8  9a01              LDR      r2,[sp,#4]
0000ea  13e4              ASRS     r4,r4,#15
0000ec  8014              STRH     r4,[r2,#0]
;;;345            px++;
0000ee  9a01              LDR      r2,[sp,#4]
0000f0  1c92              ADDS     r2,r2,#2
;;;346    
;;;347            /* Decrement the column loop counter */
;;;348            col--;
0000f2  9201              STR      r2,[sp,#4]
0000f4  f1aa0201          SUB      r2,r10,#1
0000f8  b292              UXTH     r2,r2
0000fa  ea5f0a02          MOVS     r10,r2
;;;349    
;;;350          } while(col > 0u);
0000fe  d1cc              BNE      |L1.154|
;;;351    
;;;352          i = i + numColsA;
000100  eb07010b          ADD      r1,r7,r11
000104  b28f              UXTH     r7,r1
;;;353    
;;;354          /* Decrement the row loop counter */
;;;355          row--;
000106  9900              LDR      r1,[sp,#0]
000108  1e49              SUBS     r1,r1,#1
00010a  0409              LSLS     r1,r1,#16
00010c  0c09              LSRS     r1,r1,#16
;;;356    
;;;357        } while(row > 0u);
00010e  9100              STR      r1,[sp,#0]
000110  d1c1              BNE      |L1.150|
;;;358    
;;;359        /* set status as ARM_MATH_SUCCESS */
;;;360        status = ARM_MATH_SUCCESS;
;;;361      }
;;;362    
;;;363      /* Return to application */
;;;364      return (status);
;;;365    }
000112  b004              ADD      sp,sp,#0x10
000114  2000              MOVS     r0,#0                 ;360
000116  e8bd8ff0          POP      {r4-r11,pc}
;;;366    
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\MatrixFunctions\\arm_mat_mult_fast_q15.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___23_arm_mat_mult_fast_q15_c_9c634344____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___23_arm_mat_mult_fast_q15_c_9c634344____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___23_arm_mat_mult_fast_q15_c_9c634344____REVSH|
#line 144
|__asm___23_arm_mat_mult_fast_q15_c_9c634344____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___23_arm_mat_mult_fast_q15_c_9c634344____RRX|
#line 300
|__asm___23_arm_mat_mult_fast_q15_c_9c634344____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
