; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_cmplx_mult_cmplx_f32.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_cmplx_mult_cmplx_f32.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_cmplx_mult_cmplx_f32.crf src\ComplexMathFunctions\arm_cmplx_mult_cmplx_f32.c]
                          THUMB

                          AREA ||i.arm_cmplx_mult_cmplx_f32||, CODE, READONLY, ALIGN=2

                  arm_cmplx_mult_cmplx_f32 PROC
;;;82     
;;;83     void arm_cmplx_mult_cmplx_f32(
000000  b510              PUSH     {r4,lr}
;;;84       float32_t * pSrcA,
;;;85       float32_t * pSrcB,
;;;86       float32_t * pDst,
;;;87       uint32_t numSamples)
;;;88     {
;;;89       float32_t a1, b1, c1, d1;                      /* Temporary variables to store real and imaginary values */
;;;90       uint32_t blkCnt;                               /* loop counters */
;;;91     
;;;92     #ifndef ARM_MATH_CM0_FAMILY
;;;93     
;;;94       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;95       float32_t a2, b2, c2, d2;                      /* Temporary variables to store real and imaginary values */
;;;96       float32_t acc1, acc2, acc3, acc4;
;;;97     
;;;98     
;;;99       /* loop Unrolling */
;;;100      blkCnt = numSamples >> 2u;
000002  089c              LSRS     r4,r3,#2
000004  e051              B        |L1.170|
;;;101    
;;;102      /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.        
;;;103       ** a second loop below computes the remaining 1 to 3 samples. */
;;;104      while(blkCnt > 0u)
;;;105      {
;;;106        /* C[2 * i] = A[2 * i] * B[2 * i] - A[2 * i + 1] * B[2 * i + 1].  */
;;;107        /* C[2 * i + 1] = A[2 * i] * B[2 * i + 1] + A[2 * i + 1] * B[2 * i].  */
;;;108        a1 = *pSrcA;                /* A[2 * i] */
000006  bf00              NOP      
                  |L1.8|
000008  edd01a00          VLDR     s3,[r0,#0]
;;;109        c1 = *pSrcB;                /* B[2 * i] */
00000c  ed911a00          VLDR     s2,[r1,#0]
;;;110    
;;;111        b1 = *(pSrcA + 1);          /* A[2 * i + 1] */
000010  ed900a01          VLDR     s0,[r0,#4]
;;;112        acc1 = a1 * c1;             /* acc1 = A[2 * i] * B[2 * i] */
;;;113    
;;;114        a2 = *(pSrcA + 2);          /* A[2 * i + 2] */
;;;115        acc2 = (b1 * c1);           /* acc2 = A[2 * i + 1] * B[2 * i] */
;;;116    
;;;117        d1 = *(pSrcB + 1);          /* B[2 * i + 1] */
000014  ed914a01          VLDR     s8,[r1,#4]
000018  ee610a81          VMUL.F32 s1,s3,s2              ;112
00001c  ee201a01          VMUL.F32 s2,s0,s2              ;115
000020  edd02a02          VLDR     s5,[r0,#8]            ;114
;;;118        c2 = *(pSrcB + 2);          /* B[2 * i + 2] */
000024  ed913a02          VLDR     s6,[r1,#8]
;;;119        acc1 -= b1 * d1;            /* acc1 =      A[2 * i] * B[2 * i] - A[2 * i + 1] * B[2 * i + 1] */
000028  ee400a44          VMLS.F32 s1,s0,s8
;;;120    
;;;121        d2 = *(pSrcB + 3);          /* B[2 * i + 3] */
00002c  ed912a03          VLDR     s4,[r1,#0xc]
;;;122        acc3 = a2 * c2;             /* acc3 =       A[2 * i + 2] * B[2 * i + 2] */
000030  ee220a83          VMUL.F32 s0,s5,s6
;;;123    
;;;124        b2 = *(pSrcA + 3);          /* A[2 * i + 3] */
000034  edd03a03          VLDR     s7,[r0,#0xc]
;;;125        acc2 += (a1 * d1);          /* acc2 =      A[2 * i + 1] * B[2 * i] + A[2 * i] * B[2 * i + 1] */
000038  ee011a84          VMLA.F32 s2,s3,s8
;;;126    
;;;127        a1 = *(pSrcA + 4);          /* A[2 * i + 4] */
;;;128        acc4 = (a2 * d2);           /* acc4 =   A[2 * i + 2] * B[2 * i + 3] */
00003c  ee622a82          VMUL.F32 s5,s5,s4
000040  edd01a04          VLDR     s3,[r0,#0x10]         ;127
;;;129    
;;;130        c1 = *(pSrcB + 4);          /* B[2 * i + 4] */
000044  ed914a04          VLDR     s8,[r1,#0x10]
;;;131        acc3 -= (b2 * d2);          /* acc3 =       A[2 * i + 2] * B[2 * i + 2] - A[2 * i + 3] * B[2 * i + 3] */
000048  ee030ac2          VMLS.F32 s0,s7,s4
;;;132        *pDst = acc1;               /* C[2 * i] = A[2 * i] * B[2 * i] - A[2 * i + 1] * B[2 * i + 1] */
00004c  edc20a00          VSTR     s1,[r2,#0]
;;;133    
;;;134        b1 = *(pSrcA + 5);          /* A[2 * i + 5] */
000050  ed902a05          VLDR     s4,[r0,#0x14]
;;;135        acc4 += b2 * c2;            /* acc4 =   A[2 * i + 2] * B[2 * i + 3] + A[2 * i + 3] * B[2 * i + 2] */
000054  ee432a83          VMLA.F32 s5,s7,s6
;;;136    
;;;137        *(pDst + 1) = acc2;         /* C[2 * i + 1] = A[2 * i + 1] * B[2 * i] + A[2 * i] * B[2 * i + 1]  */
000058  ed821a01          VSTR     s2,[r2,#4]
;;;138        acc1 = (a1 * c1);
;;;139    
;;;140        d1 = *(pSrcB + 5);
00005c  ed913a05          VLDR     s6,[r1,#0x14]
000060  ee610a84          VMUL.F32 s1,s3,s8              ;138
;;;141        acc2 = (b1 * c1);
000064  ee221a04          VMUL.F32 s2,s4,s8
;;;142    
;;;143        *(pDst + 2) = acc3;
000068  ed820a02          VSTR     s0,[r2,#8]
;;;144        *(pDst + 3) = acc4;
00006c  edc22a03          VSTR     s5,[r2,#0xc]
;;;145    
;;;146        a2 = *(pSrcA + 6);
000070  edd02a06          VLDR     s5,[r0,#0x18]
;;;147        acc1 -= (b1 * d1);
000074  ee420a43          VMLS.F32 s1,s4,s6
;;;148    
;;;149        c2 = *(pSrcB + 6);
000078  ed910a06          VLDR     s0,[r1,#0x18]
;;;150        acc2 += (a1 * d1);
00007c  ee011a83          VMLA.F32 s2,s3,s6
;;;151    
;;;152        b2 = *(pSrcA + 7);
000080  ed903a07          VLDR     s6,[r0,#0x1c]
;;;153        acc3 = (a2 * c2);
000084  ee621a80          VMUL.F32 s3,s5,s0
;;;154    
;;;155        d2 = *(pSrcB + 7);
000088  ed912a07          VLDR     s4,[r1,#0x1c]
;;;156        acc4 = (b2 * c2);
00008c  ee230a00          VMUL.F32 s0,s6,s0
;;;157    
;;;158        *(pDst + 4) = acc1;
;;;159        pSrcA += 8u;
;;;160    
;;;161        acc3 -= (b2 * d2);
;;;162        acc4 += (a2 * d2);
;;;163    
;;;164        *(pDst + 5) = acc2;
;;;165        pSrcB += 8u;
;;;166    
;;;167        *(pDst + 6) = acc3;
;;;168        *(pDst + 7) = acc4;
000090  3020              ADDS     r0,r0,#0x20
000092  ee431a42          VMLS.F32 s3,s6,s4              ;161
000096  3120              ADDS     r1,r1,#0x20
000098  ee020a82          VMLA.F32 s0,s5,s4              ;162
00009c  ed820a07          VSTR     s0,[r2,#0x1c]
0000a0  3210              ADDS     r2,r2,#0x10
0000a2  ecc20a03          VSTM     r2,{s1-s3}
0000a6  3210              ADDS     r2,r2,#0x10
0000a8  1e64              SUBS     r4,r4,#1
                  |L1.170|
0000aa  2c00              CMP      r4,#0                 ;104
0000ac  d1ac              BNE      |L1.8|
;;;169    
;;;170        pDst += 8u;
;;;171    
;;;172        /* Decrement the numSamples loop counter */
;;;173        blkCnt--;
;;;174      }
;;;175    
;;;176      /* If the numSamples is not a multiple of 4, compute any remaining output samples here.        
;;;177       ** No loop unrolling is used. */
;;;178      blkCnt = numSamples % 0x4u;
0000ae  f0030303          AND      r3,r3,#3
;;;179    
;;;180    #else
;;;181    
;;;182      /* Run the below code for Cortex-M0 */
;;;183      blkCnt = numSamples;
;;;184    
;;;185    #endif /* #ifndef ARM_MATH_CM0_FAMILY */
;;;186    
;;;187      while(blkCnt > 0u)
0000b2  e017              B        |L1.228|
                  |L1.180|
;;;188      {
;;;189        /* C[2 * i] = A[2 * i] * B[2 * i] - A[2 * i + 1] * B[2 * i + 1].  */
;;;190        /* C[2 * i + 1] = A[2 * i] * B[2 * i + 1] + A[2 * i + 1] * B[2 * i].  */
;;;191        a1 = *pSrcA++;
0000b4  ed901a00          VLDR     s2,[r0,#0]
;;;192        b1 = *pSrcA++;
;;;193        c1 = *pSrcB++;
0000b8  ed910a00          VLDR     s0,[r1,#0]
0000bc  edd01a01          VLDR     s3,[r0,#4]            ;192
;;;194        d1 = *pSrcB++;
0000c0  edd10a01          VLDR     s1,[r1,#4]
;;;195    
;;;196        /* store the result in the destination buffer. */
;;;197        *pDst++ = (a1 * c1) - (b1 * d1);
0000c4  ee212a00          VMUL.F32 s4,s2,s0
;;;198        *pDst++ = (a1 * d1) + (b1 * c1);
0000c8  3008              ADDS     r0,r0,#8
0000ca  3108              ADDS     r1,r1,#8
0000cc  ee012ae0          VMLS.F32 s4,s3,s1              ;197
0000d0  ee610a20          VMUL.F32 s1,s2,s1
0000d4  ee410a80          VMLA.F32 s1,s3,s0
0000d8  ed822a00          VSTR     s4,[r2,#0]            ;197
0000dc  edc20a01          VSTR     s1,[r2,#4]
0000e0  3208              ADDS     r2,r2,#8
0000e2  1e5b              SUBS     r3,r3,#1
                  |L1.228|
0000e4  2b00              CMP      r3,#0                 ;187
0000e6  d1e5              BNE      |L1.180|
;;;199    
;;;200        /* Decrement the numSamples loop counter */
;;;201        blkCnt--;
;;;202      }
;;;203    }
0000e8  bd10              POP      {r4,pc}
;;;204    
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\ComplexMathFunctions\\arm_cmplx_mult_cmplx_f32.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___26_arm_cmplx_mult_cmplx_f32_c_f7e18109____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___26_arm_cmplx_mult_cmplx_f32_c_f7e18109____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___26_arm_cmplx_mult_cmplx_f32_c_f7e18109____REVSH|
#line 144
|__asm___26_arm_cmplx_mult_cmplx_f32_c_f7e18109____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___26_arm_cmplx_mult_cmplx_f32_c_f7e18109____RRX|
#line 300
|__asm___26_arm_cmplx_mult_cmplx_f32_c_f7e18109____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
