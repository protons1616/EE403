; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_fir_interpolate_f32.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_fir_interpolate_f32.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_fir_interpolate_f32.crf src\FilteringFunctions\arm_fir_interpolate_f32.c]
                          THUMB

                          AREA ||i.arm_fir_interpolate_f32||, CODE, READONLY, ALIGN=2

                  arm_fir_interpolate_f32 PROC
;;;147    
;;;148    void arm_fir_interpolate_f32(
000000  e92d4ffc          PUSH     {r2-r11,lr}
;;;149      const arm_fir_interpolate_instance_f32 * S,
;;;150      float32_t * pSrc,
;;;151      float32_t * pDst,
;;;152      uint32_t blockSize)
;;;153    {
000004  4693              MOV      r11,r2
000006  e9d04201          LDRD     r4,r2,[r0,#4]
;;;154      float32_t *pState = S->pState;                 /* State pointer */
;;;155      float32_t *pCoeffs = S->pCoeffs;               /* Coefficient pointer */
;;;156      float32_t *pStateCurnt;                        /* Points to the current sample of the state */
;;;157      float32_t *ptr1, *ptr2;                        /* Temporary pointers for state and coefficient buffers */
;;;158      float32_t sum0;                                /* Accumulators */
;;;159      float32_t x0, c0;                              /* Temporary variables to hold state and coefficient values */
;;;160      uint32_t i, blkCnt, j;                         /* Loop counters */
;;;161      uint16_t phaseLen = S->phaseLength, tapCnt;    /* Length of each polyphase filter component */
00000a  9401              STR      r4,[sp,#4]
00000c  8845              LDRH     r5,[r0,#2]
;;;162      float32_t acc0, acc1, acc2, acc3;
;;;163      float32_t x1, x2, x3;
;;;164      uint32_t blkCntN4;
;;;165      float32_t c1, c2, c3;
;;;166    
;;;167      /* S->pState buffer contains previous frame (phaseLen - 1) samples */
;;;168      /* pStateCurnt points to the location where the new input data should be written */
;;;169      pStateCurnt = S->pState + (phaseLen - 1u);
00000e  f06f0403          MVN      r4,#3
;;;170    
;;;171      /* Initialise  blkCnt */
;;;172      blkCnt = blockSize / 4;
000012  ea4f0993          LSR      r9,r3,#2
000016  eb040485          ADD      r4,r4,r5,LSL #2       ;169
;;;173      blkCntN4 = blockSize - (4 * blkCnt);
00001a  f1c90600          RSB      r6,r9,#0
00001e  4414              ADD      r4,r4,r2              ;169
000020  eb030e86          ADD      lr,r3,r6,LSL #2
;;;174    
;;;175      /* Samples loop unrolled by 4 */
;;;176      while(blkCnt > 0u)
;;;177      {
;;;178        /* Copy new input sample into the state buffer */
;;;179        *pStateCurnt++ = *pSrc++;
;;;180        *pStateCurnt++ = *pSrc++;
;;;181        *pStateCurnt++ = *pSrc++;
;;;182        *pStateCurnt++ = *pSrc++;
;;;183    
;;;184        /* Address modifier index of coefficient buffer */
;;;185        j = 1u;
;;;186    
;;;187        /* Loop over the Interpolation factor. */
;;;188        i = (S->L);
;;;189    
;;;190        while(i > 0u)
;;;191        {
;;;192          /* Set accumulator to zero */
;;;193          acc0 = 0.0f;
000024  eddf4aa5          VLDR     s9,|L1.700|
000028  e0b9              B        |L1.414|
00002a  bf00              NOP                            ;179
                  |L1.44|
00002c  ed910a00          VLDR     s0,[r1,#0]            ;179
000030  2301              MOVS     r3,#1                 ;185
000032  ed840a00          VSTR     s0,[r4,#0]            ;179
000036  ed910a01          VLDR     s0,[r1,#4]            ;180
00003a  ed840a01          VSTR     s0,[r4,#4]            ;180
00003e  ed910a02          VLDR     s0,[r1,#8]            ;181
000042  ed840a02          VSTR     s0,[r4,#8]            ;181
000046  ed910a03          VLDR     s0,[r1,#0xc]          ;182
00004a  3110              ADDS     r1,r1,#0x10           ;188
00004c  ed840a03          VSTR     s0,[r4,#0xc]          ;182
000050  9300              STR      r3,[sp,#0]            ;188
000052  f890a000          LDRB     r10,[r0,#0]           ;188
000056  3410              ADDS     r4,r4,#0x10           ;188
000058  e095              B        |L1.390|
00005a  bf00              NOP      
                  |L1.92|
;;;194          acc1 = 0.0f;
;;;195          acc2 = 0.0f;
;;;196          acc3 = 0.0f;
;;;197    
;;;198          /* Initialize state pointer */
;;;199          ptr1 = pState;
;;;200    
;;;201          /* Initialize coefficient pointer */
;;;202          ptr2 = pCoeffs + (S->L - j);
00005c  7807              LDRB     r7,[r0,#0]
00005e  9b00              LDR      r3,[sp,#0]
000060  eeb00a64          VMOV.F32 s0,s9                 ;193
000064  1afe              SUBS     r6,r7,r3
000066  9b01              LDR      r3,[sp,#4]
000068  eef00a40          VMOV.F32 s1,s0                 ;194
00006c  eb030686          ADD      r6,r3,r6,LSL #2
000070  eeb01a40          VMOV.F32 s2,s0                 ;195
000074  eef01a40          VMOV.F32 s3,s0                 ;196
;;;203    
;;;204          /* Loop over the polyPhase length. Unroll by a factor of 4.        
;;;205           ** Repeat until we've computed numTaps-(4*S->L) coefficients. */
;;;206          tapCnt = phaseLen >> 2u;
000078  ea4f0c95          LSR      r12,r5,#2
;;;207    
;;;208          x0 = *(ptr1++);
00007c  ed923a00          VLDR     s6,[r2,#0]
;;;209          x1 = *(ptr1++);
000080  ed922a01          VLDR     s4,[r2,#4]
;;;210          x2 = *(ptr1++);
000084  edd22a02          VLDR     s5,[r2,#8]
000088  f102030c          ADD      r3,r2,#0xc
;;;211    
;;;212          while(tapCnt > 0u)
00008c  e03f              B        |L1.270|
;;;213          {
;;;214    
;;;215            /* Read the input sample */
;;;216            x3 = *(ptr1++);
00008e  bf00              NOP      
                  |L1.144|
;;;217    
;;;218            /* Read the coefficient */
;;;219            c0 = *(ptr2);
000090  edd63a00          VLDR     s7,[r6,#0]
000094  ed934a00          VLDR     s8,[r3,#0]            ;216
;;;220    
;;;221            /* Perform the multiply-accumulate */
;;;222            acc0 += x0 * c0;
;;;223            acc1 += x1 * c0;
;;;224            acc2 += x2 * c0;
;;;225            acc3 += x3 * c0;
;;;226    
;;;227            /* Read the coefficient */
;;;228            c1 = *(ptr2 + S->L);
000098  eb060887          ADD      r8,r6,r7,LSL #2
00009c  ee030a23          VMLA.F32 s0,s6,s7              ;222
0000a0  ee420a23          VMLA.F32 s1,s4,s7              ;223
0000a4  ee021aa3          VMLA.F32 s2,s5,s7              ;224
0000a8  ee441a23          VMLA.F32 s3,s8,s7              ;225
0000ac  edd83a00          VLDR     s7,[r8,#0]
;;;229    
;;;230            /* Read the input sample */
;;;231            x0 = *(ptr1++);
0000b0  ed933a01          VLDR     s6,[r3,#4]
;;;232    
;;;233            /* Perform the multiply-accumulate */
;;;234            acc0 += x1 * c1;
;;;235            acc1 += x2 * c1;
;;;236            acc2 += x3 * c1;
;;;237            acc3 += x0 * c1;
;;;238    
;;;239            /* Read the coefficient */
;;;240            c2 = *(ptr2 + S->L * 2);
0000b4  eb0608c7          ADD      r8,r6,r7,LSL #3
0000b8  ee020a23          VMLA.F32 s0,s4,s7              ;234
0000bc  ee420aa3          VMLA.F32 s1,s5,s7              ;235
0000c0  ee041a23          VMLA.F32 s2,s8,s7              ;236
0000c4  ee431a23          VMLA.F32 s3,s6,s7              ;237
0000c8  edd83a00          VLDR     s7,[r8,#0]
;;;241    
;;;242            /* Read the input sample */
;;;243            x1 = *(ptr1++);
0000cc  ed932a02          VLDR     s4,[r3,#8]
;;;244    
;;;245            /* Perform the multiply-accumulate */
;;;246            acc0 += x2 * c2;
;;;247            acc1 += x3 * c2;
;;;248            acc2 += x0 * c2;
;;;249            acc3 += x1 * c2;
;;;250    
;;;251            /* Read the coefficient */
;;;252            c3 = *(ptr2 + S->L * 3);
0000d0  eb070847          ADD      r8,r7,r7,LSL #1
0000d4  eb060888          ADD      r8,r6,r8,LSL #2
0000d8  ee020aa3          VMLA.F32 s0,s5,s7              ;246
0000dc  ee440a23          VMLA.F32 s1,s8,s7              ;247
0000e0  ee031a23          VMLA.F32 s2,s6,s7              ;248
0000e4  ee421a23          VMLA.F32 s3,s4,s7              ;249
0000e8  edd83a00          VLDR     s7,[r8,#0]
;;;253    
;;;254            /* Read the input sample */
;;;255            x2 = *(ptr1++);
0000ec  edd32a03          VLDR     s5,[r3,#0xc]
;;;256    
;;;257            /* Perform the multiply-accumulate */
;;;258            acc0 += x3 * c3;
;;;259            acc1 += x0 * c3;
;;;260            acc2 += x1 * c3;
;;;261            acc3 += x2 * c3;
;;;262    
;;;263    
;;;264            /* Upsampling is done by stuffing L-1 zeros between each sample.        
;;;265             * So instead of multiplying zeros with coefficients,        
;;;266             * Increment the coefficient pointer by interpolation factor times. */
;;;267            ptr2 += 4 * S->L;
0000f0  f1ac0c01          SUB      r12,r12,#1
0000f4  ee040a23          VMLA.F32 s0,s8,s7              ;258
0000f8  ee430a23          VMLA.F32 s1,s6,s7              ;259
0000fc  ee021a23          VMLA.F32 s2,s4,s7              ;260
000100  ee421aa3          VMLA.F32 s3,s5,s7              ;261
000104  eb061607          ADD      r6,r6,r7,LSL #4
;;;268    
;;;269            /* Decrement the loop counter */
;;;270            tapCnt--;
000108  fa1ffc8c          UXTH     r12,r12
00010c  3310              ADDS     r3,r3,#0x10
                  |L1.270|
00010e  f1bc0f00          CMP      r12,#0                ;212
000112  d1bd              BNE      |L1.144|
;;;271          }
;;;272    
;;;273          /* If the polyPhase length is not a multiple of 4, compute the remaining filter taps */
;;;274          tapCnt = phaseLen % 0x4u;
000114  f0050c03          AND      r12,r5,#3
;;;275    
;;;276          while(tapCnt > 0u)
000118  e018              B        |L1.332|
;;;277          {
;;;278    
;;;279            /* Read the input sample */
;;;280            x3 = *(ptr1++);
00011a  bf00              NOP      
                  |L1.284|
;;;281    
;;;282            /* Read the coefficient */
;;;283            c0 = *(ptr2);
00011c  edd63a00          VLDR     s7,[r6,#0]
;;;284    
;;;285            /* Perform the multiply-accumulate */
;;;286            acc0 += x0 * c0;
;;;287            acc1 += x1 * c0;
;;;288            acc2 += x2 * c0;
;;;289            acc3 += x3 * c0;
;;;290    
;;;291            /* Increment the coefficient pointer by interpolation factor times. */
;;;292            ptr2 += S->L;
;;;293    
;;;294            /* update states for next sample processing */
;;;295            x0 = x1;
;;;296            x1 = x2;
;;;297            x2 = x3;
000120  f1ac0c01          SUB      r12,r12,#1
000124  ecb34a01          VLDM     r3!,{s8}              ;280
000128  ee030a23          VMLA.F32 s0,s6,s7              ;286
00012c  ee420a23          VMLA.F32 s1,s4,s7              ;287
000130  ee021aa3          VMLA.F32 s2,s5,s7              ;288
000134  eeb03a42          VMOV.F32 s6,s4                 ;295
000138  ee441a23          VMLA.F32 s3,s8,s7              ;289
00013c  eeb02a62          VMOV.F32 s4,s5                 ;296
000140  eb060687          ADD      r6,r6,r7,LSL #2       ;292
000144  eef02a44          VMOV.F32 s5,s8
;;;298    
;;;299            /* Decrement the loop counter */
;;;300            tapCnt--;
000148  fa1ffc8c          UXTH     r12,r12
                  |L1.332|
00014c  f1bc0f00          CMP      r12,#0                ;276
000150  d1e4              BNE      |L1.284|
;;;301          }
;;;302    
;;;303          /* The result is in the accumulator, store in the destination buffer. */
;;;304          *pDst = acc0;
000152  ed8b0a00          VSTR     s0,[r11,#0]
;;;305          *(pDst + S->L) = acc1;
000156  7806              LDRB     r6,[r0,#0]
;;;306          *(pDst + 2 * S->L) = acc2;
;;;307          *(pDst + 3 * S->L) = acc3;
;;;308    
;;;309          pDst++;
;;;310    
;;;311          /* Increment the address modifier index of coefficient buffer */
;;;312          j++;
;;;313    
;;;314          /* Decrement the loop counter */
;;;315          i--;
000158  f1aa0a01          SUB      r10,r10,#1
00015c  eb0b0386          ADD      r3,r11,r6,LSL #2      ;305
000160  edc30a00          VSTR     s1,[r3,#0]            ;305
000164  7806              LDRB     r6,[r0,#0]            ;306
000166  eb0b03c6          ADD      r3,r11,r6,LSL #3      ;306
00016a  ed831a00          VSTR     s2,[r3,#0]            ;306
00016e  7803              LDRB     r3,[r0,#0]            ;307
000170  eb030643          ADD      r6,r3,r3,LSL #1       ;307
000174  eb0b0386          ADD      r3,r11,r6,LSL #2      ;307
000178  f10b0b04          ADD      r11,r11,#4            ;309
00017c  edc31a00          VSTR     s3,[r3,#0]            ;307
000180  9b00              LDR      r3,[sp,#0]            ;312
000182  1c5b              ADDS     r3,r3,#1              ;312
000184  9300              STR      r3,[sp,#0]
                  |L1.390|
000186  f1ba0f00          CMP      r10,#0                ;190
00018a  f47faf67          BNE      |L1.92|
;;;316        }
;;;317    
;;;318        /* Advance the state pointer by 1        
;;;319         * to process the next group of interpolation factor number samples */
;;;320        pState = pState + 4;
;;;321    
;;;322        pDst += S->L * 3;
00018e  7803              LDRB     r3,[r0,#0]
;;;323    
;;;324        /* Decrement the loop counter */
;;;325        blkCnt--;
000190  f1a90901          SUB      r9,r9,#1
000194  eb030643          ADD      r6,r3,r3,LSL #1       ;322
000198  eb0b0b86          ADD      r11,r11,r6,LSL #2     ;322
00019c  3210              ADDS     r2,r2,#0x10
                  |L1.414|
00019e  f1b90f00          CMP      r9,#0                 ;176
0001a2  f47faf43          BNE      |L1.44|
0001a6  e05c              B        |L1.610|
                  |L1.424|
;;;326      }
;;;327    
;;;328      /* If the blockSize is not a multiple of 4, compute any remaining output samples here.        
;;;329       ** No loop unrolling is used. */
;;;330    
;;;331      while(blkCntN4 > 0u)
;;;332      {
;;;333        /* Copy new input sample into the state buffer */
;;;334        *pStateCurnt++ = *pSrc++;
0001a8  ecb10a01          VLDM     r1!,{s0}
;;;335    
;;;336        /* Address modifier index of coefficient buffer */
;;;337        j = 1u;
0001ac  f04f0901          MOV      r9,#1
0001b0  eca40a01          VSTM     r4!,{s0}              ;334
;;;338    
;;;339        /* Loop over the Interpolation factor. */
;;;340        i = S->L;
0001b4  f8908000          LDRB     r8,[r0,#0]
;;;341        while(i > 0u)
0001b8  e04d              B        |L1.598|
;;;342        {
;;;343          /* Set accumulator to zero */
;;;344          sum0 = 0.0f;
0001ba  bf00              NOP      
                  |L1.444|
;;;345    
;;;346          /* Initialize state pointer */
;;;347          ptr1 = pState;
;;;348    
;;;349          /* Initialize coefficient pointer */
;;;350          ptr2 = pCoeffs + (S->L - j);
0001bc  7807              LDRB     r7,[r0,#0]
0001be  9e01              LDR      r6,[sp,#4]
0001c0  eba70c09          SUB      r12,r7,r9
0001c4  eb06068c          ADD      r6,r6,r12,LSL #2
0001c8  eeb00a64          VMOV.F32 s0,s9                 ;344
0001cc  4613              MOV      r3,r2                 ;347
;;;351    
;;;352          /* Loop over the polyPhase length. Unroll by a factor of 4.        
;;;353           ** Repeat until we've computed numTaps-(4*S->L) coefficients. */
;;;354          tapCnt = phaseLen >> 2u;
0001ce  ea4f0c95          LSR      r12,r5,#2
;;;355          while(tapCnt > 0u)
0001d2  e024              B        |L1.542|
                  |L1.468|
;;;356          {
;;;357    
;;;358            /* Read the coefficient */
;;;359            c0 = *(ptr2);
0001d4  ed961a00          VLDR     s2,[r6,#0]
;;;360    
;;;361            /* Upsampling is done by stuffing L-1 zeros between each sample.        
;;;362             * So instead of multiplying zeros with coefficients,        
;;;363             * Increment the coefficient pointer by interpolation factor times. */
;;;364            ptr2 += S->L;
;;;365    
;;;366            /* Read the input sample */
;;;367            x0 = *(ptr1++);
0001d8  edd30a00          VLDR     s1,[r3,#0]
0001dc  eb060687          ADD      r6,r6,r7,LSL #2       ;364
;;;368    
;;;369            /* Perform the multiply-accumulate */
;;;370            sum0 += x0 * c0;
;;;371    
;;;372            /* Read the coefficient */
;;;373            c0 = *(ptr2);
;;;374    
;;;375            /* Increment the coefficient pointer by interpolation factor times. */
;;;376            ptr2 += S->L;
;;;377    
;;;378            /* Read the input sample */
;;;379            x0 = *(ptr1++);
;;;380    
;;;381            /* Perform the multiply-accumulate */
;;;382            sum0 += x0 * c0;
;;;383    
;;;384            /* Read the coefficient */
;;;385            c0 = *(ptr2);
;;;386    
;;;387            /* Increment the coefficient pointer by interpolation factor times. */
;;;388            ptr2 += S->L;
;;;389    
;;;390            /* Read the input sample */
;;;391            x0 = *(ptr1++);
;;;392    
;;;393            /* Perform the multiply-accumulate */
;;;394            sum0 += x0 * c0;
;;;395    
;;;396            /* Read the coefficient */
;;;397            c0 = *(ptr2);
;;;398    
;;;399            /* Increment the coefficient pointer by interpolation factor times. */
;;;400            ptr2 += S->L;
;;;401    
;;;402            /* Read the input sample */
;;;403            x0 = *(ptr1++);
;;;404    
;;;405            /* Perform the multiply-accumulate */
;;;406            sum0 += x0 * c0;
0001e0  f1ac0c01          SUB      r12,r12,#1
0001e4  ee000a81          VMLA.F32 s0,s1,s2              ;370
0001e8  ed961a00          VLDR     s2,[r6,#0]            ;373
0001ec  edd30a01          VLDR     s1,[r3,#4]            ;379
0001f0  eb060687          ADD      r6,r6,r7,LSL #2       ;376
;;;407    
;;;408            /* Decrement the loop counter */
;;;409            tapCnt--;
0001f4  fa1ffc8c          UXTH     r12,r12
0001f8  ee000a81          VMLA.F32 s0,s1,s2              ;382
0001fc  edd60a00          VLDR     s1,[r6,#0]            ;385
000200  ed931a02          VLDR     s2,[r3,#8]            ;391
000204  eb060687          ADD      r6,r6,r7,LSL #2       ;388
000208  ee010a20          VMLA.F32 s0,s2,s1              ;394
00020c  edd60a00          VLDR     s1,[r6,#0]            ;397
000210  ed931a03          VLDR     s2,[r3,#0xc]          ;403
000214  eb060687          ADD      r6,r6,r7,LSL #2       ;400
000218  3310              ADDS     r3,r3,#0x10
00021a  ee010a20          VMLA.F32 s0,s2,s1              ;406
                  |L1.542|
00021e  f1bc0f00          CMP      r12,#0                ;355
000222  d1d7              BNE      |L1.468|
;;;410          }
;;;411    
;;;412          /* If the polyPhase length is not a multiple of 4, compute the remaining filter taps */
;;;413          tapCnt = phaseLen % 0x4u;
000224  f0050c03          AND      r12,r5,#3
;;;414    
;;;415          while(tapCnt > 0u)
000228  e00c              B        |L1.580|
;;;416          {
;;;417            /* Perform the multiply-accumulate */
;;;418            sum0 += *(ptr1++) * (*ptr2);
00022a  bf00              NOP      
                  |L1.556|
00022c  ecf30a01          VLDM     r3!,{s1}
000230  ed961a00          VLDR     s2,[r6,#0]
;;;419    
;;;420            /* Increment the coefficient pointer by interpolation factor times. */
;;;421            ptr2 += S->L;
000234  f1ac0c01          SUB      r12,r12,#1
000238  eb060687          ADD      r6,r6,r7,LSL #2
;;;422    
;;;423            /* Decrement the loop counter */
;;;424            tapCnt--;
00023c  fa1ffc8c          UXTH     r12,r12
000240  ee000a81          VMLA.F32 s0,s1,s2              ;418
                  |L1.580|
000244  f1bc0f00          CMP      r12,#0                ;415
000248  d1f0              BNE      |L1.556|
;;;425          }
;;;426    
;;;427          /* The result is in the accumulator, store in the destination buffer. */
;;;428          *pDst++ = sum0;
00024a  ecab0a01          VSTM     r11!,{s0}
;;;429    
;;;430          /* Increment the address modifier index of coefficient buffer */
;;;431          j++;
00024e  f1090901          ADD      r9,r9,#1
000252  f1a80801          SUB      r8,r8,#1
                  |L1.598|
000256  f1b80f00          CMP      r8,#0                 ;341
00025a  d1af              BNE      |L1.444|
;;;432    
;;;433          /* Decrement the loop counter */
;;;434          i--;
;;;435        }
;;;436    
;;;437        /* Advance the state pointer by 1        
;;;438         * to process the next group of interpolation factor number samples */
;;;439        pState = pState + 1;
;;;440    
;;;441        /* Decrement the loop counter */
;;;442        blkCntN4--;
00025c  f1ae0e01          SUB      lr,lr,#1
000260  1d12              ADDS     r2,r2,#4
                  |L1.610|
000262  f1be0f00          CMP      lr,#0                 ;331
000266  d19f              BNE      |L1.424|
;;;443      }
;;;444    
;;;445      /* Processing is complete.        
;;;446       ** Now copy the last phaseLen - 1 samples to the satrt of the state buffer.        
;;;447       ** This prepares the state buffer for the next function call. */
;;;448    
;;;449      /* Points to the start of the state buffer */
;;;450      pStateCurnt = S->pState;
000268  1e6d              SUBS     r5,r5,#1
00026a  6880              LDR      r0,[r0,#8]
;;;451    
;;;452      tapCnt = (phaseLen - 1u) >> 2u;
00026c  f3c5018f          UBFX     r1,r5,#2,#16
;;;453    
;;;454      /* copy data */
;;;455      while(tapCnt > 0u)
000270  e014              B        |L1.668|
;;;456      {
;;;457        *pStateCurnt++ = *pState++;
000272  bf00              NOP      
                  |L1.628|
000274  ed920a00          VLDR     s0,[r2,#0]
;;;458        *pStateCurnt++ = *pState++;
;;;459        *pStateCurnt++ = *pState++;
;;;460        *pStateCurnt++ = *pState++;
000278  1e49              SUBS     r1,r1,#1
00027a  ed800a00          VSTR     s0,[r0,#0]            ;457
00027e  ed920a01          VLDR     s0,[r2,#4]            ;458
;;;461    
;;;462        /* Decrement the loop counter */
;;;463        tapCnt--;
000282  b289              UXTH     r1,r1
000284  ed800a01          VSTR     s0,[r0,#4]            ;458
000288  ed920a02          VLDR     s0,[r2,#8]            ;459
00028c  ed800a02          VSTR     s0,[r0,#8]            ;459
000290  ed920a03          VLDR     s0,[r2,#0xc]          ;460
000294  ed800a03          VSTR     s0,[r0,#0xc]          ;460
000298  3010              ADDS     r0,r0,#0x10
00029a  3210              ADDS     r2,r2,#0x10
                  |L1.668|
00029c  2900              CMP      r1,#0                 ;455
00029e  d1e9              BNE      |L1.628|
;;;464      }
;;;465    
;;;466      tapCnt = (phaseLen - 1u) % 0x04u;
0002a0  f0050103          AND      r1,r5,#3
;;;467    
;;;468      /* copy data */
;;;469      while(tapCnt > 0u)
0002a4  e006              B        |L1.692|
;;;470      {
;;;471        *pStateCurnt++ = *pState++;
0002a6  bf00              NOP      
                  |L1.680|
0002a8  ecb20a01          VLDM     r2!,{s0}
0002ac  1e49              SUBS     r1,r1,#1
;;;472    
;;;473        /* Decrement the loop counter */
;;;474        tapCnt--;
0002ae  b289              UXTH     r1,r1
0002b0  eca00a01          VSTM     r0!,{s0}              ;471
                  |L1.692|
0002b4  2900              CMP      r1,#0                 ;469
0002b6  d1f7              BNE      |L1.680|
;;;475      }
;;;476    }
0002b8  e8bd8ffc          POP      {r2-r11,pc}
;;;477    
                          ENDP

                  |L1.700|
0002bc  00000000          DCFS     0x00000000 ; 0

;*** Start embedded assembler ***

#line 1 "src\\FilteringFunctions\\arm_fir_interpolate_f32.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___25_arm_fir_interpolate_f32_c_b477b884____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___25_arm_fir_interpolate_f32_c_b477b884____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___25_arm_fir_interpolate_f32_c_b477b884____REVSH|
#line 144
|__asm___25_arm_fir_interpolate_f32_c_b477b884____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___25_arm_fir_interpolate_f32_c_b477b884____RRX|
#line 300
|__asm___25_arm_fir_interpolate_f32_c_b477b884____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
