; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_biquad_cascade_df1_fast_q15.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_biquad_cascade_df1_fast_q15.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_biquad_cascade_df1_fast_q15.crf src\FilteringFunctions\arm_biquad_cascade_df1_fast_q15.c]
                          THUMB

                          AREA ||i.arm_biquad_cascade_df1_fast_q15||, CODE, READONLY, ALIGN=2

                  arm_biquad_cascade_df1_fast_q15 PROC
;;;74     
;;;75     void arm_biquad_cascade_df1_fast_q15(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;76       const arm_biquad_casd_df1_inst_q15 * S,
;;;77       q15_t * pSrc,
;;;78       q15_t * pDst,
;;;79       uint32_t blockSize)
;;;80     {
;;;81       q15_t *pIn = pSrc;                             /*  Source pointer                               */
;;;82       q15_t *pOut = pDst;                            /*  Destination pointer                          */
;;;83       q31_t in;                                      /*  Temporary variable to hold input value       */
;;;84       q31_t out;                                     /*  Temporary variable to hold output value      */
;;;85       q31_t b0;                                      /*  Temporary variable to hold bo value          */
;;;86       q31_t b1, a1;                                  /*  Filter coefficients                          */
;;;87       q31_t state_in, state_out;                     /*  Filter state variables                       */
;;;88       q31_t acc;                                     /*  Accumulator                                  */
;;;89       int32_t shift = (int32_t) (15 - S->postShift); /*  Post shift                                   */
000004  f990200c          LDRSB    r2,[r0,#0xc]
000008  b083              SUB      sp,sp,#0xc            ;80
00000a  f1c20b0f          RSB      r11,r2,#0xf
00000e  e9d05201          LDRD     r5,r2,[r0,#4]
;;;90       q15_t *pState = S->pState;                     /*  State pointer                                */
;;;91       q15_t *pCoeffs = S->pCoeffs;                   /*  Coefficient pointer                          */
;;;92       uint32_t sample, stage = S->numStages;         /*  Stage loop counter                           */
000012  f9900000          LDRSB    r0,[r0,#0]
000016  9b05              LDR      r3,[sp,#0x14]
000018  9000              STR      r0,[sp,#0]            ;80
;;;93     
;;;94     
;;;95     
;;;96       do
;;;97       {
;;;98     
;;;99         /* Read the b0 and 0 coefficients using SIMD  */
;;;100        b0 = *__SIMD32(pCoeffs)++;
;;;101    
;;;102        /* Read the b1 and b2 coefficients using SIMD */
;;;103        b1 = *__SIMD32(pCoeffs)++;
;;;104    
;;;105        /* Read the a1 and a2 coefficients using SIMD */
;;;106        a1 = *__SIMD32(pCoeffs)++;
;;;107    
;;;108        /* Read the input state values from the state buffer:  x[n-1], x[n-2] */
;;;109        state_in = *__SIMD32(pState)++;
;;;110    
;;;111        /* Read the output state values from the state buffer:  y[n-1], y[n-2] */
;;;112        state_out = *__SIMD32(pState)--;
;;;113    
;;;114        /* Apply loop unrolling and compute 2 output values simultaneously. */
;;;115        /*      The variable acc hold output values that are being computed:       
;;;116         *    
;;;117         *    acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2]       
;;;118         *    acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2]       
;;;119         */
;;;120        sample = blockSize >> 1u;
00001a  9806              LDR      r0,[sp,#0x18]
00001c  0840              LSRS     r0,r0,#1
00001e  9002              STR      r0,[sp,#8]
                  |L1.32|
000020  f8529b04          LDR      r9,[r2],#4            ;100
000024  6828              LDR      r0,[r5,#0]            ;109
000026  f852ab04          LDR      r10,[r2],#4           ;103
00002a  686c              LDR      r4,[r5,#4]            ;112
00002c  f8527b04          LDR      r7,[r2],#4            ;106
000030  9501              STR      r5,[sp,#4]            ;112
;;;121    
;;;122        /* First part of the processing with loop unrolling.  Compute 2 outputs at a time.    
;;;123         ** a second loop below computes the remaining 1 sample. */
;;;124        while(sample > 0u)
000032  9d02              LDR      r5,[sp,#8]
000034  e024              B        |L1.128|
;;;125        {
;;;126    
;;;127          /* Read the input */
;;;128          in = *__SIMD32(pIn)++;
000036  bf00              NOP      
                  |L1.56|
000038  f8516b04          LDR      r6,[r1],#4
;;;129    
;;;130          /* out =  b0 * x[n] + 0 * 0 */
;;;131          out = __SMUAD(b0, in);
00003c  fb29fc06          SMUAD    r12,r9,r6
;;;132          /* acc =  b1 * x[n-1] + acc +=  b2 * x[n-2] + out */
;;;133          acc = __SMLAD(b1, state_in, out);
000040  fb2acc00          SMLAD    r12,r10,r0,r12
;;;134          /* acc +=  a1 * y[n-1] + acc +=  a2 * y[n-2] */
;;;135          acc = __SMLAD(a1, state_out, acc);
000044  fb27cc04          SMLAD    r12,r7,r4,r12
;;;136    
;;;137          /* The result is converted from 3.29 to 1.31 and then saturation is applied */
;;;138          out = __SSAT((acc >> shift), 16);
000048  fa4cfc0b          ASR      r12,r12,r11
00004c  f30c0c0f          SSAT     r12,#16,r12
;;;139    
;;;140          /* Every time after the output is computed state should be updated. */
;;;141          /* The states should be updated as:  */
;;;142          /* Xn2 = Xn1    */
;;;143          /* Xn1 = Xn     */
;;;144          /* Yn2 = Yn1    */
;;;145          /* Yn1 = acc   */
;;;146          /* x[n-N], x[n-N-1] are packed together to make state_in of type q31 */
;;;147          /* y[n-N], y[n-N-1] are packed together to make state_out of type q31 */
;;;148    
;;;149    #ifndef  ARM_MATH_BIG_ENDIAN
;;;150    
;;;151          state_in = __PKHBT(in, state_in, 16);
000050  eac64e00          PKHBT    lr,r6,r0,LSL #16
;;;152          state_out = __PKHBT(out, state_out, 16);
000054  eacc4404          PKHBT    r4,r12,r4,LSL #16
;;;153    
;;;154    #else
;;;155    
;;;156          state_in = __PKHBT(state_in >> 16, (in >> 16), 16);
;;;157          state_out = __PKHBT(state_out >> 16, (out), 16);
;;;158    
;;;159    #endif /*      #ifndef  ARM_MATH_BIG_ENDIAN    */
;;;160    
;;;161          /* out =  b0 * x[n] + 0 * 0 */
;;;162          out = __SMUADX(b0, in);
000058  fb29fc16          SMUADX   r12,r9,r6
;;;163          /* acc0 =  b1 * x[n-1] , acc0 +=  b2 * x[n-2] + out */
;;;164          acc = __SMLAD(b1, state_in, out);
00005c  fb2ac00e          SMLAD    r0,r10,lr,r12
;;;165          /* acc +=  a1 * y[n-1] + acc +=  a2 * y[n-2] */
;;;166          acc = __SMLAD(a1, state_out, acc);
000060  fb270004          SMLAD    r0,r7,r4,r0
;;;167    
;;;168          /* The result is converted from 3.29 to 1.31 and then saturation is applied */
;;;169          out = __SSAT((acc >> shift), 16);
000064  fa40f00b          ASR      r0,r0,r11
000068  f3000c0f          SSAT     r12,#16,r0
;;;170    
;;;171    
;;;172          /* Store the output in the destination buffer. */
;;;173    
;;;174    #ifndef  ARM_MATH_BIG_ENDIAN
;;;175    
;;;176          *__SIMD32(pOut)++ = __PKHBT(state_out, out, 16);
00006c  eac4400c          PKHBT    r0,r4,r12,LSL #16
000070  f8430b04          STR      r0,[r3],#4
;;;177    
;;;178    #else
;;;179    
;;;180          *__SIMD32(pOut)++ = __PKHBT(out, state_out >> 16, 16);
;;;181    
;;;182    #endif /*      #ifndef  ARM_MATH_BIG_ENDIAN    */
;;;183    
;;;184          /* Every time after the output is computed state should be updated. */
;;;185          /* The states should be updated as:  */
;;;186          /* Xn2 = Xn1    */
;;;187          /* Xn1 = Xn     */
;;;188          /* Yn2 = Yn1    */
;;;189          /* Yn1 = acc   */
;;;190          /* x[n-N], x[n-N-1] are packed together to make state_in of type q31 */
;;;191          /* y[n-N], y[n-N-1] are packed together to make state_out of type q31 */
;;;192    
;;;193    #ifndef  ARM_MATH_BIG_ENDIAN
;;;194    
;;;195          state_in = __PKHBT(in >> 16, state_in, 16);
000074  1436              ASRS     r6,r6,#16
000076  eac6400e          PKHBT    r0,r6,lr,LSL #16
;;;196          state_out = __PKHBT(out, state_out, 16);
00007a  eacc4404          PKHBT    r4,r12,r4,LSL #16
00007e  1e6d              SUBS     r5,r5,#1
                  |L1.128|
000080  2d00              CMP      r5,#0                 ;124
000082  d1d9              BNE      |L1.56|
;;;197    
;;;198    #else
;;;199    
;;;200          state_in = __PKHBT(state_in >> 16, in, 16);
;;;201          state_out = __PKHBT(state_out >> 16, out, 16);
;;;202    
;;;203    #endif /*      #ifndef  ARM_MATH_BIG_ENDIAN    */
;;;204    
;;;205    
;;;206          /* Decrement the loop counter */
;;;207          sample--;
;;;208    
;;;209        }
;;;210    
;;;211        /* If the blockSize is not a multiple of 2, compute any remaining output samples here.    
;;;212         ** No loop unrolling is used. */
;;;213    
;;;214        if((blockSize & 0x1u) != 0u)
000084  9d06              LDR      r5,[sp,#0x18]
000086  07ed              LSLS     r5,r5,#31
000088  d010              BEQ      |L1.172|
;;;215        {
;;;216          /* Read the input */
;;;217          in = *pIn++;
00008a  f9b15000          LDRSH    r5,[r1,#0]
;;;218    
;;;219          /* out =  b0 * x[n] + 0 * 0 */
;;;220    
;;;221    #ifndef  ARM_MATH_BIG_ENDIAN
;;;222    
;;;223          out = __SMUAD(b0, in);
00008e  fb29f105          SMUAD    r1,r9,r5
;;;224    
;;;225    #else
;;;226    
;;;227          out = __SMUADX(b0, in);
;;;228    
;;;229    #endif /*      #ifndef  ARM_MATH_BIG_ENDIAN    */
;;;230    
;;;231          /* acc =  b1 * x[n-1], acc +=  b2 * x[n-2] + out */
;;;232          acc = __SMLAD(b1, state_in, out);
000092  fb2a1100          SMLAD    r1,r10,r0,r1
;;;233          /* acc +=  a1 * y[n-1] + acc +=  a2 * y[n-2] */
;;;234          acc = __SMLAD(a1, state_out, acc);
000096  fb271104          SMLAD    r1,r7,r4,r1
;;;235    
;;;236          /* The result is converted from 3.29 to 1.31 and then saturation is applied */
;;;237          out = __SSAT((acc >> shift), 16);
00009a  fa41f10b          ASR      r1,r1,r11
00009e  f301010f          SSAT     r1,#16,r1
;;;238    
;;;239          /* Store the output in the destination buffer. */
;;;240          *pOut++ = (q15_t) out;
0000a2  8019              STRH     r1,[r3,#0]
;;;241    
;;;242          /* Every time after the output is computed state should be updated. */
;;;243          /* The states should be updated as:  */
;;;244          /* Xn2 = Xn1    */
;;;245          /* Xn1 = Xn     */
;;;246          /* Yn2 = Yn1    */
;;;247          /* Yn1 = acc   */
;;;248          /* x[n-N], x[n-N-1] are packed together to make state_in of type q31 */
;;;249          /* y[n-N], y[n-N-1] are packed together to make state_out of type q31 */
;;;250    
;;;251    #ifndef  ARM_MATH_BIG_ENDIAN
;;;252    
;;;253          state_in = __PKHBT(in, state_in, 16);
0000a4  eac54000          PKHBT    r0,r5,r0,LSL #16
;;;254          state_out = __PKHBT(out, state_out, 16);
0000a8  eac14404          PKHBT    r4,r1,r4,LSL #16
                  |L1.172|
;;;255    
;;;256    #else
;;;257    
;;;258          state_in = __PKHBT(state_in >> 16, in, 16);
;;;259          state_out = __PKHBT(state_out >> 16, out, 16);
;;;260    
;;;261    #endif /*   #ifndef  ARM_MATH_BIG_ENDIAN    */
;;;262    
;;;263        }
;;;264    
;;;265        /*  The first stage goes from the input buffer to the output buffer.  */
;;;266        /*  Subsequent (numStages - 1) occur in-place in the output buffer  */
;;;267        pIn = pDst;
;;;268    
;;;269        /* Reset the output pointer */
;;;270        pOut = pDst;
;;;271    
;;;272        /*  Store the updated state variables back into the state array */
;;;273        *__SIMD32(pState)++ = state_in;
0000ac  9d01              LDR      r5,[sp,#4]
0000ae  9905              LDR      r1,[sp,#0x14]         ;270
0000b0  6028              STR      r0,[r5,#0]
;;;274        *__SIMD32(pState)++ = state_out;
0000b2  9d01              LDR      r5,[sp,#4]
0000b4  460b              MOV      r3,r1                 ;270
0000b6  606c              STR      r4,[r5,#4]
;;;275    
;;;276    
;;;277        /* Decrement the loop counter */
;;;278        stage--;
0000b8  9800              LDR      r0,[sp,#0]
0000ba  f1050508          ADD      r5,r5,#8
0000be  1e40              SUBS     r0,r0,#1
;;;279    
;;;280      } while(stage > 0u);
0000c0  9000              STR      r0,[sp,#0]
0000c2  d1ad              BNE      |L1.32|
;;;281    }
0000c4  b007              ADD      sp,sp,#0x1c
0000c6  e8bd8ff0          POP      {r4-r11,pc}
;;;282    
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\FilteringFunctions\\arm_biquad_cascade_df1_fast_q15.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___33_arm_biquad_cascade_df1_fast_q15_c_3ae4055a____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___33_arm_biquad_cascade_df1_fast_q15_c_3ae4055a____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___33_arm_biquad_cascade_df1_fast_q15_c_3ae4055a____REVSH|
#line 144
|__asm___33_arm_biquad_cascade_df1_fast_q15_c_3ae4055a____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___33_arm_biquad_cascade_df1_fast_q15_c_3ae4055a____RRX|
#line 300
|__asm___33_arm_biquad_cascade_df1_fast_q15_c_3ae4055a____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
