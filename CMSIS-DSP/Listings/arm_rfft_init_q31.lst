L 1 "src\TransformFunctions\arm_rfft_init_q31.c"
N/* ----------------------------------------------------------------------    
N* Copyright (C) 2010-2014 ARM Limited. All rights reserved.    
N*    
N* $Date:        19. March 2015 
N* $Revision: 	V.1.4.5  
N*    
N* Project: 	    CMSIS DSP Library    
N* Title:	    arm_rfft_init_q31.c    
N*    
N* Description:	RFFT & RIFFT Q31 initialisation function    
N*    
N* Target Processor: Cortex-M4/Cortex-M3/Cortex-M0
N*  
N* Redistribution and use in source and binary forms, with or without 
N* modification, are permitted provided that the following conditions
N* are met:
N*   - Redistributions of source code must retain the above copyright
N*     notice, this list of conditions and the following disclaimer.
N*   - Redistributions in binary form must reproduce the above copyright
N*     notice, this list of conditions and the following disclaimer in
N*     the documentation and/or other materials provided with the 
N*     distribution.
N*   - Neither the name of ARM LIMITED nor the names of its contributors
N*     may be used to endorse or promote products derived from this
N*     software without specific prior written permission.
N*
N* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
N* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
N* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
N* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE 
N* COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
N* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
N* BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
N* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N* CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N* LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
N* ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N* POSSIBILITY OF SUCH DAMAGE.  
N* -------------------------------------------------------------------- */
N
N#include "arm_math.h"
L 1 ".\inc\arm_math.h" 1
N/* ----------------------------------------------------------------------
N* Copyright (C) 2010-2014 ARM Limited. All rights reserved.
N*
N* $Date:        12. March 2014
N* $Revision: 	V1.4.4
N*
N* Project: 	    CMSIS DSP Library
N* Title:	    arm_math.h
N*
N* Description:	Public header file for CMSIS DSP Library
N*
N* Target Processor: Cortex-M7/Cortex-M4/Cortex-M3/Cortex-M0
N*
N* Redistribution and use in source and binary forms, with or without
N* modification, are permitted provided that the following conditions
N* are met:
N*   - Redistributions of source code must retain the above copyright
N*     notice, this list of conditions and the following disclaimer.
N*   - Redistributions in binary form must reproduce the above copyright
N*     notice, this list of conditions and the following disclaimer in
N*     the documentation and/or other materials provided with the
N*     distribution.
N*   - Neither the name of ARM LIMITED nor the names of its contributors
N*     may be used to endorse or promote products derived from this
N*     software without specific prior written permission.
N*
N* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
N* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
N* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
N* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
N* COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
N* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
N* BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
N* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N* CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N* LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
N* ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N* POSSIBILITY OF SUCH DAMAGE.
N * -------------------------------------------------------------------- */
N
N/**
N   \mainpage CMSIS DSP Software Library
N   *
N   * Introduction
N   * ------------
N   *
N   * This user manual describes the CMSIS DSP software library,
N   * a suite of common signal processing functions for use on Cortex-M processor based devices.
N   *
N   * The library is divided into a number of functions each covering a specific category:
N   * - Basic math functions
N   * - Fast math functions
N   * - Complex math functions
N   * - Filters
N   * - Matrix functions
N   * - Transforms
N   * - Motor control functions
N   * - Statistical functions
N   * - Support functions
N   * - Interpolation functions
N   *
N   * The library has separate functions for operating on 8-bit integers, 16-bit integers,
N   * 32-bit integer and 32-bit floating-point values.
N   *
N   * Using the Library
N   * ------------
N   *
N   * The library installer contains prebuilt versions of the libraries in the <code>Lib</code> folder.
N   * - arm_cortexM4lf_math.lib (Little endian and Floating Point Unit on Cortex-M4)
N   * - arm_cortexM4bf_math.lib (Big endian and Floating Point Unit on Cortex-M4)
N   * - arm_cortexM4l_math.lib (Little endian on Cortex-M4)
N   * - arm_cortexM4b_math.lib (Big endian on Cortex-M4)
N   * - arm_cortexM3l_math.lib (Little endian on Cortex-M3)
N   * - arm_cortexM3b_math.lib (Big endian on Cortex-M3)
N   * - arm_cortexM0l_math.lib (Little endian on Cortex-M0)
N   * - arm_cortexM0b_math.lib (Big endian on Cortex-M3)
N   *
N   * The library functions are declared in the public file <code>arm_math.h</code> which is placed in the <code>Include</code> folder.
N   * Simply include this file and link the appropriate library in the application and begin calling the library functions. The Library supports single
N   * public header file <code> arm_math.h</code> for Cortex-M4/M3/M0 with little endian and big endian. Same header file will be used for floating point unit(FPU) variants.
N   * Define the appropriate pre processor MACRO ARM_MATH_CM4 or  ARM_MATH_CM3 or
N   * ARM_MATH_CM0 or ARM_MATH_CM0PLUS depending on the target processor in the application.
N   *
N   * Examples
N   * --------
N   *
N   * The library ships with a number of examples which demonstrate how to use the library functions.
N   *
N   * Toolchain Support
N   * ------------
N   *
N   * The library has been developed and tested with MDK-ARM version 4.60.
N   * The library is being tested in GCC and IAR toolchains and updates on this activity will be made available shortly.
N   *
N   * Building the Library
N   * ------------
N   *
N   * The library installer contains a project file to re build libraries on MDK-ARM Tool chain in the <code>CMSIS\\DSP_Lib\\Source\\ARM</code> folder.
N   * - arm_cortexM_math.uvproj
N   *
N   *
N   * The libraries can be built by opening the arm_cortexM_math.uvproj project in MDK-ARM, selecting a specific target, and defining the optional pre processor MACROs detailed above.
N   *
N   * Pre-processor Macros
N   * ------------
N   *
N   * Each library project have differant pre-processor macros.
N   *
N   * - UNALIGNED_SUPPORT_DISABLE:
N   *
N   * Define macro UNALIGNED_SUPPORT_DISABLE, If the silicon does not support unaligned memory access
N   *
N   * - ARM_MATH_BIG_ENDIAN:
N   *
N   * Define macro ARM_MATH_BIG_ENDIAN to build the library for big endian targets. By default library builds for little endian targets.
N   *
N   * - ARM_MATH_MATRIX_CHECK:
N   *
N   * Define macro ARM_MATH_MATRIX_CHECK for checking on the input and output sizes of matrices
N   *
N   * - ARM_MATH_ROUNDING:
N   *
N   * Define macro ARM_MATH_ROUNDING for rounding on support functions
N   *
N   * - ARM_MATH_CMx:
N   *
N   * Define macro ARM_MATH_CM4 for building the library on Cortex-M4 target, ARM_MATH_CM3 for building library on Cortex-M3 target
N   * and ARM_MATH_CM0 for building library on cortex-M0 target, ARM_MATH_CM0PLUS for building library on cortex-M0+ target.
N   *
N   * - __FPU_PRESENT:
N   *
N   * Initialize macro __FPU_PRESENT = 1 when building on FPU supported Targets. Enable this macro for M4bf and M4lf libraries
N   *
N   * <hr>
N   * CMSIS-DSP in ARM::CMSIS Pack
N   * -----------------------------
N   * 
N   * The following files relevant to CMSIS-DSP are present in the <b>ARM::CMSIS</b> Pack directories:
N   * |File/Folder                   |Content                                                                 |
N   * |------------------------------|------------------------------------------------------------------------|
N   * |\b CMSIS\\Documentation\\DSP  | This documentation                                                     |
N   * |\b CMSIS\\DSP_Lib             | Software license agreement (license.txt)                               |
N   * |\b CMSIS\\DSP_Lib\\Examples   | Example projects demonstrating the usage of the library functions      |
N   * |\b CMSIS\\DSP_Lib\\Source     | Source files for rebuilding the library                                |
N   * 
N   * <hr>
N   * Revision History of CMSIS-DSP
N   * ------------
N   * Please refer to \ref ChangeLog_pg.
N   *
N   * Copyright Notice
N   * ------------
N   *
N   * Copyright (C) 2010-2014 ARM Limited. All rights reserved.
N   */
N
N
N/**
N * @defgroup groupMath Basic Math Functions
N */
N
N/**
N * @defgroup groupFastMath Fast Math Functions
N * This set of functions provides a fast approximation to sine, cosine, and square root.
N * As compared to most of the other functions in the CMSIS math library, the fast math functions
N * operate on individual values and not arrays.
N * There are separate functions for Q15, Q31, and floating-point data.
N *
N */
N
N/**
N * @defgroup groupCmplxMath Complex Math Functions
N * This set of functions operates on complex data vectors.
N * The data in the complex arrays is stored in an interleaved fashion
N * (real, imag, real, imag, ...).
N * In the API functions, the number of samples in a complex array refers
N * to the number of complex values; the array contains twice this number of
N * real values.
N */
N
N/**
N * @defgroup groupFilters Filtering Functions
N */
N
N/**
N * @defgroup groupMatrix Matrix Functions
N *
N * This set of functions provides basic matrix math operations.
N * The functions operate on matrix data structures.  For example,
N * the type
N * definition for the floating-point matrix structure is shown
N * below:
N * <pre>
N *     typedef struct
N *     {
N *       uint16_t numRows;     // number of rows of the matrix.
N *       uint16_t numCols;     // number of columns of the matrix.
N *       float32_t *pData;     // points to the data of the matrix.
N *     } arm_matrix_instance_f32;
N * </pre>
N * There are similar definitions for Q15 and Q31 data types.
N *
N * The structure specifies the size of the matrix and then points to
N * an array of data.  The array is of size <code>numRows X numCols</code>
N * and the values are arranged in row order.  That is, the
N * matrix element (i, j) is stored at:
N * <pre>
N *     pData[i*numCols + j]
N * </pre>
N *
N * \par Init Functions
N * There is an associated initialization function for each type of matrix
N * data structure.
N * The initialization function sets the values of the internal structure fields.
N * Refer to the function <code>arm_mat_init_f32()</code>, <code>arm_mat_init_q31()</code>
N * and <code>arm_mat_init_q15()</code> for floating-point, Q31 and Q15 types,  respectively.
N *
N * \par
N * Use of the initialization function is optional. However, if initialization function is used
N * then the instance structure cannot be placed into a const data section.
N * To place the instance structure in a const data
N * section, manually initialize the data structure.  For example:
N * <pre>
N * <code>arm_matrix_instance_f32 S = {nRows, nColumns, pData};</code>
N * <code>arm_matrix_instance_q31 S = {nRows, nColumns, pData};</code>
N * <code>arm_matrix_instance_q15 S = {nRows, nColumns, pData};</code>
N * </pre>
N * where <code>nRows</code> specifies the number of rows, <code>nColumns</code>
N * specifies the number of columns, and <code>pData</code> points to the
N * data array.
N *
N * \par Size Checking
N * By default all of the matrix functions perform size checking on the input and
N * output matrices.  For example, the matrix addition function verifies that the
N * two input matrices and the output matrix all have the same number of rows and
N * columns.  If the size check fails the functions return:
N * <pre>
N *     ARM_MATH_SIZE_MISMATCH
N * </pre>
N * Otherwise the functions return
N * <pre>
N *     ARM_MATH_SUCCESS
N * </pre>
N * There is some overhead associated with this matrix size checking.
N * The matrix size checking is enabled via the \#define
N * <pre>
N *     ARM_MATH_MATRIX_CHECK
N * </pre>
N * within the library project settings.  By default this macro is defined
N * and size checking is enabled.  By changing the project settings and
N * undefining this macro size checking is eliminated and the functions
N * run a bit faster.  With size checking disabled the functions always
N * return <code>ARM_MATH_SUCCESS</code>.
N */
N
N/**
N * @defgroup groupTransforms Transform Functions
N */
N
N/**
N * @defgroup groupController Controller Functions
N */
N
N/**
N * @defgroup groupStats Statistics Functions
N */
N/**
N * @defgroup groupSupport Support Functions
N */
N
N/**
N * @defgroup groupInterpolation Interpolation Functions
N * These functions perform 1- and 2-dimensional interpolation of data.
N * Linear interpolation is used for 1-dimensional data and
N * bilinear interpolation is used for 2-dimensional data.
N */
N
N/**
N * @defgroup groupExamples Examples
N */
N#ifndef _ARM_MATH_H
N#define _ARM_MATH_H
N
N#define __CMSIS_GENERIC         /* disable NVIC and Systick functions */
N
N#if defined(ARM_MATH_CM7)
X#if 0L
S  #include "core_cm7.h"
N#elif defined (ARM_MATH_CM4)
X#elif 1L
N  #include "core_cm4.h"
L 1 ".\inc\core_cm4.h" 1
N/**************************************************************************//**
N * @file     core_cm4.h
N * @brief    CMSIS Cortex-M4 Core Peripheral Access Layer Header File
N * @version  V4.00
N * @date     22. August 2014
N *
N * @note
N *
N ******************************************************************************/
N/* Copyright (c) 2009 - 2014 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if defined ( __ICCARM__ )
X#if 0L
S #pragma system_include  /* treat file as system include file for MISRA check */
N#endif
N
N#ifndef __CORE_CM4_H_GENERIC
N#define __CORE_CM4_H_GENERIC
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/** \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/** \ingroup Cortex_M4
N  @{
N */
N
N/*  CMSIS CM4 definitions */
N#define __CM4_CMSIS_VERSION_MAIN  (0x04)                                   /*!< [31:16] CMSIS HAL main version   */
N#define __CM4_CMSIS_VERSION_SUB   (0x00)                                   /*!< [15:0]  CMSIS HAL sub version    */
N#define __CM4_CMSIS_VERSION       ((__CM4_CMSIS_VERSION_MAIN << 16) | \
N                                    __CM4_CMSIS_VERSION_SUB          )     /*!< CMSIS HAL version number         */
X#define __CM4_CMSIS_VERSION       ((__CM4_CMSIS_VERSION_MAIN << 16) |                                     __CM4_CMSIS_VERSION_SUB          )      
N
N#define __CORTEX_M                (0x04)                                   /*!< Cortex-M Core                    */
N
N
N#if   defined ( __CC_ARM )
X#if   1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
N  #define __STATIC_INLINE  static __inline
N
N#elif defined ( __GNUC__ )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __ICCARM__ )
S  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TMS470__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TI CCS Compiler       */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TASKING__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __CSMC__ )
S  #define __packed
S  #define __ASM            _asm                                      /*!< asm keyword for COSMIC Compiler      */
S  #define __INLINE         inline                                    /*use -pc99 on compile line !< inline keyword for COSMIC Compiler   */
S  #define __STATIC_INLINE  static inline
S
N#endif
N
N/** __FPU_USED indicates whether an FPU is used or not.
N    For this, __FPU_PRESENT has to be checked prior to making use of FPU specific registers and functions.
N*/
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 1L
N    #if (__FPU_PRESENT == 1)
X    #if (1 == 1)
N      #define __FPU_USED       1
N    #else
S      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0
N    #endif
N  #else
S    #define __FPU_USED         0
N  #endif
N
N#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #if (__FPU_PRESENT == 1)
S      #define __FPU_USED       1
S    #else
S      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0
S    #endif
S  #else
S    #define __FPU_USED         0
S  #endif
S
S#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #if (__FPU_PRESENT == 1)
S      #define __FPU_USED       1
S    #else
S      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0
S    #endif
S  #else
S    #define __FPU_USED         0
S  #endif
S
S#elif defined ( __TMS470__ )
S  #if defined __TI_VFP_SUPPORT__
S    #if (__FPU_PRESENT == 1)
S      #define __FPU_USED       1
S    #else
S      #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0
S    #endif
S  #else
S    #define __FPU_USED         0
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #if (__FPU_PRESENT == 1)
S      #define __FPU_USED       1
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0
S    #endif
S  #else
S    #define __FPU_USED         0
S  #endif
S
S#elif defined ( __CSMC__ )		/* Cosmic */
S  #if ( __CSMC__ & 0x400)		// FPU present for parser
S    #if (__FPU_PRESENT == 1)
S      #define __FPU_USED       1
S    #else
S      #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S      #define __FPU_USED       0
S    #endif
S  #else
S    #define __FPU_USED         0
S  #endif
N#endif
N
N#include <stdint.h>                      /* standard types definitions                      */
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060019
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 188 ".\inc\core_cm4.h" 2
N#include <core_cmInstr.h>                /* Core Instruction Access                         */
L 1 ".\inc\core_cmInstr.h" 1
N/**************************************************************************//**
N * @file     core_cmInstr.h
N * @brief    CMSIS Cortex-M Core Instruction Access Header File
N * @version  V4.00
N * @date     28. August 2014
N *
N * @note
N *
N ******************************************************************************/
N/* Copyright (c) 2009 - 2014 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#ifndef __CORE_CMINSTR_H
N#define __CORE_CMINSTR_H
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N#if (__ARMCC_VERSION < 400677)
X#if (5060422 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N
N/** \brief  No Operation
N
N    No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/** \brief  Wait For Interrupt
N
N    Wait For Interrupt is a hint instruction that suspends execution
N    until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/** \brief  Wait For Event
N
N    Wait For Event is a hint instruction that permits the processor to enter
N    a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/** \brief  Send Event
N
N    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/** \brief  Instruction Synchronization Barrier
N
N    Instruction Synchronization Barrier flushes the pipeline in the processor,
N    so that all instructions following the ISB are fetched from cache or
N    memory, after the instruction has been completed.
N */
N#define __ISB()                           __isb(0xF)
N
N
N/** \brief  Data Synchronization Barrier
N
N    This function acts as a special kind of Data Memory Barrier.
N    It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB()                           __dsb(0xF)
N
N
N/** \brief  Data Memory Barrier
N
N    This function ensures the apparent order of the explicit memory operations before
N    and after the instruction, without ensuring their completion.
N */
N#define __DMB()                           __dmb(0xF)
N
N
N/** \brief  Reverse byte order (32 bit)
N
N    This function reverses the byte order in integer value.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/** \brief  Reverse byte order (16 bit)
N
N    This function reverses the byte order in two unsigned short values.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N#endif
N
N/** \brief  Reverse byte order in signed short value
N
N    This function reverses the byte order in a signed short value with sign extension to integer.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int32_t __REVSH(int32_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N#endif
N
N
N/** \brief  Rotate Right in unsigned value (32 bit)
N
N    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N
N    \param [in]    value  Value to rotate
N    \param [in]    value  Number of Bits to rotate
N    \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N/** \brief  Breakpoint
N
N    This function causes the processor to enter Debug state.
N    Debug tools can use this to investigate system state when the instruction at a particular address is reached.
N
N    \param [in]    value  is ignored by the processor.
N                   If required, a debugger can use it to store additional information about the breakpoint.
N */
N#define __BKPT(value)                       __breakpoint(value)
N
N
N#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
X#if       ((0x04) >= 0x03) || (__CORTEX_SC >= 300)
N
N/** \brief  Reverse bit order of value
N
N    This function reverses the bit order of the given value.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#define __RBIT                            __rbit
N
N
N/** \brief  LDR Exclusive (8 bit)
N
N    This function executes a exclusive LDR instruction for 8 bit value.
N
N    \param [in]    ptr  Pointer to data
N    \return             value of type uint8_t at (*ptr)
N */
N#define __LDREXB(ptr)                     ((uint8_t ) __ldrex(ptr))
N
N
N/** \brief  LDR Exclusive (16 bit)
N
N    This function executes a exclusive LDR instruction for 16 bit values.
N
N    \param [in]    ptr  Pointer to data
N    \return        value of type uint16_t at (*ptr)
N */
N#define __LDREXH(ptr)                     ((uint16_t) __ldrex(ptr))
N
N
N/** \brief  LDR Exclusive (32 bit)
N
N    This function executes a exclusive LDR instruction for 32 bit values.
N
N    \param [in]    ptr  Pointer to data
N    \return        value of type uint32_t at (*ptr)
N */
N#define __LDREXW(ptr)                     ((uint32_t ) __ldrex(ptr))
N
N
N/** \brief  STR Exclusive (8 bit)
N
N    This function executes a exclusive STR instruction for 8 bit values.
N
N    \param [in]  value  Value to store
N    \param [in]    ptr  Pointer to location
N    \return          0  Function succeeded
N    \return          1  Function failed
N */
N#define __STREXB(value, ptr)              __strex(value, ptr)
N
N
N/** \brief  STR Exclusive (16 bit)
N
N    This function executes a exclusive STR instruction for 16 bit values.
N
N    \param [in]  value  Value to store
N    \param [in]    ptr  Pointer to location
N    \return          0  Function succeeded
N    \return          1  Function failed
N */
N#define __STREXH(value, ptr)              __strex(value, ptr)
N
N
N/** \brief  STR Exclusive (32 bit)
N
N    This function executes a exclusive STR instruction for 32 bit values.
N
N    \param [in]  value  Value to store
N    \param [in]    ptr  Pointer to location
N    \return          0  Function succeeded
N    \return          1  Function failed
N */
N#define __STREXW(value, ptr)              __strex(value, ptr)
N
N
N/** \brief  Remove the exclusive lock
N
N    This function removes the exclusive lock which is created by LDREX.
N
N */
N#define __CLREX                           __clrex
N
N
N/** \brief  Signed Saturate
N
N    This function saturates a signed value.
N
N    \param [in]  value  Value to be saturated
N    \param [in]    sat  Bit position to saturate to (1..32)
N    \return             Saturated value
N */
N#define __SSAT                            __ssat
N
N
N/** \brief  Unsigned Saturate
N
N    This function saturates an unsigned value.
N
N    \param [in]  value  Value to be saturated
N    \param [in]    sat  Bit position to saturate to (0..31)
N    \return             Saturated value
N */
N#define __USAT                            __usat
N
N
N/** \brief  Count leading zeros
N
N    This function counts the number of leading zeros of a data value.
N
N    \param [in]  value  Value to count the leading zeros
N    \return             number of leading zeros in value
N */
N#define __CLZ                             __clz
N
N
N/** \brief  Rotate Right with Extend (32 bit)
N
N    This function moves each bit of a bitstring right by one bit. The carry input is shifted in at the left end of the bitstring.
N
N    \param [in]    value  Value to rotate
N    \return               Rotated value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rrx_text"))) __STATIC_INLINE __ASM uint32_t __RRX(uint32_t value)
X__attribute__((section(".rrx_text"))) static __inline __asm uint32_t __RRX(uint32_t value)
N{
N  rrx r0, r0
N  bx lr
N}
N#endif
N
N
N/** \brief  LDRT Unprivileged (8 bit)
N
N    This function executes a Unprivileged LDRT instruction for 8 bit value.
N
N    \param [in]    ptr  Pointer to data
N    \return             value of type uint8_t at (*ptr)
N */
N#define __LDRBT(ptr)                      ((uint8_t )  __ldrt(ptr))
N
N
N/** \brief  LDRT Unprivileged (16 bit)
N
N    This function executes a Unprivileged LDRT instruction for 16 bit values.
N
N    \param [in]    ptr  Pointer to data
N    \return        value of type uint16_t at (*ptr)
N */
N#define __LDRHT(ptr)                      ((uint16_t)  __ldrt(ptr))
N
N
N/** \brief  LDRT Unprivileged (32 bit)
N
N    This function executes a Unprivileged LDRT instruction for 32 bit values.
N
N    \param [in]    ptr  Pointer to data
N    \return        value of type uint32_t at (*ptr)
N */
N#define __LDRT(ptr)                       ((uint32_t ) __ldrt(ptr))
N
N
N/** \brief  STRT Unprivileged (8 bit)
N
N    This function executes a Unprivileged STRT instruction for 8 bit values.
N
N    \param [in]  value  Value to store
N    \param [in]    ptr  Pointer to location
N */
N#define __STRBT(value, ptr)               __strt(value, ptr)
N
N
N/** \brief  STRT Unprivileged (16 bit)
N
N    This function executes a Unprivileged STRT instruction for 16 bit values.
N
N    \param [in]  value  Value to store
N    \param [in]    ptr  Pointer to location
N */
N#define __STRHT(value, ptr)               __strt(value, ptr)
N
N
N/** \brief  STRT Unprivileged (32 bit)
N
N    This function executes a Unprivileged STRT instruction for 32 bit values.
N
N    \param [in]  value  Value to store
N    \param [in]    ptr  Pointer to location
N */
N#define __STRT(value, ptr)                __strt(value, ptr)
N
N#endif /* (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300) */
N
N
N#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/* Define macros for porting to both thumb1 and thumb2.
S * For thumb1, use low register (r0-r7), specified by constrant "l"
S * Otherwise, use general registers, specified by constrant "r" */
S#if defined (__thumb__) && !defined (__thumb2__)
S#define __CMSIS_GCC_OUT_REG(r) "=l" (r)
S#define __CMSIS_GCC_USE_REG(r) "l" (r)
S#else
S#define __CMSIS_GCC_OUT_REG(r) "=r" (r)
S#define __CMSIS_GCC_USE_REG(r) "r" (r)
S#endif
S
S/** \brief  No Operation
S
S    No Operation does nothing. This instruction can be used for code alignment purposes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __NOP(void)
S{
S  __ASM volatile ("nop");
S}
S
S
S/** \brief  Wait For Interrupt
S
S    Wait For Interrupt is a hint instruction that suspends execution
S    until one of a number of events occurs.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFI(void)
S{
S  __ASM volatile ("wfi");
S}
S
S
S/** \brief  Wait For Event
S
S    Wait For Event is a hint instruction that permits the processor to enter
S    a low-power state until one of a number of events occurs.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFE(void)
S{
S  __ASM volatile ("wfe");
S}
S
S
S/** \brief  Send Event
S
S    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __SEV(void)
S{
S  __ASM volatile ("sev");
S}
S
S
S/** \brief  Instruction Synchronization Barrier
S
S    Instruction Synchronization Barrier flushes the pipeline in the processor,
S    so that all instructions following the ISB are fetched from cache or
S    memory, after the instruction has been completed.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __ISB(void)
S{
S  __ASM volatile ("isb");
S}
S
S
S/** \brief  Data Synchronization Barrier
S
S    This function acts as a special kind of Data Memory Barrier.
S    It completes when all explicit memory accesses before this instruction complete.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __DSB(void)
S{
S  __ASM volatile ("dsb");
S}
S
S
S/** \brief  Data Memory Barrier
S
S    This function ensures the apparent order of the explicit memory operations before
S    and after the instruction, without ensuring their completion.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
S{
S  __ASM volatile ("dmb");
S}
S
S
S/** \brief  Reverse byte order (32 bit)
S
S    This function reverses the byte order in integer value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV(uint32_t value)
S{
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)
S  return __builtin_bswap32(value);
S#else
S  uint32_t result;
S
S  __ASM volatile ("rev %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
S  return(result);
S#endif
S}
S
S
S/** \brief  Reverse byte order (16 bit)
S
S    This function reverses the byte order in two unsigned short values.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV16(uint32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("rev16 %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
S  return(result);
S}
S
S
S/** \brief  Reverse byte order in signed short value
S
S    This function reverses the byte order in a signed short value with sign extension to integer.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE int32_t __REVSH(int32_t value)
S{
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S  return (short)__builtin_bswap16(value);
S#else
S  uint32_t result;
S
S  __ASM volatile ("revsh %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
S  return(result);
S#endif
S}
S
S
S/** \brief  Rotate Right in unsigned value (32 bit)
S
S    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
S
S    \param [in]    value  Value to rotate
S    \param [in]    value  Number of Bits to rotate
S    \return               Rotated value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __ROR(uint32_t op1, uint32_t op2)
S{
S  return (op1 >> op2) | (op1 << (32 - op2)); 
S}
S
S
S/** \brief  Breakpoint
S
S    This function causes the processor to enter Debug state.
S    Debug tools can use this to investigate system state when the instruction at a particular address is reached.
S
S    \param [in]    value  is ignored by the processor.
S                   If required, a debugger can use it to store additional information about the breakpoint.
S */
S#define __BKPT(value)                       __ASM volatile ("bkpt "#value)
S
S
S#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
S
S/** \brief  Reverse bit order of value
S
S    This function reverses the bit order of the given value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
S{
S  uint32_t result;
S
S   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (8 bit)
S
S    This function executes a exclusive LDR instruction for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __LDREXB(volatile uint8_t *addr)
S{
S    uint32_t result;
S
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S   __ASM volatile ("ldrexb %0, %1" : "=r" (result) : "Q" (*addr) );
S#else
S    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
S       accepted by assembler. So has to use following less efficient pattern.
S    */
S   __ASM volatile ("ldrexb %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
S#endif
S   return ((uint8_t) result);    /* Add explicit type cast here */
S}
S
S
S/** \brief  LDR Exclusive (16 bit)
S
S    This function executes a exclusive LDR instruction for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint16_t __LDREXH(volatile uint16_t *addr)
S{
S    uint32_t result;
S
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S   __ASM volatile ("ldrexh %0, %1" : "=r" (result) : "Q" (*addr) );
S#else
S    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
S       accepted by assembler. So has to use following less efficient pattern.
S    */
S   __ASM volatile ("ldrexh %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
S#endif
S   return ((uint16_t) result);    /* Add explicit type cast here */
S}
S
S
S/** \brief  LDR Exclusive (32 bit)
S
S    This function executes a exclusive LDR instruction for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __LDREXW(volatile uint32_t *addr)
S{
S    uint32_t result;
S
S   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (8 bit)
S
S    This function executes a exclusive STR instruction for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXB(uint8_t value, volatile uint8_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strexb %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" ((uint32_t)value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (16 bit)
S
S    This function executes a exclusive STR instruction for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXH(uint16_t value, volatile uint16_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strexh %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" ((uint32_t)value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (32 bit)
S
S    This function executes a exclusive STR instruction for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
S   return(result);
S}
S
S
S/** \brief  Remove the exclusive lock
S
S    This function removes the exclusive lock which is created by LDREX.
S
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __CLREX(void)
S{
S  __ASM volatile ("clrex" ::: "memory");
S}
S
S
S/** \brief  Signed Saturate
S
S    This function saturates a signed value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (1..32)
S    \return             Saturated value
S */
S#define __SSAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __SSAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Unsigned Saturate
S
S    This function saturates an unsigned value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (0..31)
S    \return             Saturated value
S */
S#define __USAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __USAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Count leading zeros
S
S    This function counts the number of leading zeros of a data value.
S
S    \param [in]  value  Value to count the leading zeros
S    \return             number of leading zeros in value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
S   return ((uint8_t) result);    /* Add explicit type cast here */
S}
S
S
S/** \brief  Rotate Right with Extend (32 bit)
S
S    This function moves each bit of a bitstring right by one bit. The carry input is shifted in at the left end of the bitstring.
S
S    \param [in]    value  Value to rotate
S    \return               Rotated value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RRX(uint32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("rrx %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
S  return(result);
S}
S
S
S/** \brief  LDRT Unprivileged (8 bit)
S
S    This function executes a Unprivileged LDRT instruction for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __LDRBT(volatile uint8_t *addr)
S{
S    uint32_t result;
S
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S   __ASM volatile ("ldrbt %0, %1" : "=r" (result) : "Q" (*addr) );
S#else
S    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
S       accepted by assembler. So has to use following less efficient pattern.
S    */
S   __ASM volatile ("ldrbt %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
S#endif
S   return ((uint8_t) result);    /* Add explicit type cast here */
S}
S
S
S/** \brief  LDRT Unprivileged (16 bit)
S
S    This function executes a Unprivileged LDRT instruction for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint16_t __LDRHT(volatile uint16_t *addr)
S{
S    uint32_t result;
S
S#if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
S   __ASM volatile ("ldrht %0, %1" : "=r" (result) : "Q" (*addr) );
S#else
S    /* Prior to GCC 4.8, "Q" will be expanded to [rx, #0] which is not
S       accepted by assembler. So has to use following less efficient pattern.
S    */
S   __ASM volatile ("ldrht %0, [%1]" : "=r" (result) : "r" (addr) : "memory" );
S#endif
S   return ((uint16_t) result);    /* Add explicit type cast here */
S}
S
S
S/** \brief  LDRT Unprivileged (32 bit)
S
S    This function executes a Unprivileged LDRT instruction for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __LDRT(volatile uint32_t *addr)
S{
S    uint32_t result;
S
S   __ASM volatile ("ldrt %0, %1" : "=r" (result) : "Q" (*addr) );
S   return(result);
S}
S
S
S/** \brief  STRT Unprivileged (8 bit)
S
S    This function executes a Unprivileged STRT instruction for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __STRBT(uint8_t value, volatile uint8_t *addr)
S{
S   __ASM volatile ("strbt %1, %0" : "=Q" (*addr) : "r" ((uint32_t)value) );
S}
S
S
S/** \brief  STRT Unprivileged (16 bit)
S
S    This function executes a Unprivileged STRT instruction for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __STRHT(uint16_t value, volatile uint16_t *addr)
S{
S   __ASM volatile ("strht %1, %0" : "=Q" (*addr) : "r" ((uint32_t)value) );
S}
S
S
S/** \brief  STRT Unprivileged (32 bit)
S
S    This function executes a Unprivileged STRT instruction for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __STRT(uint32_t value, volatile uint32_t *addr)
S{
S   __ASM volatile ("strt %1, %0" : "=Q" (*addr) : "r" (value) );
S}
S
S#endif /* (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300) */
S
S
S#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S#include <cmsis_iar.h>
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S#include <cmsis_ccs.h>
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all intrinsics,
S * Including the CMSIS ones.
S */
S
S
S#elif defined ( __CSMC__ ) /*------------------ COSMIC Compiler -------------------*/
S/* Cosmic specific functions */
S#include <cmsis_csm.h>
S
N#endif
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N#endif /* __CORE_CMINSTR_H */
L 189 ".\inc\core_cm4.h" 2
N#include <core_cmFunc.h>                 /* Core Function Access                            */
L 1 ".\inc\core_cmFunc.h" 1
N/**************************************************************************//**
N * @file     core_cmFunc.h
N * @brief    CMSIS Cortex-M Core Function Access Header File
N * @version  V4.00
N * @date     28. August 2014
N *
N * @note
N *
N ******************************************************************************/
N/* Copyright (c) 2009 - 2014 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#ifndef __CORE_CMFUNC_H
N#define __CORE_CMFUNC_H
N
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N#if (__ARMCC_VERSION < 400677)
X#if (5060422 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N/** \brief  Get Control Register
N
N    This function returns the content of the Control Register.
N
N    \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/** \brief  Set Control Register
N
N    This function writes the given value to the Control Register.
N
N    \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/** \brief  Get IPSR Register
N
N    This function returns the content of the IPSR Register.
N
N    \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/** \brief  Get APSR Register
N
N    This function returns the content of the APSR Register.
N
N    \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/** \brief  Get xPSR Register
N
N    This function returns the content of the xPSR Register.
N
N    \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/** \brief  Get Process Stack Pointer
N
N    This function returns the current value of the Process Stack Pointer (PSP).
N
N    \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/** \brief  Set Process Stack Pointer
N
N    This function assigns the given value to the Process Stack Pointer (PSP).
N
N    \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/** \brief  Get Main Stack Pointer
N
N    This function returns the current value of the Main Stack Pointer (MSP).
N
N    \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/** \brief  Set Main Stack Pointer
N
N    This function assigns the given value to the Main Stack Pointer (MSP).
N
N    \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/** \brief  Get Priority Mask
N
N    This function returns the current state of the priority mask bit from the Priority Mask Register.
N
N    \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/** \brief  Set Priority Mask
N
N    This function assigns the given value to the Priority Mask Register.
N
N    \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if       (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300)
X#if       ((0x04) >= 0x03) || (__CORTEX_SC >= 300)
N
N/** \brief  Enable FIQ
N
N    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
N    Can only be executed in Privileged modes.
N */
N#define __enable_fault_irq                __enable_fiq
N
N
N/** \brief  Disable FIQ
N
N    This function disables FIQ interrupts by setting the F-bit in the CPSR.
N    Can only be executed in Privileged modes.
N */
N#define __disable_fault_irq               __disable_fiq
N
N
N/** \brief  Get Base Priority
N
N    This function returns the current value of the Base Priority register.
N
N    \return               Base Priority register value
N */
N__STATIC_INLINE uint32_t  __get_BASEPRI(void)
Xstatic __inline uint32_t  __get_BASEPRI(void)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  return(__regBasePri);
N}
N
N
N/** \brief  Set Base Priority
N
N    This function assigns the given value to the Base Priority register.
N
N    \param [in]    basePri  Base Priority value to set
N */
N__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
Xstatic __inline void __set_BASEPRI(uint32_t basePri)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  __regBasePri = (basePri & 0xff);
N}
N
N
N/** \brief  Get Fault Mask
N
N    This function returns the current value of the Fault Mask register.
N
N    \return               Fault Mask register value
N */
N__STATIC_INLINE uint32_t __get_FAULTMASK(void)
Xstatic __inline uint32_t __get_FAULTMASK(void)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  return(__regFaultMask);
N}
N
N
N/** \brief  Set Fault Mask
N
N    This function assigns the given value to the Fault Mask register.
N
N    \param [in]    faultMask  Fault Mask value to set
N */
N__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
Xstatic __inline void __set_FAULTMASK(uint32_t faultMask)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  __regFaultMask = (faultMask & (uint32_t)1);
N}
N
N#endif /* (__CORTEX_M >= 0x03) || (__CORTEX_SC >= 300) */
N
N
N#if       (__CORTEX_M == 0x04) || (__CORTEX_M == 0x07)
X#if       ((0x04) == 0x04) || ((0x04) == 0x07)
N
N/** \brief  Get FPSCR
N
N    This function returns the current value of the Floating Point Status/Control register.
N
N    \return               Floating Point Status/Control register value
N */
N__STATIC_INLINE uint32_t __get_FPSCR(void)
Xstatic __inline uint32_t __get_FPSCR(void)
N{
N#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
X#if (1 == 1) && (1 == 1)
N  register uint32_t __regfpscr         __ASM("fpscr");
X  register uint32_t __regfpscr         __asm("fpscr");
N  return(__regfpscr);
N#else
S   return(0);
N#endif
N}
N
N
N/** \brief  Set FPSCR
N
N    This function assigns the given value to the Floating Point Status/Control register.
N
N    \param [in]    fpscr  Floating Point Status/Control value to set
N */
N__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
Xstatic __inline void __set_FPSCR(uint32_t fpscr)
N{
N#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
X#if (1 == 1) && (1 == 1)
N  register uint32_t __regfpscr         __ASM("fpscr");
X  register uint32_t __regfpscr         __asm("fpscr");
N  __regfpscr = (fpscr);
N#endif
N}
N
N#endif /* (__CORTEX_M == 0x04) || (__CORTEX_M == 0x07) */
N
N
N#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/** \brief  Enable IRQ Interrupts
S
S  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
S{
S  __ASM volatile ("cpsie i" : : : "memory");
S}
S
S
S/** \brief  Disable IRQ Interrupts
S
S  This function disables IRQ interrupts by setting the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
S{
S  __ASM volatile ("cpsid i" : : : "memory");
S}
S
S
S/** \brief  Get Control Register
S
S    This function returns the content of the Control Register.
S
S    \return               Control Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_CONTROL(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, control" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Control Register
S
S    This function writes the given value to the Control Register.
S
S    \param [in]    control  Control Register value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_CONTROL(uint32_t control)
S{
S  __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
S}
S
S
S/** \brief  Get IPSR Register
S
S    This function returns the content of the IPSR Register.
S
S    \return               IPSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get APSR Register
S
S    This function returns the content of the APSR Register.
S
S    \return               APSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_APSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, apsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get xPSR Register
S
S    This function returns the content of the xPSR Register.
S
S    \return               xPSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_xPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get Process Stack Pointer
S
S    This function returns the current value of the Process Stack Pointer (PSP).
S
S    \return               PSP Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Process Stack Pointer
S
S    This function assigns the given value to the Process Stack Pointer (PSP).
S
S    \param [in]    topOfProcStack  Process Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
S{
S  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
S}
S
S
S/** \brief  Get Main Stack Pointer
S
S    This function returns the current value of the Main Stack Pointer (MSP).
S
S    \return               MSP Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_MSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, msp\n" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Main Stack Pointer
S
S    This function assigns the given value to the Main Stack Pointer (MSP).
S
S    \param [in]    topOfMainStack  Main Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
S{
S  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) : "sp");
S}
S
S
S/** \brief  Get Priority Mask
S
S    This function returns the current state of the priority mask bit from the Priority Mask Register.
S
S    \return               Priority Mask value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, primask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Priority Mask
S
S    This function assigns the given value to the Priority Mask Register.
S
S    \param [in]    priMask  Priority Mask
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
S{
S  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
S}
S
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Enable FIQ
S
S    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_fault_irq(void)
S{
S  __ASM volatile ("cpsie f" : : : "memory");
S}
S
S
S/** \brief  Disable FIQ
S
S    This function disables FIQ interrupts by setting the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_fault_irq(void)
S{
S  __ASM volatile ("cpsid f" : : : "memory");
S}
S
S
S/** \brief  Get Base Priority
S
S    This function returns the current value of the Base Priority register.
S
S    \return               Base Priority register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, basepri_max" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Base Priority
S
S    This function assigns the given value to the Base Priority register.
S
S    \param [in]    basePri  Base Priority value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
S{
S  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
S}
S
S
S/** \brief  Get Fault Mask
S
S    This function returns the current value of the Fault Mask register.
S
S    \return               Fault Mask register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Fault Mask
S
S    This function assigns the given value to the Fault Mask register.
S
S    \param [in]    faultMask  Fault Mask value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
S}
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S#if       (__CORTEX_M == 0x04) || (__CORTEX_M == 0x07)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  uint32_t result;
S
S  /* Empty asm statement works as a scheduling barrier */
S  __ASM volatile ("");
S  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
S  __ASM volatile ("");
S  return(result);
S#else
S   return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  /* Empty asm statement works as a scheduling barrier */
S  __ASM volatile ("");
S  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc");
S  __ASM volatile ("");
S#endif
S}
S
S#endif /* (__CORTEX_M == 0x04) || (__CORTEX_M == 0x07) */
S
S
S#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S#include <cmsis_iar.h>
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S#include <cmsis_ccs.h>
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all intrinsics,
S * Including the CMSIS ones.
S */
S
S
S#elif defined ( __CSMC__ ) /*------------------ COSMIC Compiler -------------------*/
S/* Cosmic specific functions */
S#include <cmsis_csm.h>
S
N#endif
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N#endif /* __CORE_CMFUNC_H */
L 190 ".\inc\core_cm4.h" 2
N#include <core_cmSimd.h>                 /* Compiler specific SIMD Intrinsics               */
L 1 ".\inc\core_cmSimd.h" 1
N/**************************************************************************//**
N * @file     core_cmSimd.h
N * @brief    CMSIS Cortex-M SIMD Header File
N * @version  V4.00
N * @date     22. August 2014
N *
N * @note
N *
N ******************************************************************************/
N/* Copyright (c) 2009 - 2014 ARM LIMITED
N
N   All rights reserved.
N   Redistribution and use in source and binary forms, with or without
N   modification, are permitted provided that the following conditions are met:
N   - Redistributions of source code must retain the above copyright
N     notice, this list of conditions and the following disclaimer.
N   - Redistributions in binary form must reproduce the above copyright
N     notice, this list of conditions and the following disclaimer in the
N     documentation and/or other materials provided with the distribution.
N   - Neither the name of ARM nor the names of its contributors may be used
N     to endorse or promote products derived from this software without
N     specific prior written permission.
N   *
N   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
N   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
N   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
N   ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
N   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
N   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
N   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
N   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
N   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
N   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N   POSSIBILITY OF SUCH DAMAGE.
N   ---------------------------------------------------------------------------*/
N
N
N#if defined ( __ICCARM__ )
X#if 0L
S #pragma system_include  /* treat file as system include file for MISRA check */
N#endif
N
N#ifndef __CORE_CMSIMD_H
N#define __CORE_CMSIMD_H
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N ******************************************************************************/
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
N  Access to dedicated SIMD instructions
N  @{
N*/
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N#define __SADD8                           __sadd8
N#define __QADD8                           __qadd8
N#define __SHADD8                          __shadd8
N#define __UADD8                           __uadd8
N#define __UQADD8                          __uqadd8
N#define __UHADD8                          __uhadd8
N#define __SSUB8                           __ssub8
N#define __QSUB8                           __qsub8
N#define __SHSUB8                          __shsub8
N#define __USUB8                           __usub8
N#define __UQSUB8                          __uqsub8
N#define __UHSUB8                          __uhsub8
N#define __SADD16                          __sadd16
N#define __QADD16                          __qadd16
N#define __SHADD16                         __shadd16
N#define __UADD16                          __uadd16
N#define __UQADD16                         __uqadd16
N#define __UHADD16                         __uhadd16
N#define __SSUB16                          __ssub16
N#define __QSUB16                          __qsub16
N#define __SHSUB16                         __shsub16
N#define __USUB16                          __usub16
N#define __UQSUB16                         __uqsub16
N#define __UHSUB16                         __uhsub16
N#define __SASX                            __sasx
N#define __QASX                            __qasx
N#define __SHASX                           __shasx
N#define __UASX                            __uasx
N#define __UQASX                           __uqasx
N#define __UHASX                           __uhasx
N#define __SSAX                            __ssax
N#define __QSAX                            __qsax
N#define __SHSAX                           __shsax
N#define __USAX                            __usax
N#define __UQSAX                           __uqsax
N#define __UHSAX                           __uhsax
N#define __USAD8                           __usad8
N#define __USADA8                          __usada8
N#define __SSAT16                          __ssat16
N#define __USAT16                          __usat16
N#define __UXTB16                          __uxtb16
N#define __UXTAB16                         __uxtab16
N#define __SXTB16                          __sxtb16
N#define __SXTAB16                         __sxtab16
N#define __SMUAD                           __smuad
N#define __SMUADX                          __smuadx
N#define __SMLAD                           __smlad
N#define __SMLADX                          __smladx
N#define __SMLALD                          __smlald
N#define __SMLALDX                         __smlaldx
N#define __SMUSD                           __smusd
N#define __SMUSDX                          __smusdx
N#define __SMLSD                           __smlsd
N#define __SMLSDX                          __smlsdx
N#define __SMLSLD                          __smlsld
N#define __SMLSLDX                         __smlsldx
N#define __SEL                             __sel
N#define __QADD                            __qadd
N#define __QSUB                            __qsub
N
N#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |  \
N                                           ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
X#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |                                             ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
N
N#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |  \
N                                           ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
X#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |                                             ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
N
N#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) + \
N                                                      ((int64_t)(ARG3) << 32)      ) >> 32))
X#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) +                                                       ((int64_t)(ARG3) << 32)      ) >> 32))
N
N
N#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SADD8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("sadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QADD8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("qadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SHADD8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("shadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UADD8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UQADD8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uqadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UHADD8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uhadd8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SSUB8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("ssub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QSUB8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("qsub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SHSUB8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("shsub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __USUB8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("usub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UQSUB8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uqsub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UHSUB8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uhsub8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SADD16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("sadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QADD16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("qadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SHADD16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("shadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UADD16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UQADD16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uqadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UHADD16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uhadd16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SSUB16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("ssub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QSUB16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("qsub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SHSUB16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("shsub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __USUB16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("usub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UQSUB16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uqsub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UHSUB16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uhsub16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SASX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("sasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QASX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("qasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SHASX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("shasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UASX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UQASX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uqasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UHASX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uhasx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SSAX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("ssax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QSAX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("qsax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SHSAX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("shsax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __USAX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("usax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UQSAX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uqsax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UHSAX(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uhsax %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __USAD8(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("usad8 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __USADA8(uint32_t op1, uint32_t op2, uint32_t op3)
S{
S  uint32_t result;
S
S  __ASM volatile ("usada8 %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
S  return(result);
S}
S
S#define __SSAT16(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("ssat16 %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __SSAT16(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("ssat16 %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S#define __USAT16(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("usat16 %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __USAT16(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("usat16 %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UXTB16(uint32_t op1)
S{
S  uint32_t result;
S
S  __ASM volatile ("uxtb16 %0, %1" : "=r" (result) : "r" (op1));
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __UXTAB16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("uxtab16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SXTB16(uint32_t op1)
S{
S  uint32_t result;
S
S  __ASM volatile ("sxtb16 %0, %1" : "=r" (result) : "r" (op1));
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SXTAB16(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("sxtab16 %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMUAD  (uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("smuad %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMUADX (uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("smuadx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMLAD (uint32_t op1, uint32_t op2, uint32_t op3)
S{
S  uint32_t result;
S
S  __ASM volatile ("smlad %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMLADX (uint32_t op1, uint32_t op2, uint32_t op3)
S{
S  uint32_t result;
S
S  __ASM volatile ("smladx %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint64_t __SMLALD (uint32_t op1, uint32_t op2, uint64_t acc)
S{
S  union llreg_u{
S    uint32_t w32[2];
S    uint64_t w64;
S  } llr;
S  llr.w64 = acc;
S
S#ifndef __ARMEB__   // Little endian
S  __ASM volatile ("smlald %0, %1, %2, %3" : "=r" (llr.w32[0]), "=r" (llr.w32[1]): "r" (op1), "r" (op2) , "0" (llr.w32[0]), "1" (llr.w32[1]) );
S#else               // Big endian
S  __ASM volatile ("smlald %0, %1, %2, %3" : "=r" (llr.w32[1]), "=r" (llr.w32[0]): "r" (op1), "r" (op2) , "0" (llr.w32[1]), "1" (llr.w32[0]) );
S#endif
S
S  return(llr.w64);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint64_t __SMLALDX (uint32_t op1, uint32_t op2, uint64_t acc)
S{
S  union llreg_u{
S    uint32_t w32[2];
S    uint64_t w64;
S  } llr;
S  llr.w64 = acc;
S
S#ifndef __ARMEB__   // Little endian
S  __ASM volatile ("smlaldx %0, %1, %2, %3" : "=r" (llr.w32[0]), "=r" (llr.w32[1]): "r" (op1), "r" (op2) , "0" (llr.w32[0]), "1" (llr.w32[1]) );
S#else               // Big endian
S  __ASM volatile ("smlaldx %0, %1, %2, %3" : "=r" (llr.w32[1]), "=r" (llr.w32[0]): "r" (op1), "r" (op2) , "0" (llr.w32[1]), "1" (llr.w32[0]) );
S#endif
S
S  return(llr.w64);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMUSD  (uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("smusd %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMUSDX (uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("smusdx %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMLSD (uint32_t op1, uint32_t op2, uint32_t op3)
S{
S  uint32_t result;
S
S  __ASM volatile ("smlsd %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMLSDX (uint32_t op1, uint32_t op2, uint32_t op3)
S{
S  uint32_t result;
S
S  __ASM volatile ("smlsdx %0, %1, %2, %3" : "=r" (result) : "r" (op1), "r" (op2), "r" (op3) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint64_t __SMLSLD (uint32_t op1, uint32_t op2, uint64_t acc)
S{
S  union llreg_u{
S    uint32_t w32[2];
S    uint64_t w64;
S  } llr;
S  llr.w64 = acc;
S
S#ifndef __ARMEB__   // Little endian
S  __ASM volatile ("smlsld %0, %1, %2, %3" : "=r" (llr.w32[0]), "=r" (llr.w32[1]): "r" (op1), "r" (op2) , "0" (llr.w32[0]), "1" (llr.w32[1]) );
S#else               // Big endian
S  __ASM volatile ("smlsld %0, %1, %2, %3" : "=r" (llr.w32[1]), "=r" (llr.w32[0]): "r" (op1), "r" (op2) , "0" (llr.w32[1]), "1" (llr.w32[0]) );
S#endif
S
S  return(llr.w64);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint64_t __SMLSLDX (uint32_t op1, uint32_t op2, uint64_t acc)
S{
S  union llreg_u{
S    uint32_t w32[2];
S    uint64_t w64;
S  } llr;
S  llr.w64 = acc;
S
S#ifndef __ARMEB__   // Little endian
S  __ASM volatile ("smlsldx %0, %1, %2, %3" : "=r" (llr.w32[0]), "=r" (llr.w32[1]): "r" (op1), "r" (op2) , "0" (llr.w32[0]), "1" (llr.w32[1]) );
S#else               // Big endian
S  __ASM volatile ("smlsldx %0, %1, %2, %3" : "=r" (llr.w32[1]), "=r" (llr.w32[0]): "r" (op1), "r" (op2) , "0" (llr.w32[1]), "1" (llr.w32[0]) );
S#endif
S
S  return(llr.w64);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SEL  (uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("sel %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QADD(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("qadd %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __QSUB(uint32_t op1, uint32_t op2)
S{
S  uint32_t result;
S
S  __ASM volatile ("qsub %0, %1, %2" : "=r" (result) : "r" (op1), "r" (op2) );
S  return(result);
S}
S
S#define __PKHBT(ARG1,ARG2,ARG3) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1), __ARG2 = (ARG2); \
S  __ASM ("pkhbt %0, %1, %2, lsl %3" : "=r" (__RES) :  "r" (__ARG1), "r" (__ARG2), "I" (ARG3)  ); \
S  __RES; \
S })
X#define __PKHBT(ARG1,ARG2,ARG3) ({                            uint32_t __RES, __ARG1 = (ARG1), __ARG2 = (ARG2);   __ASM ("pkhbt %0, %1, %2, lsl %3" : "=r" (__RES) :  "r" (__ARG1), "r" (__ARG2), "I" (ARG3)  );   __RES;  })
S
S#define __PKHTB(ARG1,ARG2,ARG3) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1), __ARG2 = (ARG2); \
S  if (ARG3 == 0) \
S    __ASM ("pkhtb %0, %1, %2" : "=r" (__RES) :  "r" (__ARG1), "r" (__ARG2)  ); \
S  else \
S    __ASM ("pkhtb %0, %1, %2, asr %3" : "=r" (__RES) :  "r" (__ARG1), "r" (__ARG2), "I" (ARG3)  ); \
S  __RES; \
S })
X#define __PKHTB(ARG1,ARG2,ARG3) ({                            uint32_t __RES, __ARG1 = (ARG1), __ARG2 = (ARG2);   if (ARG3 == 0)     __ASM ("pkhtb %0, %1, %2" : "=r" (__RES) :  "r" (__ARG1), "r" (__ARG2)  );   else     __ASM ("pkhtb %0, %1, %2, asr %3" : "=r" (__RES) :  "r" (__ARG1), "r" (__ARG2), "I" (ARG3)  );   __RES;  })
S
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __SMMLA (int32_t op1, int32_t op2, int32_t op3)
S{
S int32_t result;
S
S __ASM volatile ("smmla %0, %1, %2, %3" : "=r" (result): "r"  (op1), "r" (op2), "r" (op3) );
S return(result);
S}
S
S
S#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S#include <cmsis_iar.h>
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S#include <cmsis_ccs.h>
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S/* not yet supported */
S
S
S#elif defined ( __CSMC__ ) /*------------------ COSMIC Compiler -------------------*/
S/* Cosmic specific functions */
S#include <cmsis_csm.h>
S
N#endif
N
N/*@} end of group CMSIS_SIMD_intrinsics */
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CMSIMD_H */
L 191 ".\inc\core_cm4.h" 2
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM4_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
S
S#ifndef __CORE_CM4_H_DEPENDANT
S#define __CORE_CM4_H_DEPENDANT
S
S#ifdef __cplusplus
S extern "C" {
S#endif
S
S/* check device defines and use defaults */
S#if defined __CHECK_DEVICE_DEFINES
S  #ifndef __CM4_REV
S    #define __CM4_REV               0x0000
S    #warning "__CM4_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __FPU_PRESENT
S    #define __FPU_PRESENT             0
S    #warning "__FPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __MPU_PRESENT
S    #define __MPU_PRESENT             0
S    #warning "__MPU_PRESENT not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          4
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
S#endif
S
S/* IO definitions (access restrictions to peripheral registers) */
S/**
S    \defgroup CMSIS_glob_defs CMSIS Global Defines
S
S    <strong>IO Type Qualifiers</strong> are used
S    \li to specify the access to peripheral variables.
S    \li for automatic generation of peripheral register debug information.
S*/
S#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions                 */
S#else
S  #define   __I     volatile const       /*!< Defines 'read only' permissions                 */
S#endif
S#define     __O     volatile             /*!< Defines 'write only' permissions                */
S#define     __IO    volatile             /*!< Defines 'read / write' permissions              */
S
S/*@} end of group Cortex_M4 */
S
S
S
S/*******************************************************************************
S *                 Register Abstraction
S  Core Register contain:
S  - Core Register
S  - Core NVIC Register
S  - Core SCB Register
S  - Core SysTick Register
S  - Core Debug Register
S  - Core MPU Register
S  - Core FPU Register
S ******************************************************************************/
S/** \defgroup CMSIS_core_register Defines and Type Definitions
S    \brief Type definitions and defines for Cortex-M processor based devices.
S*/
S
S/** \ingroup    CMSIS_core_register
S    \defgroup   CMSIS_CORE  Status and Control Registers
S    \brief  Core Register type definitions.
S  @{
S */
S
S/** \brief  Union type to access the Application Program Status Register (APSR).
S */
Stypedef union
S{
S  struct
S  {
S#if (__CORTEX_M != 0x04)
S    uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved                           */
S#else
S    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved                           */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
S    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved                           */
S#endif
S    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
S    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
S    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
S    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
S    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
S  } b;                                   /*!< Structure used for bit  access                  */
S  uint32_t w;                            /*!< Type      used for word access                  */
S} APSR_Type;
S
S
S/** \brief  Union type to access the Interrupt Program Status Register (IPSR).
S */
Stypedef union
S{
S  struct
S  {
S    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
S    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved                           */
S  } b;                                   /*!< Structure used for bit  access                  */
S  uint32_t w;                            /*!< Type      used for word access                  */
S} IPSR_Type;
S
S
S/** \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
S */
Stypedef union
S{
S  struct
S  {
S    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
S#if (__CORTEX_M != 0x04)
S    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved                           */
S#else
S    uint32_t _reserved0:7;               /*!< bit:  9..15  Reserved                           */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
S    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved                           */
S#endif
S    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0)          */
S    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0)          */
S    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
S    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
S    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
S    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
S    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
S  } b;                                   /*!< Structure used for bit  access                  */
S  uint32_t w;                            /*!< Type      used for word access                  */
S} xPSR_Type;
S
S
S/** \brief  Union type to access the Control Registers (CONTROL).
S */
Stypedef union
S{
S  struct
S  {
S    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
S    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used                   */
S    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag           */
S    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved                           */
S  } b;                                   /*!< Structure used for bit  access                  */
S  uint32_t w;                            /*!< Type      used for word access                  */
S} CONTROL_Type;
S
S/*@} end of group CMSIS_CORE */
S
S
S/** \ingroup    CMSIS_core_register
S    \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
S    \brief      Type definitions for the NVIC Registers
S  @{
S */
S
S/** \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
S */
Stypedef struct
S{
S  __IO uint32_t ISER[8];                 /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register           */
S       uint32_t RESERVED0[24];
S  __IO uint32_t ICER[8];                 /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register         */
S       uint32_t RSERVED1[24];
S  __IO uint32_t ISPR[8];                 /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register          */
S       uint32_t RESERVED2[24];
S  __IO uint32_t ICPR[8];                 /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register        */
S       uint32_t RESERVED3[24];
S  __IO uint32_t IABR[8];                 /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register           */
S       uint32_t RESERVED4[56];
S  __IO uint8_t  IP[240];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bit wide) */
S       uint32_t RESERVED5[644];
S  __O  uint32_t STIR;                    /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Register     */
S}  NVIC_Type;
S
S/* Software Triggered Interrupt Register Definitions */
S#define NVIC_STIR_INTID_Pos                 0                                          /*!< STIR: INTLINESNUM Position */
S#define NVIC_STIR_INTID_Msk                (0x1FFUL << NVIC_STIR_INTID_Pos)            /*!< STIR: INTLINESNUM Mask */
S
S/*@} end of group CMSIS_NVIC */
S
S
S/** \ingroup  CMSIS_core_register
S    \defgroup CMSIS_SCB     System Control Block (SCB)
S    \brief      Type definitions for the System Control Block Registers
S  @{
S */
S
S/** \brief  Structure type to access the System Control Block (SCB).
S */
Stypedef struct
S{
S  __I  uint32_t CPUID;                   /*!< Offset: 0x000 (R/ )  CPUID Base Register                                   */
S  __IO uint32_t ICSR;                    /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register                  */
S  __IO uint32_t VTOR;                    /*!< Offset: 0x008 (R/W)  Vector Table Offset Register                          */
S  __IO uint32_t AIRCR;                   /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register      */
S  __IO uint32_t SCR;                     /*!< Offset: 0x010 (R/W)  System Control Register                               */
S  __IO uint32_t CCR;                     /*!< Offset: 0x014 (R/W)  Configuration Control Register                        */
S  __IO uint8_t  SHP[12];                 /*!< Offset: 0x018 (R/W)  System Handlers Priority Registers (4-7, 8-11, 12-15) */
S  __IO uint32_t SHCSR;                   /*!< Offset: 0x024 (R/W)  System Handler Control and State Register             */
S  __IO uint32_t CFSR;                    /*!< Offset: 0x028 (R/W)  Configurable Fault Status Register                    */
S  __IO uint32_t HFSR;                    /*!< Offset: 0x02C (R/W)  HardFault Status Register                             */
S  __IO uint32_t DFSR;                    /*!< Offset: 0x030 (R/W)  Debug Fault Status Register                           */
S  __IO uint32_t MMFAR;                   /*!< Offset: 0x034 (R/W)  MemManage Fault Address Register                      */
S  __IO uint32_t BFAR;                    /*!< Offset: 0x038 (R/W)  BusFault Address Register                             */
S  __IO uint32_t AFSR;                    /*!< Offset: 0x03C (R/W)  Auxiliary Fault Status Register                       */
S  __I  uint32_t PFR[2];                  /*!< Offset: 0x040 (R/ )  Processor Feature Register                            */
S  __I  uint32_t DFR;                     /*!< Offset: 0x048 (R/ )  Debug Feature Register                                */
S  __I  uint32_t ADR;                     /*!< Offset: 0x04C (R/ )  Auxiliary Feature Register                            */
S  __I  uint32_t MMFR[4];                 /*!< Offset: 0x050 (R/ )  Memory Model Feature Register                         */
S  __I  uint32_t ISAR[5];                 /*!< Offset: 0x060 (R/ )  Instruction Set Attributes Register                   */
S       uint32_t RESERVED0[5];
S  __IO uint32_t CPACR;                   /*!< Offset: 0x088 (R/W)  Coprocessor Access Control Register                   */
S} SCB_Type;
S
S/* SCB CPUID Register Definitions */
S#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
S#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
S
S#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
S#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
S
S#define SCB_CPUID_ARCHITECTURE_Pos         16                                             /*!< SCB CPUID: ARCHITECTURE Position */
S#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
S
S#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
S#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
S
S#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
S#define SCB_CPUID_REVISION_Msk             (0xFUL << SCB_CPUID_REVISION_Pos)              /*!< SCB CPUID: REVISION Mask */
S
S/* SCB Interrupt Control State Register Definitions */
S#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
S#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
S
S#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
S#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
S
S#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
S#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
S
S#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
S#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
S
S#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
S#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
S
S#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
S#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
S
S#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
S#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
S
S#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
S#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
S
S#define SCB_ICSR_RETTOBASE_Pos             11                                             /*!< SCB ICSR: RETTOBASE Position */
S#define SCB_ICSR_RETTOBASE_Msk             (1UL << SCB_ICSR_RETTOBASE_Pos)                /*!< SCB ICSR: RETTOBASE Mask */
S
S#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
S#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB ICSR: VECTACTIVE Mask */
S
S/* SCB Vector Table Offset Register Definitions */
S#define SCB_VTOR_TBLOFF_Pos                 7                                             /*!< SCB VTOR: TBLOFF Position */
S#define SCB_VTOR_TBLOFF_Msk                (0x1FFFFFFUL << SCB_VTOR_TBLOFF_Pos)           /*!< SCB VTOR: TBLOFF Mask */
S
S/* SCB Application Interrupt and Reset Control Register Definitions */
S#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
S#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
S
S#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
S#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
S
S#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
S#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
S
S#define SCB_AIRCR_PRIGROUP_Pos              8                                             /*!< SCB AIRCR: PRIGROUP Position */
S#define SCB_AIRCR_PRIGROUP_Msk             (7UL << SCB_AIRCR_PRIGROUP_Pos)                /*!< SCB AIRCR: PRIGROUP Mask */
S
S#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
S#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
S
S#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
S#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
S
S#define SCB_AIRCR_VECTRESET_Pos             0                                             /*!< SCB AIRCR: VECTRESET Position */
S#define SCB_AIRCR_VECTRESET_Msk            (1UL << SCB_AIRCR_VECTRESET_Pos)               /*!< SCB AIRCR: VECTRESET Mask */
S
S/* SCB System Control Register Definitions */
S#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
S#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
S
S#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
S#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
S
S#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
S#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
S
S/* SCB Configuration Control Register Definitions */
S#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
S#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
S
S#define SCB_CCR_BFHFNMIGN_Pos               8                                             /*!< SCB CCR: BFHFNMIGN Position */
S#define SCB_CCR_BFHFNMIGN_Msk              (1UL << SCB_CCR_BFHFNMIGN_Pos)                 /*!< SCB CCR: BFHFNMIGN Mask */
S
S#define SCB_CCR_DIV_0_TRP_Pos               4                                             /*!< SCB CCR: DIV_0_TRP Position */
S#define SCB_CCR_DIV_0_TRP_Msk              (1UL << SCB_CCR_DIV_0_TRP_Pos)                 /*!< SCB CCR: DIV_0_TRP Mask */
S
S#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
S#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
S
S#define SCB_CCR_USERSETMPEND_Pos            1                                             /*!< SCB CCR: USERSETMPEND Position */
S#define SCB_CCR_USERSETMPEND_Msk           (1UL << SCB_CCR_USERSETMPEND_Pos)              /*!< SCB CCR: USERSETMPEND Mask */
S
S#define SCB_CCR_NONBASETHRDENA_Pos          0                                             /*!< SCB CCR: NONBASETHRDENA Position */
S#define SCB_CCR_NONBASETHRDENA_Msk         (1UL << SCB_CCR_NONBASETHRDENA_Pos)            /*!< SCB CCR: NONBASETHRDENA Mask */
S
S/* SCB System Handler Control and State Register Definitions */
S#define SCB_SHCSR_USGFAULTENA_Pos          18                                             /*!< SCB SHCSR: USGFAULTENA Position */
S#define SCB_SHCSR_USGFAULTENA_Msk          (1UL << SCB_SHCSR_USGFAULTENA_Pos)             /*!< SCB SHCSR: USGFAULTENA Mask */
S
S#define SCB_SHCSR_BUSFAULTENA_Pos          17                                             /*!< SCB SHCSR: BUSFAULTENA Position */
S#define SCB_SHCSR_BUSFAULTENA_Msk          (1UL << SCB_SHCSR_BUSFAULTENA_Pos)             /*!< SCB SHCSR: BUSFAULTENA Mask */
S
S#define SCB_SHCSR_MEMFAULTENA_Pos          16                                             /*!< SCB SHCSR: MEMFAULTENA Position */
S#define SCB_SHCSR_MEMFAULTENA_Msk          (1UL << SCB_SHCSR_MEMFAULTENA_Pos)             /*!< SCB SHCSR: MEMFAULTENA Mask */
S
S#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
S#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
S
S#define SCB_SHCSR_BUSFAULTPENDED_Pos       14                                             /*!< SCB SHCSR: BUSFAULTPENDED Position */
S#define SCB_SHCSR_BUSFAULTPENDED_Msk       (1UL << SCB_SHCSR_BUSFAULTPENDED_Pos)          /*!< SCB SHCSR: BUSFAULTPENDED Mask */
S
S#define SCB_SHCSR_MEMFAULTPENDED_Pos       13                                             /*!< SCB SHCSR: MEMFAULTPENDED Position */
S#define SCB_SHCSR_MEMFAULTPENDED_Msk       (1UL << SCB_SHCSR_MEMFAULTPENDED_Pos)          /*!< SCB SHCSR: MEMFAULTPENDED Mask */
S
S#define SCB_SHCSR_USGFAULTPENDED_Pos       12                                             /*!< SCB SHCSR: USGFAULTPENDED Position */
S#define SCB_SHCSR_USGFAULTPENDED_Msk       (1UL << SCB_SHCSR_USGFAULTPENDED_Pos)          /*!< SCB SHCSR: USGFAULTPENDED Mask */
S
S#define SCB_SHCSR_SYSTICKACT_Pos           11                                             /*!< SCB SHCSR: SYSTICKACT Position */
S#define SCB_SHCSR_SYSTICKACT_Msk           (1UL << SCB_SHCSR_SYSTICKACT_Pos)              /*!< SCB SHCSR: SYSTICKACT Mask */
S
S#define SCB_SHCSR_PENDSVACT_Pos            10                                             /*!< SCB SHCSR: PENDSVACT Position */
S#define SCB_SHCSR_PENDSVACT_Msk            (1UL << SCB_SHCSR_PENDSVACT_Pos)               /*!< SCB SHCSR: PENDSVACT Mask */
S
S#define SCB_SHCSR_MONITORACT_Pos            8                                             /*!< SCB SHCSR: MONITORACT Position */
S#define SCB_SHCSR_MONITORACT_Msk           (1UL << SCB_SHCSR_MONITORACT_Pos)              /*!< SCB SHCSR: MONITORACT Mask */
S
S#define SCB_SHCSR_SVCALLACT_Pos             7                                             /*!< SCB SHCSR: SVCALLACT Position */
S#define SCB_SHCSR_SVCALLACT_Msk            (1UL << SCB_SHCSR_SVCALLACT_Pos)               /*!< SCB SHCSR: SVCALLACT Mask */
S
S#define SCB_SHCSR_USGFAULTACT_Pos           3                                             /*!< SCB SHCSR: USGFAULTACT Position */
S#define SCB_SHCSR_USGFAULTACT_Msk          (1UL << SCB_SHCSR_USGFAULTACT_Pos)             /*!< SCB SHCSR: USGFAULTACT Mask */
S
S#define SCB_SHCSR_BUSFAULTACT_Pos           1                                             /*!< SCB SHCSR: BUSFAULTACT Position */
S#define SCB_SHCSR_BUSFAULTACT_Msk          (1UL << SCB_SHCSR_BUSFAULTACT_Pos)             /*!< SCB SHCSR: BUSFAULTACT Mask */
S
S#define SCB_SHCSR_MEMFAULTACT_Pos           0                                             /*!< SCB SHCSR: MEMFAULTACT Position */
S#define SCB_SHCSR_MEMFAULTACT_Msk          (1UL << SCB_SHCSR_MEMFAULTACT_Pos)             /*!< SCB SHCSR: MEMFAULTACT Mask */
S
S/* SCB Configurable Fault Status Registers Definitions */
S#define SCB_CFSR_USGFAULTSR_Pos            16                                             /*!< SCB CFSR: Usage Fault Status Register Position */
S#define SCB_CFSR_USGFAULTSR_Msk            (0xFFFFUL << SCB_CFSR_USGFAULTSR_Pos)          /*!< SCB CFSR: Usage Fault Status Register Mask */
S
S#define SCB_CFSR_BUSFAULTSR_Pos             8                                             /*!< SCB CFSR: Bus Fault Status Register Position */
S#define SCB_CFSR_BUSFAULTSR_Msk            (0xFFUL << SCB_CFSR_BUSFAULTSR_Pos)            /*!< SCB CFSR: Bus Fault Status Register Mask */
S
S#define SCB_CFSR_MEMFAULTSR_Pos             0                                             /*!< SCB CFSR: Memory Manage Fault Status Register Position */
S#define SCB_CFSR_MEMFAULTSR_Msk            (0xFFUL << SCB_CFSR_MEMFAULTSR_Pos)            /*!< SCB CFSR: Memory Manage Fault Status Register Mask */
S
S/* SCB Hard Fault Status Registers Definitions */
S#define SCB_HFSR_DEBUGEVT_Pos              31                                             /*!< SCB HFSR: DEBUGEVT Position */
S#define SCB_HFSR_DEBUGEVT_Msk              (1UL << SCB_HFSR_DEBUGEVT_Pos)                 /*!< SCB HFSR: DEBUGEVT Mask */
S
S#define SCB_HFSR_FORCED_Pos                30                                             /*!< SCB HFSR: FORCED Position */
S#define SCB_HFSR_FORCED_Msk                (1UL << SCB_HFSR_FORCED_Pos)                   /*!< SCB HFSR: FORCED Mask */
S
S#define SCB_HFSR_VECTTBL_Pos                1                                             /*!< SCB HFSR: VECTTBL Position */
S#define SCB_HFSR_VECTTBL_Msk               (1UL << SCB_HFSR_VECTTBL_Pos)                  /*!< SCB HFSR: VECTTBL Mask */
S
S/* SCB Debug Fault Status Register Definitions */
S#define SCB_DFSR_EXTERNAL_Pos               4                                             /*!< SCB DFSR: EXTERNAL Position */
S#define SCB_DFSR_EXTERNAL_Msk              (1UL << SCB_DFSR_EXTERNAL_Pos)                 /*!< SCB DFSR: EXTERNAL Mask */
S
S#define SCB_DFSR_VCATCH_Pos                 3                                             /*!< SCB DFSR: VCATCH Position */
S#define SCB_DFSR_VCATCH_Msk                (1UL << SCB_DFSR_VCATCH_Pos)                   /*!< SCB DFSR: VCATCH Mask */
S
S#define SCB_DFSR_DWTTRAP_Pos                2                                             /*!< SCB DFSR: DWTTRAP Position */
S#define SCB_DFSR_DWTTRAP_Msk               (1UL << SCB_DFSR_DWTTRAP_Pos)                  /*!< SCB DFSR: DWTTRAP Mask */
S
S#define SCB_DFSR_BKPT_Pos                   1                                             /*!< SCB DFSR: BKPT Position */
S#define SCB_DFSR_BKPT_Msk                  (1UL << SCB_DFSR_BKPT_Pos)                     /*!< SCB DFSR: BKPT Mask */
S
S#define SCB_DFSR_HALTED_Pos                 0                                             /*!< SCB DFSR: HALTED Position */
S#define SCB_DFSR_HALTED_Msk                (1UL << SCB_DFSR_HALTED_Pos)                   /*!< SCB DFSR: HALTED Mask */
S
S/*@} end of group CMSIS_SCB */
S
S
S/** \ingroup  CMSIS_core_register
S    \defgroup CMSIS_SCnSCB System Controls not in SCB (SCnSCB)
S    \brief      Type definitions for the System Control and ID Register not in the SCB
S  @{
S */
S
S/** \brief  Structure type to access the System Control and ID Register not in the SCB.
S */
Stypedef struct
S{
S       uint32_t RESERVED0[1];
S  __I  uint32_t ICTR;                    /*!< Offset: 0x004 (R/ )  Interrupt Controller Type Register      */
S  __IO uint32_t ACTLR;                   /*!< Offset: 0x008 (R/W)  Auxiliary Control Register              */
S} SCnSCB_Type;
S
S/* Interrupt Controller Type Register Definitions */
S#define SCnSCB_ICTR_INTLINESNUM_Pos         0                                          /*!< ICTR: INTLINESNUM Position */
S#define SCnSCB_ICTR_INTLINESNUM_Msk        (0xFUL << SCnSCB_ICTR_INTLINESNUM_Pos)      /*!< ICTR: INTLINESNUM Mask */
S
S/* Auxiliary Control Register Definitions */
S#define SCnSCB_ACTLR_DISOOFP_Pos            9                                          /*!< ACTLR: DISOOFP Position */
S#define SCnSCB_ACTLR_DISOOFP_Msk           (1UL << SCnSCB_ACTLR_DISOOFP_Pos)           /*!< ACTLR: DISOOFP Mask */
S
S#define SCnSCB_ACTLR_DISFPCA_Pos            8                                          /*!< ACTLR: DISFPCA Position */
S#define SCnSCB_ACTLR_DISFPCA_Msk           (1UL << SCnSCB_ACTLR_DISFPCA_Pos)           /*!< ACTLR: DISFPCA Mask */
S
S#define SCnSCB_ACTLR_DISFOLD_Pos            2                                          /*!< ACTLR: DISFOLD Position */
S#define SCnSCB_ACTLR_DISFOLD_Msk           (1UL << SCnSCB_ACTLR_DISFOLD_Pos)           /*!< ACTLR: DISFOLD Mask */
S
S#define SCnSCB_ACTLR_DISDEFWBUF_Pos         1                                          /*!< ACTLR: DISDEFWBUF Position */
S#define SCnSCB_ACTLR_DISDEFWBUF_Msk        (1UL << SCnSCB_ACTLR_DISDEFWBUF_Pos)        /*!< ACTLR: DISDEFWBUF Mask */
S
S#define SCnSCB_ACTLR_DISMCYCINT_Pos         0                                          /*!< ACTLR: DISMCYCINT Position */
S#define SCnSCB_ACTLR_DISMCYCINT_Msk        (1UL << SCnSCB_ACTLR_DISMCYCINT_Pos)        /*!< ACTLR: DISMCYCINT Mask */
S
S/*@} end of group CMSIS_SCnotSCB */
S
S
S/** \ingroup  CMSIS_core_register
S    \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
S    \brief      Type definitions for the System Timer Registers.
S  @{
S */
S
S/** \brief  Structure type to access the System Timer (SysTick).
S */
Stypedef struct
S{
S  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
S  __IO uint32_t LOAD;                    /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register       */
S  __IO uint32_t VAL;                     /*!< Offset: 0x008 (R/W)  SysTick Current Value Register      */
S  __I  uint32_t CALIB;                   /*!< Offset: 0x00C (R/ )  SysTick Calibration Register        */
S} SysTick_Type;
S
S/* SysTick Control / Status Register Definitions */
S#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
S#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
S
S#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
S#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
S
S#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
S#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
S
S#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
S#define SysTick_CTRL_ENABLE_Msk            (1UL << SysTick_CTRL_ENABLE_Pos)               /*!< SysTick CTRL: ENABLE Mask */
S
S/* SysTick Reload Register Definitions */
S#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
S#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL << SysTick_LOAD_RELOAD_Pos)        /*!< SysTick LOAD: RELOAD Mask */
S
S/* SysTick Current Register Definitions */
S#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
S#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick VAL: CURRENT Mask */
S
S/* SysTick Calibration Register Definitions */
S#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
S#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
S
S#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
S#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
S
S#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
S#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL << SysTick_CALIB_TENMS_Pos)        /*!< SysTick CALIB: TENMS Mask */
S
S/*@} end of group CMSIS_SysTick */
S
S
S/** \ingroup  CMSIS_core_register
S    \defgroup CMSIS_ITM     Instrumentation Trace Macrocell (ITM)
S    \brief      Type definitions for the Instrumentation Trace Macrocell (ITM)
S  @{
S */
S
S/** \brief  Structure type to access the Instrumentation Trace Macrocell Register (ITM).
S */
Stypedef struct
S{
S  __O  union
S  {
S    __O  uint8_t    u8;                  /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 8-bit                   */
S    __O  uint16_t   u16;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 16-bit                  */
S    __O  uint32_t   u32;                 /*!< Offset: 0x000 ( /W)  ITM Stimulus Port 32-bit                  */
S  }  PORT [32];                          /*!< Offset: 0x000 ( /W)  ITM Stimulus Port Registers               */
S       uint32_t RESERVED0[864];
S  __IO uint32_t TER;                     /*!< Offset: 0xE00 (R/W)  ITM Trace Enable Register                 */
S       uint32_t RESERVED1[15];
S  __IO uint32_t TPR;                     /*!< Offset: 0xE40 (R/W)  ITM Trace Privilege Register              */
S       uint32_t RESERVED2[15];
S  __IO uint32_t TCR;                     /*!< Offset: 0xE80 (R/W)  ITM Trace Control Register                */
S       uint32_t RESERVED3[29];
S  __O  uint32_t IWR;                     /*!< Offset: 0xEF8 ( /W)  ITM Integration Write Register            */
S  __I  uint32_t IRR;                     /*!< Offset: 0xEFC (R/ )  ITM Integration Read Register             */
S  __IO uint32_t IMCR;                    /*!< Offset: 0xF00 (R/W)  ITM Integration Mode Control Register     */
S       uint32_t RESERVED4[43];
S  __O  uint32_t LAR;                     /*!< Offset: 0xFB0 ( /W)  ITM Lock Access Register                  */
S  __I  uint32_t LSR;                     /*!< Offset: 0xFB4 (R/ )  ITM Lock Status Register                  */
S       uint32_t RESERVED5[6];
S  __I  uint32_t PID4;                    /*!< Offset: 0xFD0 (R/ )  ITM Peripheral Identification Register #4 */
S  __I  uint32_t PID5;                    /*!< Offset: 0xFD4 (R/ )  ITM Peripheral Identification Register #5 */
S  __I  uint32_t PID6;                    /*!< Offset: 0xFD8 (R/ )  ITM Peripheral Identification Register #6 */
S  __I  uint32_t PID7;                    /*!< Offset: 0xFDC (R/ )  ITM Peripheral Identification Register #7 */
S  __I  uint32_t PID0;                    /*!< Offset: 0xFE0 (R/ )  ITM Peripheral Identification Register #0 */
S  __I  uint32_t PID1;                    /*!< Offset: 0xFE4 (R/ )  ITM Peripheral Identification Register #1 */
S  __I  uint32_t PID2;                    /*!< Offset: 0xFE8 (R/ )  ITM Peripheral Identification Register #2 */
S  __I  uint32_t PID3;                    /*!< Offset: 0xFEC (R/ )  ITM Peripheral Identification Register #3 */
S  __I  uint32_t CID0;                    /*!< Offset: 0xFF0 (R/ )  ITM Component  Identification Register #0 */
S  __I  uint32_t CID1;                    /*!< Offset: 0xFF4 (R/ )  ITM Component  Identification Register #1 */
S  __I  uint32_t CID2;                    /*!< Offset: 0xFF8 (R/ )  ITM Component  Identification Register #2 */
S  __I  uint32_t CID3;                    /*!< Offset: 0xFFC (R/ )  ITM Component  Identification Register #3 */
S} ITM_Type;
S
S/* ITM Trace Privilege Register Definitions */
S#define ITM_TPR_PRIVMASK_Pos                0                                             /*!< ITM TPR: PRIVMASK Position */
S#define ITM_TPR_PRIVMASK_Msk               (0xFUL << ITM_TPR_PRIVMASK_Pos)                /*!< ITM TPR: PRIVMASK Mask */
S
S/* ITM Trace Control Register Definitions */
S#define ITM_TCR_BUSY_Pos                   23                                             /*!< ITM TCR: BUSY Position */
S#define ITM_TCR_BUSY_Msk                   (1UL << ITM_TCR_BUSY_Pos)                      /*!< ITM TCR: BUSY Mask */
S
S#define ITM_TCR_TraceBusID_Pos             16                                             /*!< ITM TCR: ATBID Position */
S#define ITM_TCR_TraceBusID_Msk             (0x7FUL << ITM_TCR_TraceBusID_Pos)             /*!< ITM TCR: ATBID Mask */
S
S#define ITM_TCR_GTSFREQ_Pos                10                                             /*!< ITM TCR: Global timestamp frequency Position */
S#define ITM_TCR_GTSFREQ_Msk                (3UL << ITM_TCR_GTSFREQ_Pos)                   /*!< ITM TCR: Global timestamp frequency Mask */
S
S#define ITM_TCR_TSPrescale_Pos              8                                             /*!< ITM TCR: TSPrescale Position */
S#define ITM_TCR_TSPrescale_Msk             (3UL << ITM_TCR_TSPrescale_Pos)                /*!< ITM TCR: TSPrescale Mask */
S
S#define ITM_TCR_SWOENA_Pos                  4                                             /*!< ITM TCR: SWOENA Position */
S#define ITM_TCR_SWOENA_Msk                 (1UL << ITM_TCR_SWOENA_Pos)                    /*!< ITM TCR: SWOENA Mask */
S
S#define ITM_TCR_DWTENA_Pos                  3                                             /*!< ITM TCR: DWTENA Position */
S#define ITM_TCR_DWTENA_Msk                 (1UL << ITM_TCR_DWTENA_Pos)                    /*!< ITM TCR: DWTENA Mask */
S
S#define ITM_TCR_SYNCENA_Pos                 2                                             /*!< ITM TCR: SYNCENA Position */
S#define ITM_TCR_SYNCENA_Msk                (1UL << ITM_TCR_SYNCENA_Pos)                   /*!< ITM TCR: SYNCENA Mask */
S
S#define ITM_TCR_TSENA_Pos                   1                                             /*!< ITM TCR: TSENA Position */
S#define ITM_TCR_TSENA_Msk                  (1UL << ITM_TCR_TSENA_Pos)                     /*!< ITM TCR: TSENA Mask */
S
S#define ITM_TCR_ITMENA_Pos                  0                                             /*!< ITM TCR: ITM Enable bit Position */
S#define ITM_TCR_ITMENA_Msk                 (1UL << ITM_TCR_ITMENA_Pos)                    /*!< ITM TCR: ITM Enable bit Mask */
S
S/* ITM Integration Write Register Definitions */
S#define ITM_IWR_ATVALIDM_Pos                0                                             /*!< ITM IWR: ATVALIDM Position */
S#define ITM_IWR_ATVALIDM_Msk               (1UL << ITM_IWR_ATVALIDM_Pos)                  /*!< ITM IWR: ATVALIDM Mask */
S
S/* ITM Integration Read Register Definitions */
S#define ITM_IRR_ATREADYM_Pos                0                                             /*!< ITM IRR: ATREADYM Position */
S#define ITM_IRR_ATREADYM_Msk               (1UL << ITM_IRR_ATREADYM_Pos)                  /*!< ITM IRR: ATREADYM Mask */
S
S/* ITM Integration Mode Control Register Definitions */
S#define ITM_IMCR_INTEGRATION_Pos            0                                             /*!< ITM IMCR: INTEGRATION Position */
S#define ITM_IMCR_INTEGRATION_Msk           (1UL << ITM_IMCR_INTEGRATION_Pos)              /*!< ITM IMCR: INTEGRATION Mask */
S
S/* ITM Lock Status Register Definitions */
S#define ITM_LSR_ByteAcc_Pos                 2                                             /*!< ITM LSR: ByteAcc Position */
S#define ITM_LSR_ByteAcc_Msk                (1UL << ITM_LSR_ByteAcc_Pos)                   /*!< ITM LSR: ByteAcc Mask */
S
S#define ITM_LSR_Access_Pos                  1                                             /*!< ITM LSR: Access Position */
S#define ITM_LSR_Access_Msk                 (1UL << ITM_LSR_Access_Pos)                    /*!< ITM LSR: Access Mask */
S
S#define ITM_LSR_Present_Pos                 0                                             /*!< ITM LSR: Present Position */
S#define ITM_LSR_Present_Msk                (1UL << ITM_LSR_Present_Pos)                   /*!< ITM LSR: Present Mask */
S
S/*@}*/ /* end of group CMSIS_ITM */
S
S
S/** \ingroup  CMSIS_core_register
S    \defgroup CMSIS_DWT     Data Watchpoint and Trace (DWT)
S    \brief      Type definitions for the Data Watchpoint and Trace (DWT)
S  @{
S */
S
S/** \brief  Structure type to access the Data Watchpoint and Trace Register (DWT).
S */
Stypedef struct
S{
S  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  Control Register                          */
S  __IO uint32_t CYCCNT;                  /*!< Offset: 0x004 (R/W)  Cycle Count Register                      */
S  __IO uint32_t CPICNT;                  /*!< Offset: 0x008 (R/W)  CPI Count Register                        */
S  __IO uint32_t EXCCNT;                  /*!< Offset: 0x00C (R/W)  Exception Overhead Count Register         */
S  __IO uint32_t SLEEPCNT;                /*!< Offset: 0x010 (R/W)  Sleep Count Register                      */
S  __IO uint32_t LSUCNT;                  /*!< Offset: 0x014 (R/W)  LSU Count Register                        */
S  __IO uint32_t FOLDCNT;                 /*!< Offset: 0x018 (R/W)  Folded-instruction Count Register         */
S  __I  uint32_t PCSR;                    /*!< Offset: 0x01C (R/ )  Program Counter Sample Register           */
S  __IO uint32_t COMP0;                   /*!< Offset: 0x020 (R/W)  Comparator Register 0                     */
S  __IO uint32_t MASK0;                   /*!< Offset: 0x024 (R/W)  Mask Register 0                           */
S  __IO uint32_t FUNCTION0;               /*!< Offset: 0x028 (R/W)  Function Register 0                       */
S       uint32_t RESERVED0[1];
S  __IO uint32_t COMP1;                   /*!< Offset: 0x030 (R/W)  Comparator Register 1                     */
S  __IO uint32_t MASK1;                   /*!< Offset: 0x034 (R/W)  Mask Register 1                           */
S  __IO uint32_t FUNCTION1;               /*!< Offset: 0x038 (R/W)  Function Register 1                       */
S       uint32_t RESERVED1[1];
S  __IO uint32_t COMP2;                   /*!< Offset: 0x040 (R/W)  Comparator Register 2                     */
S  __IO uint32_t MASK2;                   /*!< Offset: 0x044 (R/W)  Mask Register 2                           */
S  __IO uint32_t FUNCTION2;               /*!< Offset: 0x048 (R/W)  Function Register 2                       */
S       uint32_t RESERVED2[1];
S  __IO uint32_t COMP3;                   /*!< Offset: 0x050 (R/W)  Comparator Register 3                     */
S  __IO uint32_t MASK3;                   /*!< Offset: 0x054 (R/W)  Mask Register 3                           */
S  __IO uint32_t FUNCTION3;               /*!< Offset: 0x058 (R/W)  Function Register 3                       */
S} DWT_Type;
S
S/* DWT Control Register Definitions */
S#define DWT_CTRL_NUMCOMP_Pos               28                                          /*!< DWT CTRL: NUMCOMP Position */
S#define DWT_CTRL_NUMCOMP_Msk               (0xFUL << DWT_CTRL_NUMCOMP_Pos)             /*!< DWT CTRL: NUMCOMP Mask */
S
S#define DWT_CTRL_NOTRCPKT_Pos              27                                          /*!< DWT CTRL: NOTRCPKT Position */
S#define DWT_CTRL_NOTRCPKT_Msk              (0x1UL << DWT_CTRL_NOTRCPKT_Pos)            /*!< DWT CTRL: NOTRCPKT Mask */
S
S#define DWT_CTRL_NOEXTTRIG_Pos             26                                          /*!< DWT CTRL: NOEXTTRIG Position */
S#define DWT_CTRL_NOEXTTRIG_Msk             (0x1UL << DWT_CTRL_NOEXTTRIG_Pos)           /*!< DWT CTRL: NOEXTTRIG Mask */
S
S#define DWT_CTRL_NOCYCCNT_Pos              25                                          /*!< DWT CTRL: NOCYCCNT Position */
S#define DWT_CTRL_NOCYCCNT_Msk              (0x1UL << DWT_CTRL_NOCYCCNT_Pos)            /*!< DWT CTRL: NOCYCCNT Mask */
S
S#define DWT_CTRL_NOPRFCNT_Pos              24                                          /*!< DWT CTRL: NOPRFCNT Position */
S#define DWT_CTRL_NOPRFCNT_Msk              (0x1UL << DWT_CTRL_NOPRFCNT_Pos)            /*!< DWT CTRL: NOPRFCNT Mask */
S
S#define DWT_CTRL_CYCEVTENA_Pos             22                                          /*!< DWT CTRL: CYCEVTENA Position */
S#define DWT_CTRL_CYCEVTENA_Msk             (0x1UL << DWT_CTRL_CYCEVTENA_Pos)           /*!< DWT CTRL: CYCEVTENA Mask */
S
S#define DWT_CTRL_FOLDEVTENA_Pos            21                                          /*!< DWT CTRL: FOLDEVTENA Position */
S#define DWT_CTRL_FOLDEVTENA_Msk            (0x1UL << DWT_CTRL_FOLDEVTENA_Pos)          /*!< DWT CTRL: FOLDEVTENA Mask */
S
S#define DWT_CTRL_LSUEVTENA_Pos             20                                          /*!< DWT CTRL: LSUEVTENA Position */
S#define DWT_CTRL_LSUEVTENA_Msk             (0x1UL << DWT_CTRL_LSUEVTENA_Pos)           /*!< DWT CTRL: LSUEVTENA Mask */
S
S#define DWT_CTRL_SLEEPEVTENA_Pos           19                                          /*!< DWT CTRL: SLEEPEVTENA Position */
S#define DWT_CTRL_SLEEPEVTENA_Msk           (0x1UL << DWT_CTRL_SLEEPEVTENA_Pos)         /*!< DWT CTRL: SLEEPEVTENA Mask */
S
S#define DWT_CTRL_EXCEVTENA_Pos             18                                          /*!< DWT CTRL: EXCEVTENA Position */
S#define DWT_CTRL_EXCEVTENA_Msk             (0x1UL << DWT_CTRL_EXCEVTENA_Pos)           /*!< DWT CTRL: EXCEVTENA Mask */
S
S#define DWT_CTRL_CPIEVTENA_Pos             17                                          /*!< DWT CTRL: CPIEVTENA Position */
S#define DWT_CTRL_CPIEVTENA_Msk             (0x1UL << DWT_CTRL_CPIEVTENA_Pos)           /*!< DWT CTRL: CPIEVTENA Mask */
S
S#define DWT_CTRL_EXCTRCENA_Pos             16                                          /*!< DWT CTRL: EXCTRCENA Position */
S#define DWT_CTRL_EXCTRCENA_Msk             (0x1UL << DWT_CTRL_EXCTRCENA_Pos)           /*!< DWT CTRL: EXCTRCENA Mask */
S
S#define DWT_CTRL_PCSAMPLENA_Pos            12                                          /*!< DWT CTRL: PCSAMPLENA Position */
S#define DWT_CTRL_PCSAMPLENA_Msk            (0x1UL << DWT_CTRL_PCSAMPLENA_Pos)          /*!< DWT CTRL: PCSAMPLENA Mask */
S
S#define DWT_CTRL_SYNCTAP_Pos               10                                          /*!< DWT CTRL: SYNCTAP Position */
S#define DWT_CTRL_SYNCTAP_Msk               (0x3UL << DWT_CTRL_SYNCTAP_Pos)             /*!< DWT CTRL: SYNCTAP Mask */
S
S#define DWT_CTRL_CYCTAP_Pos                 9                                          /*!< DWT CTRL: CYCTAP Position */
S#define DWT_CTRL_CYCTAP_Msk                (0x1UL << DWT_CTRL_CYCTAP_Pos)              /*!< DWT CTRL: CYCTAP Mask */
S
S#define DWT_CTRL_POSTINIT_Pos               5                                          /*!< DWT CTRL: POSTINIT Position */
S#define DWT_CTRL_POSTINIT_Msk              (0xFUL << DWT_CTRL_POSTINIT_Pos)            /*!< DWT CTRL: POSTINIT Mask */
S
S#define DWT_CTRL_POSTPRESET_Pos             1                                          /*!< DWT CTRL: POSTPRESET Position */
S#define DWT_CTRL_POSTPRESET_Msk            (0xFUL << DWT_CTRL_POSTPRESET_Pos)          /*!< DWT CTRL: POSTPRESET Mask */
S
S#define DWT_CTRL_CYCCNTENA_Pos              0                                          /*!< DWT CTRL: CYCCNTENA Position */
S#define DWT_CTRL_CYCCNTENA_Msk             (0x1UL << DWT_CTRL_CYCCNTENA_Pos)           /*!< DWT CTRL: CYCCNTENA Mask */
S
S/* DWT CPI Count Register Definitions */
S#define DWT_CPICNT_CPICNT_Pos               0                                          /*!< DWT CPICNT: CPICNT Position */
S#define DWT_CPICNT_CPICNT_Msk              (0xFFUL << DWT_CPICNT_CPICNT_Pos)           /*!< DWT CPICNT: CPICNT Mask */
S
S/* DWT Exception Overhead Count Register Definitions */
S#define DWT_EXCCNT_EXCCNT_Pos               0                                          /*!< DWT EXCCNT: EXCCNT Position */
S#define DWT_EXCCNT_EXCCNT_Msk              (0xFFUL << DWT_EXCCNT_EXCCNT_Pos)           /*!< DWT EXCCNT: EXCCNT Mask */
S
S/* DWT Sleep Count Register Definitions */
S#define DWT_SLEEPCNT_SLEEPCNT_Pos           0                                          /*!< DWT SLEEPCNT: SLEEPCNT Position */
S#define DWT_SLEEPCNT_SLEEPCNT_Msk          (0xFFUL << DWT_SLEEPCNT_SLEEPCNT_Pos)       /*!< DWT SLEEPCNT: SLEEPCNT Mask */
S
S/* DWT LSU Count Register Definitions */
S#define DWT_LSUCNT_LSUCNT_Pos               0                                          /*!< DWT LSUCNT: LSUCNT Position */
S#define DWT_LSUCNT_LSUCNT_Msk              (0xFFUL << DWT_LSUCNT_LSUCNT_Pos)           /*!< DWT LSUCNT: LSUCNT Mask */
S
S/* DWT Folded-instruction Count Register Definitions */
S#define DWT_FOLDCNT_FOLDCNT_Pos             0                                          /*!< DWT FOLDCNT: FOLDCNT Position */
S#define DWT_FOLDCNT_FOLDCNT_Msk            (0xFFUL << DWT_FOLDCNT_FOLDCNT_Pos)         /*!< DWT FOLDCNT: FOLDCNT Mask */
S
S/* DWT Comparator Mask Register Definitions */
S#define DWT_MASK_MASK_Pos                   0                                          /*!< DWT MASK: MASK Position */
S#define DWT_MASK_MASK_Msk                  (0x1FUL << DWT_MASK_MASK_Pos)               /*!< DWT MASK: MASK Mask */
S
S/* DWT Comparator Function Register Definitions */
S#define DWT_FUNCTION_MATCHED_Pos           24                                          /*!< DWT FUNCTION: MATCHED Position */
S#define DWT_FUNCTION_MATCHED_Msk           (0x1UL << DWT_FUNCTION_MATCHED_Pos)         /*!< DWT FUNCTION: MATCHED Mask */
S
S#define DWT_FUNCTION_DATAVADDR1_Pos        16                                          /*!< DWT FUNCTION: DATAVADDR1 Position */
S#define DWT_FUNCTION_DATAVADDR1_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR1_Pos)      /*!< DWT FUNCTION: DATAVADDR1 Mask */
S
S#define DWT_FUNCTION_DATAVADDR0_Pos        12                                          /*!< DWT FUNCTION: DATAVADDR0 Position */
S#define DWT_FUNCTION_DATAVADDR0_Msk        (0xFUL << DWT_FUNCTION_DATAVADDR0_Pos)      /*!< DWT FUNCTION: DATAVADDR0 Mask */
S
S#define DWT_FUNCTION_DATAVSIZE_Pos         10                                          /*!< DWT FUNCTION: DATAVSIZE Position */
S#define DWT_FUNCTION_DATAVSIZE_Msk         (0x3UL << DWT_FUNCTION_DATAVSIZE_Pos)       /*!< DWT FUNCTION: DATAVSIZE Mask */
S
S#define DWT_FUNCTION_LNK1ENA_Pos            9                                          /*!< DWT FUNCTION: LNK1ENA Position */
S#define DWT_FUNCTION_LNK1ENA_Msk           (0x1UL << DWT_FUNCTION_LNK1ENA_Pos)         /*!< DWT FUNCTION: LNK1ENA Mask */
S
S#define DWT_FUNCTION_DATAVMATCH_Pos         8                                          /*!< DWT FUNCTION: DATAVMATCH Position */
S#define DWT_FUNCTION_DATAVMATCH_Msk        (0x1UL << DWT_FUNCTION_DATAVMATCH_Pos)      /*!< DWT FUNCTION: DATAVMATCH Mask */
S
S#define DWT_FUNCTION_CYCMATCH_Pos           7                                          /*!< DWT FUNCTION: CYCMATCH Position */
S#define DWT_FUNCTION_CYCMATCH_Msk          (0x1UL << DWT_FUNCTION_CYCMATCH_Pos)        /*!< DWT FUNCTION: CYCMATCH Mask */
S
S#define DWT_FUNCTION_EMITRANGE_Pos          5                                          /*!< DWT FUNCTION: EMITRANGE Position */
S#define DWT_FUNCTION_EMITRANGE_Msk         (0x1UL << DWT_FUNCTION_EMITRANGE_Pos)       /*!< DWT FUNCTION: EMITRANGE Mask */
S
S#define DWT_FUNCTION_FUNCTION_Pos           0                                          /*!< DWT FUNCTION: FUNCTION Position */
S#define DWT_FUNCTION_FUNCTION_Msk          (0xFUL << DWT_FUNCTION_FUNCTION_Pos)        /*!< DWT FUNCTION: FUNCTION Mask */
S
S/*@}*/ /* end of group CMSIS_DWT */
S
S
S/** \ingroup  CMSIS_core_register
S    \defgroup CMSIS_TPI     Trace Port Interface (TPI)
S    \brief      Type definitions for the Trace Port Interface (TPI)
S  @{
S */
S
S/** \brief  Structure type to access the Trace Port Interface Register (TPI).
S */
Stypedef struct
S{
S  __IO uint32_t SSPSR;                   /*!< Offset: 0x000 (R/ )  Supported Parallel Port Size Register     */
S  __IO uint32_t CSPSR;                   /*!< Offset: 0x004 (R/W)  Current Parallel Port Size Register */
S       uint32_t RESERVED0[2];
S  __IO uint32_t ACPR;                    /*!< Offset: 0x010 (R/W)  Asynchronous Clock Prescaler Register */
S       uint32_t RESERVED1[55];
S  __IO uint32_t SPPR;                    /*!< Offset: 0x0F0 (R/W)  Selected Pin Protocol Register */
S       uint32_t RESERVED2[131];
S  __I  uint32_t FFSR;                    /*!< Offset: 0x300 (R/ )  Formatter and Flush Status Register */
S  __IO uint32_t FFCR;                    /*!< Offset: 0x304 (R/W)  Formatter and Flush Control Register */
S  __I  uint32_t FSCR;                    /*!< Offset: 0x308 (R/ )  Formatter Synchronization Counter Register */
S       uint32_t RESERVED3[759];
S  __I  uint32_t TRIGGER;                 /*!< Offset: 0xEE8 (R/ )  TRIGGER */
S  __I  uint32_t FIFO0;                   /*!< Offset: 0xEEC (R/ )  Integration ETM Data */
S  __I  uint32_t ITATBCTR2;               /*!< Offset: 0xEF0 (R/ )  ITATBCTR2 */
S       uint32_t RESERVED4[1];
S  __I  uint32_t ITATBCTR0;               /*!< Offset: 0xEF8 (R/ )  ITATBCTR0 */
S  __I  uint32_t FIFO1;                   /*!< Offset: 0xEFC (R/ )  Integration ITM Data */
S  __IO uint32_t ITCTRL;                  /*!< Offset: 0xF00 (R/W)  Integration Mode Control */
S       uint32_t RESERVED5[39];
S  __IO uint32_t CLAIMSET;                /*!< Offset: 0xFA0 (R/W)  Claim tag set */
S  __IO uint32_t CLAIMCLR;                /*!< Offset: 0xFA4 (R/W)  Claim tag clear */
S       uint32_t RESERVED7[8];
S  __I  uint32_t DEVID;                   /*!< Offset: 0xFC8 (R/ )  TPIU_DEVID */
S  __I  uint32_t DEVTYPE;                 /*!< Offset: 0xFCC (R/ )  TPIU_DEVTYPE */
S} TPI_Type;
S
S/* TPI Asynchronous Clock Prescaler Register Definitions */
S#define TPI_ACPR_PRESCALER_Pos              0                                          /*!< TPI ACPR: PRESCALER Position */
S#define TPI_ACPR_PRESCALER_Msk             (0x1FFFUL << TPI_ACPR_PRESCALER_Pos)        /*!< TPI ACPR: PRESCALER Mask */
S
S/* TPI Selected Pin Protocol Register Definitions */
S#define TPI_SPPR_TXMODE_Pos                 0                                          /*!< TPI SPPR: TXMODE Position */
S#define TPI_SPPR_TXMODE_Msk                (0x3UL << TPI_SPPR_TXMODE_Pos)              /*!< TPI SPPR: TXMODE Mask */
S
S/* TPI Formatter and Flush Status Register Definitions */
S#define TPI_FFSR_FtNonStop_Pos              3                                          /*!< TPI FFSR: FtNonStop Position */
S#define TPI_FFSR_FtNonStop_Msk             (0x1UL << TPI_FFSR_FtNonStop_Pos)           /*!< TPI FFSR: FtNonStop Mask */
S
S#define TPI_FFSR_TCPresent_Pos              2                                          /*!< TPI FFSR: TCPresent Position */
S#define TPI_FFSR_TCPresent_Msk             (0x1UL << TPI_FFSR_TCPresent_Pos)           /*!< TPI FFSR: TCPresent Mask */
S
S#define TPI_FFSR_FtStopped_Pos              1                                          /*!< TPI FFSR: FtStopped Position */
S#define TPI_FFSR_FtStopped_Msk             (0x1UL << TPI_FFSR_FtStopped_Pos)           /*!< TPI FFSR: FtStopped Mask */
S
S#define TPI_FFSR_FlInProg_Pos               0                                          /*!< TPI FFSR: FlInProg Position */
S#define TPI_FFSR_FlInProg_Msk              (0x1UL << TPI_FFSR_FlInProg_Pos)            /*!< TPI FFSR: FlInProg Mask */
S
S/* TPI Formatter and Flush Control Register Definitions */
S#define TPI_FFCR_TrigIn_Pos                 8                                          /*!< TPI FFCR: TrigIn Position */
S#define TPI_FFCR_TrigIn_Msk                (0x1UL << TPI_FFCR_TrigIn_Pos)              /*!< TPI FFCR: TrigIn Mask */
S
S#define TPI_FFCR_EnFCont_Pos                1                                          /*!< TPI FFCR: EnFCont Position */
S#define TPI_FFCR_EnFCont_Msk               (0x1UL << TPI_FFCR_EnFCont_Pos)             /*!< TPI FFCR: EnFCont Mask */
S
S/* TPI TRIGGER Register Definitions */
S#define TPI_TRIGGER_TRIGGER_Pos             0                                          /*!< TPI TRIGGER: TRIGGER Position */
S#define TPI_TRIGGER_TRIGGER_Msk            (0x1UL << TPI_TRIGGER_TRIGGER_Pos)          /*!< TPI TRIGGER: TRIGGER Mask */
S
S/* TPI Integration ETM Data Register Definitions (FIFO0) */
S#define TPI_FIFO0_ITM_ATVALID_Pos          29                                          /*!< TPI FIFO0: ITM_ATVALID Position */
S#define TPI_FIFO0_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ITM_ATVALID_Pos)        /*!< TPI FIFO0: ITM_ATVALID Mask */
S
S#define TPI_FIFO0_ITM_bytecount_Pos        27                                          /*!< TPI FIFO0: ITM_bytecount Position */
S#define TPI_FIFO0_ITM_bytecount_Msk        (0x3UL << TPI_FIFO0_ITM_bytecount_Pos)      /*!< TPI FIFO0: ITM_bytecount Mask */
S
S#define TPI_FIFO0_ETM_ATVALID_Pos          26                                          /*!< TPI FIFO0: ETM_ATVALID Position */
S#define TPI_FIFO0_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO0_ETM_ATVALID_Pos)        /*!< TPI FIFO0: ETM_ATVALID Mask */
S
S#define TPI_FIFO0_ETM_bytecount_Pos        24                                          /*!< TPI FIFO0: ETM_bytecount Position */
S#define TPI_FIFO0_ETM_bytecount_Msk        (0x3UL << TPI_FIFO0_ETM_bytecount_Pos)      /*!< TPI FIFO0: ETM_bytecount Mask */
S
S#define TPI_FIFO0_ETM2_Pos                 16                                          /*!< TPI FIFO0: ETM2 Position */
S#define TPI_FIFO0_ETM2_Msk                 (0xFFUL << TPI_FIFO0_ETM2_Pos)              /*!< TPI FIFO0: ETM2 Mask */
S
S#define TPI_FIFO0_ETM1_Pos                  8                                          /*!< TPI FIFO0: ETM1 Position */
S#define TPI_FIFO0_ETM1_Msk                 (0xFFUL << TPI_FIFO0_ETM1_Pos)              /*!< TPI FIFO0: ETM1 Mask */
S
S#define TPI_FIFO0_ETM0_Pos                  0                                          /*!< TPI FIFO0: ETM0 Position */
S#define TPI_FIFO0_ETM0_Msk                 (0xFFUL << TPI_FIFO0_ETM0_Pos)              /*!< TPI FIFO0: ETM0 Mask */
S
S/* TPI ITATBCTR2 Register Definitions */
S#define TPI_ITATBCTR2_ATREADY_Pos           0                                          /*!< TPI ITATBCTR2: ATREADY Position */
S#define TPI_ITATBCTR2_ATREADY_Msk          (0x1UL << TPI_ITATBCTR2_ATREADY_Pos)        /*!< TPI ITATBCTR2: ATREADY Mask */
S
S/* TPI Integration ITM Data Register Definitions (FIFO1) */
S#define TPI_FIFO1_ITM_ATVALID_Pos          29                                          /*!< TPI FIFO1: ITM_ATVALID Position */
S#define TPI_FIFO1_ITM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ITM_ATVALID_Pos)        /*!< TPI FIFO1: ITM_ATVALID Mask */
S
S#define TPI_FIFO1_ITM_bytecount_Pos        27                                          /*!< TPI FIFO1: ITM_bytecount Position */
S#define TPI_FIFO1_ITM_bytecount_Msk        (0x3UL << TPI_FIFO1_ITM_bytecount_Pos)      /*!< TPI FIFO1: ITM_bytecount Mask */
S
S#define TPI_FIFO1_ETM_ATVALID_Pos          26                                          /*!< TPI FIFO1: ETM_ATVALID Position */
S#define TPI_FIFO1_ETM_ATVALID_Msk          (0x3UL << TPI_FIFO1_ETM_ATVALID_Pos)        /*!< TPI FIFO1: ETM_ATVALID Mask */
S
S#define TPI_FIFO1_ETM_bytecount_Pos        24                                          /*!< TPI FIFO1: ETM_bytecount Position */
S#define TPI_FIFO1_ETM_bytecount_Msk        (0x3UL << TPI_FIFO1_ETM_bytecount_Pos)      /*!< TPI FIFO1: ETM_bytecount Mask */
S
S#define TPI_FIFO1_ITM2_Pos                 16                                          /*!< TPI FIFO1: ITM2 Position */
S#define TPI_FIFO1_ITM2_Msk                 (0xFFUL << TPI_FIFO1_ITM2_Pos)              /*!< TPI FIFO1: ITM2 Mask */
S
S#define TPI_FIFO1_ITM1_Pos                  8                                          /*!< TPI FIFO1: ITM1 Position */
S#define TPI_FIFO1_ITM1_Msk                 (0xFFUL << TPI_FIFO1_ITM1_Pos)              /*!< TPI FIFO1: ITM1 Mask */
S
S#define TPI_FIFO1_ITM0_Pos                  0                                          /*!< TPI FIFO1: ITM0 Position */
S#define TPI_FIFO1_ITM0_Msk                 (0xFFUL << TPI_FIFO1_ITM0_Pos)              /*!< TPI FIFO1: ITM0 Mask */
S
S/* TPI ITATBCTR0 Register Definitions */
S#define TPI_ITATBCTR0_ATREADY_Pos           0                                          /*!< TPI ITATBCTR0: ATREADY Position */
S#define TPI_ITATBCTR0_ATREADY_Msk          (0x1UL << TPI_ITATBCTR0_ATREADY_Pos)        /*!< TPI ITATBCTR0: ATREADY Mask */
S
S/* TPI Integration Mode Control Register Definitions */
S#define TPI_ITCTRL_Mode_Pos                 0                                          /*!< TPI ITCTRL: Mode Position */
S#define TPI_ITCTRL_Mode_Msk                (0x1UL << TPI_ITCTRL_Mode_Pos)              /*!< TPI ITCTRL: Mode Mask */
S
S/* TPI DEVID Register Definitions */
S#define TPI_DEVID_NRZVALID_Pos             11                                          /*!< TPI DEVID: NRZVALID Position */
S#define TPI_DEVID_NRZVALID_Msk             (0x1UL << TPI_DEVID_NRZVALID_Pos)           /*!< TPI DEVID: NRZVALID Mask */
S
S#define TPI_DEVID_MANCVALID_Pos            10                                          /*!< TPI DEVID: MANCVALID Position */
S#define TPI_DEVID_MANCVALID_Msk            (0x1UL << TPI_DEVID_MANCVALID_Pos)          /*!< TPI DEVID: MANCVALID Mask */
S
S#define TPI_DEVID_PTINVALID_Pos             9                                          /*!< TPI DEVID: PTINVALID Position */
S#define TPI_DEVID_PTINVALID_Msk            (0x1UL << TPI_DEVID_PTINVALID_Pos)          /*!< TPI DEVID: PTINVALID Mask */
S
S#define TPI_DEVID_MinBufSz_Pos              6                                          /*!< TPI DEVID: MinBufSz Position */
S#define TPI_DEVID_MinBufSz_Msk             (0x7UL << TPI_DEVID_MinBufSz_Pos)           /*!< TPI DEVID: MinBufSz Mask */
S
S#define TPI_DEVID_AsynClkIn_Pos             5                                          /*!< TPI DEVID: AsynClkIn Position */
S#define TPI_DEVID_AsynClkIn_Msk            (0x1UL << TPI_DEVID_AsynClkIn_Pos)          /*!< TPI DEVID: AsynClkIn Mask */
S
S#define TPI_DEVID_NrTraceInput_Pos          0                                          /*!< TPI DEVID: NrTraceInput Position */
S#define TPI_DEVID_NrTraceInput_Msk         (0x1FUL << TPI_DEVID_NrTraceInput_Pos)      /*!< TPI DEVID: NrTraceInput Mask */
S
S/* TPI DEVTYPE Register Definitions */
S#define TPI_DEVTYPE_SubType_Pos             0                                          /*!< TPI DEVTYPE: SubType Position */
S#define TPI_DEVTYPE_SubType_Msk            (0xFUL << TPI_DEVTYPE_SubType_Pos)          /*!< TPI DEVTYPE: SubType Mask */
S
S#define TPI_DEVTYPE_MajorType_Pos           4                                          /*!< TPI DEVTYPE: MajorType Position */
S#define TPI_DEVTYPE_MajorType_Msk          (0xFUL << TPI_DEVTYPE_MajorType_Pos)        /*!< TPI DEVTYPE: MajorType Mask */
S
S/*@}*/ /* end of group CMSIS_TPI */
S
S
S#if (__MPU_PRESENT == 1)
S/** \ingroup  CMSIS_core_register
S    \defgroup CMSIS_MPU     Memory Protection Unit (MPU)
S    \brief      Type definitions for the Memory Protection Unit (MPU)
S  @{
S */
S
S/** \brief  Structure type to access the Memory Protection Unit (MPU).
S */
Stypedef struct
S{
S  __I  uint32_t TYPE;                    /*!< Offset: 0x000 (R/ )  MPU Type Register                              */
S  __IO uint32_t CTRL;                    /*!< Offset: 0x004 (R/W)  MPU Control Register                           */
S  __IO uint32_t RNR;                     /*!< Offset: 0x008 (R/W)  MPU Region RNRber Register                     */
S  __IO uint32_t RBAR;                    /*!< Offset: 0x00C (R/W)  MPU Region Base Address Register               */
S  __IO uint32_t RASR;                    /*!< Offset: 0x010 (R/W)  MPU Region Attribute and Size Register         */
S  __IO uint32_t RBAR_A1;                 /*!< Offset: 0x014 (R/W)  MPU Alias 1 Region Base Address Register       */
S  __IO uint32_t RASR_A1;                 /*!< Offset: 0x018 (R/W)  MPU Alias 1 Region Attribute and Size Register */
S  __IO uint32_t RBAR_A2;                 /*!< Offset: 0x01C (R/W)  MPU Alias 2 Region Base Address Register       */
S  __IO uint32_t RASR_A2;                 /*!< Offset: 0x020 (R/W)  MPU Alias 2 Region Attribute and Size Register */
S  __IO uint32_t RBAR_A3;                 /*!< Offset: 0x024 (R/W)  MPU Alias 3 Region Base Address Register       */
S  __IO uint32_t RASR_A3;                 /*!< Offset: 0x028 (R/W)  MPU Alias 3 Region Attribute and Size Register */
S} MPU_Type;
S
S/* MPU Type Register */
S#define MPU_TYPE_IREGION_Pos               16                                             /*!< MPU TYPE: IREGION Position */
S#define MPU_TYPE_IREGION_Msk               (0xFFUL << MPU_TYPE_IREGION_Pos)               /*!< MPU TYPE: IREGION Mask */
S
S#define MPU_TYPE_DREGION_Pos                8                                             /*!< MPU TYPE: DREGION Position */
S#define MPU_TYPE_DREGION_Msk               (0xFFUL << MPU_TYPE_DREGION_Pos)               /*!< MPU TYPE: DREGION Mask */
S
S#define MPU_TYPE_SEPARATE_Pos               0                                             /*!< MPU TYPE: SEPARATE Position */
S#define MPU_TYPE_SEPARATE_Msk              (1UL << MPU_TYPE_SEPARATE_Pos)                 /*!< MPU TYPE: SEPARATE Mask */
S
S/* MPU Control Register */
S#define MPU_CTRL_PRIVDEFENA_Pos             2                                             /*!< MPU CTRL: PRIVDEFENA Position */
S#define MPU_CTRL_PRIVDEFENA_Msk            (1UL << MPU_CTRL_PRIVDEFENA_Pos)               /*!< MPU CTRL: PRIVDEFENA Mask */
S
S#define MPU_CTRL_HFNMIENA_Pos               1                                             /*!< MPU CTRL: HFNMIENA Position */
S#define MPU_CTRL_HFNMIENA_Msk              (1UL << MPU_CTRL_HFNMIENA_Pos)                 /*!< MPU CTRL: HFNMIENA Mask */
S
S#define MPU_CTRL_ENABLE_Pos                 0                                             /*!< MPU CTRL: ENABLE Position */
S#define MPU_CTRL_ENABLE_Msk                (1UL << MPU_CTRL_ENABLE_Pos)                   /*!< MPU CTRL: ENABLE Mask */
S
S/* MPU Region Number Register */
S#define MPU_RNR_REGION_Pos                  0                                             /*!< MPU RNR: REGION Position */
S#define MPU_RNR_REGION_Msk                 (0xFFUL << MPU_RNR_REGION_Pos)                 /*!< MPU RNR: REGION Mask */
S
S/* MPU Region Base Address Register */
S#define MPU_RBAR_ADDR_Pos                   5                                             /*!< MPU RBAR: ADDR Position */
S#define MPU_RBAR_ADDR_Msk                  (0x7FFFFFFUL << MPU_RBAR_ADDR_Pos)             /*!< MPU RBAR: ADDR Mask */
S
S#define MPU_RBAR_VALID_Pos                  4                                             /*!< MPU RBAR: VALID Position */
S#define MPU_RBAR_VALID_Msk                 (1UL << MPU_RBAR_VALID_Pos)                    /*!< MPU RBAR: VALID Mask */
S
S#define MPU_RBAR_REGION_Pos                 0                                             /*!< MPU RBAR: REGION Position */
S#define MPU_RBAR_REGION_Msk                (0xFUL << MPU_RBAR_REGION_Pos)                 /*!< MPU RBAR: REGION Mask */
S
S/* MPU Region Attribute and Size Register */
S#define MPU_RASR_ATTRS_Pos                 16                                             /*!< MPU RASR: MPU Region Attribute field Position */
S#define MPU_RASR_ATTRS_Msk                 (0xFFFFUL << MPU_RASR_ATTRS_Pos)               /*!< MPU RASR: MPU Region Attribute field Mask */
S
S#define MPU_RASR_XN_Pos                    28                                             /*!< MPU RASR: ATTRS.XN Position */
S#define MPU_RASR_XN_Msk                    (1UL << MPU_RASR_XN_Pos)                       /*!< MPU RASR: ATTRS.XN Mask */
S
S#define MPU_RASR_AP_Pos                    24                                             /*!< MPU RASR: ATTRS.AP Position */
S#define MPU_RASR_AP_Msk                    (0x7UL << MPU_RASR_AP_Pos)                     /*!< MPU RASR: ATTRS.AP Mask */
S
S#define MPU_RASR_TEX_Pos                   19                                             /*!< MPU RASR: ATTRS.TEX Position */
S#define MPU_RASR_TEX_Msk                   (0x7UL << MPU_RASR_TEX_Pos)                    /*!< MPU RASR: ATTRS.TEX Mask */
S
S#define MPU_RASR_S_Pos                     18                                             /*!< MPU RASR: ATTRS.S Position */
S#define MPU_RASR_S_Msk                     (1UL << MPU_RASR_S_Pos)                        /*!< MPU RASR: ATTRS.S Mask */
S
S#define MPU_RASR_C_Pos                     17                                             /*!< MPU RASR: ATTRS.C Position */
S#define MPU_RASR_C_Msk                     (1UL << MPU_RASR_C_Pos)                        /*!< MPU RASR: ATTRS.C Mask */
S
S#define MPU_RASR_B_Pos                     16                                             /*!< MPU RASR: ATTRS.B Position */
S#define MPU_RASR_B_Msk                     (1UL << MPU_RASR_B_Pos)                        /*!< MPU RASR: ATTRS.B Mask */
S
S#define MPU_RASR_SRD_Pos                    8                                             /*!< MPU RASR: Sub-Region Disable Position */
S#define MPU_RASR_SRD_Msk                   (0xFFUL << MPU_RASR_SRD_Pos)                   /*!< MPU RASR: Sub-Region Disable Mask */
S
S#define MPU_RASR_SIZE_Pos                   1                                             /*!< MPU RASR: Region Size Field Position */
S#define MPU_RASR_SIZE_Msk                  (0x1FUL << MPU_RASR_SIZE_Pos)                  /*!< MPU RASR: Region Size Field Mask */
S
S#define MPU_RASR_ENABLE_Pos                 0                                             /*!< MPU RASR: Region enable bit Position */
S#define MPU_RASR_ENABLE_Msk                (1UL << MPU_RASR_ENABLE_Pos)                   /*!< MPU RASR: Region enable bit Disable Mask */
S
S/*@} end of group CMSIS_MPU */
S#endif
S
S
S#if (__FPU_PRESENT == 1)
S/** \ingroup  CMSIS_core_register
S    \defgroup CMSIS_FPU     Floating Point Unit (FPU)
S    \brief      Type definitions for the Floating Point Unit (FPU)
S  @{
S */
S
S/** \brief  Structure type to access the Floating Point Unit (FPU).
S */
Stypedef struct
S{
S       uint32_t RESERVED0[1];
S  __IO uint32_t FPCCR;                   /*!< Offset: 0x004 (R/W)  Floating-Point Context Control Register               */
S  __IO uint32_t FPCAR;                   /*!< Offset: 0x008 (R/W)  Floating-Point Context Address Register               */
S  __IO uint32_t FPDSCR;                  /*!< Offset: 0x00C (R/W)  Floating-Point Default Status Control Register        */
S  __I  uint32_t MVFR0;                   /*!< Offset: 0x010 (R/ )  Media and FP Feature Register 0                       */
S  __I  uint32_t MVFR1;                   /*!< Offset: 0x014 (R/ )  Media and FP Feature Register 1                       */
S} FPU_Type;
S
S/* Floating-Point Context Control Register */
S#define FPU_FPCCR_ASPEN_Pos                31                                             /*!< FPCCR: ASPEN bit Position */
S#define FPU_FPCCR_ASPEN_Msk                (1UL << FPU_FPCCR_ASPEN_Pos)                   /*!< FPCCR: ASPEN bit Mask */
S
S#define FPU_FPCCR_LSPEN_Pos                30                                             /*!< FPCCR: LSPEN Position */
S#define FPU_FPCCR_LSPEN_Msk                (1UL << FPU_FPCCR_LSPEN_Pos)                   /*!< FPCCR: LSPEN bit Mask */
S
S#define FPU_FPCCR_MONRDY_Pos                8                                             /*!< FPCCR: MONRDY Position */
S#define FPU_FPCCR_MONRDY_Msk               (1UL << FPU_FPCCR_MONRDY_Pos)                  /*!< FPCCR: MONRDY bit Mask */
S
S#define FPU_FPCCR_BFRDY_Pos                 6                                             /*!< FPCCR: BFRDY Position */
S#define FPU_FPCCR_BFRDY_Msk                (1UL << FPU_FPCCR_BFRDY_Pos)                   /*!< FPCCR: BFRDY bit Mask */
S
S#define FPU_FPCCR_MMRDY_Pos                 5                                             /*!< FPCCR: MMRDY Position */
S#define FPU_FPCCR_MMRDY_Msk                (1UL << FPU_FPCCR_MMRDY_Pos)                   /*!< FPCCR: MMRDY bit Mask */
S
S#define FPU_FPCCR_HFRDY_Pos                 4                                             /*!< FPCCR: HFRDY Position */
S#define FPU_FPCCR_HFRDY_Msk                (1UL << FPU_FPCCR_HFRDY_Pos)                   /*!< FPCCR: HFRDY bit Mask */
S
S#define FPU_FPCCR_THREAD_Pos                3                                             /*!< FPCCR: processor mode bit Position */
S#define FPU_FPCCR_THREAD_Msk               (1UL << FPU_FPCCR_THREAD_Pos)                  /*!< FPCCR: processor mode active bit Mask */
S
S#define FPU_FPCCR_USER_Pos                  1                                             /*!< FPCCR: privilege level bit Position */
S#define FPU_FPCCR_USER_Msk                 (1UL << FPU_FPCCR_USER_Pos)                    /*!< FPCCR: privilege level bit Mask */
S
S#define FPU_FPCCR_LSPACT_Pos                0                                             /*!< FPCCR: Lazy state preservation active bit Position */
S#define FPU_FPCCR_LSPACT_Msk               (1UL << FPU_FPCCR_LSPACT_Pos)                  /*!< FPCCR: Lazy state preservation active bit Mask */
S
S/* Floating-Point Context Address Register */
S#define FPU_FPCAR_ADDRESS_Pos               3                                             /*!< FPCAR: ADDRESS bit Position */
S#define FPU_FPCAR_ADDRESS_Msk              (0x1FFFFFFFUL << FPU_FPCAR_ADDRESS_Pos)        /*!< FPCAR: ADDRESS bit Mask */
S
S/* Floating-Point Default Status Control Register */
S#define FPU_FPDSCR_AHP_Pos                 26                                             /*!< FPDSCR: AHP bit Position */
S#define FPU_FPDSCR_AHP_Msk                 (1UL << FPU_FPDSCR_AHP_Pos)                    /*!< FPDSCR: AHP bit Mask */
S
S#define FPU_FPDSCR_DN_Pos                  25                                             /*!< FPDSCR: DN bit Position */
S#define FPU_FPDSCR_DN_Msk                  (1UL << FPU_FPDSCR_DN_Pos)                     /*!< FPDSCR: DN bit Mask */
S
S#define FPU_FPDSCR_FZ_Pos                  24                                             /*!< FPDSCR: FZ bit Position */
S#define FPU_FPDSCR_FZ_Msk                  (1UL << FPU_FPDSCR_FZ_Pos)                     /*!< FPDSCR: FZ bit Mask */
S
S#define FPU_FPDSCR_RMode_Pos               22                                             /*!< FPDSCR: RMode bit Position */
S#define FPU_FPDSCR_RMode_Msk               (3UL << FPU_FPDSCR_RMode_Pos)                  /*!< FPDSCR: RMode bit Mask */
S
S/* Media and FP Feature Register 0 */
S#define FPU_MVFR0_FP_rounding_modes_Pos    28                                             /*!< MVFR0: FP rounding modes bits Position */
S#define FPU_MVFR0_FP_rounding_modes_Msk    (0xFUL << FPU_MVFR0_FP_rounding_modes_Pos)     /*!< MVFR0: FP rounding modes bits Mask */
S
S#define FPU_MVFR0_Short_vectors_Pos        24                                             /*!< MVFR0: Short vectors bits Position */
S#define FPU_MVFR0_Short_vectors_Msk        (0xFUL << FPU_MVFR0_Short_vectors_Pos)         /*!< MVFR0: Short vectors bits Mask */
S
S#define FPU_MVFR0_Square_root_Pos          20                                             /*!< MVFR0: Square root bits Position */
S#define FPU_MVFR0_Square_root_Msk          (0xFUL << FPU_MVFR0_Square_root_Pos)           /*!< MVFR0: Square root bits Mask */
S
S#define FPU_MVFR0_Divide_Pos               16                                             /*!< MVFR0: Divide bits Position */
S#define FPU_MVFR0_Divide_Msk               (0xFUL << FPU_MVFR0_Divide_Pos)                /*!< MVFR0: Divide bits Mask */
S
S#define FPU_MVFR0_FP_excep_trapping_Pos    12                                             /*!< MVFR0: FP exception trapping bits Position */
S#define FPU_MVFR0_FP_excep_trapping_Msk    (0xFUL << FPU_MVFR0_FP_excep_trapping_Pos)     /*!< MVFR0: FP exception trapping bits Mask */
S
S#define FPU_MVFR0_Double_precision_Pos      8                                             /*!< MVFR0: Double-precision bits Position */
S#define FPU_MVFR0_Double_precision_Msk     (0xFUL << FPU_MVFR0_Double_precision_Pos)      /*!< MVFR0: Double-precision bits Mask */
S
S#define FPU_MVFR0_Single_precision_Pos      4                                             /*!< MVFR0: Single-precision bits Position */
S#define FPU_MVFR0_Single_precision_Msk     (0xFUL << FPU_MVFR0_Single_precision_Pos)      /*!< MVFR0: Single-precision bits Mask */
S
S#define FPU_MVFR0_A_SIMD_registers_Pos      0                                             /*!< MVFR0: A_SIMD registers bits Position */
S#define FPU_MVFR0_A_SIMD_registers_Msk     (0xFUL << FPU_MVFR0_A_SIMD_registers_Pos)      /*!< MVFR0: A_SIMD registers bits Mask */
S
S/* Media and FP Feature Register 1 */
S#define FPU_MVFR1_FP_fused_MAC_Pos         28                                             /*!< MVFR1: FP fused MAC bits Position */
S#define FPU_MVFR1_FP_fused_MAC_Msk         (0xFUL << FPU_MVFR1_FP_fused_MAC_Pos)          /*!< MVFR1: FP fused MAC bits Mask */
S
S#define FPU_MVFR1_FP_HPFP_Pos              24                                             /*!< MVFR1: FP HPFP bits Position */
S#define FPU_MVFR1_FP_HPFP_Msk              (0xFUL << FPU_MVFR1_FP_HPFP_Pos)               /*!< MVFR1: FP HPFP bits Mask */
S
S#define FPU_MVFR1_D_NaN_mode_Pos            4                                             /*!< MVFR1: D_NaN mode bits Position */
S#define FPU_MVFR1_D_NaN_mode_Msk           (0xFUL << FPU_MVFR1_D_NaN_mode_Pos)            /*!< MVFR1: D_NaN mode bits Mask */
S
S#define FPU_MVFR1_FtZ_mode_Pos              0                                             /*!< MVFR1: FtZ mode bits Position */
S#define FPU_MVFR1_FtZ_mode_Msk             (0xFUL << FPU_MVFR1_FtZ_mode_Pos)              /*!< MVFR1: FtZ mode bits Mask */
S
S/*@} end of group CMSIS_FPU */
S#endif
S
S
S/** \ingroup  CMSIS_core_register
S    \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
S    \brief      Type definitions for the Core Debug Registers
S  @{
S */
S
S/** \brief  Structure type to access the Core Debug Register (CoreDebug).
S */
Stypedef struct
S{
S  __IO uint32_t DHCSR;                   /*!< Offset: 0x000 (R/W)  Debug Halting Control and Status Register    */
S  __O  uint32_t DCRSR;                   /*!< Offset: 0x004 ( /W)  Debug Core Register Selector Register        */
S  __IO uint32_t DCRDR;                   /*!< Offset: 0x008 (R/W)  Debug Core Register Data Register            */
S  __IO uint32_t DEMCR;                   /*!< Offset: 0x00C (R/W)  Debug Exception and Monitor Control Register */
S} CoreDebug_Type;
S
S/* Debug Halting Control and Status Register */
S#define CoreDebug_DHCSR_DBGKEY_Pos         16                                             /*!< CoreDebug DHCSR: DBGKEY Position */
S#define CoreDebug_DHCSR_DBGKEY_Msk         (0xFFFFUL << CoreDebug_DHCSR_DBGKEY_Pos)       /*!< CoreDebug DHCSR: DBGKEY Mask */
S
S#define CoreDebug_DHCSR_S_RESET_ST_Pos     25                                             /*!< CoreDebug DHCSR: S_RESET_ST Position */
S#define CoreDebug_DHCSR_S_RESET_ST_Msk     (1UL << CoreDebug_DHCSR_S_RESET_ST_Pos)        /*!< CoreDebug DHCSR: S_RESET_ST Mask */
S
S#define CoreDebug_DHCSR_S_RETIRE_ST_Pos    24                                             /*!< CoreDebug DHCSR: S_RETIRE_ST Position */
S#define CoreDebug_DHCSR_S_RETIRE_ST_Msk    (1UL << CoreDebug_DHCSR_S_RETIRE_ST_Pos)       /*!< CoreDebug DHCSR: S_RETIRE_ST Mask */
S
S#define CoreDebug_DHCSR_S_LOCKUP_Pos       19                                             /*!< CoreDebug DHCSR: S_LOCKUP Position */
S#define CoreDebug_DHCSR_S_LOCKUP_Msk       (1UL << CoreDebug_DHCSR_S_LOCKUP_Pos)          /*!< CoreDebug DHCSR: S_LOCKUP Mask */
S
S#define CoreDebug_DHCSR_S_SLEEP_Pos        18                                             /*!< CoreDebug DHCSR: S_SLEEP Position */
S#define CoreDebug_DHCSR_S_SLEEP_Msk        (1UL << CoreDebug_DHCSR_S_SLEEP_Pos)           /*!< CoreDebug DHCSR: S_SLEEP Mask */
S
S#define CoreDebug_DHCSR_S_HALT_Pos         17                                             /*!< CoreDebug DHCSR: S_HALT Position */
S#define CoreDebug_DHCSR_S_HALT_Msk         (1UL << CoreDebug_DHCSR_S_HALT_Pos)            /*!< CoreDebug DHCSR: S_HALT Mask */
S
S#define CoreDebug_DHCSR_S_REGRDY_Pos       16                                             /*!< CoreDebug DHCSR: S_REGRDY Position */
S#define CoreDebug_DHCSR_S_REGRDY_Msk       (1UL << CoreDebug_DHCSR_S_REGRDY_Pos)          /*!< CoreDebug DHCSR: S_REGRDY Mask */
S
S#define CoreDebug_DHCSR_C_SNAPSTALL_Pos     5                                             /*!< CoreDebug DHCSR: C_SNAPSTALL Position */
S#define CoreDebug_DHCSR_C_SNAPSTALL_Msk    (1UL << CoreDebug_DHCSR_C_SNAPSTALL_Pos)       /*!< CoreDebug DHCSR: C_SNAPSTALL Mask */
S
S#define CoreDebug_DHCSR_C_MASKINTS_Pos      3                                             /*!< CoreDebug DHCSR: C_MASKINTS Position */
S#define CoreDebug_DHCSR_C_MASKINTS_Msk     (1UL << CoreDebug_DHCSR_C_MASKINTS_Pos)        /*!< CoreDebug DHCSR: C_MASKINTS Mask */
S
S#define CoreDebug_DHCSR_C_STEP_Pos          2                                             /*!< CoreDebug DHCSR: C_STEP Position */
S#define CoreDebug_DHCSR_C_STEP_Msk         (1UL << CoreDebug_DHCSR_C_STEP_Pos)            /*!< CoreDebug DHCSR: C_STEP Mask */
S
S#define CoreDebug_DHCSR_C_HALT_Pos          1                                             /*!< CoreDebug DHCSR: C_HALT Position */
S#define CoreDebug_DHCSR_C_HALT_Msk         (1UL << CoreDebug_DHCSR_C_HALT_Pos)            /*!< CoreDebug DHCSR: C_HALT Mask */
S
S#define CoreDebug_DHCSR_C_DEBUGEN_Pos       0                                             /*!< CoreDebug DHCSR: C_DEBUGEN Position */
S#define CoreDebug_DHCSR_C_DEBUGEN_Msk      (1UL << CoreDebug_DHCSR_C_DEBUGEN_Pos)         /*!< CoreDebug DHCSR: C_DEBUGEN Mask */
S
S/* Debug Core Register Selector Register */
S#define CoreDebug_DCRSR_REGWnR_Pos         16                                             /*!< CoreDebug DCRSR: REGWnR Position */
S#define CoreDebug_DCRSR_REGWnR_Msk         (1UL << CoreDebug_DCRSR_REGWnR_Pos)            /*!< CoreDebug DCRSR: REGWnR Mask */
S
S#define CoreDebug_DCRSR_REGSEL_Pos          0                                             /*!< CoreDebug DCRSR: REGSEL Position */
S#define CoreDebug_DCRSR_REGSEL_Msk         (0x1FUL << CoreDebug_DCRSR_REGSEL_Pos)         /*!< CoreDebug DCRSR: REGSEL Mask */
S
S/* Debug Exception and Monitor Control Register */
S#define CoreDebug_DEMCR_TRCENA_Pos         24                                             /*!< CoreDebug DEMCR: TRCENA Position */
S#define CoreDebug_DEMCR_TRCENA_Msk         (1UL << CoreDebug_DEMCR_TRCENA_Pos)            /*!< CoreDebug DEMCR: TRCENA Mask */
S
S#define CoreDebug_DEMCR_MON_REQ_Pos        19                                             /*!< CoreDebug DEMCR: MON_REQ Position */
S#define CoreDebug_DEMCR_MON_REQ_Msk        (1UL << CoreDebug_DEMCR_MON_REQ_Pos)           /*!< CoreDebug DEMCR: MON_REQ Mask */
S
S#define CoreDebug_DEMCR_MON_STEP_Pos       18                                             /*!< CoreDebug DEMCR: MON_STEP Position */
S#define CoreDebug_DEMCR_MON_STEP_Msk       (1UL << CoreDebug_DEMCR_MON_STEP_Pos)          /*!< CoreDebug DEMCR: MON_STEP Mask */
S
S#define CoreDebug_DEMCR_MON_PEND_Pos       17                                             /*!< CoreDebug DEMCR: MON_PEND Position */
S#define CoreDebug_DEMCR_MON_PEND_Msk       (1UL << CoreDebug_DEMCR_MON_PEND_Pos)          /*!< CoreDebug DEMCR: MON_PEND Mask */
S
S#define CoreDebug_DEMCR_MON_EN_Pos         16                                             /*!< CoreDebug DEMCR: MON_EN Position */
S#define CoreDebug_DEMCR_MON_EN_Msk         (1UL << CoreDebug_DEMCR_MON_EN_Pos)            /*!< CoreDebug DEMCR: MON_EN Mask */
S
S#define CoreDebug_DEMCR_VC_HARDERR_Pos     10                                             /*!< CoreDebug DEMCR: VC_HARDERR Position */
S#define CoreDebug_DEMCR_VC_HARDERR_Msk     (1UL << CoreDebug_DEMCR_VC_HARDERR_Pos)        /*!< CoreDebug DEMCR: VC_HARDERR Mask */
S
S#define CoreDebug_DEMCR_VC_INTERR_Pos       9                                             /*!< CoreDebug DEMCR: VC_INTERR Position */
S#define CoreDebug_DEMCR_VC_INTERR_Msk      (1UL << CoreDebug_DEMCR_VC_INTERR_Pos)         /*!< CoreDebug DEMCR: VC_INTERR Mask */
S
S#define CoreDebug_DEMCR_VC_BUSERR_Pos       8                                             /*!< CoreDebug DEMCR: VC_BUSERR Position */
S#define CoreDebug_DEMCR_VC_BUSERR_Msk      (1UL << CoreDebug_DEMCR_VC_BUSERR_Pos)         /*!< CoreDebug DEMCR: VC_BUSERR Mask */
S
S#define CoreDebug_DEMCR_VC_STATERR_Pos      7                                             /*!< CoreDebug DEMCR: VC_STATERR Position */
S#define CoreDebug_DEMCR_VC_STATERR_Msk     (1UL << CoreDebug_DEMCR_VC_STATERR_Pos)        /*!< CoreDebug DEMCR: VC_STATERR Mask */
S
S#define CoreDebug_DEMCR_VC_CHKERR_Pos       6                                             /*!< CoreDebug DEMCR: VC_CHKERR Position */
S#define CoreDebug_DEMCR_VC_CHKERR_Msk      (1UL << CoreDebug_DEMCR_VC_CHKERR_Pos)         /*!< CoreDebug DEMCR: VC_CHKERR Mask */
S
S#define CoreDebug_DEMCR_VC_NOCPERR_Pos      5                                             /*!< CoreDebug DEMCR: VC_NOCPERR Position */
S#define CoreDebug_DEMCR_VC_NOCPERR_Msk     (1UL << CoreDebug_DEMCR_VC_NOCPERR_Pos)        /*!< CoreDebug DEMCR: VC_NOCPERR Mask */
S
S#define CoreDebug_DEMCR_VC_MMERR_Pos        4                                             /*!< CoreDebug DEMCR: VC_MMERR Position */
S#define CoreDebug_DEMCR_VC_MMERR_Msk       (1UL << CoreDebug_DEMCR_VC_MMERR_Pos)          /*!< CoreDebug DEMCR: VC_MMERR Mask */
S
S#define CoreDebug_DEMCR_VC_CORERESET_Pos    0                                             /*!< CoreDebug DEMCR: VC_CORERESET Position */
S#define CoreDebug_DEMCR_VC_CORERESET_Msk   (1UL << CoreDebug_DEMCR_VC_CORERESET_Pos)      /*!< CoreDebug DEMCR: VC_CORERESET Mask */
S
S/*@} end of group CMSIS_CoreDebug */
S
S
S/** \ingroup    CMSIS_core_register
S    \defgroup   CMSIS_core_base     Core Definitions
S    \brief      Definitions for base addresses, unions, and structures.
S  @{
S */
S
S/* Memory mapping of Cortex-M4 Hardware */
S#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address  */
S#define ITM_BASE            (0xE0000000UL)                            /*!< ITM Base Address                   */
S#define DWT_BASE            (0xE0001000UL)                            /*!< DWT Base Address                   */
S#define TPI_BASE            (0xE0040000UL)                            /*!< TPI Base Address                   */
S#define CoreDebug_BASE      (0xE000EDF0UL)                            /*!< Core Debug Base Address            */
S#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address               */
S#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address                  */
S#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address  */
S
S#define SCnSCB              ((SCnSCB_Type    *)     SCS_BASE      )   /*!< System control Register not in SCB */
S#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct           */
S#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct       */
S#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct          */
S#define ITM                 ((ITM_Type       *)     ITM_BASE      )   /*!< ITM configuration struct           */
S#define DWT                 ((DWT_Type       *)     DWT_BASE      )   /*!< DWT configuration struct           */
S#define TPI                 ((TPI_Type       *)     TPI_BASE      )   /*!< TPI configuration struct           */
S#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct    */
S
S#if (__MPU_PRESENT == 1)
S  #define MPU_BASE          (SCS_BASE +  0x0D90UL)                    /*!< Memory Protection Unit             */
S  #define MPU               ((MPU_Type       *)     MPU_BASE      )   /*!< Memory Protection Unit             */
S#endif
S
S#if (__FPU_PRESENT == 1)
S  #define FPU_BASE          (SCS_BASE +  0x0F30UL)                    /*!< Floating Point Unit                */
S  #define FPU               ((FPU_Type       *)     FPU_BASE      )   /*!< Floating Point Unit                */
S#endif
S
S/*@} */
S
S
S
S/*******************************************************************************
S *                Hardware Abstraction Layer
S  Core Function Interface contains:
S  - Core NVIC Functions
S  - Core SysTick Functions
S  - Core Debug Functions
S  - Core Register Access Functions
S ******************************************************************************/
S/** \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
S*/
S
S
S
S/* ##########################   NVIC functions  #################################### */
S/** \ingroup  CMSIS_Core_FunctionInterface
S    \defgroup CMSIS_Core_NVICFunctions NVIC Functions
S    \brief      Functions that manage interrupts and exceptions via the NVIC.
S    @{
S */
S
S/** \brief  Set Priority Grouping
S
S  The function sets the priority grouping field using the required unlock sequence.
S  The parameter PriorityGroup is assigned to the field SCB->AIRCR [10:8] PRIGROUP field.
S  Only values from 0..7 are used.
S  In case of a conflict between priority grouping and available
S  priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
S
S    \param [in]      PriorityGroup  Priority grouping field.
S */
S__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
S{
S  uint32_t reg_value;
S  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */
S
S  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
S  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
S  reg_value  =  (reg_value                                 |
S                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
S                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
S  SCB->AIRCR =  reg_value;
S}
S
S
S/** \brief  Get Priority Grouping
S
S  The function reads the priority grouping field from the NVIC Interrupt Controller.
S
S    \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
S */
S__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
S{
S  return ((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos);   /* read priority grouping field */
S}
S
S
S/** \brief  Enable External Interrupt
S
S    The function enables a device-specific interrupt in the NVIC interrupt controller.
S
S    \param [in]      IRQn  External interrupt number. Value cannot be negative.
S */
S__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
S{
S/*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
S  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
S}
S
S
S/** \brief  Disable External Interrupt
S
S    The function disables a device-specific interrupt in the NVIC interrupt controller.
S
S    \param [in]      IRQn  External interrupt number. Value cannot be negative.
S */
S__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
S{
S  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
S}
S
S
S/** \brief  Get Pending Interrupt
S
S    The function reads the pending register in the NVIC and returns the pending bit
S    for the specified interrupt.
S
S    \param [in]      IRQn  Interrupt number.
S
S    \return             0  Interrupt status is not pending.
S    \return             1  Interrupt status is pending.
S */
S__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
S{
S  return((uint32_t) ((NVIC->ISPR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if pending else 0 */
S}
S
S
S/** \brief  Set Pending Interrupt
S
S    The function sets the pending bit of an external interrupt.
S
S    \param [in]      IRQn  Interrupt number. Value cannot be negative.
S */
S__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
S{
S  NVIC->ISPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* set interrupt pending */
S}
S
S
S/** \brief  Clear Pending Interrupt
S
S    The function clears the pending bit of an external interrupt.
S
S    \param [in]      IRQn  External interrupt number. Value cannot be negative.
S */
S__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
S{
S  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
S}
S
S
S/** \brief  Get Active Interrupt
S
S    The function reads the active register in NVIC and returns the active bit.
S
S    \param [in]      IRQn  Interrupt number.
S
S    \return             0  Interrupt status is not active.
S    \return             1  Interrupt status is active.
S */
S__STATIC_INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
S{
S  return((uint32_t)((NVIC->IABR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if active else 0 */
S}
S
S
S/** \brief  Set Interrupt Priority
S
S    The function sets the priority of an interrupt.
S
S    \note The priority cannot be set for every core interrupt.
S
S    \param [in]      IRQn  Interrupt number.
S    \param [in]  priority  Priority to set.
S */
S__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
S{
S  if(IRQn < 0) {
S    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
S  else {
S    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
S}
S
S
S/** \brief  Get Interrupt Priority
S
S    The function reads the priority of an interrupt. The interrupt
S    number can be positive to specify an external (device specific)
S    interrupt, or negative to specify an internal (core) interrupt.
S
S
S    \param [in]   IRQn  Interrupt number.
S    \return             Interrupt Priority. Value is aligned automatically to the implemented
S                        priority bits of the microcontroller.
S */
S__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
S{
S
S  if(IRQn < 0) {
S    return((uint32_t)(SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M  system interrupts */
S  else {
S    return((uint32_t)(NVIC->IP[(uint32_t)(IRQn)]           >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
S}
S
S
S/** \brief  Encode Priority
S
S    The function encodes the priority for an interrupt with the given priority group,
S    preemptive priority value, and subpriority value.
S    In case of a conflict between priority grouping and available
S    priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
S
S    \param [in]     PriorityGroup  Used priority group.
S    \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
S    \param [in]       SubPriority  Subpriority value (starting from 0).
S    \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
S */
S__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
S{
S  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
S  uint32_t PreemptPriorityBits;
S  uint32_t SubPriorityBits;
S
S  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
S  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
S
S  return (
S           ((PreemptPriority & ((1 << (PreemptPriorityBits)) - 1)) << SubPriorityBits) |
S           ((SubPriority     & ((1 << (SubPriorityBits    )) - 1)))
S         );
S}
S
S
S/** \brief  Decode Priority
S
S    The function decodes an interrupt priority value with a given priority group to
S    preemptive priority value and subpriority value.
S    In case of a conflict between priority grouping and available
S    priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
S
S    \param [in]         Priority   Priority value, which can be retrieved with the function \ref NVIC_GetPriority().
S    \param [in]     PriorityGroup  Used priority group.
S    \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
S    \param [out]     pSubPriority  Subpriority value (starting from 0).
S */
S__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
S{
S  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);          /* only values 0..7 are used          */
S  uint32_t PreemptPriorityBits;
S  uint32_t SubPriorityBits;
S
S  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
S  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
S
S  *pPreemptPriority = (Priority >> SubPriorityBits) & ((1 << (PreemptPriorityBits)) - 1);
S  *pSubPriority     = (Priority                   ) & ((1 << (SubPriorityBits    )) - 1);
S}
S
S
S/** \brief  System Reset
S
S    The function initiates a system reset request to reset the MCU.
S */
S__STATIC_INLINE void NVIC_SystemReset(void)
S{
S  __DSB();                                                     /* Ensure all outstanding memory accesses included
S                                                                  buffered write are completed before reset */
S  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
S                 (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
S                 SCB_AIRCR_SYSRESETREQ_Msk);                   /* Keep priority group unchanged */
S  __DSB();                                                     /* Ensure completion of memory access */
S  while(1);                                                    /* wait until reset */
S}
S
S/*@} end of CMSIS_Core_NVICFunctions */
S
S
S
S/* ##################################    SysTick function  ############################################ */
S/** \ingroup  CMSIS_Core_FunctionInterface
S    \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
S    \brief      Functions that configure the System.
S  @{
S */
S
S#if (__Vendor_SysTickConfig == 0)
S
S/** \brief  System Tick Configuration
S
S    The function initializes the System Timer and its interrupt, and starts the System Tick Timer.
S    Counter is in free running mode to generate periodic interrupts.
S
S    \param [in]  ticks  Number of ticks between two interrupts.
S
S    \return          0  Function succeeded.
S    \return          1  Function failed.
S
S    \note     When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
S    function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
S    must contain a vendor-specific implementation of this function.
S
S */
S__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
S{
S  if ((ticks - 1) > SysTick_LOAD_RELOAD_Msk)  return (1);      /* Reload value impossible */
S
S  SysTick->LOAD  = ticks - 1;                                  /* set reload register */
S  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
S  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
S  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
S                   SysTick_CTRL_TICKINT_Msk   |
S                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
S  return (0);                                                  /* Function successful */
S}
S
S#endif
S
S/*@} end of CMSIS_Core_SysTickFunctions */
S
S
S
S/* ##################################### Debug In/Output function ########################################### */
S/** \ingroup  CMSIS_Core_FunctionInterface
S    \defgroup CMSIS_core_DebugFunctions ITM Functions
S    \brief   Functions that access the ITM debug interface.
S  @{
S */
S
Sextern volatile int32_t ITM_RxBuffer;                    /*!< External variable to receive characters.                         */
S#define                 ITM_RXBUFFER_EMPTY    0x5AA55AA5 /*!< Value identifying \ref ITM_RxBuffer is ready for next character. */
S
S
S/** \brief  ITM Send Character
S
S    The function transmits a character via the ITM channel 0, and
S    \li Just returns when no debugger is connected that has booked the output.
S    \li Is blocking when a debugger is connected, but the previous character sent has not been transmitted.
S
S    \param [in]     ch  Character to transmit.
S
S    \returns            Character to transmit.
S */
S__STATIC_INLINE uint32_t ITM_SendChar (uint32_t ch)
S{
S  if ((ITM->TCR & ITM_TCR_ITMENA_Msk)                  &&      /* ITM enabled */
S      (ITM->TER & (1UL << 0)        )                    )     /* ITM Port #0 enabled */
S  {
S    while (ITM->PORT[0].u32 == 0);
S    ITM->PORT[0].u8 = (uint8_t) ch;
S  }
S  return (ch);
S}
S
S
S/** \brief  ITM Receive Character
S
S    The function inputs a character via the external variable \ref ITM_RxBuffer.
S
S    \return             Received character.
S    \return         -1  No character pending.
S */
S__STATIC_INLINE int32_t ITM_ReceiveChar (void) {
S  int32_t ch = -1;                           /* no character available */
S
S  if (ITM_RxBuffer != ITM_RXBUFFER_EMPTY) {
S    ch = ITM_RxBuffer;
S    ITM_RxBuffer = ITM_RXBUFFER_EMPTY;       /* ready for next character */
S  }
S
S  return (ch);
S}
S
S
S/** \brief  ITM Check Character
S
S    The function checks whether a character is pending for reading in the variable \ref ITM_RxBuffer.
S
S    \return          0  No character available.
S    \return          1  Character available.
S */
S__STATIC_INLINE int32_t ITM_CheckChar (void) {
S
S  if (ITM_RxBuffer == ITM_RXBUFFER_EMPTY) {
S    return (0);                                 /* no character available */
S  } else {
S    return (1);                                 /*    character available */
S  }
S}
S
S/*@} end of CMSIS_core_DebugFunctions */
S
S
S
S
S#ifdef __cplusplus
S}
S#endif
S
S#endif /* __CORE_CM4_H_DEPENDANT */
S
N#endif /* __CMSIS_GENERIC */
L 290 ".\inc\arm_math.h" 2
N#elif defined (ARM_MATH_CM3)
S  #include "core_cm3.h"
S#elif defined (ARM_MATH_CM0)
S  #include "core_cm0.h"
S#define ARM_MATH_CM0_FAMILY
S  #elif defined (ARM_MATH_CM0PLUS)
S#include "core_cm0plus.h"
S  #define ARM_MATH_CM0_FAMILY
S#else
S  #error "Define according the used Cortex core ARM_MATH_CM7, ARM_MATH_CM4, ARM_MATH_CM3, ARM_MATH_CM0PLUS or ARM_MATH_CM0"
N#endif
N
N#undef  __CMSIS_GENERIC         /* enable NVIC and Systick functions */
N#include "string.h"
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5060019
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 304 ".\inc\arm_math.h" 2
N#include "math.h"
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\math.h" 1
N/*
N * math.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.5
N * Copyright (C) Codemist Ltd., 1988
N * Copyright 1991-1998,2004-2006,2014 ARM Limited. All rights reserved
N */
N
N/*
N * RCS $Revision$ Codemist 0.03
N * Checkin $Date$
N * Revising $Author: statham $
N */
N
N/*
N * Parts of this file are based upon fdlibm:
N *
N * ====================================================
N * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
N *
N * Developed at SunSoft, a Sun Microsystems, Inc. business.
N * Permission to use, copy, modify, and distribute this
N * software is freely granted, provided that this notice
N * is preserved.
N * ====================================================
N */
N
N#ifndef __math_h
N#define __math_h
N#define __ARMCLIB_VERSION 5060019
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N/*
N * Some of these declarations are new in C99.  To access them in C++
N * you can use -D__USE_C99_MATH (or -D__USE_C99_ALL).
N */
N#ifndef __USE_C99_MATH
N  #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X  #if 0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N    #define __USE_C99_MATH 1
N  #endif
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#ifdef __TARGET_ARCH_AARCH64
S# define _ARMABI_SOFTFP __declspec(__nothrow)
N#else
N# define _ARMABI_SOFTFP __declspec(__nothrow) __attribute__((__pcs__("aapcs")))
N# define __HAVE_LONGDOUBLE 1
N#endif
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#ifdef __FP_FENV_EXCEPTIONS
S# define _ARMABI_FPEXCEPT _ARMABI
N#else
N# define _ARMABI_FPEXCEPT _ARMABI __attribute__((const))
N#endif
N
N#ifdef __cplusplus
S#define _ARMABI_INLINE inline
S#define _ARMABI_INLINE_DEF inline
S#elif defined __GNUC__ || defined _USE_STATIC_INLINE
X#elif 0L || 0L
S#define _ARMABI_INLINE static __inline
S#define _ARMABI_INLINE_DEF static __inline
N#elif (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#elif (1L && 199901L <= 199901L)
N#define _ARMABI_INLINE inline
N#define _ARMABI_INLINE_DEF static inline
N#else
S#define _ARMABI_INLINE __inline
S#define _ARMABI_INLINE_DEF __inline
N#endif
N
N#ifdef __TARGET_ARCH_AARCH64
S#  define _SOFTFP
N#else
N#  define _SOFTFP __attribute__((__pcs__("aapcs")))
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain the nans function, as well as the
N    * FP_NANS and FP_NANQ classification macros.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
N/*
N * Macros for our inline functions down below.
N * unsigned& __FLT(float x) - returns the bit pattern of x
N * unsigned& __HI(double x) - returns the bit pattern of the high part of x
N *                            (high part has exponent & sign bit in it)
N * unsigned& __LO(double x) - returns the bit pattern of the low part of x
N *
N * We can assign to __FLT, __HI, and __LO and the appropriate bits get set in
N * the floating point variable used.
N *
N * __HI & __LO are affected by the endianness and the target FPU.
N */
N#define __FLT(x) (*(unsigned *)&(x))
N#if defined(__ARM_BIG_ENDIAN) || defined(__BIG_ENDIAN)
X#if 0L || 0L
S#  define __LO(x) (*(1 + (unsigned *)&(x)))
S#  define __HI(x) (*(unsigned *)&(x))
N#else /* !defined(__ARM_BIG_ENDIAN) && !defined(__BIG_ENDIAN) */
N#  define __HI(x) (*(1 + (unsigned *)&(x)))
N#  define __LO(x) (*(unsigned *)&(x))
N#endif /* !defined(__ARM_BIG_ENDIAN) && !defined(__BIG_ENDIAN) */
N
N#   ifndef __MATH_DECLS
N#   define __MATH_DECLS
N
N
N/*
N * A set of functions that we don't actually want to put in the standard
N * namespace ever.  These are all called by the C99 macros.  As they're
N * not specified by any standard they can't belong in ::std::.  The
N * macro #defines are below amongst the standard function declarations.
N * We only include these if we actually need them later on
N */
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 1L
N#   ifdef __cplusplus
S      extern "C" {
N#   endif /* __cplusplus */
N
Nextern _SOFTFP unsigned __ARM_dcmp4(double /*x*/, double /*y*/);
Xextern __attribute__((__pcs__("aapcs"))) unsigned __ARM_dcmp4(double  , double  );
Nextern _SOFTFP unsigned __ARM_fcmp4(float /*x*/, float /*y*/);
Xextern __attribute__((__pcs__("aapcs"))) unsigned __ARM_fcmp4(float  , float  );
N    /*
N     * Compare x and y and return the CPSR in r0.  These means we can test for
N     * result types with bit pattern matching.
N     *
N     * These are a copy of the declarations in rt_fp.h keep in sync.
N     */
N
Nextern _ARMABI_SOFTFP int __ARM_fpclassifyf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_fpclassifyf(float  );
Nextern _ARMABI_SOFTFP int __ARM_fpclassify(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_fpclassify(double  );
N    /* Classify x into NaN, infinite, normal, subnormal, zero */
N    /* Used by fpclassify macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isfinitef(float __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isfinitef(float __x)
N{
N    return ((__FLT(__x) >> 23) & 0xff) != 0xff;
X    return (((*(unsigned *)&(__x)) >> 23) & 0xff) != 0xff;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isfinite(double __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isfinite(double __x)
N{
N    return ((__HI(__x) >> 20) & 0x7ff) != 0x7ff;
X    return (((*(1 + (unsigned *)&(__x))) >> 20) & 0x7ff) != 0x7ff;
N}
N    /* Return 1 if __x is finite, 0 otherwise */
N    /* Used by isfinite macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isinff(float __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isinff(float __x)
N{
N    return (__FLT(__x) << 1) == 0xff000000;
X    return ((*(unsigned *)&(__x)) << 1) == 0xff000000;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isinf(double __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isinf(double __x)
N{
N    return ((__HI(__x) << 1) == 0xffe00000) && (__LO(__x) == 0);
X    return (((*(1 + (unsigned *)&(__x))) << 1) == 0xffe00000) && ((*(unsigned *)&(__x)) == 0);
N}
N    /* Return 1 if __x is infinite, 0 otherwise */
N    /* Used by isinf macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_islessgreaterf(float __x, float __y)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_islessgreaterf(float __x, float __y)
N{
N    unsigned __f = __ARM_fcmp4(__x, __y) >> 28;
N    return (__f == 8) || (__f == 2); /* Just N set or Just Z set */
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_islessgreater(double __x, double __y)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_islessgreater(double __x, double __y)
N{
N    unsigned __f = __ARM_dcmp4(__x, __y) >> 28;
N    return (__f == 8) || (__f == 2); /* Just N set or Just Z set */
N}
N    /*
N     * Compare __x and __y and return 1 if __x < __y or __x > __y, 0 otherwise
N     * Used by islessgreater macro
N     */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnanf(float __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnanf(float __x)
N{
N    return (0x7f800000 - (__FLT(__x) & 0x7fffffff)) >> 31;
X    return (0x7f800000 - ((*(unsigned *)&(__x)) & 0x7fffffff)) >> 31;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnan(double __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnan(double __x)
N{
N    unsigned __xf = __HI(__x) | ((__LO(__x) == 0) ? 0 : 1);
X    unsigned __xf = (*(1 + (unsigned *)&(__x))) | (((*(unsigned *)&(__x)) == 0) ? 0 : 1);
N    return (0x7ff00000 - (__xf & 0x7fffffff)) >> 31;
N}
N    /* Return 1 if __x is a NaN, 0 otherwise */
N    /* Used by isnan macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnormalf(float __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnormalf(float __x)
N{
N    unsigned __xe = (__FLT(__x) >> 23) & 0xff;
X    unsigned __xe = ((*(unsigned *)&(__x)) >> 23) & 0xff;
N    return (__xe != 0xff) && (__xe != 0);
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnormal(double __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnormal(double __x)
N{
N    unsigned __xe = (__HI(__x) >> 20) & 0x7ff;
X    unsigned __xe = ((*(1 + (unsigned *)&(__x))) >> 20) & 0x7ff;
N    return (__xe != 0x7ff) && (__xe != 0);
N}
N    /* Return 1 if __x is a normalised number, 0 otherwise */
N    /* used by isnormal macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_signbitf(float __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_signbitf(float __x)
N{
N    return __FLT(__x) >> 31;
X    return (*(unsigned *)&(__x)) >> 31;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_signbit(double __x)
Xstatic inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_signbit(double __x)
N{
N    return __HI(__x) >> 31;
X    return (*(1 + (unsigned *)&(__x))) >> 31;
N}
N    /* Return signbit of __x */
N    /* Used by signbit macro */
N
N#   ifdef __cplusplus
S      } /* extern "C" */
N#   endif /* __cplusplus */
N#endif /* Strict ANSI */
N
N#   undef __CLIBNS
N
N#   ifdef __cplusplus
S      namespace std {
S#       define __CLIBNS ::std::
S        extern "C" {
N#   else
N#       define __CLIBNS
N#   endif  /* __cplusplus */
N
N
N#ifndef __has_builtin
N  #define __has_builtin(x) 0
N#endif
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 1L
N  /* C99 additions */
N  typedef float float_t;
N  typedef double double_t;
N#if __has_builtin(__builtin_inf)
X#if 0
S#   define HUGE_VALF __builtin_inff()
S#   define HUGE_VALL __builtin_infl()
S#   define INFINITY __builtin_inff()
S#   define NAN __builtin_nanf("")
N# else
N#   define HUGE_VALF ((float)__INFINITY__)
N#   define HUGE_VALL ((long double)__INFINITY__)
N#   define INFINITY ((float)__INFINITY__)
N#   define NAN (__ESCAPE__(0f_7FC00000))
N#endif
N
N#   define MATH_ERRNO 1
N#   define MATH_ERREXCEPT 2
Nextern const int math_errhandling;
N#endif
N#if __has_builtin(__builtin_inf)
X#if 0
S# define HUGE_VAL __builtin_inf()
N#else
N# define HUGE_VAL ((double)__INFINITY__)
N#endif
N
Nextern _ARMABI double acos(double /*x*/);
Xextern __declspec(__nothrow) double acos(double  );
N   /* computes the principal value of the arc cosine of x */
N   /* a domain error occurs for arguments not in the range -1 to 1 */
N   /* Returns: the arc cosine in the range 0 to Pi. */
Nextern _ARMABI double asin(double /*x*/);
Xextern __declspec(__nothrow) double asin(double  );
N   /* computes the principal value of the arc sine of x */
N   /* a domain error occurs for arguments not in the range -1 to 1 */
N   /* and -HUGE_VAL is returned. */
N   /* Returns: the arc sine in the range -Pi/2 to Pi/2. */
N
Nextern _ARMABI_PURE double atan(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double atan(double  );
N   /* computes the principal value of the arc tangent of x */
N   /* Returns: the arc tangent in the range -Pi/2 to Pi/2. */
N
Nextern _ARMABI double atan2(double /*y*/, double /*x*/);
Xextern __declspec(__nothrow) double atan2(double  , double  );
N   /* computes the principal value of the arc tangent of y/x, using the */
N   /* signs of both arguments to determine the quadrant of the return value */
N   /* a domain error occurs if both args are zero, and -HUGE_VAL returned. */
N   /* Returns: the arc tangent of y/x, in the range -Pi to Pi. */
N
Nextern _ARMABI double cos(double /*x*/);
Xextern __declspec(__nothrow) double cos(double  );
N   /* computes the cosine of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance. */
N   /* a domain error occurs for infinite input (C 7.12.1 footnote 196). */
N   /* Returns: the cosine value. */
Nextern _ARMABI double sin(double /*x*/);
Xextern __declspec(__nothrow) double sin(double  );
N   /* computes the sine of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance. */
N   /* a domain error occurs for infinite input (C 7.12.1 footnote 196). */
N   /* Returns: the sine value. */
N
Nextern void __use_accurate_range_reduction(void);
N   /* reference this to select the larger, slower, but more accurate */
N   /* range reduction in sin, cos and tan */
N
Nextern _ARMABI double tan(double /*x*/);
Xextern __declspec(__nothrow) double tan(double  );
N   /* computes the tangent of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance */
N   /* Returns: the tangent value. */
N   /*          if range error; returns HUGE_VAL. */
N
Nextern _ARMABI double cosh(double /*x*/);
Xextern __declspec(__nothrow) double cosh(double  );
N   /* computes the hyperbolic cosine of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the hyperbolic cosine value. */
N   /*          if range error; returns HUGE_VAL. */
Nextern _ARMABI double sinh(double /*x*/);
Xextern __declspec(__nothrow) double sinh(double  );
N   /* computes the hyperbolic sine of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the hyperbolic sine value. */
N   /*          if range error; returns -HUGE_VAL or HUGE_VAL depending */
N   /*          on the sign of the argument */
N
Nextern _ARMABI_PURE double tanh(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double tanh(double  );
N   /* computes the hyperbolic tangent of x. */
N   /* Returns: the hyperbolic tangent value. */
N
Nextern _ARMABI double exp(double /*x*/);
Xextern __declspec(__nothrow) double exp(double  );
N   /* computes the exponential function of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the exponential value. */
N   /*          if underflow range error; 0 is returned. */
N   /*          if overflow range error; HUGE_VAL is returned. */
N
Nextern _ARMABI double frexp(double /*value*/, int * /*exp*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) double frexp(double  , int *  ) __attribute__((__nonnull__(2)));
N   /* breaks a floating-point number into a normalised fraction and an */
N   /* integral power of 2. It stores the integer in the int object pointed */
N   /* to by exp. */
N   /* Returns: the value x, such that x is a double with magnitude in the */
N   /* interval 0.5 to 1.0 or zero, and value equals x times 2 raised to the */
N   /* power *exp. If value is zero, both parts of the result are zero. */
N
Nextern _ARMABI double ldexp(double /*x*/, int /*exp*/);
Xextern __declspec(__nothrow) double ldexp(double  , int  );
N   /* multiplies a floating-point number by an integral power of 2. */
N   /* A range error may occur. */
N   /* Returns: the value of x times 2 raised to the power of exp. */
N   /*          if range error; HUGE_VAL is returned. */
Nextern _ARMABI double log(double /*x*/);
Xextern __declspec(__nothrow) double log(double  );
N   /* computes the natural logarithm of x. A domain error occurs if the */
N   /* argument is negative, and -HUGE_VAL is returned. A range error occurs */
N   /* if the argument is zero. */
N   /* Returns: the natural logarithm. */
N   /*          if range error; -HUGE_VAL is returned. */
Nextern _ARMABI double log10(double /*x*/);
Xextern __declspec(__nothrow) double log10(double  );
N   /* computes the base-ten logarithm of x. A domain error occurs if the */
N   /* argument is negative. A range error occurs if the argument is zero. */
N   /* Returns: the base-ten logarithm. */
Nextern _ARMABI double modf(double /*value*/, double * /*iptr*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) double modf(double  , double *  ) __attribute__((__nonnull__(2)));
N   /* breaks the argument value into integral and fraction parts, each of */
N   /* which has the same sign as the argument. It stores the integral part */
N   /* as a double in the object pointed to by iptr. */
N   /* Returns: the signed fractional part of value. */
N
Nextern _ARMABI double pow(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double pow(double  , double  );
N   /* computes x raised to the power of y. A domain error occurs if x is */
N   /* zero and y is less than or equal to zero, or if x is negative and y */
N   /* is not an integer, and -HUGE_VAL returned. A range error may occur. */
N   /* Returns: the value of x raised to the power of y. */
N   /*          if underflow range error; 0 is returned. */
N   /*          if overflow range error; HUGE_VAL is returned. */
Nextern _ARMABI double sqrt(double /*x*/);
Xextern __declspec(__nothrow) double sqrt(double  );
N   /* computes the non-negative square root of x. A domain error occurs */
N   /* if the argument is negative, and -HUGE_VAL returned. */
N   /* Returns: the value of the square root. */
N
N#if defined(__TARGET_FPU_VFP_DOUBLE) && !defined(__TARGET_FPU_SOFTVFP)
X#if 0L && !0L
S    _ARMABI_INLINE double _sqrt(double __x) { return __sqrt(__x); }
N#else
N    _ARMABI_INLINE double _sqrt(double __x) { return sqrt(__x); }
X    inline double _sqrt(double __x) { return sqrt(__x); }
N#endif
N#if defined(__TARGET_FPU_VFP_SINGLE) && !defined(__TARGET_FPU_SOFTVFP)
X#if 1L && !0L
N    _ARMABI_INLINE float _sqrtf(float __x) { return __sqrtf(__x); }
X    inline float _sqrtf(float __x) { return __sqrtf(__x); }
N#else
S    _ARMABI_INLINE float _sqrtf(float __x) { return (float)sqrt(__x); }
N#endif
N    /* With VFP, _sqrt and _sqrtf should expand inline as the native VFP square root
N     * instructions. They will not behave like the C sqrt() function, because
N     * they will report unusual values as IEEE exceptions (in fpmodes which
N     * support IEEE exceptions) rather than in errno. These function names
N     * are not specified in any standard. */
N
Nextern _ARMABI_PURE double ceil(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double ceil(double  );
N   /* computes the smallest integer not less than x. */
N   /* Returns: the smallest integer not less than x, expressed as a double. */
Nextern _ARMABI_PURE double fabs(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double fabs(double  );
N   /* computes the absolute value of the floating-point number x. */
N   /* Returns: the absolute value of x. */
N
Nextern _ARMABI_PURE double floor(double /*d*/);
Xextern __declspec(__nothrow) __attribute__((const)) double floor(double  );
N   /* computes the largest integer not greater than x. */
N   /* Returns: the largest integer not greater than x, expressed as a double */
N
Nextern _ARMABI double fmod(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double fmod(double  , double  );
N   /* computes the floating-point remainder of x/y. */
N   /* Returns: the value x - i * y, for some integer i such that, if y is */
N   /*          nonzero, the result has the same sign as x and magnitude */
N   /*          less than the magnitude of y. If y is zero, a domain error */
N   /*          occurs and -HUGE_VAL is returned. */
N
N    /* Additional Mathlib functions not defined by the ANSI standard.
N     * Not guaranteed, and not necessarily very well tested.
N     * C99 requires the user to include <math.h> to use these functions
N     * declaring them "by hand" is not sufficient
N     *
N     * The above statement is not completely true now.  Some of the above
N     * C99 functionality has been added as per the Standard, and (where
N     * necessary) old Mathlib functionality withdrawn/changed.  Before
N     * including this header #define __ENABLE_MATHLIB_LEGACY if you want to
N     * re-enable the legacy functionality.
N     */
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 1L
N
Nextern _ARMABI double acosh(double /*x*/);
Xextern __declspec(__nothrow) double acosh(double  );
N    /*
N     * Inverse cosh. EDOM if argument < 1.0
N     */
Nextern _ARMABI double asinh(double /*x*/);
Xextern __declspec(__nothrow) double asinh(double  );
N    /*
N     * Inverse sinh.
N     */
Nextern _ARMABI double atanh(double /*x*/);
Xextern __declspec(__nothrow) double atanh(double  );
N    /*
N     * Inverse tanh. EDOM if |argument| > 1.0
N     */
Nextern _ARMABI double cbrt(double /*x*/);
Xextern __declspec(__nothrow) double cbrt(double  );
N    /*
N     * Cube root.
N     */
N_ARMABI_INLINE _ARMABI_PURE double copysign(double __x, double __y)
Xinline __declspec(__nothrow) __attribute__((const)) double copysign(double __x, double __y)
N    /*
N     * Returns x with sign bit replaced by sign of y.
N     */
N{
N    __HI(__x) = (__HI(__x) & 0x7fffffff) | (__HI(__y) & 0x80000000);
X    (*(1 + (unsigned *)&(__x))) = ((*(1 + (unsigned *)&(__x))) & 0x7fffffff) | ((*(1 + (unsigned *)&(__y))) & 0x80000000);
N    return __x;
N}
N_ARMABI_INLINE _ARMABI_PURE float copysignf(float __x, float __y)
Xinline __declspec(__nothrow) __attribute__((const)) float copysignf(float __x, float __y)
N    /*
N     * Returns x with sign bit replaced by sign of y.
N     */
N{
N    __FLT(__x) = (__FLT(__x) & 0x7fffffff) | (__FLT(__y) & 0x80000000);
X    (*(unsigned *)&(__x)) = ((*(unsigned *)&(__x)) & 0x7fffffff) | ((*(unsigned *)&(__y)) & 0x80000000);
N    return __x;
N}
Nextern _ARMABI double erf(double /*x*/);
Xextern __declspec(__nothrow) double erf(double  );
N    /*
N     * Error function. (2/sqrt(pi)) * integral from 0 to x of exp(-t*t) dt.
N     */
Nextern _ARMABI double erfc(double /*x*/);
Xextern __declspec(__nothrow) double erfc(double  );
N    /*
N     * 1-erf(x). (More accurate than just coding 1-erf(x), for large x.)
N     */
Nextern _ARMABI double expm1(double /*x*/);
Xextern __declspec(__nothrow) double expm1(double  );
N    /*
N     * exp(x)-1. (More accurate than just coding exp(x)-1, for small x.)
N     */
N#define fpclassify(x) \
N    ((sizeof(x) == sizeof(float)) ? \
N        __ARM_fpclassifyf(x) : __ARM_fpclassify(x))
X#define fpclassify(x)     ((sizeof(x) == sizeof(float)) ?         __ARM_fpclassifyf(x) : __ARM_fpclassify(x))
N    /*
N     * Classify a floating point number into one of the following values:
N     */
N#define FP_ZERO         (0)
N#define FP_SUBNORMAL    (4)
N#define FP_NORMAL       (5)
N#define FP_INFINITE     (3)
N#define FP_NAN          (7)
N
N#if defined(_WANT_SNAN) && defined(__SUPPORT_SNAN__)
X#if 0L && 0L
S/* 
S * Note that we'll never classify a number as FP_NAN, as all NaNs will 
S * be either FP_NANQ or FP_NANS
S */
S#  define FP_NANQ       (8)
S#  define FP_NANS       (9)
N#endif
N
N
Nextern _ARMABI double hypot(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double hypot(double  , double  );
N    /*
N     * sqrt(x*x+y*y), ie the length of the vector (x,y) or the
N     * hypotenuse of a right triangle whose other two sides are x
N     * and y. Won't overflow unless the _answer_ is too big, even
N     * if the intermediate x*x+y*y is too big.
N     */
Nextern _ARMABI int ilogb(double /*x*/);
Xextern __declspec(__nothrow) int ilogb(double  );
N    /*
N     * Exponent of x (returns 0 for 1.0, 1 for 2.0, -1 for 0.5, etc.)
N     */
Nextern _ARMABI int ilogbf(float /*x*/);
Xextern __declspec(__nothrow) int ilogbf(float  );
N    /*
N     * Like ilogb but takes a float
N     */
Nextern _ARMABI int ilogbl(long double /*x*/);
Xextern __declspec(__nothrow) int ilogbl(long double  );
N    /*
N     * Exponent of x (returns 0 for 1.0, 1 for 2.0, -1 for 0.5, etc.)
N     */
N#define FP_ILOGB0   (-0x7fffffff) /* ilogb(0) == -INT_MAX */
N#define FP_ILOGBNAN ( 0x80000000) /* ilogb(NAN) == INT_MIN */
N
N#define isfinite(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isfinitef(x) \
N        : __ARM_isfinite(x))
X#define isfinite(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isfinitef(x)         : __ARM_isfinite(x))
N    /*
N     * Returns true if x is a finite number, size independent.
N     */
N
N#define isgreater(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x20000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x20000000))
X#define isgreater(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x20000000)         : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x20000000))
N    /*
N     * Returns true if x > y, throws no exceptions except on Signaling NaNs
N     *
N     * We want the C not set but the Z bit clear, V must be clear
N     */
N
N#define isgreaterequal(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0x30000000) == 0x20000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0x30000000) == 0x20000000))
X#define isgreaterequal(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0x30000000) == 0x20000000)         : ((__ARM_dcmp4((x), (y)) & 0x30000000) == 0x20000000))
N    /*
N     * Returns true if x >= y, throws no exceptions except on Signaling NaNs
N     *
N     * We just need to see if the C bit is set or not and ensure V clear
N     */
N
N#define isinf(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isinff(x) \
N        : __ARM_isinf(x))
X#define isinf(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isinff(x)         : __ARM_isinf(x))
N    /*
N     * Returns true if x is an infinity, size independent.
N     */
N
N#define isless(x, y)  \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x80000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x80000000))
X#define isless(x, y)      (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x80000000)         : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x80000000))
N    /*
N     * Returns true if x < y, throws no exceptions except on Signaling NaNs
N     *
N     * We're less than if N is set, V clear
N     */
N
N#define islessequal(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xc0000000) != 0) \
N        : ((__ARM_dcmp4((x), (y)) & 0xc0000000) != 0))
X#define islessequal(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xc0000000) != 0)         : ((__ARM_dcmp4((x), (y)) & 0xc0000000) != 0))
N    /*
N     * Returns true if x <= y, throws no exceptions except on Signaling NaNs
N     *
N     * We're less than or equal if one of N or Z is set, V clear
N     */
N
N#define islessgreater(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? __ARM_islessgreaterf((x), (y)) \
N        : __ARM_islessgreater((x), (y)))
X#define islessgreater(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? __ARM_islessgreaterf((x), (y))         : __ARM_islessgreater((x), (y)))
N    /*
N     * Returns true if x <> y, throws no exceptions except on Signaling NaNs
N     * Unfortunately this test is too complicated to do in a macro without
N     * evaluating x & y twice.  Shame really...
N     */
N
N#define isnan(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isnanf(x) \
N        : __ARM_isnan(x))
X#define isnan(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isnanf(x)         : __ARM_isnan(x))
N    /*
N     * Returns TRUE if x is a NaN.
N     */
N
N#define isnormal(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isnormalf(x) \
N        : __ARM_isnormal(x))
X#define isnormal(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isnormalf(x)         : __ARM_isnormal(x))
N    /*
N     * Returns TRUE if x is a NaN.
N     */
N
N#define isunordered(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0x10000000) == 0x10000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0x10000000) == 0x10000000))
X#define isunordered(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0x10000000) == 0x10000000)         : ((__ARM_dcmp4((x), (y)) & 0x10000000) == 0x10000000))
N    /*
N     * Returns true if x ? y, throws no exceptions except on Signaling NaNs
N     * Unordered occurs if and only if the V bit is set
N     */
N
Nextern _ARMABI double lgamma (double /*x*/);
Xextern __declspec(__nothrow) double lgamma (double  );
N    /*
N     * The log of the absolute value of the gamma function of x. The sign
N     * of the gamma function of x is returned in the global `signgam'.
N     */
Nextern _ARMABI double log1p(double /*x*/);
Xextern __declspec(__nothrow) double log1p(double  );
N    /*
N     * log(1+x). (More accurate than just coding log(1+x), for small x.)
N     */
Nextern _ARMABI double logb(double /*x*/);
Xextern __declspec(__nothrow) double logb(double  );
N    /*
N     * Like ilogb but returns a double.
N     */
Nextern _ARMABI float logbf(float /*x*/);
Xextern __declspec(__nothrow) float logbf(float  );
N    /*
N     * Like logb but takes and returns float
N     */
Nextern _ARMABI long double logbl(long double /*x*/);
Xextern __declspec(__nothrow) long double logbl(long double  );
N    /*
N     * Like logb but takes and returns long double
N     */
Nextern _ARMABI double nextafter(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double nextafter(double  , double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI float nextafterf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float nextafterf(float  , float  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI long double nextafterl(long double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) long double nextafterl(long double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI double nexttoward(double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) double nexttoward(double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI float nexttowardf(float /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) float nexttowardf(float  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI long double nexttowardl(long double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) long double nexttowardl(long double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI double remainder(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double remainder(double  , double  );
N    /*
N     * Returns the remainder of x by y, in the IEEE 754 sense.
N     */
Nextern _ARMABI_FPEXCEPT double rint(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double rint(double  );
N    /*
N     * Rounds x to an integer, in the IEEE 754 sense.
N     */
Nextern _ARMABI double scalbln(double /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) double scalbln(double  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI float scalblnf(float /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) float scalblnf(float  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI long double scalblnl(long double /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) long double scalblnl(long double  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI double scalbn(double /*x*/, int /*n*/);
Xextern __declspec(__nothrow) double scalbn(double  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI float scalbnf(float /*x*/, int /*n*/);
Xextern __declspec(__nothrow) float scalbnf(float  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI long double scalbnl(long double /*x*/, int /*n*/);
Xextern __declspec(__nothrow) long double scalbnl(long double  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
N#define signbit(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_signbitf(x) \
N        : __ARM_signbit(x))
X#define signbit(x)     ((sizeof(x) == sizeof(float))         ? __ARM_signbitf(x)         : __ARM_signbit(x))
N    /*
N     * Returns the signbit of x, size independent macro
N     */
N#endif
N
N/* C99 float versions of functions.  math.h has always reserved these
N   identifiers for this purpose (7.13.4). */
Nextern _ARMABI_PURE float _fabsf(float); /* old ARM name */
Xextern __declspec(__nothrow) __attribute__((const)) float _fabsf(float);  
N_ARMABI_INLINE _ARMABI_PURE float fabsf(float __f) { return _fabsf(__f); }
Xinline __declspec(__nothrow) __attribute__((const)) float fabsf(float __f) { return _fabsf(__f); }
Nextern _ARMABI float sinf(float /*x*/);
Xextern __declspec(__nothrow) float sinf(float  );
Nextern _ARMABI float cosf(float /*x*/);
Xextern __declspec(__nothrow) float cosf(float  );
Nextern _ARMABI float tanf(float /*x*/);
Xextern __declspec(__nothrow) float tanf(float  );
Nextern _ARMABI float acosf(float /*x*/);
Xextern __declspec(__nothrow) float acosf(float  );
Nextern _ARMABI float asinf(float /*x*/);
Xextern __declspec(__nothrow) float asinf(float  );
Nextern _ARMABI float atanf(float /*x*/);
Xextern __declspec(__nothrow) float atanf(float  );
Nextern _ARMABI float atan2f(float /*y*/, float /*x*/);
Xextern __declspec(__nothrow) float atan2f(float  , float  );
Nextern _ARMABI float sinhf(float /*x*/);
Xextern __declspec(__nothrow) float sinhf(float  );
Nextern _ARMABI float coshf(float /*x*/);
Xextern __declspec(__nothrow) float coshf(float  );
Nextern _ARMABI float tanhf(float /*x*/);
Xextern __declspec(__nothrow) float tanhf(float  );
Nextern _ARMABI float expf(float /*x*/);
Xextern __declspec(__nothrow) float expf(float  );
Nextern _ARMABI float logf(float /*x*/);
Xextern __declspec(__nothrow) float logf(float  );
Nextern _ARMABI float log10f(float /*x*/);
Xextern __declspec(__nothrow) float log10f(float  );
Nextern _ARMABI float powf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float powf(float  , float  );
Nextern _ARMABI float sqrtf(float /*x*/);
Xextern __declspec(__nothrow) float sqrtf(float  );
Nextern _ARMABI float ldexpf(float /*x*/, int /*exp*/);
Xextern __declspec(__nothrow) float ldexpf(float  , int  );
Nextern _ARMABI float frexpf(float /*value*/, int * /*exp*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) float frexpf(float  , int *  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI_PURE float ceilf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float ceilf(float  );
Nextern _ARMABI_PURE float floorf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float floorf(float  );
Nextern _ARMABI float fmodf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float fmodf(float  , float  );
Nextern _ARMABI float modff(float /*value*/, float * /*iptr*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) float modff(float  , float *  ) __attribute__((__nonnull__(2)));
N
N/* C99 long double versions of functions. */
N/* (also need to have 'using' declarations below) */
N#define _ARMDEFLD1(f) \
N    _ARMABI long double f##l(long double /*x*/)
X#define _ARMDEFLD1(f)     _ARMABI long double f##l(long double  )
N
N#define _ARMDEFLD1P(f, T) \
N    _ARMABI long double f##l(long double /*x*/, T /*p*/)
X#define _ARMDEFLD1P(f, T)     _ARMABI long double f##l(long double  , T  )
N
N#define _ARMDEFLD2(f) \
N    _ARMABI long double f##l(long double /*x*/, long double /*y*/)
X#define _ARMDEFLD2(f)     _ARMABI long double f##l(long double  , long double  )
N
N/*
N * Long double versions of C89 functions can be defined
N * unconditionally, because C89 reserved these names in "future
N * library directions".
N */
N_ARMDEFLD1(acos);
X__declspec(__nothrow) long double acosl(long double );
N_ARMDEFLD1(asin);
X__declspec(__nothrow) long double asinl(long double );
N_ARMDEFLD1(atan);
X__declspec(__nothrow) long double atanl(long double );
N_ARMDEFLD2(atan2);
X__declspec(__nothrow) long double atan2l(long double , long double );
N_ARMDEFLD1(ceil);
X__declspec(__nothrow) long double ceill(long double );
N_ARMDEFLD1(cos);
X__declspec(__nothrow) long double cosl(long double );
N_ARMDEFLD1(cosh);
X__declspec(__nothrow) long double coshl(long double );
N_ARMDEFLD1(exp);
X__declspec(__nothrow) long double expl(long double );
N_ARMDEFLD1(fabs);
X__declspec(__nothrow) long double fabsl(long double );
N_ARMDEFLD1(floor);
X__declspec(__nothrow) long double floorl(long double );
N_ARMDEFLD2(fmod);
X__declspec(__nothrow) long double fmodl(long double , long double );
N_ARMDEFLD1P(frexp, int*) __attribute__((__nonnull__(2)));
X__declspec(__nothrow) long double frexpl(long double , int* ) __attribute__((__nonnull__(2)));
N_ARMDEFLD1P(ldexp, int);
X__declspec(__nothrow) long double ldexpl(long double , int );
N_ARMDEFLD1(log);
X__declspec(__nothrow) long double logl(long double );
N_ARMDEFLD1(log10);
X__declspec(__nothrow) long double log10l(long double );
N_ARMABI long double modfl(long double /*x*/, long double * /*p*/) __attribute__((__nonnull__(2)));
X__declspec(__nothrow) long double modfl(long double  , long double *  ) __attribute__((__nonnull__(2)));
N_ARMDEFLD2(pow);
X__declspec(__nothrow) long double powl(long double , long double );
N_ARMDEFLD1(sin);
X__declspec(__nothrow) long double sinl(long double );
N_ARMDEFLD1(sinh);
X__declspec(__nothrow) long double sinhl(long double );
N_ARMDEFLD1(sqrt);
X__declspec(__nothrow) long double sqrtl(long double );
N_ARMDEFLD1(tan);
X__declspec(__nothrow) long double tanl(long double );
N_ARMDEFLD1(tanh);
X__declspec(__nothrow) long double tanhl(long double );
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 1L
N
N/*
N * C99 float and long double versions of extra-C89 functions.
N */
Nextern _ARMABI float acoshf(float /*x*/);
Xextern __declspec(__nothrow) float acoshf(float  );
N_ARMDEFLD1(acosh);
X__declspec(__nothrow) long double acoshl(long double );
Nextern _ARMABI float asinhf(float /*x*/);
Xextern __declspec(__nothrow) float asinhf(float  );
N_ARMDEFLD1(asinh);
X__declspec(__nothrow) long double asinhl(long double );
Nextern _ARMABI float atanhf(float /*x*/);
Xextern __declspec(__nothrow) float atanhf(float  );
N_ARMDEFLD1(atanh);
X__declspec(__nothrow) long double atanhl(long double );
N_ARMDEFLD2(copysign);
X__declspec(__nothrow) long double copysignl(long double , long double );
Nextern _ARMABI float cbrtf(float /*x*/);
Xextern __declspec(__nothrow) float cbrtf(float  );
N_ARMDEFLD1(cbrt);
X__declspec(__nothrow) long double cbrtl(long double );
Nextern _ARMABI float erff(float /*x*/);
Xextern __declspec(__nothrow) float erff(float  );
N_ARMDEFLD1(erf);
X__declspec(__nothrow) long double erfl(long double );
Nextern _ARMABI float erfcf(float /*x*/);
Xextern __declspec(__nothrow) float erfcf(float  );
N_ARMDEFLD1(erfc);
X__declspec(__nothrow) long double erfcl(long double );
Nextern _ARMABI float expm1f(float /*x*/);
Xextern __declspec(__nothrow) float expm1f(float  );
N_ARMDEFLD1(expm1);
X__declspec(__nothrow) long double expm1l(long double );
Nextern _ARMABI float log1pf(float /*x*/);
Xextern __declspec(__nothrow) float log1pf(float  );
N_ARMDEFLD1(log1p);
X__declspec(__nothrow) long double log1pl(long double );
Nextern _ARMABI float hypotf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float hypotf(float  , float  );
N_ARMDEFLD2(hypot);
X__declspec(__nothrow) long double hypotl(long double , long double );
Nextern _ARMABI float lgammaf(float /*x*/);
Xextern __declspec(__nothrow) float lgammaf(float  );
N_ARMDEFLD1(lgamma);
X__declspec(__nothrow) long double lgammal(long double );
Nextern _ARMABI float remainderf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float remainderf(float  , float  );
N_ARMDEFLD2(remainder);
X__declspec(__nothrow) long double remainderl(long double , long double );
Nextern _ARMABI float rintf(float /*x*/);
Xextern __declspec(__nothrow) float rintf(float  );
N_ARMDEFLD1(rint);
X__declspec(__nothrow) long double rintl(long double );
N
N#endif
N
N#if (defined(__clang__) && !defined(__STRICT_ANSI)) || defined(__USE_C99_MATH)
X#if (0L && !0L) || 1L
N/*
N * Functions new in C99.
N */
Nextern _ARMABI double exp2(double /*x*/); /* * 2.^x. */
Xextern __declspec(__nothrow) double exp2(double  );  
Nextern _ARMABI float exp2f(float /*x*/);
Xextern __declspec(__nothrow) float exp2f(float  );
N_ARMDEFLD1(exp2);
X__declspec(__nothrow) long double exp2l(long double );
Nextern _ARMABI double fdim(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double fdim(double  , double  );
Nextern _ARMABI float fdimf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float fdimf(float  , float  );
N_ARMDEFLD2(fdim);
X__declspec(__nothrow) long double fdiml(long double , long double );
N#ifdef __FP_FAST_FMA
S#define FP_FAST_FMA
N#endif
N#ifdef __FP_FAST_FMAF
N#define FP_FAST_FMAF
N#endif
N#ifdef __FP_FAST_FMAL
S#define FP_FAST_FMAL
N#endif
Nextern _ARMABI double fma(double /*x*/, double /*y*/, double /*z*/);
Xextern __declspec(__nothrow) double fma(double  , double  , double  );
Nextern _ARMABI float fmaf(float /*x*/, float /*y*/, float /*z*/);
Xextern __declspec(__nothrow) float fmaf(float  , float  , float  );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI long double fmal(long double __x, long double __y, long double __z) \
N    { return (long double)fma((double)__x, (double)__y, (double)__z); }
Xinline __declspec(__nothrow) long double fmal(long double __x, long double __y, long double __z)     { return (long double)fma((double)__x, (double)__y, (double)__z); }
N#endif
Nextern _ARMABI_FPEXCEPT double fmax(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) __attribute__((const)) double fmax(double  , double  );
Nextern _ARMABI_FPEXCEPT float fmaxf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) __attribute__((const)) float fmaxf(float  , float  );
N_ARMDEFLD2(fmax);
X__declspec(__nothrow) long double fmaxl(long double , long double );
Nextern _ARMABI_FPEXCEPT double fmin(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) __attribute__((const)) double fmin(double  , double  );
Nextern _ARMABI_FPEXCEPT float fminf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) __attribute__((const)) float fminf(float  , float  );
N_ARMDEFLD2(fmin);
X__declspec(__nothrow) long double fminl(long double , long double );
Nextern _ARMABI double log2(double /*x*/); /* * log base 2 of x. */
Xextern __declspec(__nothrow) double log2(double  );  
Nextern _ARMABI float log2f(float /*x*/);
Xextern __declspec(__nothrow) float log2f(float  );
N_ARMDEFLD1(log2);
X__declspec(__nothrow) long double log2l(long double );
Nextern _ARMABI long lrint(double /*x*/);
Xextern __declspec(__nothrow) long lrint(double  );
Nextern _ARMABI long lrintf(float /*x*/);
Xextern __declspec(__nothrow) long lrintf(float  );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI long lrintl(long double __x) \
N    { return lrint((double)__x); }
Xinline __declspec(__nothrow) long lrintl(long double __x)     { return lrint((double)__x); }
N#endif
Nextern _ARMABI __LONGLONG llrint(double /*x*/);
Xextern __declspec(__nothrow) long long llrint(double  );
Nextern _ARMABI __LONGLONG llrintf(float /*x*/);
Xextern __declspec(__nothrow) long long llrintf(float  );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI __LONGLONG llrintl(long double __x) \
N    { return llrint((double)__x); }
Xinline __declspec(__nothrow) long long llrintl(long double __x)     { return llrint((double)__x); }
N#endif
Nextern _ARMABI long lround(double /*x*/);
Xextern __declspec(__nothrow) long lround(double  );
Nextern _ARMABI long lroundf(float /*x*/);
Xextern __declspec(__nothrow) long lroundf(float  );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI long lroundl(long double __x) \
N    { return lround((double)__x); }
Xinline __declspec(__nothrow) long lroundl(long double __x)     { return lround((double)__x); }
N#endif
Nextern _ARMABI __LONGLONG llround(double /*x*/);
Xextern __declspec(__nothrow) long long llround(double  );
Nextern _ARMABI __LONGLONG llroundf(float /*x*/);
Xextern __declspec(__nothrow) long long llroundf(float  );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI __LONGLONG llroundl(long double __x) \
N    { return llround((double)__x); }
Xinline __declspec(__nothrow) long long llroundl(long double __x)     { return llround((double)__x); }
N#endif
Nextern _ARMABI_PURE double nan(const char */*tagp*/);
Xextern __declspec(__nothrow) __attribute__((const)) double nan(const char * );
Nextern _ARMABI_PURE float nanf(const char */*tagp*/);
Xextern __declspec(__nothrow) __attribute__((const)) float nanf(const char * );
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE _ARMABI_PURE long double nanl(const char *__t) \
N    { return (long double)nan(__t); }
Xinline __declspec(__nothrow) __attribute__((const)) long double nanl(const char *__t)     { return (long double)nan(__t); }
N#endif
N#if defined(_WANT_SNAN) && defined(__SUPPORT_SNAN__)
X#if 0L && 0L
Sextern _ARMABI_PURE double nans(const char */*tagp*/);
Sextern _ARMABI_PURE float nansf(const char */*tagp*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI_FPEXCEPT long double nansl(const char *__t) \
S    { return (long double)nans(__t); }
X_ARMABI_INLINE _ARMABI_FPEXCEPT long double nansl(const char *__t)     { return (long double)nans(__t); }
S#endif
N#endif 
Nextern _ARMABI_FPEXCEPT double nearbyint(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double nearbyint(double  );
Nextern _ARMABI_FPEXCEPT float nearbyintf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float nearbyintf(float  );
N_ARMDEFLD1(nearbyint);
X__declspec(__nothrow) long double nearbyintl(long double );
Nextern  double remquo(double /*x*/, double /*y*/, int */*quo*/);
Nextern  float remquof(float /*x*/, float /*y*/, int */*quo*/);
N#ifdef __HAVE_LONGDOUBLE
N_ARMABI_INLINE long double remquol(long double __x, long double __y, int *__q) \
N    { return (long double)remquo((double)__x, (double)__y, __q); }
Xinline long double remquol(long double __x, long double __y, int *__q)     { return (long double)remquo((double)__x, (double)__y, __q); }
N#endif
Nextern _ARMABI_FPEXCEPT double round(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double round(double  );
Nextern _ARMABI_FPEXCEPT float roundf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float roundf(float  );
N_ARMDEFLD1(round);
X__declspec(__nothrow) long double roundl(long double );
Nextern _ARMABI double tgamma(double /*x*/); /* * The gamma function of x. */
Xextern __declspec(__nothrow) double tgamma(double  );  
Nextern _ARMABI float tgammaf(float /*x*/);
Xextern __declspec(__nothrow) float tgammaf(float  );
N_ARMDEFLD1(tgamma);
X__declspec(__nothrow) long double tgammal(long double );
Nextern _ARMABI_FPEXCEPT double trunc(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double trunc(double  );
Nextern _ARMABI_FPEXCEPT float truncf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float truncf(float  );
N_ARMDEFLD1(trunc);
X__declspec(__nothrow) long double truncl(long double );
N#endif
N
N#undef _ARMDEFLD1
N#undef _ARMDEFLD1P
N#undef _ARMDEFLD2
N
N#if defined(__cplusplus) && ((!defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)) || defined(__ARMCOMPILER_LIBCXX))
X#if 0L && ((!0L || 1L) || 0L)
S  extern "C++" {
S    inline int (fpclassify)(double __x) { return fpclassify(__x); }
S    inline bool (isfinite)(double __x) { return isfinite(__x); }
S    inline bool (isgreater)(double __x, double __y) { return isgreater(__x, __y); }
S    inline bool (isgreaterequal)(double __x, double __y) { return isgreaterequal(__x, __y); }
S    inline bool (isinf)(double __x) { return isinf(__x); }
S    inline bool (isless)(double __x, double __y) { return isless(__x, __y); }
S    inline bool (islessequal)(double __x, double __y) { return islessequal(__x, __y); }
S    inline bool (islessgreater)(double __x, double __y) { return islessgreater(__x, __y); }
S    inline bool (isnan)(double __x) { return isnan(__x); }
S    inline bool (isnormal)(double __x) { return isnormal(__x); }
S    inline bool (isunordered)(double __x, double __y) { return isunordered(__x, __y); }
S
S  }
N#endif
N
N#if defined(__cplusplus) && !defined(__ARMCOMPILER_LIBCXX)
X#if 0L && !0L
S  extern "C++" {
S    inline float abs(float __x)   { return fabsf(__x); }
S    inline float acos(float __x)  { return acosf(__x); }
S    inline float asin(float __x)  { return asinf(__x); }
S    inline float atan(float __x)  { return atanf(__x); }
S    inline float atan2(float __y, float __x)    { return atan2f(__y,__x); }
S    inline float ceil(float __x)  { return ceilf(__x); }
S    inline float cos(float __x)   { return cosf(__x); }
S    inline float cosh(float __x)  { return coshf(__x); }
S    inline float exp(float __x)   { return expf(__x); }
S    inline float fabs(float __x)  { return fabsf(__x); }
S    inline float floor(float __x) { return floorf(__x); }
S    inline float fmod(float __x, float __y)     { return fmodf(__x, __y); }
S    float frexp(float __x, int* __exp) __attribute__((__nonnull__(2)));
S    inline float frexp(float __x, int* __exp)   { return frexpf(__x, __exp); }
S    inline float ldexp(float __x, int __exp)    { return ldexpf(__x, __exp);}
S    inline float log(float __x)   { return logf(__x); }
S    inline float log10(float __x) { return log10f(__x); }
S    float modf(float __x, float* __iptr) __attribute__((__nonnull__(2)));
S    inline float modf(float __x, float* __iptr) { return modff(__x, __iptr); }
S    inline float pow(float __x, float __y)      { return powf(__x,__y); }
S    inline float pow(float __x, int __y)     { return powf(__x, (float)__y); }
S    inline float sin(float __x)   { return sinf(__x); }
S    inline float sinh(float __x)  { return sinhf(__x); }
S    inline float sqrt(float __x)  { return sqrtf(__x); }
S    inline float _sqrt(float __x) { return _sqrtf(__x); }
S    inline float tan(float __x)   { return tanf(__x); }
S    inline float tanh(float __x)  { return tanhf(__x); }
S
S    inline double abs(double __x) { return fabs(__x); }
S    inline double pow(double __x, int __y)
S                { return pow(__x, (double) __y); }
S
S#ifdef __HAVE_LONGDOUBLE
S    inline long double abs(long double __x)
S                { return (long double)fabsl(__x); }
S    inline long double acos(long double __x)
S                { return (long double)acosl(__x); }
S    inline long double asin(long double __x)
S                { return (long double)asinl(__x); }
S    inline long double atan(long double __x)
S                { return (long double)atanl(__x); }
S    inline long double atan2(long double __y, long double __x)
S                { return (long double)atan2l(__y, __x); }
S    inline long double ceil(long double __x)
S                { return (long double)ceill( __x); }
S    inline long double cos(long double __x)
S                { return (long double)cosl(__x); }
S    inline long double cosh(long double __x)
S                { return (long double)coshl(__x); }
S    inline long double exp(long double __x)
S                { return (long double)expl(__x); }
S    inline long double fabs(long double __x)
S                { return (long double)fabsl(__x); }
S    inline long double floor(long double __x)
S                { return (long double)floorl(__x); }
S    inline long double fmod(long double __x, long double __y)
S                { return (long double)fmodl(__x, __y); }
S    long double frexp(long double __x, int* __p) __attribute__((__nonnull__(2)));
S    inline long double frexp(long double __x, int* __p)
S                { return (long double)frexpl(__x, __p); }
S    inline long double ldexp(long double __x, int __exp)
S                { return (long double)ldexpl(__x, __exp); }
S    inline long double log(long double __x)
S                { return (long double)logl(__x); }
S    inline long double log10(long double __x)
S                { return (long double)log10l(__x); }
S    long double modf(long double __x, long double* __p) __attribute__((__nonnull__(2)));
S    inline long double modf(long double __x, long double* __p)
S                { return (long double)modfl(__x, __p); }
S    inline long double pow(long double __x, long double __y)
S                { return (long double)powl(__x, __y); }
S    inline long double pow(long double __x, int __y)
S                { return (long double)powl(__x, __y); }
S    inline long double sin(long double __x)
S                { return (long double)sinl(__x); }
S    inline long double sinh(long double __x)
S                { return (long double)sinhl(__x); }
S    inline long double sqrt(long double __x)
S                { return (long double)sqrtl(__x); }
S    inline long double _sqrt(long double __x)
S                { return (long double)_sqrt((double) __x); }
S    inline long double tan(long double __x)
S                { return (long double)tanl(__x); }
S    inline long double tanh(long double __x)
S                { return (long double)tanhl(__x); }
S#endif
S
S#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S    inline float acosh(float __x) { return acoshf(__x); }
S    inline float asinh(float __x) { return asinhf(__x); }
S    inline float atanh(float __x) { return atanhf(__x); }
S    inline float cbrt(float __x) { return cbrtf(__x); }
S    inline float erf(float __x) { return erff(__x); }
S    inline float erfc(float __x) { return erfcf(__x); }
S    inline float expm1(float __x) { return expm1f(__x); }
S    inline float log1p(float __x) { return log1pf(__x); }
S    inline float hypot(float __x, float __y) { return hypotf(__x, __y); }
S    inline float lgamma(float __x) { return lgammaf(__x); }
S    inline float remainder(float __x, float __y) { return remainderf(__x, __y); }
S    inline float rint(float __x) { return rintf(__x); }
S#endif
S
S#ifdef __USE_C99_MATH
S    inline float exp2(float __x) { return exp2f(__x); }
S    inline float fdim(float __x, float __y) { return fdimf(__x, __y); }
S    inline float fma(float __x, float __y, float __z) { return fmaf(__x, __y, __z); }
S    inline float fmax(float __x, float __y) { return fmaxf(__x, __y); }
S    inline float fmin(float __x, float __y) { return fminf(__x, __y); }
S    inline float log2(float __x) { return log2f(__x); }
S    inline _ARMABI long lrint(float __x) { return lrintf(__x); }
S    inline _ARMABI __LONGLONG llrint(float __x) { return llrintf(__x); }
S    inline _ARMABI long lround(float __x) { return lroundf(__x); }
S    inline _ARMABI __LONGLONG llround(float __x) { return llroundf(__x); }
S    inline _ARMABI_FPEXCEPT float nearbyint(float __x) { return nearbyintf(__x); }
S    inline float remquo(float __x, float __y, int *__q) { return remquof(__x, __y, __q); }
S    inline _ARMABI_FPEXCEPT float round(float __x) { return roundf(__x); }
S    inline float tgamma(float __x) { return tgammaf(__x); }
S    inline _ARMABI_FPEXCEPT float trunc(float __x) { return truncf(__x); }
S
S    inline int (fpclassify)(float __x) { return fpclassify(__x); }
S    inline bool (isfinite)(float __x) { return isfinite(__x); }
S    inline bool (isgreater)(float __x, float __y) { return isgreater(__x, __y); }
S    inline bool (isgreaterequal)(float __x, float __y) { return isgreaterequal(__x, __y); }
S    inline bool (isinf)(float __x) { return isinf(__x); }
S    inline bool (isless)(float __x, float __y) { return isless(__x, __y); }
S    inline bool (islessequal)(float __x, float __y) { return islessequal(__x, __y); }
S    inline bool (islessgreater)(float __x, float __y) { return islessgreater(__x, __y); }
S    inline bool (isnan)(float __x) { return isnan(__x); }
S    inline bool (isnormal)(float __x) { return isnormal(__x); }
S    inline bool (isunordered)(float __x, float __y) { return isunordered(__x, __y); }
S
S#ifdef __HAVE_LONGDOUBLE
S    inline long double acosh(long double __x) { return acoshl(__x); }
S    inline long double asinh(long double __x) { return asinhl(__x); }
S    inline long double atanh(long double __x) { return atanhl(__x); }
S    inline long double cbrt(long double __x) { return cbrtl(__x); }
S    inline long double erf(long double __x) { return erfl(__x); }
S    inline long double erfc(long double __x) { return erfcl(__x); }
S    inline long double expm1(long double __x) { return expm1l(__x); }
S    inline long double log1p(long double __x) { return log1pl(__x); }
S    inline long double hypot(long double __x, long double __y) { return hypotl(__x, __y); }
S    inline long double lgamma(long double __x) { return lgammal(__x); }
S    inline long double remainder(long double __x, long double __y) { return remainderl(__x, __y); }
S    inline long double rint(long double __x) { return rintl(__x); }
S    inline long double exp2(long double __x) { return exp2l(__x); }
S    inline long double fdim(long double __x, long double __y) { return fdiml(__x, __y); }
S    inline long double fma(long double __x, long double __y, long double __z) { return fmal(__x, __y, __z); }
S    inline long double fmax(long double __x, long double __y) { return fmaxl(__x, __y); }
S    inline long double fmin(long double __x, long double __y) { return fminl(__x, __y); }
S    inline long double log2(long double __x) { return log2l(__x); }
S    inline _ARMABI long lrint(long double __x) { return lrintl(__x); }
S    inline _ARMABI __LONGLONG llrint(long double __x) { return llrintl(__x); }
S    inline _ARMABI long lround(long double __x) { return lroundl(__x); }
S    inline _ARMABI __LONGLONG llround(long double __x) { return llroundl(__x); }
S    inline _ARMABI_FPEXCEPT long double nearbyint(long double __x) { return nearbyintl(__x); }
S    inline long double remquo(long double __x, long double __y, int *__q) { return remquol(__x, __y, __q); }
S    inline _ARMABI_FPEXCEPT long double round(long double __x) { return roundl(__x); }
S    inline long double tgamma(long double __x) { return tgammal(__x); }
S    inline _ARMABI_FPEXCEPT long double trunc(long double __x) { return truncl(__x); }
S    inline int (fpclassify)(long double __x) { return fpclassify(__x); }
S    inline bool (isfinite)(long double __x) { return isfinite(__x); }
S    inline bool (isgreater)(long double __x, long double __y) { return isgreater(__x, __y); }
S    inline bool (isgreaterequal)(long double __x, long double __y) { return isgreaterequal(__x, __y); }
S    inline bool (isinf)(long double __x) { return isinf(__x); }
S    inline bool (isless)(long double __x, long double __y) { return isless(__x, __y); }
S    inline bool (islessequal)(long double __x, long double __y) { return islessequal(__x, __y); }
S    inline bool (islessgreater)(long double __x, long double __y) { return islessgreater(__x, __y); }
S    inline bool (isnan)(long double __x) { return isnan(__x); }
S    inline bool (isnormal)(long double __x) { return isnormal(__x); }
S    inline bool (isunordered)(long double __x, long double __y) { return isunordered(__x, __y); }
S#endif
S
S#undef fpclassify
S#undef isfinite
S#undef isgreater
S#undef isgreaterequal
S#undef isinf
S#undef isless
S#undef islessequal
S#undef islessgreater
S#undef isnan
S#undef isnormal
S#undef isunordered
S
S#endif
S
S  }
N#endif
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __MATH_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__MATH_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::__use_accurate_range_reduction;
S    #ifndef __ARMCOMPILER_LIBCXX
S      using ::std::abs;
S    #endif
S    using ::std::acos;
S    using ::std::asin;
S    using ::std::atan2;
S    using ::std::atan;
S    using ::std::ceil;
S    using ::std::cos;
S    using ::std::cosh;
S    using ::std::exp;
S    using ::std::fabs;
S    using ::std::floor;
S    using ::std::fmod;
S    using ::std::frexp;
S    using ::std::ldexp;
S    using ::std::log10;
S    using ::std::log;
S    using ::std::modf;
S    using ::std::pow;
S    using ::std::sin;
S    using ::std::sinh;
S    using ::std::sqrt;
S    using ::std::_sqrt;
S    using ::std::_sqrtf;
S    using ::std::tan;
S    using ::std::tanh;
S    using ::std::_fabsf;
S    /* C99 float and long double versions in already-C89-reserved namespace */
S    using ::std::acosf;
S    using ::std::acosl;
S    using ::std::asinf;
S    using ::std::asinl;
S    using ::std::atan2f;
S    using ::std::atan2l;
S    using ::std::atanf;
S    using ::std::atanl;
S    using ::std::ceilf;
S    using ::std::ceill;
S    using ::std::cosf;
S    using ::std::coshf;
S    using ::std::coshl;
S    using ::std::cosl;
S    using ::std::expf;
S    using ::std::expl;
S    using ::std::fabsf;
S    using ::std::fabsl;
S    using ::std::floorf;
S    using ::std::floorl;
S    using ::std::fmodf;
S    using ::std::fmodl;
S    using ::std::frexpf;
S    using ::std::frexpl;
S    using ::std::ldexpf;
S    using ::std::ldexpl;
S    using ::std::log10f;
S    using ::std::log10l;
S    using ::std::logf;
S    using ::std::logl;
S    using ::std::modff;
S    using ::std::modfl;
S    using ::std::powf;
S    using ::std::powl;
S    using ::std::sinf;
S    using ::std::sinhf;
S    using ::std::sinhl;
S    using ::std::sinl;
S    using ::std::sqrtf;
S    using ::std::sqrtl;
S    using ::std::tanf;
S    using ::std::tanhf;
S    using ::std::tanhl;
S    using ::std::tanl;
S    #if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S      /* C99 additions which for historical reasons appear in non-strict mode */
S      using ::std::acosh;
S      using ::std::asinh;
S      using ::std::atanh;
S      using ::std::cbrt;
S      using ::std::copysign;
S      using ::std::copysignf;
S      using ::std::erf;
S      using ::std::erfc;
S      using ::std::expm1;
S      using ::std::hypot;
S      using ::std::ilogb;
S      using ::std::ilogbf;
S      using ::std::ilogbl;
S      using ::std::lgamma;
S      using ::std::log1p;
S      using ::std::logb;
S      using ::std::logbf;
S      using ::std::logbl;
S      using ::std::nextafter;
S      using ::std::nextafterf;
S      using ::std::nextafterl;
S      using ::std::nexttoward;
S      using ::std::nexttowardf;
S      using ::std::nexttowardl;
S      using ::std::remainder;
S      using ::std::rint;
S      using ::std::scalbln;
S      using ::std::scalblnf;
S      using ::std::scalblnl;
S      using ::std::scalbn;
S      using ::std::scalbnf;
S      using ::std::scalbnl;
S      using ::std::math_errhandling;
S      using ::std::acoshf;
S      using ::std::acoshl;
S      using ::std::asinhf;
S      using ::std::asinhl;
S      using ::std::atanhf;
S      using ::std::atanhl;
S      using ::std::copysignl;
S      using ::std::cbrtf;
S      using ::std::cbrtl;
S      using ::std::erff;
S      using ::std::erfl;
S      using ::std::erfcf;
S      using ::std::erfcl;
S      using ::std::expm1f;
S      using ::std::expm1l;
S      using ::std::log1pf;
S      using ::std::log1pl;
S      using ::std::hypotf;
S      using ::std::hypotl;
S      using ::std::lgammaf;
S      using ::std::lgammal;
S      using ::std::remainderf;
S      using ::std::remainderl;
S      using ::std::rintf;
S      using ::std::rintl;
S      /* New in C99. */
S      using ::std::float_t;
S      using ::std::double_t;
S    #endif
S    #if (defined(__clang__) && !defined(__STRICT_ANSI)) || defined(__USE_C99_MATH)
S      /* Functions new in C99. */
S      using ::std::exp2;
S      using ::std::exp2f;
S      using ::std::exp2l;
S      using ::std::fdim;
S      using ::std::fdimf;
S      using ::std::fdiml;
S      using ::std::fma;
S      using ::std::fmaf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::fmal;
S#endif
S      using ::std::fmax;
S      using ::std::fmaxf;
S      using ::std::fmaxl;
S      using ::std::fmin;
S      using ::std::fminf;
S      using ::std::fminl;
S      using ::std::log2;
S      using ::std::log2f;
S      using ::std::log2l;
S      using ::std::lrint;
S      using ::std::lrintf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::lrintl;
S#endif
S      using ::std::llrint;
S      using ::std::llrintf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::llrintl;
S#endif
S      using ::std::lround;
S      using ::std::lroundf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::lroundl;
S#endif
S      using ::std::llround;
S      using ::std::llroundf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::llroundl;
S#endif
S      using ::std::nan;
S      using ::std::nanf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::nanl;
S#endif
S      using ::std::nearbyint;
S      using ::std::nearbyintf;
S      using ::std::nearbyintl;
S      using ::std::remquo;
S      using ::std::remquof;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::remquol;
S#endif
S      using ::std::round;
S      using ::std::roundf;
S      using ::std::roundl;
S      using ::std::tgamma;
S      using ::std::tgammaf;
S      using ::std::tgammal;
S      using ::std::trunc;
S      using ::std::truncf;
S      using ::std::truncl;
S    #endif
S
S    #if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S      using ::std::fpclassify;
S      using ::std::isfinite;
S      using ::std::isgreater;
S      using ::std::isgreaterequal;
S      using ::std::isinf;
S      using ::std::isless;
S      using ::std::islessequal;
S      using ::std::islessgreater;
S      using ::std::isnan;
S      using ::std::isnormal;
S      using ::std::isunordered;
S    #endif
N  #endif
N
N#undef __LONGLONG
N
N#endif /* __math_h */
N
N/* end of math.h */
L 305 ".\inc\arm_math.h" 2
N#ifdef	__cplusplus
Sextern "C"
S{
N#endif
N
N
N  /**
N   * @brief Macros required for reciprocal calculation in Normalized LMS
N   */
N
N#define DELTA_Q31 			(0x100)
N#define DELTA_Q15 			0x5
N#define INDEX_MASK 			0x0000003F
N#ifndef PI
N#define PI					3.14159265358979f
N#endif
N
N  /**
N   * @brief Macros required for SINE and COSINE Fast math approximations
N   */
N
N#define FAST_MATH_TABLE_SIZE  512
N#define FAST_MATH_Q31_SHIFT   (32 - 10)
N#define FAST_MATH_Q15_SHIFT   (16 - 10)
N#define CONTROLLER_Q31_SHIFT  (32 - 9)
N#define TABLE_SIZE  256
N#define TABLE_SPACING_Q31	   0x400000
N#define TABLE_SPACING_Q15	   0x80
N
N  /**
N   * @brief Macros required for SINE and COSINE Controller functions
N   */
N  /* 1.31(q31) Fixed value of 2/360 */
N  /* -1 to +1 is divided into 360 values so total spacing is (2/360) */
N#define INPUT_SPACING			0xB60B61
N
N  /**
N   * @brief Macro for Unaligned Support
N   */
N#ifndef UNALIGNED_SUPPORT_DISABLE
N    #define ALIGN4
N#else
S  #if defined  (__GNUC__)
S    #define ALIGN4 __attribute__((aligned(4)))
S  #else
S    #define ALIGN4 __align(4)
S  #endif
N#endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE	*/
N
N  /**
N   * @brief Error status returned by some functions in the library.
N   */
N
N  typedef enum
N  {
N    ARM_MATH_SUCCESS = 0,                /**< No error */
N    ARM_MATH_ARGUMENT_ERROR = -1,        /**< One or more arguments are incorrect */
N    ARM_MATH_LENGTH_ERROR = -2,          /**< Length of data buffer is incorrect */
N    ARM_MATH_SIZE_MISMATCH = -3,         /**< Size of matrices is not compatible with the operation. */
N    ARM_MATH_NANINF = -4,                /**< Not-a-number (NaN) or infinity is generated */
N    ARM_MATH_SINGULAR = -5,              /**< Generated by matrix inversion if the input matrix is singular and cannot be inverted. */
N    ARM_MATH_TEST_FAILURE = -6           /**< Test Failed  */
N  } arm_status;
N
N  /**
N   * @brief 8-bit fractional data type in 1.7 format.
N   */
N  typedef int8_t q7_t;
N
N  /**
N   * @brief 16-bit fractional data type in 1.15 format.
N   */
N  typedef int16_t q15_t;
N
N  /**
N   * @brief 32-bit fractional data type in 1.31 format.
N   */
N  typedef int32_t q31_t;
N
N  /**
N   * @brief 64-bit fractional data type in 1.63 format.
N   */
N  typedef int64_t q63_t;
N
N  /**
N   * @brief 32-bit floating-point type definition.
N   */
N  typedef float float32_t;
N
N  /**
N   * @brief 64-bit floating-point type definition.
N   */
N  typedef double float64_t;
N
N  /**
N   * @brief definition to read/write two 16 bit values.
N   */
N#if defined __CC_ARM
X#if 1L
N#define __SIMD32_TYPE int32_t __packed
N#define CMSIS_UNUSED __attribute__((unused))
N#elif defined __ICCARM__
S#define CMSIS_UNUSED
S#define __SIMD32_TYPE int32_t __packed
S#elif defined __GNUC__
S#define __SIMD32_TYPE int32_t
S#define CMSIS_UNUSED __attribute__((unused))
S#elif defined __CSMC__			/* Cosmic */
S#define CMSIS_UNUSED
S#define __SIMD32_TYPE int32_t
S#else
S#error Unknown compiler
N#endif
N
N#define __SIMD32(addr)  (*(__SIMD32_TYPE **) & (addr))
N#define __SIMD32_CONST(addr)  ((__SIMD32_TYPE *)(addr))
N
N#define _SIMD32_OFFSET(addr)  (*(__SIMD32_TYPE *)  (addr))
N
N#define __SIMD64(addr)  (*(int64_t **) & (addr))
N
N#if defined (ARM_MATH_CM3) || defined (ARM_MATH_CM0_FAMILY)
X#if 0L || 0L
S  /**
S   * @brief definition to pack two 16 bit values.
S   */
S#define __PKHBT(ARG1, ARG2, ARG3)      ( (((int32_t)(ARG1) <<  0) & (int32_t)0x0000FFFF) | \
S                                         (((int32_t)(ARG2) << ARG3) & (int32_t)0xFFFF0000)  )
X#define __PKHBT(ARG1, ARG2, ARG3)      ( (((int32_t)(ARG1) <<  0) & (int32_t)0x0000FFFF) |                                          (((int32_t)(ARG2) << ARG3) & (int32_t)0xFFFF0000)  )
S#define __PKHTB(ARG1, ARG2, ARG3)      ( (((int32_t)(ARG1) <<  0) & (int32_t)0xFFFF0000) | \
S                                         (((int32_t)(ARG2) >> ARG3) & (int32_t)0x0000FFFF)  )
X#define __PKHTB(ARG1, ARG2, ARG3)      ( (((int32_t)(ARG1) <<  0) & (int32_t)0xFFFF0000) |                                          (((int32_t)(ARG2) >> ARG3) & (int32_t)0x0000FFFF)  )
S
N#endif
N
N
N   /**
N   * @brief definition to pack four 8 bit values.
N   */
N#ifndef ARM_MATH_BIG_ENDIAN
N
N#define __PACKq7(v0,v1,v2,v3) ( (((int32_t)(v0) <<  0) & (int32_t)0x000000FF) |	\
N                                (((int32_t)(v1) <<  8) & (int32_t)0x0000FF00) |	\
N							    (((int32_t)(v2) << 16) & (int32_t)0x00FF0000) |	\
N							    (((int32_t)(v3) << 24) & (int32_t)0xFF000000)  )
X#define __PACKq7(v0,v1,v2,v3) ( (((int32_t)(v0) <<  0) & (int32_t)0x000000FF) |	                                (((int32_t)(v1) <<  8) & (int32_t)0x0000FF00) |								    (((int32_t)(v2) << 16) & (int32_t)0x00FF0000) |								    (((int32_t)(v3) << 24) & (int32_t)0xFF000000)  )
N#else
S
S#define __PACKq7(v0,v1,v2,v3) ( (((int32_t)(v3) <<  0) & (int32_t)0x000000FF) |	\
S                                (((int32_t)(v2) <<  8) & (int32_t)0x0000FF00) |	\
S							    (((int32_t)(v1) << 16) & (int32_t)0x00FF0000) |	\
S							    (((int32_t)(v0) << 24) & (int32_t)0xFF000000)  )
X#define __PACKq7(v0,v1,v2,v3) ( (((int32_t)(v3) <<  0) & (int32_t)0x000000FF) |	                                (((int32_t)(v2) <<  8) & (int32_t)0x0000FF00) |								    (((int32_t)(v1) << 16) & (int32_t)0x00FF0000) |								    (((int32_t)(v0) << 24) & (int32_t)0xFF000000)  )
S
N#endif
N
N
N  /**
N   * @brief Clips Q63 to Q31 values.
N   */
N  static __INLINE q31_t clip_q63_to_q31(
X  static __inline q31_t clip_q63_to_q31(
N  q63_t x)
N  {
N    return ((q31_t) (x >> 32) != ((q31_t) x >> 31)) ?
N      ((0x7FFFFFFF ^ ((q31_t) (x >> 63)))) : (q31_t) x;
N  }
N
N  /**
N   * @brief Clips Q63 to Q15 values.
N   */
N  static __INLINE q15_t clip_q63_to_q15(
X  static __inline q15_t clip_q63_to_q15(
N  q63_t x)
N  {
N    return ((q31_t) (x >> 32) != ((q31_t) x >> 31)) ?
N      ((0x7FFF ^ ((q15_t) (x >> 63)))) : (q15_t) (x >> 15);
N  }
N
N  /**
N   * @brief Clips Q31 to Q7 values.
N   */
N  static __INLINE q7_t clip_q31_to_q7(
X  static __inline q7_t clip_q31_to_q7(
N  q31_t x)
N  {
N    return ((q31_t) (x >> 24) != ((q31_t) x >> 23)) ?
N      ((0x7F ^ ((q7_t) (x >> 31)))) : (q7_t) x;
N  }
N
N  /**
N   * @brief Clips Q31 to Q15 values.
N   */
N  static __INLINE q15_t clip_q31_to_q15(
X  static __inline q15_t clip_q31_to_q15(
N  q31_t x)
N  {
N    return ((q31_t) (x >> 16) != ((q31_t) x >> 15)) ?
N      ((0x7FFF ^ ((q15_t) (x >> 31)))) : (q15_t) x;
N  }
N
N  /**
N   * @brief Multiplies 32 X 64 and returns 32 bit result in 2.30 format.
N   */
N
N  static __INLINE q63_t mult32x64(
X  static __inline q63_t mult32x64(
N  q63_t x,
N  q31_t y)
N  {
N    return ((((q63_t) (x & 0x00000000FFFFFFFF) * y) >> 32) +
N            (((q63_t) (x >> 32) * y)));
N  }
N
N
N#if defined (ARM_MATH_CM0_FAMILY) && defined ( __CC_ARM   )
X#if 0L && 1L
S#define __CLZ __clz
N#endif
N
N#if defined (ARM_MATH_CM0_FAMILY) && ((defined (__ICCARM__)) ||(defined (__GNUC__)) || defined (__TASKING__) )
X#if 0L && ((0L) ||(0L) || 0L )
S
S  static __INLINE uint32_t __CLZ(
S  q31_t data);
S
S
S  static __INLINE uint32_t __CLZ(
S  q31_t data)
S  {
S    uint32_t count = 0;
S    uint32_t mask = 0x80000000;
S
S    while((data & mask) == 0)
S    {
S      count += 1u;
S      mask = mask >> 1u;
S    }
S
S    return (count);
S
S  }
S
N#endif
N
N  /**
N   * @brief Function to Calculates 1/in (reciprocal) value of Q31 Data type.
N   */
N
N  static __INLINE uint32_t arm_recip_q31(
X  static __inline uint32_t arm_recip_q31(
N  q31_t in,
N  q31_t * dst,
N  q31_t * pRecipTable)
N  {
N
N    uint32_t out, tempVal;
N    uint32_t index, i;
N    uint32_t signBits;
N
N    if(in > 0)
N    {
N      signBits = __CLZ(in) - 1;
X      signBits = __clz(in) - 1;
N    }
N    else
N    {
N      signBits = __CLZ(-in) - 1;
X      signBits = __clz(-in) - 1;
N    }
N
N    /* Convert input sample to 1.31 format */
N    in = in << signBits;
N
N    /* calculation of index for initial approximated Val */
N    index = (uint32_t) (in >> 24u);
N    index = (index & INDEX_MASK);
X    index = (index & 0x0000003F);
N
N    /* 1.31 with exp 1 */
N    out = pRecipTable[index];
N
N    /* calculation of reciprocal value */
N    /* running approximation for two iterations */
N    for (i = 0u; i < 2u; i++)
N    {
N      tempVal = (q31_t) (((q63_t) in * out) >> 31u);
N      tempVal = 0x7FFFFFFF - tempVal;
N      /*      1.31 with exp 1 */
N      //out = (q31_t) (((q63_t) out * tempVal) >> 30u);
N      out = (q31_t) clip_q63_to_q31(((q63_t) out * tempVal) >> 30u);
N    }
N
N    /* write output */
N    *dst = out;
N
N    /* return num of signbits of out = 1/in value */
N    return (signBits + 1u);
N
N  }
N
N  /**
N   * @brief Function to Calculates 1/in (reciprocal) value of Q15 Data type.
N   */
N  static __INLINE uint32_t arm_recip_q15(
X  static __inline uint32_t arm_recip_q15(
N  q15_t in,
N  q15_t * dst,
N  q15_t * pRecipTable)
N  {
N
N    uint32_t out = 0, tempVal = 0;
N    uint32_t index = 0, i = 0;
N    uint32_t signBits = 0;
N
N    if(in > 0)
N    {
N      signBits = __CLZ(in) - 17;
X      signBits = __clz(in) - 17;
N    }
N    else
N    {
N      signBits = __CLZ(-in) - 17;
X      signBits = __clz(-in) - 17;
N    }
N
N    /* Convert input sample to 1.15 format */
N    in = in << signBits;
N
N    /* calculation of index for initial approximated Val */
N    index = in >> 8;
N    index = (index & INDEX_MASK);
X    index = (index & 0x0000003F);
N
N    /*      1.15 with exp 1  */
N    out = pRecipTable[index];
N
N    /* calculation of reciprocal value */
N    /* running approximation for two iterations */
N    for (i = 0; i < 2; i++)
N    {
N      tempVal = (q15_t) (((q31_t) in * out) >> 15);
N      tempVal = 0x7FFF - tempVal;
N      /*      1.15 with exp 1 */
N      out = (q15_t) (((q31_t) out * tempVal) >> 14);
N    }
N
N    /* write output */
N    *dst = out;
N
N    /* return num of signbits of out = 1/in value */
N    return (signBits + 1);
N
N  }
N
N
N  /*
N   * @brief C custom defined intrinisic function for only M0 processors
N   */
N#if defined(ARM_MATH_CM0_FAMILY)
X#if 0L
S
S  static __INLINE q31_t __SSAT(
S  q31_t x,
S  uint32_t y)
S  {
S    int32_t posMax, negMin;
S    uint32_t i;
S
S    posMax = 1;
S    for (i = 0; i < (y - 1); i++)
S    {
S      posMax = posMax * 2;
S    }
S
S    if(x > 0)
S    {
S      posMax = (posMax - 1);
S
S      if(x > posMax)
S      {
S        x = posMax;
S      }
S    }
S    else
S    {
S      negMin = -posMax;
S
S      if(x < negMin)
S      {
S        x = negMin;
S      }
S    }
S    return (x);
S
S
S  }
S
N#endif /* end of ARM_MATH_CM0_FAMILY */
N
N
N
N  /*
N   * @brief C custom defined intrinsic function for M3 and M0 processors
N   */
N#if defined (ARM_MATH_CM3) || defined (ARM_MATH_CM0_FAMILY)
X#if 0L || 0L
S
S  /*
S   * @brief C custom defined QADD8 for M3 and M0 processors
S   */
S  static __INLINE q31_t __QADD8(
S  q31_t x,
S  q31_t y)
S  {
S
S    q31_t sum;
S    q7_t r, s, t, u;
S
S    r = (q7_t) x;
S    s = (q7_t) y;
S
S    r = __SSAT((q31_t) (r + s), 8);
S    s = __SSAT(((q31_t) (((x << 16) >> 24) + ((y << 16) >> 24))), 8);
S    t = __SSAT(((q31_t) (((x << 8) >> 24) + ((y << 8) >> 24))), 8);
S    u = __SSAT(((q31_t) ((x >> 24) + (y >> 24))), 8);
S
S    sum =
S      (((q31_t) u << 24) & 0xFF000000) | (((q31_t) t << 16) & 0x00FF0000) |
S      (((q31_t) s << 8) & 0x0000FF00) | (r & 0x000000FF);
S
S    return sum;
S
S  }
S
S  /*
S   * @brief C custom defined QSUB8 for M3 and M0 processors
S   */
S  static __INLINE q31_t __QSUB8(
S  q31_t x,
S  q31_t y)
S  {
S
S    q31_t sum;
S    q31_t r, s, t, u;
S
S    r = (q7_t) x;
S    s = (q7_t) y;
S
S    r = __SSAT((r - s), 8);
S    s = __SSAT(((q31_t) (((x << 16) >> 24) - ((y << 16) >> 24))), 8) << 8;
S    t = __SSAT(((q31_t) (((x << 8) >> 24) - ((y << 8) >> 24))), 8) << 16;
S    u = __SSAT(((q31_t) ((x >> 24) - (y >> 24))), 8) << 24;
S
S    sum =
S      (u & 0xFF000000) | (t & 0x00FF0000) | (s & 0x0000FF00) | (r &
S                                                                0x000000FF);
S
S    return sum;
S  }
S
S  /*
S   * @brief C custom defined QADD16 for M3 and M0 processors
S   */
S
S  /*
S   * @brief C custom defined QADD16 for M3 and M0 processors
S   */
S  static __INLINE q31_t __QADD16(
S  q31_t x,
S  q31_t y)
S  {
S
S    q31_t sum;
S    q31_t r, s;
S
S    r = (q15_t) x;
S    s = (q15_t) y;
S
S    r = __SSAT(r + s, 16);
S    s = __SSAT(((q31_t) ((x >> 16) + (y >> 16))), 16) << 16;
S
S    sum = (s & 0xFFFF0000) | (r & 0x0000FFFF);
S
S    return sum;
S
S  }
S
S  /*
S   * @brief C custom defined SHADD16 for M3 and M0 processors
S   */
S  static __INLINE q31_t __SHADD16(
S  q31_t x,
S  q31_t y)
S  {
S
S    q31_t sum;
S    q31_t r, s;
S
S    r = (q15_t) x;
S    s = (q15_t) y;
S
S    r = ((r >> 1) + (s >> 1));
S    s = ((q31_t) ((x >> 17) + (y >> 17))) << 16;
S
S    sum = (s & 0xFFFF0000) | (r & 0x0000FFFF);
S
S    return sum;
S
S  }
S
S  /*
S   * @brief C custom defined QSUB16 for M3 and M0 processors
S   */
S  static __INLINE q31_t __QSUB16(
S  q31_t x,
S  q31_t y)
S  {
S
S    q31_t sum;
S    q31_t r, s;
S
S    r = (q15_t) x;
S    s = (q15_t) y;
S
S    r = __SSAT(r - s, 16);
S    s = __SSAT(((q31_t) ((x >> 16) - (y >> 16))), 16) << 16;
S
S    sum = (s & 0xFFFF0000) | (r & 0x0000FFFF);
S
S    return sum;
S  }
S
S  /*
S   * @brief C custom defined SHSUB16 for M3 and M0 processors
S   */
S  static __INLINE q31_t __SHSUB16(
S  q31_t x,
S  q31_t y)
S  {
S
S    q31_t diff;
S    q31_t r, s;
S
S    r = (q15_t) x;
S    s = (q15_t) y;
S
S    r = ((r >> 1) - (s >> 1));
S    s = (((x >> 17) - (y >> 17)) << 16);
S
S    diff = (s & 0xFFFF0000) | (r & 0x0000FFFF);
S
S    return diff;
S  }
S
S  /*
S   * @brief C custom defined QASX for M3 and M0 processors
S   */
S  static __INLINE q31_t __QASX(
S  q31_t x,
S  q31_t y)
S  {
S
S    q31_t sum = 0;
S
S    sum =
S      ((sum +
S        clip_q31_to_q15((q31_t) ((q15_t) (x >> 16) + (q15_t) y))) << 16) +
S      clip_q31_to_q15((q31_t) ((q15_t) x - (q15_t) (y >> 16)));
S
S    return sum;
S  }
S
S  /*
S   * @brief C custom defined SHASX for M3 and M0 processors
S   */
S  static __INLINE q31_t __SHASX(
S  q31_t x,
S  q31_t y)
S  {
S
S    q31_t sum;
S    q31_t r, s;
S
S    r = (q15_t) x;
S    s = (q15_t) y;
S
S    r = ((r >> 1) - (y >> 17));
S    s = (((x >> 17) + (s >> 1)) << 16);
S
S    sum = (s & 0xFFFF0000) | (r & 0x0000FFFF);
S
S    return sum;
S  }
S
S
S  /*
S   * @brief C custom defined QSAX for M3 and M0 processors
S   */
S  static __INLINE q31_t __QSAX(
S  q31_t x,
S  q31_t y)
S  {
S
S    q31_t sum = 0;
S
S    sum =
S      ((sum +
S        clip_q31_to_q15((q31_t) ((q15_t) (x >> 16) - (q15_t) y))) << 16) +
S      clip_q31_to_q15((q31_t) ((q15_t) x + (q15_t) (y >> 16)));
S
S    return sum;
S  }
S
S  /*
S   * @brief C custom defined SHSAX for M3 and M0 processors
S   */
S  static __INLINE q31_t __SHSAX(
S  q31_t x,
S  q31_t y)
S  {
S
S    q31_t sum;
S    q31_t r, s;
S
S    r = (q15_t) x;
S    s = (q15_t) y;
S
S    r = ((r >> 1) + (y >> 17));
S    s = (((x >> 17) - (s >> 1)) << 16);
S
S    sum = (s & 0xFFFF0000) | (r & 0x0000FFFF);
S
S    return sum;
S  }
S
S  /*
S   * @brief C custom defined SMUSDX for M3 and M0 processors
S   */
S  static __INLINE q31_t __SMUSDX(
S  q31_t x,
S  q31_t y)
S  {
S
S    return ((q31_t) (((q15_t) x * (q15_t) (y >> 16)) -
S                     ((q15_t) (x >> 16) * (q15_t) y)));
S  }
S
S  /*
S   * @brief C custom defined SMUADX for M3 and M0 processors
S   */
S  static __INLINE q31_t __SMUADX(
S  q31_t x,
S  q31_t y)
S  {
S
S    return ((q31_t) (((q15_t) x * (q15_t) (y >> 16)) +
S                     ((q15_t) (x >> 16) * (q15_t) y)));
S  }
S
S  /*
S   * @brief C custom defined QADD for M3 and M0 processors
S   */
S  static __INLINE q31_t __QADD(
S  q31_t x,
S  q31_t y)
S  {
S    return clip_q63_to_q31((q63_t) x + y);
S  }
S
S  /*
S   * @brief C custom defined QSUB for M3 and M0 processors
S   */
S  static __INLINE q31_t __QSUB(
S  q31_t x,
S  q31_t y)
S  {
S    return clip_q63_to_q31((q63_t) x - y);
S  }
S
S  /*
S   * @brief C custom defined SMLAD for M3 and M0 processors
S   */
S  static __INLINE q31_t __SMLAD(
S  q31_t x,
S  q31_t y,
S  q31_t sum)
S  {
S
S    return (sum + ((q15_t) (x >> 16) * (q15_t) (y >> 16)) +
S            ((q15_t) x * (q15_t) y));
S  }
S
S  /*
S   * @brief C custom defined SMLADX for M3 and M0 processors
S   */
S  static __INLINE q31_t __SMLADX(
S  q31_t x,
S  q31_t y,
S  q31_t sum)
S  {
S
S    return (sum + ((q15_t) (x >> 16) * (q15_t) (y)) +
S            ((q15_t) x * (q15_t) (y >> 16)));
S  }
S
S  /*
S   * @brief C custom defined SMLSDX for M3 and M0 processors
S   */
S  static __INLINE q31_t __SMLSDX(
S  q31_t x,
S  q31_t y,
S  q31_t sum)
S  {
S
S    return (sum - ((q15_t) (x >> 16) * (q15_t) (y)) +
S            ((q15_t) x * (q15_t) (y >> 16)));
S  }
S
S  /*
S   * @brief C custom defined SMLALD for M3 and M0 processors
S   */
S  static __INLINE q63_t __SMLALD(
S  q31_t x,
S  q31_t y,
S  q63_t sum)
S  {
S
S    return (sum + ((q15_t) (x >> 16) * (q15_t) (y >> 16)) +
S            ((q15_t) x * (q15_t) y));
S  }
S
S  /*
S   * @brief C custom defined SMLALDX for M3 and M0 processors
S   */
S  static __INLINE q63_t __SMLALDX(
S  q31_t x,
S  q31_t y,
S  q63_t sum)
S  {
S
S    return (sum + ((q15_t) (x >> 16) * (q15_t) y)) +
S      ((q15_t) x * (q15_t) (y >> 16));
S  }
S
S  /*
S   * @brief C custom defined SMUAD for M3 and M0 processors
S   */
S  static __INLINE q31_t __SMUAD(
S  q31_t x,
S  q31_t y)
S  {
S
S    return (((x >> 16) * (y >> 16)) +
S            (((x << 16) >> 16) * ((y << 16) >> 16)));
S  }
S
S  /*
S   * @brief C custom defined SMUSD for M3 and M0 processors
S   */
S  static __INLINE q31_t __SMUSD(
S  q31_t x,
S  q31_t y)
S  {
S
S    return (-((x >> 16) * (y >> 16)) +
S            (((x << 16) >> 16) * ((y << 16) >> 16)));
S  }
S
S
S  /*
S   * @brief C custom defined SXTB16 for M3 and M0 processors
S   */
S  static __INLINE q31_t __SXTB16(
S  q31_t x)
S  {
S
S    return ((((x << 24) >> 24) & 0x0000FFFF) |
S            (((x << 8) >> 8) & 0xFFFF0000));
S  }
S
S
N#endif /* defined (ARM_MATH_CM3) || defined (ARM_MATH_CM0_FAMILY) */
N
N
N  /**
N   * @brief Instance structure for the Q7 FIR filter.
N   */
N  typedef struct
N  {
N    uint16_t numTaps;        /**< number of filter coefficients in the filter. */
N    q7_t *pState;            /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
N    q7_t *pCoeffs;           /**< points to the coefficient array. The array is of length numTaps.*/
N  } arm_fir_instance_q7;
N
N  /**
N   * @brief Instance structure for the Q15 FIR filter.
N   */
N  typedef struct
N  {
N    uint16_t numTaps;         /**< number of filter coefficients in the filter. */
N    q15_t *pState;            /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
N    q15_t *pCoeffs;           /**< points to the coefficient array. The array is of length numTaps.*/
N  } arm_fir_instance_q15;
N
N  /**
N   * @brief Instance structure for the Q31 FIR filter.
N   */
N  typedef struct
N  {
N    uint16_t numTaps;         /**< number of filter coefficients in the filter. */
N    q31_t *pState;            /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
N    q31_t *pCoeffs;           /**< points to the coefficient array. The array is of length numTaps. */
N  } arm_fir_instance_q31;
N
N  /**
N   * @brief Instance structure for the floating-point FIR filter.
N   */
N  typedef struct
N  {
N    uint16_t numTaps;     /**< number of filter coefficients in the filter. */
N    float32_t *pState;    /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
N    float32_t *pCoeffs;   /**< points to the coefficient array. The array is of length numTaps. */
N  } arm_fir_instance_f32;
N
N
N  /**
N   * @brief Processing function for the Q7 FIR filter.
N   * @param[in] *S points to an instance of the Q7 FIR filter structure.
N   * @param[in] *pSrc points to the block of input data.
N   * @param[out] *pDst points to the block of output data.
N   * @param[in] blockSize number of samples to process.
N   * @return none.
N   */
N  void arm_fir_q7(
N  const arm_fir_instance_q7 * S,
N  q7_t * pSrc,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Initialization function for the Q7 FIR filter.
N   * @param[in,out] *S points to an instance of the Q7 FIR structure.
N   * @param[in] numTaps  Number of filter coefficients in the filter.
N   * @param[in] *pCoeffs points to the filter coefficients.
N   * @param[in] *pState points to the state buffer.
N   * @param[in] blockSize number of samples that are processed.
N   * @return none
N   */
N  void arm_fir_init_q7(
N  arm_fir_instance_q7 * S,
N  uint16_t numTaps,
N  q7_t * pCoeffs,
N  q7_t * pState,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Processing function for the Q15 FIR filter.
N   * @param[in] *S points to an instance of the Q15 FIR structure.
N   * @param[in] *pSrc points to the block of input data.
N   * @param[out] *pDst points to the block of output data.
N   * @param[in] blockSize number of samples to process.
N   * @return none.
N   */
N  void arm_fir_q15(
N  const arm_fir_instance_q15 * S,
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Processing function for the fast Q15 FIR filter for Cortex-M3 and Cortex-M4.
N   * @param[in] *S points to an instance of the Q15 FIR filter structure.
N   * @param[in] *pSrc points to the block of input data.
N   * @param[out] *pDst points to the block of output data.
N   * @param[in] blockSize number of samples to process.
N   * @return none.
N   */
N  void arm_fir_fast_q15(
N  const arm_fir_instance_q15 * S,
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Initialization function for the Q15 FIR filter.
N   * @param[in,out] *S points to an instance of the Q15 FIR filter structure.
N   * @param[in] numTaps  Number of filter coefficients in the filter. Must be even and greater than or equal to 4.
N   * @param[in] *pCoeffs points to the filter coefficients.
N   * @param[in] *pState points to the state buffer.
N   * @param[in] blockSize number of samples that are processed at a time.
N   * @return The function returns ARM_MATH_SUCCESS if initialization was successful or ARM_MATH_ARGUMENT_ERROR if
N   * <code>numTaps</code> is not a supported value.
N   */
N
N  arm_status arm_fir_init_q15(
N  arm_fir_instance_q15 * S,
N  uint16_t numTaps,
N  q15_t * pCoeffs,
N  q15_t * pState,
N  uint32_t blockSize);
N
N  /**
N   * @brief Processing function for the Q31 FIR filter.
N   * @param[in] *S points to an instance of the Q31 FIR filter structure.
N   * @param[in] *pSrc points to the block of input data.
N   * @param[out] *pDst points to the block of output data.
N   * @param[in] blockSize number of samples to process.
N   * @return none.
N   */
N  void arm_fir_q31(
N  const arm_fir_instance_q31 * S,
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Processing function for the fast Q31 FIR filter for Cortex-M3 and Cortex-M4.
N   * @param[in] *S points to an instance of the Q31 FIR structure.
N   * @param[in] *pSrc points to the block of input data.
N   * @param[out] *pDst points to the block of output data.
N   * @param[in] blockSize number of samples to process.
N   * @return none.
N   */
N  void arm_fir_fast_q31(
N  const arm_fir_instance_q31 * S,
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Initialization function for the Q31 FIR filter.
N   * @param[in,out] *S points to an instance of the Q31 FIR structure.
N   * @param[in] 	numTaps  Number of filter coefficients in the filter.
N   * @param[in] 	*pCoeffs points to the filter coefficients.
N   * @param[in] 	*pState points to the state buffer.
N   * @param[in] 	blockSize number of samples that are processed at a time.
N   * @return 		none.
N   */
N  void arm_fir_init_q31(
N  arm_fir_instance_q31 * S,
N  uint16_t numTaps,
N  q31_t * pCoeffs,
N  q31_t * pState,
N  uint32_t blockSize);
N
N  /**
N   * @brief Processing function for the floating-point FIR filter.
N   * @param[in] *S points to an instance of the floating-point FIR structure.
N   * @param[in] *pSrc points to the block of input data.
N   * @param[out] *pDst points to the block of output data.
N   * @param[in] blockSize number of samples to process.
N   * @return none.
N   */
N  void arm_fir_f32(
N  const arm_fir_instance_f32 * S,
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Initialization function for the floating-point FIR filter.
N   * @param[in,out] *S points to an instance of the floating-point FIR filter structure.
N   * @param[in] 	numTaps  Number of filter coefficients in the filter.
N   * @param[in] 	*pCoeffs points to the filter coefficients.
N   * @param[in] 	*pState points to the state buffer.
N   * @param[in] 	blockSize number of samples that are processed at a time.
N   * @return    	none.
N   */
N  void arm_fir_init_f32(
N  arm_fir_instance_f32 * S,
N  uint16_t numTaps,
N  float32_t * pCoeffs,
N  float32_t * pState,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Instance structure for the Q15 Biquad cascade filter.
N   */
N  typedef struct
N  {
N    int8_t numStages;         /**< number of 2nd order stages in the filter.  Overall order is 2*numStages. */
N    q15_t *pState;            /**< Points to the array of state coefficients.  The array is of length 4*numStages. */
N    q15_t *pCoeffs;           /**< Points to the array of coefficients.  The array is of length 5*numStages. */
N    int8_t postShift;         /**< Additional shift, in bits, applied to each output sample. */
N
N  } arm_biquad_casd_df1_inst_q15;
N
N
N  /**
N   * @brief Instance structure for the Q31 Biquad cascade filter.
N   */
N  typedef struct
N  {
N    uint32_t numStages;      /**< number of 2nd order stages in the filter.  Overall order is 2*numStages. */
N    q31_t *pState;           /**< Points to the array of state coefficients.  The array is of length 4*numStages. */
N    q31_t *pCoeffs;          /**< Points to the array of coefficients.  The array is of length 5*numStages. */
N    uint8_t postShift;       /**< Additional shift, in bits, applied to each output sample. */
N
N  } arm_biquad_casd_df1_inst_q31;
N
N  /**
N   * @brief Instance structure for the floating-point Biquad cascade filter.
N   */
N  typedef struct
N  {
N    uint32_t numStages;         /**< number of 2nd order stages in the filter.  Overall order is 2*numStages. */
N    float32_t *pState;          /**< Points to the array of state coefficients.  The array is of length 4*numStages. */
N    float32_t *pCoeffs;         /**< Points to the array of coefficients.  The array is of length 5*numStages. */
N
N
N  } arm_biquad_casd_df1_inst_f32;
N
N
N
N  /**
N   * @brief Processing function for the Q15 Biquad cascade filter.
N   * @param[in]  *S points to an instance of the Q15 Biquad cascade structure.
N   * @param[in]  *pSrc points to the block of input data.
N   * @param[out] *pDst points to the block of output data.
N   * @param[in]  blockSize number of samples to process.
N   * @return     none.
N   */
N
N  void arm_biquad_cascade_df1_q15(
N  const arm_biquad_casd_df1_inst_q15 * S,
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Initialization function for the Q15 Biquad cascade filter.
N   * @param[in,out] *S           points to an instance of the Q15 Biquad cascade structure.
N   * @param[in]     numStages    number of 2nd order stages in the filter.
N   * @param[in]     *pCoeffs     points to the filter coefficients.
N   * @param[in]     *pState      points to the state buffer.
N   * @param[in]     postShift    Shift to be applied to the output. Varies according to the coefficients format
N   * @return        none
N   */
N
N  void arm_biquad_cascade_df1_init_q15(
N  arm_biquad_casd_df1_inst_q15 * S,
N  uint8_t numStages,
N  q15_t * pCoeffs,
N  q15_t * pState,
N  int8_t postShift);
N
N
N  /**
N   * @brief Fast but less precise processing function for the Q15 Biquad cascade filter for Cortex-M3 and Cortex-M4.
N   * @param[in]  *S points to an instance of the Q15 Biquad cascade structure.
N   * @param[in]  *pSrc points to the block of input data.
N   * @param[out] *pDst points to the block of output data.
N   * @param[in]  blockSize number of samples to process.
N   * @return     none.
N   */
N
N  void arm_biquad_cascade_df1_fast_q15(
N  const arm_biquad_casd_df1_inst_q15 * S,
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Processing function for the Q31 Biquad cascade filter
N   * @param[in]  *S         points to an instance of the Q31 Biquad cascade structure.
N   * @param[in]  *pSrc      points to the block of input data.
N   * @param[out] *pDst      points to the block of output data.
N   * @param[in]  blockSize  number of samples to process.
N   * @return     none.
N   */
N
N  void arm_biquad_cascade_df1_q31(
N  const arm_biquad_casd_df1_inst_q31 * S,
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Fast but less precise processing function for the Q31 Biquad cascade filter for Cortex-M3 and Cortex-M4.
N   * @param[in]  *S         points to an instance of the Q31 Biquad cascade structure.
N   * @param[in]  *pSrc      points to the block of input data.
N   * @param[out] *pDst      points to the block of output data.
N   * @param[in]  blockSize  number of samples to process.
N   * @return     none.
N   */
N
N  void arm_biquad_cascade_df1_fast_q31(
N  const arm_biquad_casd_df1_inst_q31 * S,
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Initialization function for the Q31 Biquad cascade filter.
N   * @param[in,out] *S           points to an instance of the Q31 Biquad cascade structure.
N   * @param[in]     numStages      number of 2nd order stages in the filter.
N   * @param[in]     *pCoeffs     points to the filter coefficients.
N   * @param[in]     *pState      points to the state buffer.
N   * @param[in]     postShift    Shift to be applied to the output. Varies according to the coefficients format
N   * @return        none
N   */
N
N  void arm_biquad_cascade_df1_init_q31(
N  arm_biquad_casd_df1_inst_q31 * S,
N  uint8_t numStages,
N  q31_t * pCoeffs,
N  q31_t * pState,
N  int8_t postShift);
N
N  /**
N   * @brief Processing function for the floating-point Biquad cascade filter.
N   * @param[in]  *S         points to an instance of the floating-point Biquad cascade structure.
N   * @param[in]  *pSrc      points to the block of input data.
N   * @param[out] *pDst      points to the block of output data.
N   * @param[in]  blockSize  number of samples to process.
N   * @return     none.
N   */
N
N  void arm_biquad_cascade_df1_f32(
N  const arm_biquad_casd_df1_inst_f32 * S,
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Initialization function for the floating-point Biquad cascade filter.
N   * @param[in,out] *S           points to an instance of the floating-point Biquad cascade structure.
N   * @param[in]     numStages    number of 2nd order stages in the filter.
N   * @param[in]     *pCoeffs     points to the filter coefficients.
N   * @param[in]     *pState      points to the state buffer.
N   * @return        none
N   */
N
N  void arm_biquad_cascade_df1_init_f32(
N  arm_biquad_casd_df1_inst_f32 * S,
N  uint8_t numStages,
N  float32_t * pCoeffs,
N  float32_t * pState);
N
N
N  /**
N   * @brief Instance structure for the floating-point matrix structure.
N   */
N
N  typedef struct
N  {
N    uint16_t numRows;     /**< number of rows of the matrix.     */
N    uint16_t numCols;     /**< number of columns of the matrix.  */
N    float32_t *pData;     /**< points to the data of the matrix. */
N  } arm_matrix_instance_f32;
N
N
N  /**
N   * @brief Instance structure for the floating-point matrix structure.
N   */
N
N  typedef struct
N  {
N    uint16_t numRows;     /**< number of rows of the matrix.     */
N    uint16_t numCols;     /**< number of columns of the matrix.  */
N    float64_t *pData;     /**< points to the data of the matrix. */
N  } arm_matrix_instance_f64;
N
N  /**
N   * @brief Instance structure for the Q15 matrix structure.
N   */
N
N  typedef struct
N  {
N    uint16_t numRows;     /**< number of rows of the matrix.     */
N    uint16_t numCols;     /**< number of columns of the matrix.  */
N    q15_t *pData;         /**< points to the data of the matrix. */
N
N  } arm_matrix_instance_q15;
N
N  /**
N   * @brief Instance structure for the Q31 matrix structure.
N   */
N
N  typedef struct
N  {
N    uint16_t numRows;     /**< number of rows of the matrix.     */
N    uint16_t numCols;     /**< number of columns of the matrix.  */
N    q31_t *pData;         /**< points to the data of the matrix. */
N
N  } arm_matrix_instance_q31;
N
N
N
N  /**
N   * @brief Floating-point matrix addition.
N   * @param[in]       *pSrcA points to the first input matrix structure
N   * @param[in]       *pSrcB points to the second input matrix structure
N   * @param[out]      *pDst points to output matrix structure
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N
N  arm_status arm_mat_add_f32(
N  const arm_matrix_instance_f32 * pSrcA,
N  const arm_matrix_instance_f32 * pSrcB,
N  arm_matrix_instance_f32 * pDst);
N
N  /**
N   * @brief Q15 matrix addition.
N   * @param[in]       *pSrcA points to the first input matrix structure
N   * @param[in]       *pSrcB points to the second input matrix structure
N   * @param[out]      *pDst points to output matrix structure
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N
N  arm_status arm_mat_add_q15(
N  const arm_matrix_instance_q15 * pSrcA,
N  const arm_matrix_instance_q15 * pSrcB,
N  arm_matrix_instance_q15 * pDst);
N
N  /**
N   * @brief Q31 matrix addition.
N   * @param[in]       *pSrcA points to the first input matrix structure
N   * @param[in]       *pSrcB points to the second input matrix structure
N   * @param[out]      *pDst points to output matrix structure
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N
N  arm_status arm_mat_add_q31(
N  const arm_matrix_instance_q31 * pSrcA,
N  const arm_matrix_instance_q31 * pSrcB,
N  arm_matrix_instance_q31 * pDst);
N
N  /**
N   * @brief Floating-point, complex, matrix multiplication.
N   * @param[in]       *pSrcA points to the first input matrix structure
N   * @param[in]       *pSrcB points to the second input matrix structure
N   * @param[out]      *pDst points to output matrix structure
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N
N  arm_status arm_mat_cmplx_mult_f32(
N  const arm_matrix_instance_f32 * pSrcA,
N  const arm_matrix_instance_f32 * pSrcB,
N  arm_matrix_instance_f32 * pDst);
N
N  /**
N   * @brief Q15, complex,  matrix multiplication.
N   * @param[in]       *pSrcA points to the first input matrix structure
N   * @param[in]       *pSrcB points to the second input matrix structure
N   * @param[out]      *pDst points to output matrix structure
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N
N  arm_status arm_mat_cmplx_mult_q15(
N  const arm_matrix_instance_q15 * pSrcA,
N  const arm_matrix_instance_q15 * pSrcB,
N  arm_matrix_instance_q15 * pDst,
N  q15_t * pScratch);
N
N  /**
N   * @brief Q31, complex, matrix multiplication.
N   * @param[in]       *pSrcA points to the first input matrix structure
N   * @param[in]       *pSrcB points to the second input matrix structure
N   * @param[out]      *pDst points to output matrix structure
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N
N  arm_status arm_mat_cmplx_mult_q31(
N  const arm_matrix_instance_q31 * pSrcA,
N  const arm_matrix_instance_q31 * pSrcB,
N  arm_matrix_instance_q31 * pDst);
N
N
N  /**
N   * @brief Floating-point matrix transpose.
N   * @param[in]  *pSrc points to the input matrix
N   * @param[out] *pDst points to the output matrix
N   * @return 	The function returns either  <code>ARM_MATH_SIZE_MISMATCH</code>
N   * or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N
N  arm_status arm_mat_trans_f32(
N  const arm_matrix_instance_f32 * pSrc,
N  arm_matrix_instance_f32 * pDst);
N
N
N  /**
N   * @brief Q15 matrix transpose.
N   * @param[in]  *pSrc points to the input matrix
N   * @param[out] *pDst points to the output matrix
N   * @return 	The function returns either  <code>ARM_MATH_SIZE_MISMATCH</code>
N   * or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N
N  arm_status arm_mat_trans_q15(
N  const arm_matrix_instance_q15 * pSrc,
N  arm_matrix_instance_q15 * pDst);
N
N  /**
N   * @brief Q31 matrix transpose.
N   * @param[in]  *pSrc points to the input matrix
N   * @param[out] *pDst points to the output matrix
N   * @return 	The function returns either  <code>ARM_MATH_SIZE_MISMATCH</code>
N   * or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N
N  arm_status arm_mat_trans_q31(
N  const arm_matrix_instance_q31 * pSrc,
N  arm_matrix_instance_q31 * pDst);
N
N
N  /**
N   * @brief Floating-point matrix multiplication
N   * @param[in]       *pSrcA points to the first input matrix structure
N   * @param[in]       *pSrcB points to the second input matrix structure
N   * @param[out]      *pDst points to output matrix structure
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N
N  arm_status arm_mat_mult_f32(
N  const arm_matrix_instance_f32 * pSrcA,
N  const arm_matrix_instance_f32 * pSrcB,
N  arm_matrix_instance_f32 * pDst);
N
N  /**
N   * @brief Q15 matrix multiplication
N   * @param[in]       *pSrcA points to the first input matrix structure
N   * @param[in]       *pSrcB points to the second input matrix structure
N   * @param[out]      *pDst points to output matrix structure
N   * @param[in]		 *pState points to the array for storing intermediate results
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N
N  arm_status arm_mat_mult_q15(
N  const arm_matrix_instance_q15 * pSrcA,
N  const arm_matrix_instance_q15 * pSrcB,
N  arm_matrix_instance_q15 * pDst,
N  q15_t * pState);
N
N  /**
N   * @brief Q15 matrix multiplication (fast variant) for Cortex-M3 and Cortex-M4
N   * @param[in]       *pSrcA  points to the first input matrix structure
N   * @param[in]       *pSrcB  points to the second input matrix structure
N   * @param[out]      *pDst   points to output matrix structure
N   * @param[in]		  *pState points to the array for storing intermediate results
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N
N  arm_status arm_mat_mult_fast_q15(
N  const arm_matrix_instance_q15 * pSrcA,
N  const arm_matrix_instance_q15 * pSrcB,
N  arm_matrix_instance_q15 * pDst,
N  q15_t * pState);
N
N  /**
N   * @brief Q31 matrix multiplication
N   * @param[in]       *pSrcA points to the first input matrix structure
N   * @param[in]       *pSrcB points to the second input matrix structure
N   * @param[out]      *pDst points to output matrix structure
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N
N  arm_status arm_mat_mult_q31(
N  const arm_matrix_instance_q31 * pSrcA,
N  const arm_matrix_instance_q31 * pSrcB,
N  arm_matrix_instance_q31 * pDst);
N
N  /**
N   * @brief Q31 matrix multiplication (fast variant) for Cortex-M3 and Cortex-M4
N   * @param[in]       *pSrcA points to the first input matrix structure
N   * @param[in]       *pSrcB points to the second input matrix structure
N   * @param[out]      *pDst points to output matrix structure
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N
N  arm_status arm_mat_mult_fast_q31(
N  const arm_matrix_instance_q31 * pSrcA,
N  const arm_matrix_instance_q31 * pSrcB,
N  arm_matrix_instance_q31 * pDst);
N
N
N  /**
N   * @brief Floating-point matrix subtraction
N   * @param[in]       *pSrcA points to the first input matrix structure
N   * @param[in]       *pSrcB points to the second input matrix structure
N   * @param[out]      *pDst points to output matrix structure
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N
N  arm_status arm_mat_sub_f32(
N  const arm_matrix_instance_f32 * pSrcA,
N  const arm_matrix_instance_f32 * pSrcB,
N  arm_matrix_instance_f32 * pDst);
N
N  /**
N   * @brief Q15 matrix subtraction
N   * @param[in]       *pSrcA points to the first input matrix structure
N   * @param[in]       *pSrcB points to the second input matrix structure
N   * @param[out]      *pDst points to output matrix structure
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N
N  arm_status arm_mat_sub_q15(
N  const arm_matrix_instance_q15 * pSrcA,
N  const arm_matrix_instance_q15 * pSrcB,
N  arm_matrix_instance_q15 * pDst);
N
N  /**
N   * @brief Q31 matrix subtraction
N   * @param[in]       *pSrcA points to the first input matrix structure
N   * @param[in]       *pSrcB points to the second input matrix structure
N   * @param[out]      *pDst points to output matrix structure
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N
N  arm_status arm_mat_sub_q31(
N  const arm_matrix_instance_q31 * pSrcA,
N  const arm_matrix_instance_q31 * pSrcB,
N  arm_matrix_instance_q31 * pDst);
N
N  /**
N   * @brief Floating-point matrix scaling.
N   * @param[in]  *pSrc points to the input matrix
N   * @param[in]  scale scale factor
N   * @param[out] *pDst points to the output matrix
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N
N  arm_status arm_mat_scale_f32(
N  const arm_matrix_instance_f32 * pSrc,
N  float32_t scale,
N  arm_matrix_instance_f32 * pDst);
N
N  /**
N   * @brief Q15 matrix scaling.
N   * @param[in]       *pSrc points to input matrix
N   * @param[in]       scaleFract fractional portion of the scale factor
N   * @param[in]       shift number of bits to shift the result by
N   * @param[out]      *pDst points to output matrix
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N
N  arm_status arm_mat_scale_q15(
N  const arm_matrix_instance_q15 * pSrc,
N  q15_t scaleFract,
N  int32_t shift,
N  arm_matrix_instance_q15 * pDst);
N
N  /**
N   * @brief Q31 matrix scaling.
N   * @param[in]       *pSrc points to input matrix
N   * @param[in]       scaleFract fractional portion of the scale factor
N   * @param[in]       shift number of bits to shift the result by
N   * @param[out]      *pDst points to output matrix structure
N   * @return     The function returns either
N   * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
N   */
N
N  arm_status arm_mat_scale_q31(
N  const arm_matrix_instance_q31 * pSrc,
N  q31_t scaleFract,
N  int32_t shift,
N  arm_matrix_instance_q31 * pDst);
N
N
N  /**
N   * @brief  Q31 matrix initialization.
N   * @param[in,out] *S             points to an instance of the floating-point matrix structure.
N   * @param[in]     nRows          number of rows in the matrix.
N   * @param[in]     nColumns       number of columns in the matrix.
N   * @param[in]     *pData	       points to the matrix data array.
N   * @return        none
N   */
N
N  void arm_mat_init_q31(
N  arm_matrix_instance_q31 * S,
N  uint16_t nRows,
N  uint16_t nColumns,
N  q31_t * pData);
N
N  /**
N   * @brief  Q15 matrix initialization.
N   * @param[in,out] *S             points to an instance of the floating-point matrix structure.
N   * @param[in]     nRows          number of rows in the matrix.
N   * @param[in]     nColumns       number of columns in the matrix.
N   * @param[in]     *pData	       points to the matrix data array.
N   * @return        none
N   */
N
N  void arm_mat_init_q15(
N  arm_matrix_instance_q15 * S,
N  uint16_t nRows,
N  uint16_t nColumns,
N  q15_t * pData);
N
N  /**
N   * @brief  Floating-point matrix initialization.
N   * @param[in,out] *S             points to an instance of the floating-point matrix structure.
N   * @param[in]     nRows          number of rows in the matrix.
N   * @param[in]     nColumns       number of columns in the matrix.
N   * @param[in]     *pData	       points to the matrix data array.
N   * @return        none
N   */
N
N  void arm_mat_init_f32(
N  arm_matrix_instance_f32 * S,
N  uint16_t nRows,
N  uint16_t nColumns,
N  float32_t * pData);
N
N
N
N  /**
N   * @brief Instance structure for the Q15 PID Control.
N   */
N  typedef struct
N  {
N    q15_t A0;    /**< The derived gain, A0 = Kp + Ki + Kd . */
N#ifdef ARM_MATH_CM0_FAMILY
S    q15_t A1;
S    q15_t A2;
N#else
N    q31_t A1;           /**< The derived gain A1 = -Kp - 2Kd | Kd.*/
N#endif
N    q15_t state[3];       /**< The state array of length 3. */
N    q15_t Kp;           /**< The proportional gain. */
N    q15_t Ki;           /**< The integral gain. */
N    q15_t Kd;           /**< The derivative gain. */
N  } arm_pid_instance_q15;
N
N  /**
N   * @brief Instance structure for the Q31 PID Control.
N   */
N  typedef struct
N  {
N    q31_t A0;            /**< The derived gain, A0 = Kp + Ki + Kd . */
N    q31_t A1;            /**< The derived gain, A1 = -Kp - 2Kd. */
N    q31_t A2;            /**< The derived gain, A2 = Kd . */
N    q31_t state[3];      /**< The state array of length 3. */
N    q31_t Kp;            /**< The proportional gain. */
N    q31_t Ki;            /**< The integral gain. */
N    q31_t Kd;            /**< The derivative gain. */
N
N  } arm_pid_instance_q31;
N
N  /**
N   * @brief Instance structure for the floating-point PID Control.
N   */
N  typedef struct
N  {
N    float32_t A0;          /**< The derived gain, A0 = Kp + Ki + Kd . */
N    float32_t A1;          /**< The derived gain, A1 = -Kp - 2Kd. */
N    float32_t A2;          /**< The derived gain, A2 = Kd . */
N    float32_t state[3];    /**< The state array of length 3. */
N    float32_t Kp;               /**< The proportional gain. */
N    float32_t Ki;               /**< The integral gain. */
N    float32_t Kd;               /**< The derivative gain. */
N  } arm_pid_instance_f32;
N
N
N
N  /**
N   * @brief  Initialization function for the floating-point PID Control.
N   * @param[in,out] *S      points to an instance of the PID structure.
N   * @param[in]     resetStateFlag  flag to reset the state. 0 = no change in state 1 = reset the state.
N   * @return none.
N   */
N  void arm_pid_init_f32(
N  arm_pid_instance_f32 * S,
N  int32_t resetStateFlag);
N
N  /**
N   * @brief  Reset function for the floating-point PID Control.
N   * @param[in,out] *S is an instance of the floating-point PID Control structure
N   * @return none
N   */
N  void arm_pid_reset_f32(
N  arm_pid_instance_f32 * S);
N
N
N  /**
N   * @brief  Initialization function for the Q31 PID Control.
N   * @param[in,out] *S points to an instance of the Q15 PID structure.
N   * @param[in]     resetStateFlag  flag to reset the state. 0 = no change in state 1 = reset the state.
N   * @return none.
N   */
N  void arm_pid_init_q31(
N  arm_pid_instance_q31 * S,
N  int32_t resetStateFlag);
N
N
N  /**
N   * @brief  Reset function for the Q31 PID Control.
N   * @param[in,out] *S points to an instance of the Q31 PID Control structure
N   * @return none
N   */
N
N  void arm_pid_reset_q31(
N  arm_pid_instance_q31 * S);
N
N  /**
N   * @brief  Initialization function for the Q15 PID Control.
N   * @param[in,out] *S points to an instance of the Q15 PID structure.
N   * @param[in] resetStateFlag  flag to reset the state. 0 = no change in state 1 = reset the state.
N   * @return none.
N   */
N  void arm_pid_init_q15(
N  arm_pid_instance_q15 * S,
N  int32_t resetStateFlag);
N
N  /**
N   * @brief  Reset function for the Q15 PID Control.
N   * @param[in,out] *S points to an instance of the q15 PID Control structure
N   * @return none
N   */
N  void arm_pid_reset_q15(
N  arm_pid_instance_q15 * S);
N
N
N  /**
N   * @brief Instance structure for the floating-point Linear Interpolate function.
N   */
N  typedef struct
N  {
N    uint32_t nValues;           /**< nValues */
N    float32_t x1;               /**< x1 */
N    float32_t xSpacing;         /**< xSpacing */
N    float32_t *pYData;          /**< pointer to the table of Y values */
N  } arm_linear_interp_instance_f32;
N
N  /**
N   * @brief Instance structure for the floating-point bilinear interpolation function.
N   */
N
N  typedef struct
N  {
N    uint16_t numRows;   /**< number of rows in the data table. */
N    uint16_t numCols;   /**< number of columns in the data table. */
N    float32_t *pData;   /**< points to the data table. */
N  } arm_bilinear_interp_instance_f32;
N
N   /**
N   * @brief Instance structure for the Q31 bilinear interpolation function.
N   */
N
N  typedef struct
N  {
N    uint16_t numRows;   /**< number of rows in the data table. */
N    uint16_t numCols;   /**< number of columns in the data table. */
N    q31_t *pData;       /**< points to the data table. */
N  } arm_bilinear_interp_instance_q31;
N
N   /**
N   * @brief Instance structure for the Q15 bilinear interpolation function.
N   */
N
N  typedef struct
N  {
N    uint16_t numRows;   /**< number of rows in the data table. */
N    uint16_t numCols;   /**< number of columns in the data table. */
N    q15_t *pData;       /**< points to the data table. */
N  } arm_bilinear_interp_instance_q15;
N
N   /**
N   * @brief Instance structure for the Q15 bilinear interpolation function.
N   */
N
N  typedef struct
N  {
N    uint16_t numRows;   /**< number of rows in the data table. */
N    uint16_t numCols;   /**< number of columns in the data table. */
N    q7_t *pData;                /**< points to the data table. */
N  } arm_bilinear_interp_instance_q7;
N
N
N  /**
N   * @brief Q7 vector multiplication.
N   * @param[in]       *pSrcA points to the first input vector
N   * @param[in]       *pSrcB points to the second input vector
N   * @param[out]      *pDst  points to the output vector
N   * @param[in]       blockSize number of samples in each vector
N   * @return none.
N   */
N
N  void arm_mult_q7(
N  q7_t * pSrcA,
N  q7_t * pSrcB,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Q15 vector multiplication.
N   * @param[in]       *pSrcA points to the first input vector
N   * @param[in]       *pSrcB points to the second input vector
N   * @param[out]      *pDst  points to the output vector
N   * @param[in]       blockSize number of samples in each vector
N   * @return none.
N   */
N
N  void arm_mult_q15(
N  q15_t * pSrcA,
N  q15_t * pSrcB,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Q31 vector multiplication.
N   * @param[in]       *pSrcA points to the first input vector
N   * @param[in]       *pSrcB points to the second input vector
N   * @param[out]      *pDst points to the output vector
N   * @param[in]       blockSize number of samples in each vector
N   * @return none.
N   */
N
N  void arm_mult_q31(
N  q31_t * pSrcA,
N  q31_t * pSrcB,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Floating-point vector multiplication.
N   * @param[in]       *pSrcA points to the first input vector
N   * @param[in]       *pSrcB points to the second input vector
N   * @param[out]      *pDst points to the output vector
N   * @param[in]       blockSize number of samples in each vector
N   * @return none.
N   */
N
N  void arm_mult_f32(
N  float32_t * pSrcA,
N  float32_t * pSrcB,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N
N
N
N
N
N  /**
N   * @brief Instance structure for the Q15 CFFT/CIFFT function.
N   */
N
N  typedef struct
N  {
N    uint16_t fftLen;                 /**< length of the FFT. */
N    uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform. */
N    uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output. */
N    q15_t *pTwiddle;                     /**< points to the Sin twiddle factor table. */
N    uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
N    uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
N    uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs with the same bit reversal table. */
N  } arm_cfft_radix2_instance_q15;
N
N/* Deprecated */
N  arm_status arm_cfft_radix2_init_q15(
N  arm_cfft_radix2_instance_q15 * S,
N  uint16_t fftLen,
N  uint8_t ifftFlag,
N  uint8_t bitReverseFlag);
N
N/* Deprecated */
N  void arm_cfft_radix2_q15(
N  const arm_cfft_radix2_instance_q15 * S,
N  q15_t * pSrc);
N
N
N
N  /**
N   * @brief Instance structure for the Q15 CFFT/CIFFT function.
N   */
N
N  typedef struct
N  {
N    uint16_t fftLen;                 /**< length of the FFT. */
N    uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform. */
N    uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output. */
N    q15_t *pTwiddle;                 /**< points to the twiddle factor table. */
N    uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
N    uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
N    uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs with the same bit reversal table. */
N  } arm_cfft_radix4_instance_q15;
N
N/* Deprecated */
N  arm_status arm_cfft_radix4_init_q15(
N  arm_cfft_radix4_instance_q15 * S,
N  uint16_t fftLen,
N  uint8_t ifftFlag,
N  uint8_t bitReverseFlag);
N
N/* Deprecated */
N  void arm_cfft_radix4_q15(
N  const arm_cfft_radix4_instance_q15 * S,
N  q15_t * pSrc);
N
N  /**
N   * @brief Instance structure for the Radix-2 Q31 CFFT/CIFFT function.
N   */
N
N  typedef struct
N  {
N    uint16_t fftLen;                 /**< length of the FFT. */
N    uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform. */
N    uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output. */
N    q31_t *pTwiddle;                     /**< points to the Twiddle factor table. */
N    uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
N    uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
N    uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs with the same bit reversal table. */
N  } arm_cfft_radix2_instance_q31;
N
N/* Deprecated */
N  arm_status arm_cfft_radix2_init_q31(
N  arm_cfft_radix2_instance_q31 * S,
N  uint16_t fftLen,
N  uint8_t ifftFlag,
N  uint8_t bitReverseFlag);
N
N/* Deprecated */
N  void arm_cfft_radix2_q31(
N  const arm_cfft_radix2_instance_q31 * S,
N  q31_t * pSrc);
N
N  /**
N   * @brief Instance structure for the Q31 CFFT/CIFFT function.
N   */
N
N  typedef struct
N  {
N    uint16_t fftLen;                 /**< length of the FFT. */
N    uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform. */
N    uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output. */
N    q31_t *pTwiddle;                 /**< points to the twiddle factor table. */
N    uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
N    uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
N    uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs with the same bit reversal table. */
N  } arm_cfft_radix4_instance_q31;
N
N/* Deprecated */
N  void arm_cfft_radix4_q31(
N  const arm_cfft_radix4_instance_q31 * S,
N  q31_t * pSrc);
N
N/* Deprecated */
N  arm_status arm_cfft_radix4_init_q31(
N  arm_cfft_radix4_instance_q31 * S,
N  uint16_t fftLen,
N  uint8_t ifftFlag,
N  uint8_t bitReverseFlag);
N
N  /**
N   * @brief Instance structure for the floating-point CFFT/CIFFT function.
N   */
N
N  typedef struct
N  {
N    uint16_t fftLen;                   /**< length of the FFT. */
N    uint8_t ifftFlag;                  /**< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform. */
N    uint8_t bitReverseFlag;            /**< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output. */
N    float32_t *pTwiddle;               /**< points to the Twiddle factor table. */
N    uint16_t *pBitRevTable;            /**< points to the bit reversal table. */
N    uint16_t twidCoefModifier;         /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
N    uint16_t bitRevFactor;             /**< bit reversal modifier that supports different size FFTs with the same bit reversal table. */
N    float32_t onebyfftLen;                 /**< value of 1/fftLen. */
N  } arm_cfft_radix2_instance_f32;
N
N/* Deprecated */
N  arm_status arm_cfft_radix2_init_f32(
N  arm_cfft_radix2_instance_f32 * S,
N  uint16_t fftLen,
N  uint8_t ifftFlag,
N  uint8_t bitReverseFlag);
N
N/* Deprecated */
N  void arm_cfft_radix2_f32(
N  const arm_cfft_radix2_instance_f32 * S,
N  float32_t * pSrc);
N
N  /**
N   * @brief Instance structure for the floating-point CFFT/CIFFT function.
N   */
N
N  typedef struct
N  {
N    uint16_t fftLen;                   /**< length of the FFT. */
N    uint8_t ifftFlag;                  /**< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform. */
N    uint8_t bitReverseFlag;            /**< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output. */
N    float32_t *pTwiddle;               /**< points to the Twiddle factor table. */
N    uint16_t *pBitRevTable;            /**< points to the bit reversal table. */
N    uint16_t twidCoefModifier;         /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
N    uint16_t bitRevFactor;             /**< bit reversal modifier that supports different size FFTs with the same bit reversal table. */
N    float32_t onebyfftLen;                 /**< value of 1/fftLen. */
N  } arm_cfft_radix4_instance_f32;
N
N/* Deprecated */
N  arm_status arm_cfft_radix4_init_f32(
N  arm_cfft_radix4_instance_f32 * S,
N  uint16_t fftLen,
N  uint8_t ifftFlag,
N  uint8_t bitReverseFlag);
N
N/* Deprecated */
N  void arm_cfft_radix4_f32(
N  const arm_cfft_radix4_instance_f32 * S,
N  float32_t * pSrc);
N
N  /**
N   * @brief Instance structure for the fixed-point CFFT/CIFFT function.
N   */
N
N  typedef struct
N  {
N    uint16_t fftLen;                   /**< length of the FFT. */
N    const q15_t *pTwiddle;             /**< points to the Twiddle factor table. */
N    const uint16_t *pBitRevTable;      /**< points to the bit reversal table. */
N    uint16_t bitRevLength;             /**< bit reversal table length. */
N  } arm_cfft_instance_q15;
N
Nvoid arm_cfft_q15( 
N    const arm_cfft_instance_q15 * S, 
N    q15_t * p1,
N    uint8_t ifftFlag,
N    uint8_t bitReverseFlag);  
N
N  /**
N   * @brief Instance structure for the fixed-point CFFT/CIFFT function.
N   */
N
N  typedef struct
N  {
N    uint16_t fftLen;                   /**< length of the FFT. */
N    const q31_t *pTwiddle;             /**< points to the Twiddle factor table. */
N    const uint16_t *pBitRevTable;      /**< points to the bit reversal table. */
N    uint16_t bitRevLength;             /**< bit reversal table length. */
N  } arm_cfft_instance_q31;
N
Nvoid arm_cfft_q31( 
N    const arm_cfft_instance_q31 * S, 
N    q31_t * p1,
N    uint8_t ifftFlag,
N    uint8_t bitReverseFlag);  
N  
N  /**
N   * @brief Instance structure for the floating-point CFFT/CIFFT function.
N   */
N
N  typedef struct
N  {
N    uint16_t fftLen;                   /**< length of the FFT. */
N    const float32_t *pTwiddle;         /**< points to the Twiddle factor table. */
N    const uint16_t *pBitRevTable;      /**< points to the bit reversal table. */
N    uint16_t bitRevLength;             /**< bit reversal table length. */
N  } arm_cfft_instance_f32;
N
N  void arm_cfft_f32(
N  const arm_cfft_instance_f32 * S,
N  float32_t * p1,
N  uint8_t ifftFlag,
N  uint8_t bitReverseFlag);
N
N  /**
N   * @brief Instance structure for the Q15 RFFT/RIFFT function.
N   */
N
N  typedef struct
N  {
N    uint32_t fftLenReal;                      /**< length of the real FFT. */
N    uint8_t ifftFlagR;                        /**< flag that selects forward (ifftFlagR=0) or inverse (ifftFlagR=1) transform. */
N    uint8_t bitReverseFlagR;                  /**< flag that enables (bitReverseFlagR=1) or disables (bitReverseFlagR=0) bit reversal of output. */
N    uint32_t twidCoefRModifier;               /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
N    q15_t *pTwiddleAReal;                     /**< points to the real twiddle factor table. */
N    q15_t *pTwiddleBReal;                     /**< points to the imag twiddle factor table. */
N    const arm_cfft_instance_q15 *pCfft;       /**< points to the complex FFT instance. */
N  } arm_rfft_instance_q15;
N
N  arm_status arm_rfft_init_q15(
N  arm_rfft_instance_q15 * S,
N  uint32_t fftLenReal,
N  uint32_t ifftFlagR,
N  uint32_t bitReverseFlag);
N
N  void arm_rfft_q15(
N  const arm_rfft_instance_q15 * S,
N  q15_t * pSrc,
N  q15_t * pDst);
N
N  /**
N   * @brief Instance structure for the Q31 RFFT/RIFFT function.
N   */
N
N  typedef struct
N  {
N    uint32_t fftLenReal;                        /**< length of the real FFT. */
N    uint8_t ifftFlagR;                          /**< flag that selects forward (ifftFlagR=0) or inverse (ifftFlagR=1) transform. */
N    uint8_t bitReverseFlagR;                    /**< flag that enables (bitReverseFlagR=1) or disables (bitReverseFlagR=0) bit reversal of output. */
N    uint32_t twidCoefRModifier;                 /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
N    q31_t *pTwiddleAReal;                       /**< points to the real twiddle factor table. */
N    q31_t *pTwiddleBReal;                       /**< points to the imag twiddle factor table. */
N    const arm_cfft_instance_q31 *pCfft;         /**< points to the complex FFT instance. */
N  } arm_rfft_instance_q31;
N
N  arm_status arm_rfft_init_q31(
N  arm_rfft_instance_q31 * S,
N  uint32_t fftLenReal,
N  uint32_t ifftFlagR,
N  uint32_t bitReverseFlag);
N
N  void arm_rfft_q31(
N  const arm_rfft_instance_q31 * S,
N  q31_t * pSrc,
N  q31_t * pDst);
N
N  /**
N   * @brief Instance structure for the floating-point RFFT/RIFFT function.
N   */
N
N  typedef struct
N  {
N    uint32_t fftLenReal;                        /**< length of the real FFT. */
N    uint16_t fftLenBy2;                         /**< length of the complex FFT. */
N    uint8_t ifftFlagR;                          /**< flag that selects forward (ifftFlagR=0) or inverse (ifftFlagR=1) transform. */
N    uint8_t bitReverseFlagR;                    /**< flag that enables (bitReverseFlagR=1) or disables (bitReverseFlagR=0) bit reversal of output. */
N    uint32_t twidCoefRModifier;                     /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
N    float32_t *pTwiddleAReal;                   /**< points to the real twiddle factor table. */
N    float32_t *pTwiddleBReal;                   /**< points to the imag twiddle factor table. */
N    arm_cfft_radix4_instance_f32 *pCfft;        /**< points to the complex FFT instance. */
N  } arm_rfft_instance_f32;
N
N  arm_status arm_rfft_init_f32(
N  arm_rfft_instance_f32 * S,
N  arm_cfft_radix4_instance_f32 * S_CFFT,
N  uint32_t fftLenReal,
N  uint32_t ifftFlagR,
N  uint32_t bitReverseFlag);
N
N  void arm_rfft_f32(
N  const arm_rfft_instance_f32 * S,
N  float32_t * pSrc,
N  float32_t * pDst);
N
N  /**
N   * @brief Instance structure for the floating-point RFFT/RIFFT function.
N   */
N
Ntypedef struct
N  {
N    arm_cfft_instance_f32 Sint;      /**< Internal CFFT structure. */
N    uint16_t fftLenRFFT;                        /**< length of the real sequence */
N	float32_t * pTwiddleRFFT;					/**< Twiddle factors real stage  */
N  } arm_rfft_fast_instance_f32 ;
N
Narm_status arm_rfft_fast_init_f32 (
N	arm_rfft_fast_instance_f32 * S,
N	uint16_t fftLen);
N
Nvoid arm_rfft_fast_f32(
N  arm_rfft_fast_instance_f32 * S,
N  float32_t * p, float32_t * pOut,
N  uint8_t ifftFlag);
N
N  /**
N   * @brief Instance structure for the floating-point DCT4/IDCT4 function.
N   */
N
N  typedef struct
N  {
N    uint16_t N;                         /**< length of the DCT4. */
N    uint16_t Nby2;                      /**< half of the length of the DCT4. */
N    float32_t normalize;                /**< normalizing factor. */
N    float32_t *pTwiddle;                /**< points to the twiddle factor table. */
N    float32_t *pCosFactor;              /**< points to the cosFactor table. */
N    arm_rfft_instance_f32 *pRfft;        /**< points to the real FFT instance. */
N    arm_cfft_radix4_instance_f32 *pCfft; /**< points to the complex FFT instance. */
N  } arm_dct4_instance_f32;
N
N  /**
N   * @brief  Initialization function for the floating-point DCT4/IDCT4.
N   * @param[in,out] *S         points to an instance of floating-point DCT4/IDCT4 structure.
N   * @param[in]     *S_RFFT    points to an instance of floating-point RFFT/RIFFT structure.
N   * @param[in]     *S_CFFT    points to an instance of floating-point CFFT/CIFFT structure.
N   * @param[in]     N          length of the DCT4.
N   * @param[in]     Nby2       half of the length of the DCT4.
N   * @param[in]     normalize  normalizing factor.
N   * @return		arm_status function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_ARGUMENT_ERROR if <code>fftLenReal</code> is not a supported transform length.
N   */
N
N  arm_status arm_dct4_init_f32(
N  arm_dct4_instance_f32 * S,
N  arm_rfft_instance_f32 * S_RFFT,
N  arm_cfft_radix4_instance_f32 * S_CFFT,
N  uint16_t N,
N  uint16_t Nby2,
N  float32_t normalize);
N
N  /**
N   * @brief Processing function for the floating-point DCT4/IDCT4.
N   * @param[in]       *S             points to an instance of the floating-point DCT4/IDCT4 structure.
N   * @param[in]       *pState        points to state buffer.
N   * @param[in,out]   *pInlineBuffer points to the in-place input and output buffer.
N   * @return none.
N   */
N
N  void arm_dct4_f32(
N  const arm_dct4_instance_f32 * S,
N  float32_t * pState,
N  float32_t * pInlineBuffer);
N
N  /**
N   * @brief Instance structure for the Q31 DCT4/IDCT4 function.
N   */
N
N  typedef struct
N  {
N    uint16_t N;                         /**< length of the DCT4. */
N    uint16_t Nby2;                      /**< half of the length of the DCT4. */
N    q31_t normalize;                    /**< normalizing factor. */
N    q31_t *pTwiddle;                    /**< points to the twiddle factor table. */
N    q31_t *pCosFactor;                  /**< points to the cosFactor table. */
N    arm_rfft_instance_q31 *pRfft;        /**< points to the real FFT instance. */
N    arm_cfft_radix4_instance_q31 *pCfft; /**< points to the complex FFT instance. */
N  } arm_dct4_instance_q31;
N
N  /**
N   * @brief  Initialization function for the Q31 DCT4/IDCT4.
N   * @param[in,out] *S         points to an instance of Q31 DCT4/IDCT4 structure.
N   * @param[in]     *S_RFFT    points to an instance of Q31 RFFT/RIFFT structure
N   * @param[in]     *S_CFFT    points to an instance of Q31 CFFT/CIFFT structure
N   * @param[in]     N          length of the DCT4.
N   * @param[in]     Nby2       half of the length of the DCT4.
N   * @param[in]     normalize  normalizing factor.
N   * @return		arm_status function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_ARGUMENT_ERROR if <code>N</code> is not a supported transform length.
N   */
N
N  arm_status arm_dct4_init_q31(
N  arm_dct4_instance_q31 * S,
N  arm_rfft_instance_q31 * S_RFFT,
N  arm_cfft_radix4_instance_q31 * S_CFFT,
N  uint16_t N,
N  uint16_t Nby2,
N  q31_t normalize);
N
N  /**
N   * @brief Processing function for the Q31 DCT4/IDCT4.
N   * @param[in]       *S             points to an instance of the Q31 DCT4 structure.
N   * @param[in]       *pState        points to state buffer.
N   * @param[in,out]   *pInlineBuffer points to the in-place input and output buffer.
N   * @return none.
N   */
N
N  void arm_dct4_q31(
N  const arm_dct4_instance_q31 * S,
N  q31_t * pState,
N  q31_t * pInlineBuffer);
N
N  /**
N   * @brief Instance structure for the Q15 DCT4/IDCT4 function.
N   */
N
N  typedef struct
N  {
N    uint16_t N;                         /**< length of the DCT4. */
N    uint16_t Nby2;                      /**< half of the length of the DCT4. */
N    q15_t normalize;                    /**< normalizing factor. */
N    q15_t *pTwiddle;                    /**< points to the twiddle factor table. */
N    q15_t *pCosFactor;                  /**< points to the cosFactor table. */
N    arm_rfft_instance_q15 *pRfft;        /**< points to the real FFT instance. */
N    arm_cfft_radix4_instance_q15 *pCfft; /**< points to the complex FFT instance. */
N  } arm_dct4_instance_q15;
N
N  /**
N   * @brief  Initialization function for the Q15 DCT4/IDCT4.
N   * @param[in,out] *S         points to an instance of Q15 DCT4/IDCT4 structure.
N   * @param[in]     *S_RFFT    points to an instance of Q15 RFFT/RIFFT structure.
N   * @param[in]     *S_CFFT    points to an instance of Q15 CFFT/CIFFT structure.
N   * @param[in]     N          length of the DCT4.
N   * @param[in]     Nby2       half of the length of the DCT4.
N   * @param[in]     normalize  normalizing factor.
N   * @return		arm_status function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_ARGUMENT_ERROR if <code>N</code> is not a supported transform length.
N   */
N
N  arm_status arm_dct4_init_q15(
N  arm_dct4_instance_q15 * S,
N  arm_rfft_instance_q15 * S_RFFT,
N  arm_cfft_radix4_instance_q15 * S_CFFT,
N  uint16_t N,
N  uint16_t Nby2,
N  q15_t normalize);
N
N  /**
N   * @brief Processing function for the Q15 DCT4/IDCT4.
N   * @param[in]       *S             points to an instance of the Q15 DCT4 structure.
N   * @param[in]       *pState        points to state buffer.
N   * @param[in,out]   *pInlineBuffer points to the in-place input and output buffer.
N   * @return none.
N   */
N
N  void arm_dct4_q15(
N  const arm_dct4_instance_q15 * S,
N  q15_t * pState,
N  q15_t * pInlineBuffer);
N
N  /**
N   * @brief Floating-point vector addition.
N   * @param[in]       *pSrcA points to the first input vector
N   * @param[in]       *pSrcB points to the second input vector
N   * @param[out]      *pDst points to the output vector
N   * @param[in]       blockSize number of samples in each vector
N   * @return none.
N   */
N
N  void arm_add_f32(
N  float32_t * pSrcA,
N  float32_t * pSrcB,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Q7 vector addition.
N   * @param[in]       *pSrcA points to the first input vector
N   * @param[in]       *pSrcB points to the second input vector
N   * @param[out]      *pDst points to the output vector
N   * @param[in]       blockSize number of samples in each vector
N   * @return none.
N   */
N
N  void arm_add_q7(
N  q7_t * pSrcA,
N  q7_t * pSrcB,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Q15 vector addition.
N   * @param[in]       *pSrcA points to the first input vector
N   * @param[in]       *pSrcB points to the second input vector
N   * @param[out]      *pDst points to the output vector
N   * @param[in]       blockSize number of samples in each vector
N   * @return none.
N   */
N
N  void arm_add_q15(
N  q15_t * pSrcA,
N  q15_t * pSrcB,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Q31 vector addition.
N   * @param[in]       *pSrcA points to the first input vector
N   * @param[in]       *pSrcB points to the second input vector
N   * @param[out]      *pDst points to the output vector
N   * @param[in]       blockSize number of samples in each vector
N   * @return none.
N   */
N
N  void arm_add_q31(
N  q31_t * pSrcA,
N  q31_t * pSrcB,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Floating-point vector subtraction.
N   * @param[in]       *pSrcA points to the first input vector
N   * @param[in]       *pSrcB points to the second input vector
N   * @param[out]      *pDst points to the output vector
N   * @param[in]       blockSize number of samples in each vector
N   * @return none.
N   */
N
N  void arm_sub_f32(
N  float32_t * pSrcA,
N  float32_t * pSrcB,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Q7 vector subtraction.
N   * @param[in]       *pSrcA points to the first input vector
N   * @param[in]       *pSrcB points to the second input vector
N   * @param[out]      *pDst points to the output vector
N   * @param[in]       blockSize number of samples in each vector
N   * @return none.
N   */
N
N  void arm_sub_q7(
N  q7_t * pSrcA,
N  q7_t * pSrcB,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Q15 vector subtraction.
N   * @param[in]       *pSrcA points to the first input vector
N   * @param[in]       *pSrcB points to the second input vector
N   * @param[out]      *pDst points to the output vector
N   * @param[in]       blockSize number of samples in each vector
N   * @return none.
N   */
N
N  void arm_sub_q15(
N  q15_t * pSrcA,
N  q15_t * pSrcB,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Q31 vector subtraction.
N   * @param[in]       *pSrcA points to the first input vector
N   * @param[in]       *pSrcB points to the second input vector
N   * @param[out]      *pDst points to the output vector
N   * @param[in]       blockSize number of samples in each vector
N   * @return none.
N   */
N
N  void arm_sub_q31(
N  q31_t * pSrcA,
N  q31_t * pSrcB,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Multiplies a floating-point vector by a scalar.
N   * @param[in]       *pSrc points to the input vector
N   * @param[in]       scale scale factor to be applied
N   * @param[out]      *pDst points to the output vector
N   * @param[in]       blockSize number of samples in the vector
N   * @return none.
N   */
N
N  void arm_scale_f32(
N  float32_t * pSrc,
N  float32_t scale,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Multiplies a Q7 vector by a scalar.
N   * @param[in]       *pSrc points to the input vector
N   * @param[in]       scaleFract fractional portion of the scale value
N   * @param[in]       shift number of bits to shift the result by
N   * @param[out]      *pDst points to the output vector
N   * @param[in]       blockSize number of samples in the vector
N   * @return none.
N   */
N
N  void arm_scale_q7(
N  q7_t * pSrc,
N  q7_t scaleFract,
N  int8_t shift,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Multiplies a Q15 vector by a scalar.
N   * @param[in]       *pSrc points to the input vector
N   * @param[in]       scaleFract fractional portion of the scale value
N   * @param[in]       shift number of bits to shift the result by
N   * @param[out]      *pDst points to the output vector
N   * @param[in]       blockSize number of samples in the vector
N   * @return none.
N   */
N
N  void arm_scale_q15(
N  q15_t * pSrc,
N  q15_t scaleFract,
N  int8_t shift,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Multiplies a Q31 vector by a scalar.
N   * @param[in]       *pSrc points to the input vector
N   * @param[in]       scaleFract fractional portion of the scale value
N   * @param[in]       shift number of bits to shift the result by
N   * @param[out]      *pDst points to the output vector
N   * @param[in]       blockSize number of samples in the vector
N   * @return none.
N   */
N
N  void arm_scale_q31(
N  q31_t * pSrc,
N  q31_t scaleFract,
N  int8_t shift,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Q7 vector absolute value.
N   * @param[in]       *pSrc points to the input buffer
N   * @param[out]      *pDst points to the output buffer
N   * @param[in]       blockSize number of samples in each vector
N   * @return none.
N   */
N
N  void arm_abs_q7(
N  q7_t * pSrc,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Floating-point vector absolute value.
N   * @param[in]       *pSrc points to the input buffer
N   * @param[out]      *pDst points to the output buffer
N   * @param[in]       blockSize number of samples in each vector
N   * @return none.
N   */
N
N  void arm_abs_f32(
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Q15 vector absolute value.
N   * @param[in]       *pSrc points to the input buffer
N   * @param[out]      *pDst points to the output buffer
N   * @param[in]       blockSize number of samples in each vector
N   * @return none.
N   */
N
N  void arm_abs_q15(
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Q31 vector absolute value.
N   * @param[in]       *pSrc points to the input buffer
N   * @param[out]      *pDst points to the output buffer
N   * @param[in]       blockSize number of samples in each vector
N   * @return none.
N   */
N
N  void arm_abs_q31(
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Dot product of floating-point vectors.
N   * @param[in]       *pSrcA points to the first input vector
N   * @param[in]       *pSrcB points to the second input vector
N   * @param[in]       blockSize number of samples in each vector
N   * @param[out]      *result output result returned here
N   * @return none.
N   */
N
N  void arm_dot_prod_f32(
N  float32_t * pSrcA,
N  float32_t * pSrcB,
N  uint32_t blockSize,
N  float32_t * result);
N
N  /**
N   * @brief Dot product of Q7 vectors.
N   * @param[in]       *pSrcA points to the first input vector
N   * @param[in]       *pSrcB points to the second input vector
N   * @param[in]       blockSize number of samples in each vector
N   * @param[out]      *result output result returned here
N   * @return none.
N   */
N
N  void arm_dot_prod_q7(
N  q7_t * pSrcA,
N  q7_t * pSrcB,
N  uint32_t blockSize,
N  q31_t * result);
N
N  /**
N   * @brief Dot product of Q15 vectors.
N   * @param[in]       *pSrcA points to the first input vector
N   * @param[in]       *pSrcB points to the second input vector
N   * @param[in]       blockSize number of samples in each vector
N   * @param[out]      *result output result returned here
N   * @return none.
N   */
N
N  void arm_dot_prod_q15(
N  q15_t * pSrcA,
N  q15_t * pSrcB,
N  uint32_t blockSize,
N  q63_t * result);
N
N  /**
N   * @brief Dot product of Q31 vectors.
N   * @param[in]       *pSrcA points to the first input vector
N   * @param[in]       *pSrcB points to the second input vector
N   * @param[in]       blockSize number of samples in each vector
N   * @param[out]      *result output result returned here
N   * @return none.
N   */
N
N  void arm_dot_prod_q31(
N  q31_t * pSrcA,
N  q31_t * pSrcB,
N  uint32_t blockSize,
N  q63_t * result);
N
N  /**
N   * @brief  Shifts the elements of a Q7 vector a specified number of bits.
N   * @param[in]  *pSrc points to the input vector
N   * @param[in]  shiftBits number of bits to shift.  A positive value shifts left; a negative value shifts right.
N   * @param[out]  *pDst points to the output vector
N   * @param[in]  blockSize number of samples in the vector
N   * @return none.
N   */
N
N  void arm_shift_q7(
N  q7_t * pSrc,
N  int8_t shiftBits,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Shifts the elements of a Q15 vector a specified number of bits.
N   * @param[in]  *pSrc points to the input vector
N   * @param[in]  shiftBits number of bits to shift.  A positive value shifts left; a negative value shifts right.
N   * @param[out]  *pDst points to the output vector
N   * @param[in]  blockSize number of samples in the vector
N   * @return none.
N   */
N
N  void arm_shift_q15(
N  q15_t * pSrc,
N  int8_t shiftBits,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Shifts the elements of a Q31 vector a specified number of bits.
N   * @param[in]  *pSrc points to the input vector
N   * @param[in]  shiftBits number of bits to shift.  A positive value shifts left; a negative value shifts right.
N   * @param[out]  *pDst points to the output vector
N   * @param[in]  blockSize number of samples in the vector
N   * @return none.
N   */
N
N  void arm_shift_q31(
N  q31_t * pSrc,
N  int8_t shiftBits,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Adds a constant offset to a floating-point vector.
N   * @param[in]  *pSrc points to the input vector
N   * @param[in]  offset is the offset to be added
N   * @param[out]  *pDst points to the output vector
N   * @param[in]  blockSize number of samples in the vector
N   * @return none.
N   */
N
N  void arm_offset_f32(
N  float32_t * pSrc,
N  float32_t offset,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Adds a constant offset to a Q7 vector.
N   * @param[in]  *pSrc points to the input vector
N   * @param[in]  offset is the offset to be added
N   * @param[out]  *pDst points to the output vector
N   * @param[in]  blockSize number of samples in the vector
N   * @return none.
N   */
N
N  void arm_offset_q7(
N  q7_t * pSrc,
N  q7_t offset,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Adds a constant offset to a Q15 vector.
N   * @param[in]  *pSrc points to the input vector
N   * @param[in]  offset is the offset to be added
N   * @param[out]  *pDst points to the output vector
N   * @param[in]  blockSize number of samples in the vector
N   * @return none.
N   */
N
N  void arm_offset_q15(
N  q15_t * pSrc,
N  q15_t offset,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Adds a constant offset to a Q31 vector.
N   * @param[in]  *pSrc points to the input vector
N   * @param[in]  offset is the offset to be added
N   * @param[out]  *pDst points to the output vector
N   * @param[in]  blockSize number of samples in the vector
N   * @return none.
N   */
N
N  void arm_offset_q31(
N  q31_t * pSrc,
N  q31_t offset,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Negates the elements of a floating-point vector.
N   * @param[in]  *pSrc points to the input vector
N   * @param[out]  *pDst points to the output vector
N   * @param[in]  blockSize number of samples in the vector
N   * @return none.
N   */
N
N  void arm_negate_f32(
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Negates the elements of a Q7 vector.
N   * @param[in]  *pSrc points to the input vector
N   * @param[out]  *pDst points to the output vector
N   * @param[in]  blockSize number of samples in the vector
N   * @return none.
N   */
N
N  void arm_negate_q7(
N  q7_t * pSrc,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Negates the elements of a Q15 vector.
N   * @param[in]  *pSrc points to the input vector
N   * @param[out]  *pDst points to the output vector
N   * @param[in]  blockSize number of samples in the vector
N   * @return none.
N   */
N
N  void arm_negate_q15(
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Negates the elements of a Q31 vector.
N   * @param[in]  *pSrc points to the input vector
N   * @param[out]  *pDst points to the output vector
N   * @param[in]  blockSize number of samples in the vector
N   * @return none.
N   */
N
N  void arm_negate_q31(
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N  /**
N   * @brief  Copies the elements of a floating-point vector.
N   * @param[in]  *pSrc input pointer
N   * @param[out]  *pDst output pointer
N   * @param[in]  blockSize number of samples to process
N   * @return none.
N   */
N  void arm_copy_f32(
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Copies the elements of a Q7 vector.
N   * @param[in]  *pSrc input pointer
N   * @param[out]  *pDst output pointer
N   * @param[in]  blockSize number of samples to process
N   * @return none.
N   */
N  void arm_copy_q7(
N  q7_t * pSrc,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Copies the elements of a Q15 vector.
N   * @param[in]  *pSrc input pointer
N   * @param[out]  *pDst output pointer
N   * @param[in]  blockSize number of samples to process
N   * @return none.
N   */
N  void arm_copy_q15(
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Copies the elements of a Q31 vector.
N   * @param[in]  *pSrc input pointer
N   * @param[out]  *pDst output pointer
N   * @param[in]  blockSize number of samples to process
N   * @return none.
N   */
N  void arm_copy_q31(
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N  /**
N   * @brief  Fills a constant value into a floating-point vector.
N   * @param[in]  value input value to be filled
N   * @param[out]  *pDst output pointer
N   * @param[in]  blockSize number of samples to process
N   * @return none.
N   */
N  void arm_fill_f32(
N  float32_t value,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Fills a constant value into a Q7 vector.
N   * @param[in]  value input value to be filled
N   * @param[out]  *pDst output pointer
N   * @param[in]  blockSize number of samples to process
N   * @return none.
N   */
N  void arm_fill_q7(
N  q7_t value,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Fills a constant value into a Q15 vector.
N   * @param[in]  value input value to be filled
N   * @param[out]  *pDst output pointer
N   * @param[in]  blockSize number of samples to process
N   * @return none.
N   */
N  void arm_fill_q15(
N  q15_t value,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Fills a constant value into a Q31 vector.
N   * @param[in]  value input value to be filled
N   * @param[out]  *pDst output pointer
N   * @param[in]  blockSize number of samples to process
N   * @return none.
N   */
N  void arm_fill_q31(
N  q31_t value,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N/**
N * @brief Convolution of floating-point sequences.
N * @param[in] *pSrcA points to the first input sequence.
N * @param[in] srcALen length of the first input sequence.
N * @param[in] *pSrcB points to the second input sequence.
N * @param[in] srcBLen length of the second input sequence.
N * @param[out] *pDst points to the location where the output result is written.  Length srcALen+srcBLen-1.
N * @return none.
N */
N
N  void arm_conv_f32(
N  float32_t * pSrcA,
N  uint32_t srcALen,
N  float32_t * pSrcB,
N  uint32_t srcBLen,
N  float32_t * pDst);
N
N
N  /**
N   * @brief Convolution of Q15 sequences.
N   * @param[in] *pSrcA points to the first input sequence.
N   * @param[in] srcALen length of the first input sequence.
N   * @param[in] *pSrcB points to the second input sequence.
N   * @param[in] srcBLen length of the second input sequence.
N   * @param[out] *pDst points to the block of output data  Length srcALen+srcBLen-1.
N   * @param[in]  *pScratch1 points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
N   * @param[in]  *pScratch2 points to scratch buffer of size min(srcALen, srcBLen).
N   * @return none.
N   */
N
N
N  void arm_conv_opt_q15(
N  q15_t * pSrcA,
N  uint32_t srcALen,
N  q15_t * pSrcB,
N  uint32_t srcBLen,
N  q15_t * pDst,
N  q15_t * pScratch1,
N  q15_t * pScratch2);
N
N
N/**
N * @brief Convolution of Q15 sequences.
N * @param[in] *pSrcA points to the first input sequence.
N * @param[in] srcALen length of the first input sequence.
N * @param[in] *pSrcB points to the second input sequence.
N * @param[in] srcBLen length of the second input sequence.
N * @param[out] *pDst points to the location where the output result is written.  Length srcALen+srcBLen-1.
N * @return none.
N */
N
N  void arm_conv_q15(
N  q15_t * pSrcA,
N  uint32_t srcALen,
N  q15_t * pSrcB,
N  uint32_t srcBLen,
N  q15_t * pDst);
N
N  /**
N   * @brief Convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4
N   * @param[in] *pSrcA points to the first input sequence.
N   * @param[in] srcALen length of the first input sequence.
N   * @param[in] *pSrcB points to the second input sequence.
N   * @param[in] srcBLen length of the second input sequence.
N   * @param[out] *pDst points to the block of output data  Length srcALen+srcBLen-1.
N   * @return none.
N   */
N
N  void arm_conv_fast_q15(
N			  q15_t * pSrcA,
N			 uint32_t srcALen,
N			  q15_t * pSrcB,
N			 uint32_t srcBLen,
N			 q15_t * pDst);
N
N  /**
N   * @brief Convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4
N   * @param[in] *pSrcA points to the first input sequence.
N   * @param[in] srcALen length of the first input sequence.
N   * @param[in] *pSrcB points to the second input sequence.
N   * @param[in] srcBLen length of the second input sequence.
N   * @param[out] *pDst points to the block of output data  Length srcALen+srcBLen-1.
N   * @param[in]  *pScratch1 points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
N   * @param[in]  *pScratch2 points to scratch buffer of size min(srcALen, srcBLen).
N   * @return none.
N   */
N
N  void arm_conv_fast_opt_q15(
N  q15_t * pSrcA,
N  uint32_t srcALen,
N  q15_t * pSrcB,
N  uint32_t srcBLen,
N  q15_t * pDst,
N  q15_t * pScratch1,
N  q15_t * pScratch2);
N
N
N
N  /**
N   * @brief Convolution of Q31 sequences.
N   * @param[in] *pSrcA points to the first input sequence.
N   * @param[in] srcALen length of the first input sequence.
N   * @param[in] *pSrcB points to the second input sequence.
N   * @param[in] srcBLen length of the second input sequence.
N   * @param[out] *pDst points to the block of output data  Length srcALen+srcBLen-1.
N   * @return none.
N   */
N
N  void arm_conv_q31(
N  q31_t * pSrcA,
N  uint32_t srcALen,
N  q31_t * pSrcB,
N  uint32_t srcBLen,
N  q31_t * pDst);
N
N  /**
N   * @brief Convolution of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4
N   * @param[in] *pSrcA points to the first input sequence.
N   * @param[in] srcALen length of the first input sequence.
N   * @param[in] *pSrcB points to the second input sequence.
N   * @param[in] srcBLen length of the second input sequence.
N   * @param[out] *pDst points to the block of output data  Length srcALen+srcBLen-1.
N   * @return none.
N   */
N
N  void arm_conv_fast_q31(
N  q31_t * pSrcA,
N  uint32_t srcALen,
N  q31_t * pSrcB,
N  uint32_t srcBLen,
N  q31_t * pDst);
N
N
N    /**
N   * @brief Convolution of Q7 sequences.
N   * @param[in] *pSrcA points to the first input sequence.
N   * @param[in] srcALen length of the first input sequence.
N   * @param[in] *pSrcB points to the second input sequence.
N   * @param[in] srcBLen length of the second input sequence.
N   * @param[out] *pDst points to the block of output data  Length srcALen+srcBLen-1.
N   * @param[in]  *pScratch1 points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
N   * @param[in]  *pScratch2 points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen).
N   * @return none.
N   */
N
N  void arm_conv_opt_q7(
N  q7_t * pSrcA,
N  uint32_t srcALen,
N  q7_t * pSrcB,
N  uint32_t srcBLen,
N  q7_t * pDst,
N  q15_t * pScratch1,
N  q15_t * pScratch2);
N
N
N
N  /**
N   * @brief Convolution of Q7 sequences.
N   * @param[in] *pSrcA points to the first input sequence.
N   * @param[in] srcALen length of the first input sequence.
N   * @param[in] *pSrcB points to the second input sequence.
N   * @param[in] srcBLen length of the second input sequence.
N   * @param[out] *pDst points to the block of output data  Length srcALen+srcBLen-1.
N   * @return none.
N   */
N
N  void arm_conv_q7(
N  q7_t * pSrcA,
N  uint32_t srcALen,
N  q7_t * pSrcB,
N  uint32_t srcBLen,
N  q7_t * pDst);
N
N
N  /**
N   * @brief Partial convolution of floating-point sequences.
N   * @param[in]       *pSrcA points to the first input sequence.
N   * @param[in]       srcALen length of the first input sequence.
N   * @param[in]       *pSrcB points to the second input sequence.
N   * @param[in]       srcBLen length of the second input sequence.
N   * @param[out]      *pDst points to the block of output data
N   * @param[in]       firstIndex is the first output sample to start with.
N   * @param[in]       numPoints is the number of output points to be computed.
N   * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].
N   */
N
N  arm_status arm_conv_partial_f32(
N  float32_t * pSrcA,
N  uint32_t srcALen,
N  float32_t * pSrcB,
N  uint32_t srcBLen,
N  float32_t * pDst,
N  uint32_t firstIndex,
N  uint32_t numPoints);
N
N    /**
N   * @brief Partial convolution of Q15 sequences.
N   * @param[in]       *pSrcA points to the first input sequence.
N   * @param[in]       srcALen length of the first input sequence.
N   * @param[in]       *pSrcB points to the second input sequence.
N   * @param[in]       srcBLen length of the second input sequence.
N   * @param[out]      *pDst points to the block of output data
N   * @param[in]       firstIndex is the first output sample to start with.
N   * @param[in]       numPoints is the number of output points to be computed.
N   * @param[in]       * pScratch1 points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
N   * @param[in]       * pScratch2 points to scratch buffer of size min(srcALen, srcBLen).
N   * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].
N   */
N
N  arm_status arm_conv_partial_opt_q15(
N  q15_t * pSrcA,
N  uint32_t srcALen,
N  q15_t * pSrcB,
N  uint32_t srcBLen,
N  q15_t * pDst,
N  uint32_t firstIndex,
N  uint32_t numPoints,
N  q15_t * pScratch1,
N  q15_t * pScratch2);
N
N
N/**
N   * @brief Partial convolution of Q15 sequences.
N   * @param[in]       *pSrcA points to the first input sequence.
N   * @param[in]       srcALen length of the first input sequence.
N   * @param[in]       *pSrcB points to the second input sequence.
N   * @param[in]       srcBLen length of the second input sequence.
N   * @param[out]      *pDst points to the block of output data
N   * @param[in]       firstIndex is the first output sample to start with.
N   * @param[in]       numPoints is the number of output points to be computed.
N   * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].
N   */
N
N  arm_status arm_conv_partial_q15(
N  q15_t * pSrcA,
N  uint32_t srcALen,
N  q15_t * pSrcB,
N  uint32_t srcBLen,
N  q15_t * pDst,
N  uint32_t firstIndex,
N  uint32_t numPoints);
N
N  /**
N   * @brief Partial convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4
N   * @param[in]       *pSrcA points to the first input sequence.
N   * @param[in]       srcALen length of the first input sequence.
N   * @param[in]       *pSrcB points to the second input sequence.
N   * @param[in]       srcBLen length of the second input sequence.
N   * @param[out]      *pDst points to the block of output data
N   * @param[in]       firstIndex is the first output sample to start with.
N   * @param[in]       numPoints is the number of output points to be computed.
N   * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].
N   */
N
N  arm_status arm_conv_partial_fast_q15(
N				        q15_t * pSrcA,
N				       uint32_t srcALen,
N				        q15_t * pSrcB,
N				       uint32_t srcBLen,
N				       q15_t * pDst,
N				       uint32_t firstIndex,
N				       uint32_t numPoints);
N
N
N  /**
N   * @brief Partial convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4
N   * @param[in]       *pSrcA points to the first input sequence.
N   * @param[in]       srcALen length of the first input sequence.
N   * @param[in]       *pSrcB points to the second input sequence.
N   * @param[in]       srcBLen length of the second input sequence.
N   * @param[out]      *pDst points to the block of output data
N   * @param[in]       firstIndex is the first output sample to start with.
N   * @param[in]       numPoints is the number of output points to be computed.
N   * @param[in]       * pScratch1 points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
N   * @param[in]       * pScratch2 points to scratch buffer of size min(srcALen, srcBLen).
N   * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].
N   */
N
N  arm_status arm_conv_partial_fast_opt_q15(
N  q15_t * pSrcA,
N  uint32_t srcALen,
N  q15_t * pSrcB,
N  uint32_t srcBLen,
N  q15_t * pDst,
N  uint32_t firstIndex,
N  uint32_t numPoints,
N  q15_t * pScratch1,
N  q15_t * pScratch2);
N
N
N  /**
N   * @brief Partial convolution of Q31 sequences.
N   * @param[in]       *pSrcA points to the first input sequence.
N   * @param[in]       srcALen length of the first input sequence.
N   * @param[in]       *pSrcB points to the second input sequence.
N   * @param[in]       srcBLen length of the second input sequence.
N   * @param[out]      *pDst points to the block of output data
N   * @param[in]       firstIndex is the first output sample to start with.
N   * @param[in]       numPoints is the number of output points to be computed.
N   * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].
N   */
N
N  arm_status arm_conv_partial_q31(
N  q31_t * pSrcA,
N  uint32_t srcALen,
N  q31_t * pSrcB,
N  uint32_t srcBLen,
N  q31_t * pDst,
N  uint32_t firstIndex,
N  uint32_t numPoints);
N
N
N  /**
N   * @brief Partial convolution of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4
N   * @param[in]       *pSrcA points to the first input sequence.
N   * @param[in]       srcALen length of the first input sequence.
N   * @param[in]       *pSrcB points to the second input sequence.
N   * @param[in]       srcBLen length of the second input sequence.
N   * @param[out]      *pDst points to the block of output data
N   * @param[in]       firstIndex is the first output sample to start with.
N   * @param[in]       numPoints is the number of output points to be computed.
N   * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].
N   */
N
N  arm_status arm_conv_partial_fast_q31(
N  q31_t * pSrcA,
N  uint32_t srcALen,
N  q31_t * pSrcB,
N  uint32_t srcBLen,
N  q31_t * pDst,
N  uint32_t firstIndex,
N  uint32_t numPoints);
N
N
N  /**
N   * @brief Partial convolution of Q7 sequences
N   * @param[in]       *pSrcA points to the first input sequence.
N   * @param[in]       srcALen length of the first input sequence.
N   * @param[in]       *pSrcB points to the second input sequence.
N   * @param[in]       srcBLen length of the second input sequence.
N   * @param[out]      *pDst points to the block of output data
N   * @param[in]       firstIndex is the first output sample to start with.
N   * @param[in]       numPoints is the number of output points to be computed.
N   * @param[in]  *pScratch1 points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
N   * @param[in]  *pScratch2 points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen).
N   * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].
N   */
N
N  arm_status arm_conv_partial_opt_q7(
N  q7_t * pSrcA,
N  uint32_t srcALen,
N  q7_t * pSrcB,
N  uint32_t srcBLen,
N  q7_t * pDst,
N  uint32_t firstIndex,
N  uint32_t numPoints,
N  q15_t * pScratch1,
N  q15_t * pScratch2);
N
N
N/**
N   * @brief Partial convolution of Q7 sequences.
N   * @param[in]       *pSrcA points to the first input sequence.
N   * @param[in]       srcALen length of the first input sequence.
N   * @param[in]       *pSrcB points to the second input sequence.
N   * @param[in]       srcBLen length of the second input sequence.
N   * @param[out]      *pDst points to the block of output data
N   * @param[in]       firstIndex is the first output sample to start with.
N   * @param[in]       numPoints is the number of output points to be computed.
N   * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].
N   */
N
N  arm_status arm_conv_partial_q7(
N  q7_t * pSrcA,
N  uint32_t srcALen,
N  q7_t * pSrcB,
N  uint32_t srcBLen,
N  q7_t * pDst,
N  uint32_t firstIndex,
N  uint32_t numPoints);
N
N
N
N  /**
N   * @brief Instance structure for the Q15 FIR decimator.
N   */
N
N  typedef struct
N  {
N    uint8_t M;                      /**< decimation factor. */
N    uint16_t numTaps;               /**< number of coefficients in the filter. */
N    q15_t *pCoeffs;                  /**< points to the coefficient array. The array is of length numTaps.*/
N    q15_t *pState;                   /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
N  } arm_fir_decimate_instance_q15;
N
N  /**
N   * @brief Instance structure for the Q31 FIR decimator.
N   */
N
N  typedef struct
N  {
N    uint8_t M;                  /**< decimation factor. */
N    uint16_t numTaps;           /**< number of coefficients in the filter. */
N    q31_t *pCoeffs;              /**< points to the coefficient array. The array is of length numTaps.*/
N    q31_t *pState;               /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
N
N  } arm_fir_decimate_instance_q31;
N
N  /**
N   * @brief Instance structure for the floating-point FIR decimator.
N   */
N
N  typedef struct
N  {
N    uint8_t M;                          /**< decimation factor. */
N    uint16_t numTaps;                   /**< number of coefficients in the filter. */
N    float32_t *pCoeffs;                  /**< points to the coefficient array. The array is of length numTaps.*/
N    float32_t *pState;                   /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
N
N  } arm_fir_decimate_instance_f32;
N
N
N
N  /**
N   * @brief Processing function for the floating-point FIR decimator.
N   * @param[in] *S points to an instance of the floating-point FIR decimator structure.
N   * @param[in] *pSrc points to the block of input data.
N   * @param[out] *pDst points to the block of output data
N   * @param[in] blockSize number of input samples to process per call.
N   * @return none
N   */
N
N  void arm_fir_decimate_f32(
N  const arm_fir_decimate_instance_f32 * S,
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Initialization function for the floating-point FIR decimator.
N   * @param[in,out] *S points to an instance of the floating-point FIR decimator structure.
N   * @param[in] numTaps  number of coefficients in the filter.
N   * @param[in] M  decimation factor.
N   * @param[in] *pCoeffs points to the filter coefficients.
N   * @param[in] *pState points to the state buffer.
N   * @param[in] blockSize number of input samples to process per call.
N   * @return    The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if
N   * <code>blockSize</code> is not a multiple of <code>M</code>.
N   */
N
N  arm_status arm_fir_decimate_init_f32(
N  arm_fir_decimate_instance_f32 * S,
N  uint16_t numTaps,
N  uint8_t M,
N  float32_t * pCoeffs,
N  float32_t * pState,
N  uint32_t blockSize);
N
N  /**
N   * @brief Processing function for the Q15 FIR decimator.
N   * @param[in] *S points to an instance of the Q15 FIR decimator structure.
N   * @param[in] *pSrc points to the block of input data.
N   * @param[out] *pDst points to the block of output data
N   * @param[in] blockSize number of input samples to process per call.
N   * @return none
N   */
N
N  void arm_fir_decimate_q15(
N  const arm_fir_decimate_instance_q15 * S,
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Processing function for the Q15 FIR decimator (fast variant) for Cortex-M3 and Cortex-M4.
N   * @param[in] *S points to an instance of the Q15 FIR decimator structure.
N   * @param[in] *pSrc points to the block of input data.
N   * @param[out] *pDst points to the block of output data
N   * @param[in] blockSize number of input samples to process per call.
N   * @return none
N   */
N
N  void arm_fir_decimate_fast_q15(
N  const arm_fir_decimate_instance_q15 * S,
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N
N
N  /**
N   * @brief  Initialization function for the Q15 FIR decimator.
N   * @param[in,out] *S points to an instance of the Q15 FIR decimator structure.
N   * @param[in] numTaps  number of coefficients in the filter.
N   * @param[in] M  decimation factor.
N   * @param[in] *pCoeffs points to the filter coefficients.
N   * @param[in] *pState points to the state buffer.
N   * @param[in] blockSize number of input samples to process per call.
N   * @return    The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if
N   * <code>blockSize</code> is not a multiple of <code>M</code>.
N   */
N
N  arm_status arm_fir_decimate_init_q15(
N  arm_fir_decimate_instance_q15 * S,
N  uint16_t numTaps,
N  uint8_t M,
N  q15_t * pCoeffs,
N  q15_t * pState,
N  uint32_t blockSize);
N
N  /**
N   * @brief Processing function for the Q31 FIR decimator.
N   * @param[in] *S points to an instance of the Q31 FIR decimator structure.
N   * @param[in] *pSrc points to the block of input data.
N   * @param[out] *pDst points to the block of output data
N   * @param[in] blockSize number of input samples to process per call.
N   * @return none
N   */
N
N  void arm_fir_decimate_q31(
N  const arm_fir_decimate_instance_q31 * S,
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Processing function for the Q31 FIR decimator (fast variant) for Cortex-M3 and Cortex-M4.
N   * @param[in] *S points to an instance of the Q31 FIR decimator structure.
N   * @param[in] *pSrc points to the block of input data.
N   * @param[out] *pDst points to the block of output data
N   * @param[in] blockSize number of input samples to process per call.
N   * @return none
N   */
N
N  void arm_fir_decimate_fast_q31(
N  arm_fir_decimate_instance_q31 * S,
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Initialization function for the Q31 FIR decimator.
N   * @param[in,out] *S points to an instance of the Q31 FIR decimator structure.
N   * @param[in] numTaps  number of coefficients in the filter.
N   * @param[in] M  decimation factor.
N   * @param[in] *pCoeffs points to the filter coefficients.
N   * @param[in] *pState points to the state buffer.
N   * @param[in] blockSize number of input samples to process per call.
N   * @return    The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if
N   * <code>blockSize</code> is not a multiple of <code>M</code>.
N   */
N
N  arm_status arm_fir_decimate_init_q31(
N  arm_fir_decimate_instance_q31 * S,
N  uint16_t numTaps,
N  uint8_t M,
N  q31_t * pCoeffs,
N  q31_t * pState,
N  uint32_t blockSize);
N
N
N
N  /**
N   * @brief Instance structure for the Q15 FIR interpolator.
N   */
N
N  typedef struct
N  {
N    uint8_t L;                      /**< upsample factor. */
N    uint16_t phaseLength;           /**< length of each polyphase filter component. */
N    q15_t *pCoeffs;                 /**< points to the coefficient array. The array is of length L*phaseLength. */
N    q15_t *pState;                  /**< points to the state variable array. The array is of length blockSize+phaseLength-1. */
N  } arm_fir_interpolate_instance_q15;
N
N  /**
N   * @brief Instance structure for the Q31 FIR interpolator.
N   */
N
N  typedef struct
N  {
N    uint8_t L;                      /**< upsample factor. */
N    uint16_t phaseLength;           /**< length of each polyphase filter component. */
N    q31_t *pCoeffs;                  /**< points to the coefficient array. The array is of length L*phaseLength. */
N    q31_t *pState;                   /**< points to the state variable array. The array is of length blockSize+phaseLength-1. */
N  } arm_fir_interpolate_instance_q31;
N
N  /**
N   * @brief Instance structure for the floating-point FIR interpolator.
N   */
N
N  typedef struct
N  {
N    uint8_t L;                     /**< upsample factor. */
N    uint16_t phaseLength;          /**< length of each polyphase filter component. */
N    float32_t *pCoeffs;             /**< points to the coefficient array. The array is of length L*phaseLength. */
N    float32_t *pState;              /**< points to the state variable array. The array is of length phaseLength+numTaps-1. */
N  } arm_fir_interpolate_instance_f32;
N
N
N  /**
N   * @brief Processing function for the Q15 FIR interpolator.
N   * @param[in] *S        points to an instance of the Q15 FIR interpolator structure.
N   * @param[in] *pSrc     points to the block of input data.
N   * @param[out] *pDst    points to the block of output data.
N   * @param[in] blockSize number of input samples to process per call.
N   * @return none.
N   */
N
N  void arm_fir_interpolate_q15(
N  const arm_fir_interpolate_instance_q15 * S,
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Initialization function for the Q15 FIR interpolator.
N   * @param[in,out] *S        points to an instance of the Q15 FIR interpolator structure.
N   * @param[in]     L         upsample factor.
N   * @param[in]     numTaps   number of filter coefficients in the filter.
N   * @param[in]     *pCoeffs  points to the filter coefficient buffer.
N   * @param[in]     *pState   points to the state buffer.
N   * @param[in]     blockSize number of input samples to process per call.
N   * @return        The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if
N   * the filter length <code>numTaps</code> is not a multiple of the interpolation factor <code>L</code>.
N   */
N
N  arm_status arm_fir_interpolate_init_q15(
N  arm_fir_interpolate_instance_q15 * S,
N  uint8_t L,
N  uint16_t numTaps,
N  q15_t * pCoeffs,
N  q15_t * pState,
N  uint32_t blockSize);
N
N  /**
N   * @brief Processing function for the Q31 FIR interpolator.
N   * @param[in] *S        points to an instance of the Q15 FIR interpolator structure.
N   * @param[in] *pSrc     points to the block of input data.
N   * @param[out] *pDst    points to the block of output data.
N   * @param[in] blockSize number of input samples to process per call.
N   * @return none.
N   */
N
N  void arm_fir_interpolate_q31(
N  const arm_fir_interpolate_instance_q31 * S,
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Initialization function for the Q31 FIR interpolator.
N   * @param[in,out] *S        points to an instance of the Q31 FIR interpolator structure.
N   * @param[in]     L         upsample factor.
N   * @param[in]     numTaps   number of filter coefficients in the filter.
N   * @param[in]     *pCoeffs  points to the filter coefficient buffer.
N   * @param[in]     *pState   points to the state buffer.
N   * @param[in]     blockSize number of input samples to process per call.
N   * @return        The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if
N   * the filter length <code>numTaps</code> is not a multiple of the interpolation factor <code>L</code>.
N   */
N
N  arm_status arm_fir_interpolate_init_q31(
N  arm_fir_interpolate_instance_q31 * S,
N  uint8_t L,
N  uint16_t numTaps,
N  q31_t * pCoeffs,
N  q31_t * pState,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Processing function for the floating-point FIR interpolator.
N   * @param[in] *S        points to an instance of the floating-point FIR interpolator structure.
N   * @param[in] *pSrc     points to the block of input data.
N   * @param[out] *pDst    points to the block of output data.
N   * @param[in] blockSize number of input samples to process per call.
N   * @return none.
N   */
N
N  void arm_fir_interpolate_f32(
N  const arm_fir_interpolate_instance_f32 * S,
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Initialization function for the floating-point FIR interpolator.
N   * @param[in,out] *S        points to an instance of the floating-point FIR interpolator structure.
N   * @param[in]     L         upsample factor.
N   * @param[in]     numTaps   number of filter coefficients in the filter.
N   * @param[in]     *pCoeffs  points to the filter coefficient buffer.
N   * @param[in]     *pState   points to the state buffer.
N   * @param[in]     blockSize number of input samples to process per call.
N   * @return        The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if
N   * the filter length <code>numTaps</code> is not a multiple of the interpolation factor <code>L</code>.
N   */
N
N  arm_status arm_fir_interpolate_init_f32(
N  arm_fir_interpolate_instance_f32 * S,
N  uint8_t L,
N  uint16_t numTaps,
N  float32_t * pCoeffs,
N  float32_t * pState,
N  uint32_t blockSize);
N
N  /**
N   * @brief Instance structure for the high precision Q31 Biquad cascade filter.
N   */
N
N  typedef struct
N  {
N    uint8_t numStages;       /**< number of 2nd order stages in the filter.  Overall order is 2*numStages. */
N    q63_t *pState;           /**< points to the array of state coefficients.  The array is of length 4*numStages. */
N    q31_t *pCoeffs;          /**< points to the array of coefficients.  The array is of length 5*numStages. */
N    uint8_t postShift;       /**< additional shift, in bits, applied to each output sample. */
N
N  } arm_biquad_cas_df1_32x64_ins_q31;
N
N
N  /**
N   * @param[in]  *S        points to an instance of the high precision Q31 Biquad cascade filter structure.
N   * @param[in]  *pSrc     points to the block of input data.
N   * @param[out] *pDst     points to the block of output data
N   * @param[in]  blockSize number of samples to process.
N   * @return none.
N   */
N
N  void arm_biquad_cas_df1_32x64_q31(
N  const arm_biquad_cas_df1_32x64_ins_q31 * S,
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @param[in,out] *S           points to an instance of the high precision Q31 Biquad cascade filter structure.
N   * @param[in]     numStages    number of 2nd order stages in the filter.
N   * @param[in]     *pCoeffs     points to the filter coefficients.
N   * @param[in]     *pState      points to the state buffer.
N   * @param[in]     postShift    shift to be applied to the output. Varies according to the coefficients format
N   * @return        none
N   */
N
N  void arm_biquad_cas_df1_32x64_init_q31(
N  arm_biquad_cas_df1_32x64_ins_q31 * S,
N  uint8_t numStages,
N  q31_t * pCoeffs,
N  q63_t * pState,
N  uint8_t postShift);
N
N
N
N  /**
N   * @brief Instance structure for the floating-point transposed direct form II Biquad cascade filter.
N   */
N
N  typedef struct
N  {
N    uint8_t numStages;         /**< number of 2nd order stages in the filter.  Overall order is 2*numStages. */
N    float32_t *pState;         /**< points to the array of state coefficients.  The array is of length 2*numStages. */
N    float32_t *pCoeffs;        /**< points to the array of coefficients.  The array is of length 5*numStages. */
N  } arm_biquad_cascade_df2T_instance_f32;
N
N
N
N  /**
N   * @brief Instance structure for the floating-point transposed direct form II Biquad cascade filter.
N   */
N
N  typedef struct
N  {
N    uint8_t numStages;         /**< number of 2nd order stages in the filter.  Overall order is 2*numStages. */
N    float32_t *pState;         /**< points to the array of state coefficients.  The array is of length 4*numStages. */
N    float32_t *pCoeffs;        /**< points to the array of coefficients.  The array is of length 5*numStages. */
N  } arm_biquad_cascade_stereo_df2T_instance_f32;
N
N
N
N  /**
N   * @brief Instance structure for the floating-point transposed direct form II Biquad cascade filter.
N   */
N
N  typedef struct
N  {
N    uint8_t numStages;         /**< number of 2nd order stages in the filter.  Overall order is 2*numStages. */
N    float64_t *pState;         /**< points to the array of state coefficients.  The array is of length 2*numStages. */
N    float64_t *pCoeffs;        /**< points to the array of coefficients.  The array is of length 5*numStages. */
N  } arm_biquad_cascade_df2T_instance_f64;
N
N
N  /**
N   * @brief Processing function for the floating-point transposed direct form II Biquad cascade filter.
N   * @param[in]  *S        points to an instance of the filter data structure.
N   * @param[in]  *pSrc     points to the block of input data.
N   * @param[out] *pDst     points to the block of output data
N   * @param[in]  blockSize number of samples to process.
N   * @return none.
N   */
N
N  void arm_biquad_cascade_df2T_f32(
N  const arm_biquad_cascade_df2T_instance_f32 * S,
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Processing function for the floating-point transposed direct form II Biquad cascade filter. 2 channels
N   * @param[in]  *S        points to an instance of the filter data structure.
N   * @param[in]  *pSrc     points to the block of input data.
N   * @param[out] *pDst     points to the block of output data
N   * @param[in]  blockSize number of samples to process.
N   * @return none.
N   */
N
N  void arm_biquad_cascade_stereo_df2T_f32(
N  const arm_biquad_cascade_stereo_df2T_instance_f32 * S,
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Processing function for the floating-point transposed direct form II Biquad cascade filter.
N   * @param[in]  *S        points to an instance of the filter data structure.
N   * @param[in]  *pSrc     points to the block of input data.
N   * @param[out] *pDst     points to the block of output data
N   * @param[in]  blockSize number of samples to process.
N   * @return none.
N   */
N
N  void arm_biquad_cascade_df2T_f64(
N  const arm_biquad_cascade_df2T_instance_f64 * S,
N  float64_t * pSrc,
N  float64_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Initialization function for the floating-point transposed direct form II Biquad cascade filter.
N   * @param[in,out] *S           points to an instance of the filter data structure.
N   * @param[in]     numStages    number of 2nd order stages in the filter.
N   * @param[in]     *pCoeffs     points to the filter coefficients.
N   * @param[in]     *pState      points to the state buffer.
N   * @return        none
N   */
N
N  void arm_biquad_cascade_df2T_init_f32(
N  arm_biquad_cascade_df2T_instance_f32 * S,
N  uint8_t numStages,
N  float32_t * pCoeffs,
N  float32_t * pState);
N
N
N  /**
N   * @brief  Initialization function for the floating-point transposed direct form II Biquad cascade filter.
N   * @param[in,out] *S           points to an instance of the filter data structure.
N   * @param[in]     numStages    number of 2nd order stages in the filter.
N   * @param[in]     *pCoeffs     points to the filter coefficients.
N   * @param[in]     *pState      points to the state buffer.
N   * @return        none
N   */
N
N  void arm_biquad_cascade_stereo_df2T_init_f32(
N  arm_biquad_cascade_stereo_df2T_instance_f32 * S,
N  uint8_t numStages,
N  float32_t * pCoeffs,
N  float32_t * pState);
N
N
N  /**
N   * @brief  Initialization function for the floating-point transposed direct form II Biquad cascade filter.
N   * @param[in,out] *S           points to an instance of the filter data structure.
N   * @param[in]     numStages    number of 2nd order stages in the filter.
N   * @param[in]     *pCoeffs     points to the filter coefficients.
N   * @param[in]     *pState      points to the state buffer.
N   * @return        none
N   */
N
N  void arm_biquad_cascade_df2T_init_f64(
N  arm_biquad_cascade_df2T_instance_f64 * S,
N  uint8_t numStages,
N  float64_t * pCoeffs,
N  float64_t * pState);
N
N
N
N  /**
N   * @brief Instance structure for the Q15 FIR lattice filter.
N   */
N
N  typedef struct
N  {
N    uint16_t numStages;                          /**< number of filter stages. */
N    q15_t *pState;                               /**< points to the state variable array. The array is of length numStages. */
N    q15_t *pCoeffs;                              /**< points to the coefficient array. The array is of length numStages. */
N  } arm_fir_lattice_instance_q15;
N
N  /**
N   * @brief Instance structure for the Q31 FIR lattice filter.
N   */
N
N  typedef struct
N  {
N    uint16_t numStages;                          /**< number of filter stages. */
N    q31_t *pState;                               /**< points to the state variable array. The array is of length numStages. */
N    q31_t *pCoeffs;                              /**< points to the coefficient array. The array is of length numStages. */
N  } arm_fir_lattice_instance_q31;
N
N  /**
N   * @brief Instance structure for the floating-point FIR lattice filter.
N   */
N
N  typedef struct
N  {
N    uint16_t numStages;                  /**< number of filter stages. */
N    float32_t *pState;                   /**< points to the state variable array. The array is of length numStages. */
N    float32_t *pCoeffs;                  /**< points to the coefficient array. The array is of length numStages. */
N  } arm_fir_lattice_instance_f32;
N
N  /**
N   * @brief Initialization function for the Q15 FIR lattice filter.
N   * @param[in] *S points to an instance of the Q15 FIR lattice structure.
N   * @param[in] numStages  number of filter stages.
N   * @param[in] *pCoeffs points to the coefficient buffer.  The array is of length numStages.
N   * @param[in] *pState points to the state buffer.  The array is of length numStages.
N   * @return none.
N   */
N
N  void arm_fir_lattice_init_q15(
N  arm_fir_lattice_instance_q15 * S,
N  uint16_t numStages,
N  q15_t * pCoeffs,
N  q15_t * pState);
N
N
N  /**
N   * @brief Processing function for the Q15 FIR lattice filter.
N   * @param[in] *S points to an instance of the Q15 FIR lattice structure.
N   * @param[in] *pSrc points to the block of input data.
N   * @param[out] *pDst points to the block of output data.
N   * @param[in] blockSize number of samples to process.
N   * @return none.
N   */
N  void arm_fir_lattice_q15(
N  const arm_fir_lattice_instance_q15 * S,
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Initialization function for the Q31 FIR lattice filter.
N   * @param[in] *S points to an instance of the Q31 FIR lattice structure.
N   * @param[in] numStages  number of filter stages.
N   * @param[in] *pCoeffs points to the coefficient buffer.  The array is of length numStages.
N   * @param[in] *pState points to the state buffer.   The array is of length numStages.
N   * @return none.
N   */
N
N  void arm_fir_lattice_init_q31(
N  arm_fir_lattice_instance_q31 * S,
N  uint16_t numStages,
N  q31_t * pCoeffs,
N  q31_t * pState);
N
N
N  /**
N   * @brief Processing function for the Q31 FIR lattice filter.
N   * @param[in]  *S        points to an instance of the Q31 FIR lattice structure.
N   * @param[in]  *pSrc     points to the block of input data.
N   * @param[out] *pDst     points to the block of output data
N   * @param[in]  blockSize number of samples to process.
N   * @return none.
N   */
N
N  void arm_fir_lattice_q31(
N  const arm_fir_lattice_instance_q31 * S,
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N/**
N * @brief Initialization function for the floating-point FIR lattice filter.
N * @param[in] *S points to an instance of the floating-point FIR lattice structure.
N * @param[in] numStages  number of filter stages.
N * @param[in] *pCoeffs points to the coefficient buffer.  The array is of length numStages.
N * @param[in] *pState points to the state buffer.  The array is of length numStages.
N * @return none.
N */
N
N  void arm_fir_lattice_init_f32(
N  arm_fir_lattice_instance_f32 * S,
N  uint16_t numStages,
N  float32_t * pCoeffs,
N  float32_t * pState);
N
N  /**
N   * @brief Processing function for the floating-point FIR lattice filter.
N   * @param[in]  *S        points to an instance of the floating-point FIR lattice structure.
N   * @param[in]  *pSrc     points to the block of input data.
N   * @param[out] *pDst     points to the block of output data
N   * @param[in]  blockSize number of samples to process.
N   * @return none.
N   */
N
N  void arm_fir_lattice_f32(
N  const arm_fir_lattice_instance_f32 * S,
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Instance structure for the Q15 IIR lattice filter.
N   */
N  typedef struct
N  {
N    uint16_t numStages;                         /**< number of stages in the filter. */
N    q15_t *pState;                              /**< points to the state variable array. The array is of length numStages+blockSize. */
N    q15_t *pkCoeffs;                            /**< points to the reflection coefficient array. The array is of length numStages. */
N    q15_t *pvCoeffs;                            /**< points to the ladder coefficient array. The array is of length numStages+1. */
N  } arm_iir_lattice_instance_q15;
N
N  /**
N   * @brief Instance structure for the Q31 IIR lattice filter.
N   */
N  typedef struct
N  {
N    uint16_t numStages;                         /**< number of stages in the filter. */
N    q31_t *pState;                              /**< points to the state variable array. The array is of length numStages+blockSize. */
N    q31_t *pkCoeffs;                            /**< points to the reflection coefficient array. The array is of length numStages. */
N    q31_t *pvCoeffs;                            /**< points to the ladder coefficient array. The array is of length numStages+1. */
N  } arm_iir_lattice_instance_q31;
N
N  /**
N   * @brief Instance structure for the floating-point IIR lattice filter.
N   */
N  typedef struct
N  {
N    uint16_t numStages;                         /**< number of stages in the filter. */
N    float32_t *pState;                          /**< points to the state variable array. The array is of length numStages+blockSize. */
N    float32_t *pkCoeffs;                        /**< points to the reflection coefficient array. The array is of length numStages. */
N    float32_t *pvCoeffs;                        /**< points to the ladder coefficient array. The array is of length numStages+1. */
N  } arm_iir_lattice_instance_f32;
N
N  /**
N   * @brief Processing function for the floating-point IIR lattice filter.
N   * @param[in] *S points to an instance of the floating-point IIR lattice structure.
N   * @param[in] *pSrc points to the block of input data.
N   * @param[out] *pDst points to the block of output data.
N   * @param[in] blockSize number of samples to process.
N   * @return none.
N   */
N
N  void arm_iir_lattice_f32(
N  const arm_iir_lattice_instance_f32 * S,
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Initialization function for the floating-point IIR lattice filter.
N   * @param[in] *S points to an instance of the floating-point IIR lattice structure.
N   * @param[in] numStages number of stages in the filter.
N   * @param[in] *pkCoeffs points to the reflection coefficient buffer.  The array is of length numStages.
N   * @param[in] *pvCoeffs points to the ladder coefficient buffer.  The array is of length numStages+1.
N   * @param[in] *pState points to the state buffer.  The array is of length numStages+blockSize-1.
N   * @param[in] blockSize number of samples to process.
N   * @return none.
N   */
N
N  void arm_iir_lattice_init_f32(
N  arm_iir_lattice_instance_f32 * S,
N  uint16_t numStages,
N  float32_t * pkCoeffs,
N  float32_t * pvCoeffs,
N  float32_t * pState,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Processing function for the Q31 IIR lattice filter.
N   * @param[in] *S points to an instance of the Q31 IIR lattice structure.
N   * @param[in] *pSrc points to the block of input data.
N   * @param[out] *pDst points to the block of output data.
N   * @param[in] blockSize number of samples to process.
N   * @return none.
N   */
N
N  void arm_iir_lattice_q31(
N  const arm_iir_lattice_instance_q31 * S,
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Initialization function for the Q31 IIR lattice filter.
N   * @param[in] *S points to an instance of the Q31 IIR lattice structure.
N   * @param[in] numStages number of stages in the filter.
N   * @param[in] *pkCoeffs points to the reflection coefficient buffer.  The array is of length numStages.
N   * @param[in] *pvCoeffs points to the ladder coefficient buffer.  The array is of length numStages+1.
N   * @param[in] *pState points to the state buffer.  The array is of length numStages+blockSize.
N   * @param[in] blockSize number of samples to process.
N   * @return none.
N   */
N
N  void arm_iir_lattice_init_q31(
N  arm_iir_lattice_instance_q31 * S,
N  uint16_t numStages,
N  q31_t * pkCoeffs,
N  q31_t * pvCoeffs,
N  q31_t * pState,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Processing function for the Q15 IIR lattice filter.
N   * @param[in] *S points to an instance of the Q15 IIR lattice structure.
N   * @param[in] *pSrc points to the block of input data.
N   * @param[out] *pDst points to the block of output data.
N   * @param[in] blockSize number of samples to process.
N   * @return none.
N   */
N
N  void arm_iir_lattice_q15(
N  const arm_iir_lattice_instance_q15 * S,
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N
N/**
N * @brief Initialization function for the Q15 IIR lattice filter.
N * @param[in] *S points to an instance of the fixed-point Q15 IIR lattice structure.
N * @param[in] numStages  number of stages in the filter.
N * @param[in] *pkCoeffs points to reflection coefficient buffer.  The array is of length numStages.
N * @param[in] *pvCoeffs points to ladder coefficient buffer.  The array is of length numStages+1.
N * @param[in] *pState points to state buffer.  The array is of length numStages+blockSize.
N * @param[in] blockSize number of samples to process per call.
N * @return none.
N */
N
N  void arm_iir_lattice_init_q15(
N  arm_iir_lattice_instance_q15 * S,
N  uint16_t numStages,
N  q15_t * pkCoeffs,
N  q15_t * pvCoeffs,
N  q15_t * pState,
N  uint32_t blockSize);
N
N  /**
N   * @brief Instance structure for the floating-point LMS filter.
N   */
N
N  typedef struct
N  {
N    uint16_t numTaps;    /**< number of coefficients in the filter. */
N    float32_t *pState;   /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
N    float32_t *pCoeffs;  /**< points to the coefficient array. The array is of length numTaps. */
N    float32_t mu;        /**< step size that controls filter coefficient updates. */
N  } arm_lms_instance_f32;
N
N  /**
N   * @brief Processing function for floating-point LMS filter.
N   * @param[in]  *S points to an instance of the floating-point LMS filter structure.
N   * @param[in]  *pSrc points to the block of input data.
N   * @param[in]  *pRef points to the block of reference data.
N   * @param[out] *pOut points to the block of output data.
N   * @param[out] *pErr points to the block of error data.
N   * @param[in]  blockSize number of samples to process.
N   * @return     none.
N   */
N
N  void arm_lms_f32(
N  const arm_lms_instance_f32 * S,
N  float32_t * pSrc,
N  float32_t * pRef,
N  float32_t * pOut,
N  float32_t * pErr,
N  uint32_t blockSize);
N
N  /**
N   * @brief Initialization function for floating-point LMS filter.
N   * @param[in] *S points to an instance of the floating-point LMS filter structure.
N   * @param[in] numTaps  number of filter coefficients.
N   * @param[in] *pCoeffs points to the coefficient buffer.
N   * @param[in] *pState points to state buffer.
N   * @param[in] mu step size that controls filter coefficient updates.
N   * @param[in] blockSize number of samples to process.
N   * @return none.
N   */
N
N  void arm_lms_init_f32(
N  arm_lms_instance_f32 * S,
N  uint16_t numTaps,
N  float32_t * pCoeffs,
N  float32_t * pState,
N  float32_t mu,
N  uint32_t blockSize);
N
N  /**
N   * @brief Instance structure for the Q15 LMS filter.
N   */
N
N  typedef struct
N  {
N    uint16_t numTaps;    /**< number of coefficients in the filter. */
N    q15_t *pState;       /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
N    q15_t *pCoeffs;      /**< points to the coefficient array. The array is of length numTaps. */
N    q15_t mu;            /**< step size that controls filter coefficient updates. */
N    uint32_t postShift;  /**< bit shift applied to coefficients. */
N  } arm_lms_instance_q15;
N
N
N  /**
N   * @brief Initialization function for the Q15 LMS filter.
N   * @param[in] *S points to an instance of the Q15 LMS filter structure.
N   * @param[in] numTaps  number of filter coefficients.
N   * @param[in] *pCoeffs points to the coefficient buffer.
N   * @param[in] *pState points to the state buffer.
N   * @param[in] mu step size that controls filter coefficient updates.
N   * @param[in] blockSize number of samples to process.
N   * @param[in] postShift bit shift applied to coefficients.
N   * @return    none.
N   */
N
N  void arm_lms_init_q15(
N  arm_lms_instance_q15 * S,
N  uint16_t numTaps,
N  q15_t * pCoeffs,
N  q15_t * pState,
N  q15_t mu,
N  uint32_t blockSize,
N  uint32_t postShift);
N
N  /**
N   * @brief Processing function for Q15 LMS filter.
N   * @param[in] *S points to an instance of the Q15 LMS filter structure.
N   * @param[in] *pSrc points to the block of input data.
N   * @param[in] *pRef points to the block of reference data.
N   * @param[out] *pOut points to the block of output data.
N   * @param[out] *pErr points to the block of error data.
N   * @param[in] blockSize number of samples to process.
N   * @return none.
N   */
N
N  void arm_lms_q15(
N  const arm_lms_instance_q15 * S,
N  q15_t * pSrc,
N  q15_t * pRef,
N  q15_t * pOut,
N  q15_t * pErr,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Instance structure for the Q31 LMS filter.
N   */
N
N  typedef struct
N  {
N    uint16_t numTaps;    /**< number of coefficients in the filter. */
N    q31_t *pState;       /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
N    q31_t *pCoeffs;      /**< points to the coefficient array. The array is of length numTaps. */
N    q31_t mu;            /**< step size that controls filter coefficient updates. */
N    uint32_t postShift;  /**< bit shift applied to coefficients. */
N
N  } arm_lms_instance_q31;
N
N  /**
N   * @brief Processing function for Q31 LMS filter.
N   * @param[in]  *S points to an instance of the Q15 LMS filter structure.
N   * @param[in]  *pSrc points to the block of input data.
N   * @param[in]  *pRef points to the block of reference data.
N   * @param[out] *pOut points to the block of output data.
N   * @param[out] *pErr points to the block of error data.
N   * @param[in]  blockSize number of samples to process.
N   * @return     none.
N   */
N
N  void arm_lms_q31(
N  const arm_lms_instance_q31 * S,
N  q31_t * pSrc,
N  q31_t * pRef,
N  q31_t * pOut,
N  q31_t * pErr,
N  uint32_t blockSize);
N
N  /**
N   * @brief Initialization function for Q31 LMS filter.
N   * @param[in] *S points to an instance of the Q31 LMS filter structure.
N   * @param[in] numTaps  number of filter coefficients.
N   * @param[in] *pCoeffs points to coefficient buffer.
N   * @param[in] *pState points to state buffer.
N   * @param[in] mu step size that controls filter coefficient updates.
N   * @param[in] blockSize number of samples to process.
N   * @param[in] postShift bit shift applied to coefficients.
N   * @return none.
N   */
N
N  void arm_lms_init_q31(
N  arm_lms_instance_q31 * S,
N  uint16_t numTaps,
N  q31_t * pCoeffs,
N  q31_t * pState,
N  q31_t mu,
N  uint32_t blockSize,
N  uint32_t postShift);
N
N  /**
N   * @brief Instance structure for the floating-point normalized LMS filter.
N   */
N
N  typedef struct
N  {
N    uint16_t numTaps;     /**< number of coefficients in the filter. */
N    float32_t *pState;    /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
N    float32_t *pCoeffs;   /**< points to the coefficient array. The array is of length numTaps. */
N    float32_t mu;        /**< step size that control filter coefficient updates. */
N    float32_t energy;    /**< saves previous frame energy. */
N    float32_t x0;        /**< saves previous input sample. */
N  } arm_lms_norm_instance_f32;
N
N  /**
N   * @brief Processing function for floating-point normalized LMS filter.
N   * @param[in] *S points to an instance of the floating-point normalized LMS filter structure.
N   * @param[in] *pSrc points to the block of input data.
N   * @param[in] *pRef points to the block of reference data.
N   * @param[out] *pOut points to the block of output data.
N   * @param[out] *pErr points to the block of error data.
N   * @param[in] blockSize number of samples to process.
N   * @return none.
N   */
N
N  void arm_lms_norm_f32(
N  arm_lms_norm_instance_f32 * S,
N  float32_t * pSrc,
N  float32_t * pRef,
N  float32_t * pOut,
N  float32_t * pErr,
N  uint32_t blockSize);
N
N  /**
N   * @brief Initialization function for floating-point normalized LMS filter.
N   * @param[in] *S points to an instance of the floating-point LMS filter structure.
N   * @param[in] numTaps  number of filter coefficients.
N   * @param[in] *pCoeffs points to coefficient buffer.
N   * @param[in] *pState points to state buffer.
N   * @param[in] mu step size that controls filter coefficient updates.
N   * @param[in] blockSize number of samples to process.
N   * @return none.
N   */
N
N  void arm_lms_norm_init_f32(
N  arm_lms_norm_instance_f32 * S,
N  uint16_t numTaps,
N  float32_t * pCoeffs,
N  float32_t * pState,
N  float32_t mu,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Instance structure for the Q31 normalized LMS filter.
N   */
N  typedef struct
N  {
N    uint16_t numTaps;     /**< number of coefficients in the filter. */
N    q31_t *pState;        /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
N    q31_t *pCoeffs;       /**< points to the coefficient array. The array is of length numTaps. */
N    q31_t mu;             /**< step size that controls filter coefficient updates. */
N    uint8_t postShift;    /**< bit shift applied to coefficients. */
N    q31_t *recipTable;    /**< points to the reciprocal initial value table. */
N    q31_t energy;         /**< saves previous frame energy. */
N    q31_t x0;             /**< saves previous input sample. */
N  } arm_lms_norm_instance_q31;
N
N  /**
N   * @brief Processing function for Q31 normalized LMS filter.
N   * @param[in] *S points to an instance of the Q31 normalized LMS filter structure.
N   * @param[in] *pSrc points to the block of input data.
N   * @param[in] *pRef points to the block of reference data.
N   * @param[out] *pOut points to the block of output data.
N   * @param[out] *pErr points to the block of error data.
N   * @param[in] blockSize number of samples to process.
N   * @return none.
N   */
N
N  void arm_lms_norm_q31(
N  arm_lms_norm_instance_q31 * S,
N  q31_t * pSrc,
N  q31_t * pRef,
N  q31_t * pOut,
N  q31_t * pErr,
N  uint32_t blockSize);
N
N  /**
N   * @brief Initialization function for Q31 normalized LMS filter.
N   * @param[in] *S points to an instance of the Q31 normalized LMS filter structure.
N   * @param[in] numTaps  number of filter coefficients.
N   * @param[in] *pCoeffs points to coefficient buffer.
N   * @param[in] *pState points to state buffer.
N   * @param[in] mu step size that controls filter coefficient updates.
N   * @param[in] blockSize number of samples to process.
N   * @param[in] postShift bit shift applied to coefficients.
N   * @return none.
N   */
N
N  void arm_lms_norm_init_q31(
N  arm_lms_norm_instance_q31 * S,
N  uint16_t numTaps,
N  q31_t * pCoeffs,
N  q31_t * pState,
N  q31_t mu,
N  uint32_t blockSize,
N  uint8_t postShift);
N
N  /**
N   * @brief Instance structure for the Q15 normalized LMS filter.
N   */
N
N  typedef struct
N  {
N    uint16_t numTaps;    /**< Number of coefficients in the filter. */
N    q15_t *pState;        /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
N    q15_t *pCoeffs;       /**< points to the coefficient array. The array is of length numTaps. */
N    q15_t mu;            /**< step size that controls filter coefficient updates. */
N    uint8_t postShift;   /**< bit shift applied to coefficients. */
N    q15_t *recipTable;   /**< Points to the reciprocal initial value table. */
N    q15_t energy;        /**< saves previous frame energy. */
N    q15_t x0;            /**< saves previous input sample. */
N  } arm_lms_norm_instance_q15;
N
N  /**
N   * @brief Processing function for Q15 normalized LMS filter.
N   * @param[in] *S points to an instance of the Q15 normalized LMS filter structure.
N   * @param[in] *pSrc points to the block of input data.
N   * @param[in] *pRef points to the block of reference data.
N   * @param[out] *pOut points to the block of output data.
N   * @param[out] *pErr points to the block of error data.
N   * @param[in] blockSize number of samples to process.
N   * @return none.
N   */
N
N  void arm_lms_norm_q15(
N  arm_lms_norm_instance_q15 * S,
N  q15_t * pSrc,
N  q15_t * pRef,
N  q15_t * pOut,
N  q15_t * pErr,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief Initialization function for Q15 normalized LMS filter.
N   * @param[in] *S points to an instance of the Q15 normalized LMS filter structure.
N   * @param[in] numTaps  number of filter coefficients.
N   * @param[in] *pCoeffs points to coefficient buffer.
N   * @param[in] *pState points to state buffer.
N   * @param[in] mu step size that controls filter coefficient updates.
N   * @param[in] blockSize number of samples to process.
N   * @param[in] postShift bit shift applied to coefficients.
N   * @return none.
N   */
N
N  void arm_lms_norm_init_q15(
N  arm_lms_norm_instance_q15 * S,
N  uint16_t numTaps,
N  q15_t * pCoeffs,
N  q15_t * pState,
N  q15_t mu,
N  uint32_t blockSize,
N  uint8_t postShift);
N
N  /**
N   * @brief Correlation of floating-point sequences.
N   * @param[in] *pSrcA points to the first input sequence.
N   * @param[in] srcALen length of the first input sequence.
N   * @param[in] *pSrcB points to the second input sequence.
N   * @param[in] srcBLen length of the second input sequence.
N   * @param[out] *pDst points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
N   * @return none.
N   */
N
N  void arm_correlate_f32(
N  float32_t * pSrcA,
N  uint32_t srcALen,
N  float32_t * pSrcB,
N  uint32_t srcBLen,
N  float32_t * pDst);
N
N
N   /**
N   * @brief Correlation of Q15 sequences
N   * @param[in] *pSrcA points to the first input sequence.
N   * @param[in] srcALen length of the first input sequence.
N   * @param[in] *pSrcB points to the second input sequence.
N   * @param[in] srcBLen length of the second input sequence.
N   * @param[out] *pDst points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
N   * @param[in]  *pScratch points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
N   * @return none.
N   */
N  void arm_correlate_opt_q15(
N  q15_t * pSrcA,
N  uint32_t srcALen,
N  q15_t * pSrcB,
N  uint32_t srcBLen,
N  q15_t * pDst,
N  q15_t * pScratch);
N
N
N  /**
N   * @brief Correlation of Q15 sequences.
N   * @param[in] *pSrcA points to the first input sequence.
N   * @param[in] srcALen length of the first input sequence.
N   * @param[in] *pSrcB points to the second input sequence.
N   * @param[in] srcBLen length of the second input sequence.
N   * @param[out] *pDst points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
N   * @return none.
N   */
N
N  void arm_correlate_q15(
N  q15_t * pSrcA,
N  uint32_t srcALen,
N  q15_t * pSrcB,
N  uint32_t srcBLen,
N  q15_t * pDst);
N
N  /**
N   * @brief Correlation of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4.
N   * @param[in] *pSrcA points to the first input sequence.
N   * @param[in] srcALen length of the first input sequence.
N   * @param[in] *pSrcB points to the second input sequence.
N   * @param[in] srcBLen length of the second input sequence.
N   * @param[out] *pDst points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
N   * @return none.
N   */
N
N  void arm_correlate_fast_q15(
N			       q15_t * pSrcA,
N			      uint32_t srcALen,
N			       q15_t * pSrcB,
N			      uint32_t srcBLen,
N			      q15_t * pDst);
N
N
N
N  /**
N   * @brief Correlation of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4.
N   * @param[in] *pSrcA points to the first input sequence.
N   * @param[in] srcALen length of the first input sequence.
N   * @param[in] *pSrcB points to the second input sequence.
N   * @param[in] srcBLen length of the second input sequence.
N   * @param[out] *pDst points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
N   * @param[in]  *pScratch points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
N   * @return none.
N   */
N
N  void arm_correlate_fast_opt_q15(
N  q15_t * pSrcA,
N  uint32_t srcALen,
N  q15_t * pSrcB,
N  uint32_t srcBLen,
N  q15_t * pDst,
N  q15_t * pScratch);
N
N  /**
N   * @brief Correlation of Q31 sequences.
N   * @param[in] *pSrcA points to the first input sequence.
N   * @param[in] srcALen length of the first input sequence.
N   * @param[in] *pSrcB points to the second input sequence.
N   * @param[in] srcBLen length of the second input sequence.
N   * @param[out] *pDst points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
N   * @return none.
N   */
N
N  void arm_correlate_q31(
N  q31_t * pSrcA,
N  uint32_t srcALen,
N  q31_t * pSrcB,
N  uint32_t srcBLen,
N  q31_t * pDst);
N
N  /**
N   * @brief Correlation of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4
N   * @param[in] *pSrcA points to the first input sequence.
N   * @param[in] srcALen length of the first input sequence.
N   * @param[in] *pSrcB points to the second input sequence.
N   * @param[in] srcBLen length of the second input sequence.
N   * @param[out] *pDst points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
N   * @return none.
N   */
N
N  void arm_correlate_fast_q31(
N  q31_t * pSrcA,
N  uint32_t srcALen,
N  q31_t * pSrcB,
N  uint32_t srcBLen,
N  q31_t * pDst);
N
N
N
N /**
N   * @brief Correlation of Q7 sequences.
N   * @param[in] *pSrcA points to the first input sequence.
N   * @param[in] srcALen length of the first input sequence.
N   * @param[in] *pSrcB points to the second input sequence.
N   * @param[in] srcBLen length of the second input sequence.
N   * @param[out] *pDst points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
N   * @param[in]  *pScratch1 points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
N   * @param[in]  *pScratch2 points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen).
N   * @return none.
N   */
N
N  void arm_correlate_opt_q7(
N  q7_t * pSrcA,
N  uint32_t srcALen,
N  q7_t * pSrcB,
N  uint32_t srcBLen,
N  q7_t * pDst,
N  q15_t * pScratch1,
N  q15_t * pScratch2);
N
N
N  /**
N   * @brief Correlation of Q7 sequences.
N   * @param[in] *pSrcA points to the first input sequence.
N   * @param[in] srcALen length of the first input sequence.
N   * @param[in] *pSrcB points to the second input sequence.
N   * @param[in] srcBLen length of the second input sequence.
N   * @param[out] *pDst points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
N   * @return none.
N   */
N
N  void arm_correlate_q7(
N  q7_t * pSrcA,
N  uint32_t srcALen,
N  q7_t * pSrcB,
N  uint32_t srcBLen,
N  q7_t * pDst);
N
N
N  /**
N   * @brief Instance structure for the floating-point sparse FIR filter.
N   */
N  typedef struct
N  {
N    uint16_t numTaps;             /**< number of coefficients in the filter. */
N    uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the state buffer. */
N    float32_t *pState;            /**< points to the state buffer array. The array is of length maxDelay+blockSize-1. */
N    float32_t *pCoeffs;           /**< points to the coefficient array. The array is of length numTaps.*/
N    uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
N    int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length numTaps. */
N  } arm_fir_sparse_instance_f32;
N
N  /**
N   * @brief Instance structure for the Q31 sparse FIR filter.
N   */
N
N  typedef struct
N  {
N    uint16_t numTaps;             /**< number of coefficients in the filter. */
N    uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the state buffer. */
N    q31_t *pState;                /**< points to the state buffer array. The array is of length maxDelay+blockSize-1. */
N    q31_t *pCoeffs;               /**< points to the coefficient array. The array is of length numTaps.*/
N    uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
N    int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length numTaps. */
N  } arm_fir_sparse_instance_q31;
N
N  /**
N   * @brief Instance structure for the Q15 sparse FIR filter.
N   */
N
N  typedef struct
N  {
N    uint16_t numTaps;             /**< number of coefficients in the filter. */
N    uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the state buffer. */
N    q15_t *pState;                /**< points to the state buffer array. The array is of length maxDelay+blockSize-1. */
N    q15_t *pCoeffs;               /**< points to the coefficient array. The array is of length numTaps.*/
N    uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
N    int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length numTaps. */
N  } arm_fir_sparse_instance_q15;
N
N  /**
N   * @brief Instance structure for the Q7 sparse FIR filter.
N   */
N
N  typedef struct
N  {
N    uint16_t numTaps;             /**< number of coefficients in the filter. */
N    uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the state buffer. */
N    q7_t *pState;                 /**< points to the state buffer array. The array is of length maxDelay+blockSize-1. */
N    q7_t *pCoeffs;                /**< points to the coefficient array. The array is of length numTaps.*/
N    uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
N    int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length numTaps. */
N  } arm_fir_sparse_instance_q7;
N
N  /**
N   * @brief Processing function for the floating-point sparse FIR filter.
N   * @param[in]  *S          points to an instance of the floating-point sparse FIR structure.
N   * @param[in]  *pSrc       points to the block of input data.
N   * @param[out] *pDst       points to the block of output data
N   * @param[in]  *pScratchIn points to a temporary buffer of size blockSize.
N   * @param[in]  blockSize   number of input samples to process per call.
N   * @return none.
N   */
N
N  void arm_fir_sparse_f32(
N  arm_fir_sparse_instance_f32 * S,
N  float32_t * pSrc,
N  float32_t * pDst,
N  float32_t * pScratchIn,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Initialization function for the floating-point sparse FIR filter.
N   * @param[in,out] *S         points to an instance of the floating-point sparse FIR structure.
N   * @param[in]     numTaps    number of nonzero coefficients in the filter.
N   * @param[in]     *pCoeffs   points to the array of filter coefficients.
N   * @param[in]     *pState    points to the state buffer.
N   * @param[in]     *pTapDelay points to the array of offset times.
N   * @param[in]     maxDelay   maximum offset time supported.
N   * @param[in]     blockSize  number of samples that will be processed per block.
N   * @return none
N   */
N
N  void arm_fir_sparse_init_f32(
N  arm_fir_sparse_instance_f32 * S,
N  uint16_t numTaps,
N  float32_t * pCoeffs,
N  float32_t * pState,
N  int32_t * pTapDelay,
N  uint16_t maxDelay,
N  uint32_t blockSize);
N
N  /**
N   * @brief Processing function for the Q31 sparse FIR filter.
N   * @param[in]  *S          points to an instance of the Q31 sparse FIR structure.
N   * @param[in]  *pSrc       points to the block of input data.
N   * @param[out] *pDst       points to the block of output data
N   * @param[in]  *pScratchIn points to a temporary buffer of size blockSize.
N   * @param[in]  blockSize   number of input samples to process per call.
N   * @return none.
N   */
N
N  void arm_fir_sparse_q31(
N  arm_fir_sparse_instance_q31 * S,
N  q31_t * pSrc,
N  q31_t * pDst,
N  q31_t * pScratchIn,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Initialization function for the Q31 sparse FIR filter.
N   * @param[in,out] *S         points to an instance of the Q31 sparse FIR structure.
N   * @param[in]     numTaps    number of nonzero coefficients in the filter.
N   * @param[in]     *pCoeffs   points to the array of filter coefficients.
N   * @param[in]     *pState    points to the state buffer.
N   * @param[in]     *pTapDelay points to the array of offset times.
N   * @param[in]     maxDelay   maximum offset time supported.
N   * @param[in]     blockSize  number of samples that will be processed per block.
N   * @return none
N   */
N
N  void arm_fir_sparse_init_q31(
N  arm_fir_sparse_instance_q31 * S,
N  uint16_t numTaps,
N  q31_t * pCoeffs,
N  q31_t * pState,
N  int32_t * pTapDelay,
N  uint16_t maxDelay,
N  uint32_t blockSize);
N
N  /**
N   * @brief Processing function for the Q15 sparse FIR filter.
N   * @param[in]  *S           points to an instance of the Q15 sparse FIR structure.
N   * @param[in]  *pSrc        points to the block of input data.
N   * @param[out] *pDst        points to the block of output data
N   * @param[in]  *pScratchIn  points to a temporary buffer of size blockSize.
N   * @param[in]  *pScratchOut points to a temporary buffer of size blockSize.
N   * @param[in]  blockSize    number of input samples to process per call.
N   * @return none.
N   */
N
N  void arm_fir_sparse_q15(
N  arm_fir_sparse_instance_q15 * S,
N  q15_t * pSrc,
N  q15_t * pDst,
N  q15_t * pScratchIn,
N  q31_t * pScratchOut,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Initialization function for the Q15 sparse FIR filter.
N   * @param[in,out] *S         points to an instance of the Q15 sparse FIR structure.
N   * @param[in]     numTaps    number of nonzero coefficients in the filter.
N   * @param[in]     *pCoeffs   points to the array of filter coefficients.
N   * @param[in]     *pState    points to the state buffer.
N   * @param[in]     *pTapDelay points to the array of offset times.
N   * @param[in]     maxDelay   maximum offset time supported.
N   * @param[in]     blockSize  number of samples that will be processed per block.
N   * @return none
N   */
N
N  void arm_fir_sparse_init_q15(
N  arm_fir_sparse_instance_q15 * S,
N  uint16_t numTaps,
N  q15_t * pCoeffs,
N  q15_t * pState,
N  int32_t * pTapDelay,
N  uint16_t maxDelay,
N  uint32_t blockSize);
N
N  /**
N   * @brief Processing function for the Q7 sparse FIR filter.
N   * @param[in]  *S           points to an instance of the Q7 sparse FIR structure.
N   * @param[in]  *pSrc        points to the block of input data.
N   * @param[out] *pDst        points to the block of output data
N   * @param[in]  *pScratchIn  points to a temporary buffer of size blockSize.
N   * @param[in]  *pScratchOut points to a temporary buffer of size blockSize.
N   * @param[in]  blockSize    number of input samples to process per call.
N   * @return none.
N   */
N
N  void arm_fir_sparse_q7(
N  arm_fir_sparse_instance_q7 * S,
N  q7_t * pSrc,
N  q7_t * pDst,
N  q7_t * pScratchIn,
N  q31_t * pScratchOut,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Initialization function for the Q7 sparse FIR filter.
N   * @param[in,out] *S         points to an instance of the Q7 sparse FIR structure.
N   * @param[in]     numTaps    number of nonzero coefficients in the filter.
N   * @param[in]     *pCoeffs   points to the array of filter coefficients.
N   * @param[in]     *pState    points to the state buffer.
N   * @param[in]     *pTapDelay points to the array of offset times.
N   * @param[in]     maxDelay   maximum offset time supported.
N   * @param[in]     blockSize  number of samples that will be processed per block.
N   * @return none
N   */
N
N  void arm_fir_sparse_init_q7(
N  arm_fir_sparse_instance_q7 * S,
N  uint16_t numTaps,
N  q7_t * pCoeffs,
N  q7_t * pState,
N  int32_t * pTapDelay,
N  uint16_t maxDelay,
N  uint32_t blockSize);
N
N
N  /*
N   * @brief  Floating-point sin_cos function.
N   * @param[in]  theta    input value in degrees
N   * @param[out] *pSinVal points to the processed sine output.
N   * @param[out] *pCosVal points to the processed cos output.
N   * @return none.
N   */
N
N  void arm_sin_cos_f32(
N  float32_t theta,
N  float32_t * pSinVal,
N  float32_t * pCcosVal);
N
N  /*
N   * @brief  Q31 sin_cos function.
N   * @param[in]  theta    scaled input value in degrees
N   * @param[out] *pSinVal points to the processed sine output.
N   * @param[out] *pCosVal points to the processed cosine output.
N   * @return none.
N   */
N
N  void arm_sin_cos_q31(
N  q31_t theta,
N  q31_t * pSinVal,
N  q31_t * pCosVal);
N
N
N  /**
N   * @brief  Floating-point complex conjugate.
N   * @param[in]  *pSrc points to the input vector
N   * @param[out]  *pDst points to the output vector
N   * @param[in]  numSamples number of complex samples in each vector
N   * @return none.
N   */
N
N  void arm_cmplx_conj_f32(
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t numSamples);
N
N  /**
N   * @brief  Q31 complex conjugate.
N   * @param[in]  *pSrc points to the input vector
N   * @param[out]  *pDst points to the output vector
N   * @param[in]  numSamples number of complex samples in each vector
N   * @return none.
N   */
N
N  void arm_cmplx_conj_q31(
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t numSamples);
N
N  /**
N   * @brief  Q15 complex conjugate.
N   * @param[in]  *pSrc points to the input vector
N   * @param[out]  *pDst points to the output vector
N   * @param[in]  numSamples number of complex samples in each vector
N   * @return none.
N   */
N
N  void arm_cmplx_conj_q15(
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t numSamples);
N
N
N
N  /**
N   * @brief  Floating-point complex magnitude squared
N   * @param[in]  *pSrc points to the complex input vector
N   * @param[out]  *pDst points to the real output vector
N   * @param[in]  numSamples number of complex samples in the input vector
N   * @return none.
N   */
N
N  void arm_cmplx_mag_squared_f32(
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t numSamples);
N
N  /**
N   * @brief  Q31 complex magnitude squared
N   * @param[in]  *pSrc points to the complex input vector
N   * @param[out]  *pDst points to the real output vector
N   * @param[in]  numSamples number of complex samples in the input vector
N   * @return none.
N   */
N
N  void arm_cmplx_mag_squared_q31(
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t numSamples);
N
N  /**
N   * @brief  Q15 complex magnitude squared
N   * @param[in]  *pSrc points to the complex input vector
N   * @param[out]  *pDst points to the real output vector
N   * @param[in]  numSamples number of complex samples in the input vector
N   * @return none.
N   */
N
N  void arm_cmplx_mag_squared_q15(
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t numSamples);
N
N
N /**
N   * @ingroup groupController
N   */
N
N  /**
N   * @defgroup PID PID Motor Control
N   *
N   * A Proportional Integral Derivative (PID) controller is a generic feedback control
N   * loop mechanism widely used in industrial control systems.
N   * A PID controller is the most commonly used type of feedback controller.
N   *
N   * This set of functions implements (PID) controllers
N   * for Q15, Q31, and floating-point data types.  The functions operate on a single sample
N   * of data and each call to the function returns a single processed value.
N   * <code>S</code> points to an instance of the PID control data structure.  <code>in</code>
N   * is the input sample value. The functions return the output value.
N   *
N   * \par Algorithm:
N   * <pre>
N   *    y[n] = y[n-1] + A0 * x[n] + A1 * x[n-1] + A2 * x[n-2]
N   *    A0 = Kp + Ki + Kd
N   *    A1 = (-Kp ) - (2 * Kd )
N   *    A2 = Kd  </pre>
N   *
N   * \par
N   * where \c Kp is proportional constant, \c Ki is Integral constant and \c Kd is Derivative constant
N   *
N   * \par
N   * \image html PID.gif "Proportional Integral Derivative Controller"
N   *
N   * \par
N   * The PID controller calculates an "error" value as the difference between
N   * the measured output and the reference input.
N   * The controller attempts to minimize the error by adjusting the process control inputs.
N   * The proportional value determines the reaction to the current error,
N   * the integral value determines the reaction based on the sum of recent errors,
N   * and the derivative value determines the reaction based on the rate at which the error has been changing.
N   *
N   * \par Instance Structure
N   * The Gains A0, A1, A2 and state variables for a PID controller are stored together in an instance data structure.
N   * A separate instance structure must be defined for each PID Controller.
N   * There are separate instance structure declarations for each of the 3 supported data types.
N   *
N   * \par Reset Functions
N   * There is also an associated reset function for each data type which clears the state array.
N   *
N   * \par Initialization Functions
N   * There is also an associated initialization function for each data type.
N   * The initialization function performs the following operations:
N   * - Initializes the Gains A0, A1, A2 from Kp,Ki, Kd gains.
N   * - Zeros out the values in the state buffer.
N   *
N   * \par
N   * Instance structure cannot be placed into a const data section and it is recommended to use the initialization function.
N   *
N   * \par Fixed-Point Behavior
N   * Care must be taken when using the fixed-point versions of the PID Controller functions.
N   * In particular, the overflow and saturation behavior of the accumulator used in each function must be considered.
N   * Refer to the function specific documentation below for usage guidelines.
N   */
N
N  /**
N   * @addtogroup PID
N   * @{
N   */
N
N  /**
N   * @brief  Process function for the floating-point PID Control.
N   * @param[in,out] *S is an instance of the floating-point PID Control structure
N   * @param[in] in input sample to process
N   * @return out processed output sample.
N   */
N
N  static __INLINE float32_t arm_pid_f32
X  static __inline float32_t arm_pid_f32
N  (
N  arm_pid_instance_f32 * S,
N  float32_t in)
N  {
N    float32_t out;
N
N    /* y[n] = y[n-1] + A0 * x[n] + A1 * x[n-1] + A2 * x[n-2]  */
N    out = (S->A0 * in) +
N      (S->A1 * S->state[0]) + (S->A2 * S->state[1]) + (S->state[2]);
N
N    /* Update state */
N    S->state[1] = S->state[0];
N    S->state[0] = in;
N    S->state[2] = out;
N
N    /* return to application */
N    return (out);
N
N  }
N
N  /**
N   * @brief  Process function for the Q31 PID Control.
N   * @param[in,out] *S points to an instance of the Q31 PID Control structure
N   * @param[in] in input sample to process
N   * @return out processed output sample.
N   *
N   * <b>Scaling and Overflow Behavior:</b>
N   * \par
N   * The function is implemented using an internal 64-bit accumulator.
N   * The accumulator has a 2.62 format and maintains full precision of the intermediate multiplication results but provides only a single guard bit.
N   * Thus, if the accumulator result overflows it wraps around rather than clip.
N   * In order to avoid overflows completely the input signal must be scaled down by 2 bits as there are four additions.
N   * After all multiply-accumulates are performed, the 2.62 accumulator is truncated to 1.32 format and then saturated to 1.31 format.
N   */
N
N  static __INLINE q31_t arm_pid_q31(
X  static __inline q31_t arm_pid_q31(
N  arm_pid_instance_q31 * S,
N  q31_t in)
N  {
N    q63_t acc;
N    q31_t out;
N
N    /* acc = A0 * x[n]  */
N    acc = (q63_t) S->A0 * in;
N
N    /* acc += A1 * x[n-1] */
N    acc += (q63_t) S->A1 * S->state[0];
N
N    /* acc += A2 * x[n-2]  */
N    acc += (q63_t) S->A2 * S->state[1];
N
N    /* convert output to 1.31 format to add y[n-1] */
N    out = (q31_t) (acc >> 31u);
N
N    /* out += y[n-1] */
N    out += S->state[2];
N
N    /* Update state */
N    S->state[1] = S->state[0];
N    S->state[0] = in;
N    S->state[2] = out;
N
N    /* return to application */
N    return (out);
N
N  }
N
N  /**
N   * @brief  Process function for the Q15 PID Control.
N   * @param[in,out] *S points to an instance of the Q15 PID Control structure
N   * @param[in] in input sample to process
N   * @return out processed output sample.
N   *
N   * <b>Scaling and Overflow Behavior:</b>
N   * \par
N   * The function is implemented using a 64-bit internal accumulator.
N   * Both Gains and state variables are represented in 1.15 format and multiplications yield a 2.30 result.
N   * The 2.30 intermediate results are accumulated in a 64-bit accumulator in 34.30 format.
N   * There is no risk of internal overflow with this approach and the full precision of intermediate multiplications is preserved.
N   * After all additions have been performed, the accumulator is truncated to 34.15 format by discarding low 15 bits.
N   * Lastly, the accumulator is saturated to yield a result in 1.15 format.
N   */
N
N  static __INLINE q15_t arm_pid_q15(
X  static __inline q15_t arm_pid_q15(
N  arm_pid_instance_q15 * S,
N  q15_t in)
N  {
N    q63_t acc;
N    q15_t out;
N
N#ifndef ARM_MATH_CM0_FAMILY
N    __SIMD32_TYPE *vstate;
X    int32_t __packed *vstate;
N
N    /* Implementation of PID controller */
N
N    /* acc = A0 * x[n]  */
N    acc = (q31_t) __SMUAD(S->A0, in);
X    acc = (q31_t) __smuad(S->A0, in);
N
N    /* acc += A1 * x[n-1] + A2 * x[n-2]  */
N    vstate = __SIMD32_CONST(S->state);
X    vstate = ((int32_t __packed *)(S->state));
N    acc = __SMLALD(S->A1, (q31_t) *vstate, acc);
X    acc = __smlald(S->A1, (q31_t) *vstate, acc);
N
N#else
S    /* acc = A0 * x[n]  */
S    acc = ((q31_t) S->A0) * in;
S
S    /* acc += A1 * x[n-1] + A2 * x[n-2]  */
S    acc += (q31_t) S->A1 * S->state[0];
S    acc += (q31_t) S->A2 * S->state[1];
S
N#endif
N
N    /* acc += y[n-1] */
N    acc += (q31_t) S->state[2] << 15;
N
N    /* saturate the output */
N    out = (q15_t) (__SSAT((acc >> 15), 16));
X    out = (q15_t) (__ssat((acc >> 15), 16));
N
N    /* Update state */
N    S->state[1] = S->state[0];
N    S->state[0] = in;
N    S->state[2] = out;
N
N    /* return to application */
N    return (out);
N
N  }
N
N  /**
N   * @} end of PID group
N   */
N
N
N  /**
N   * @brief Floating-point matrix inverse.
N   * @param[in]  *src points to the instance of the input floating-point matrix structure.
N   * @param[out] *dst points to the instance of the output floating-point matrix structure.
N   * @return The function returns ARM_MATH_SIZE_MISMATCH, if the dimensions do not match.
N   * If the input matrix is singular (does not have an inverse), then the algorithm terminates and returns error status ARM_MATH_SINGULAR.
N   */
N
N  arm_status arm_mat_inverse_f32(
N  const arm_matrix_instance_f32 * src,
N  arm_matrix_instance_f32 * dst);
N
N
N  /**
N   * @brief Floating-point matrix inverse.
N   * @param[in]  *src points to the instance of the input floating-point matrix structure.
N   * @param[out] *dst points to the instance of the output floating-point matrix structure.
N   * @return The function returns ARM_MATH_SIZE_MISMATCH, if the dimensions do not match.
N   * If the input matrix is singular (does not have an inverse), then the algorithm terminates and returns error status ARM_MATH_SINGULAR.
N   */
N
N  arm_status arm_mat_inverse_f64(
N  const arm_matrix_instance_f64 * src,
N  arm_matrix_instance_f64 * dst);
N
N
N
N  /**
N   * @ingroup groupController
N   */
N
N
N  /**
N   * @defgroup clarke Vector Clarke Transform
N   * Forward Clarke transform converts the instantaneous stator phases into a two-coordinate time invariant vector.
N   * Generally the Clarke transform uses three-phase currents <code>Ia, Ib and Ic</code> to calculate currents
N   * in the two-phase orthogonal stator axis <code>Ialpha</code> and <code>Ibeta</code>.
N   * When <code>Ialpha</code> is superposed with <code>Ia</code> as shown in the figure below
N   * \image html clarke.gif Stator current space vector and its components in (a,b).
N   * and <code>Ia + Ib + Ic = 0</code>, in this condition <code>Ialpha</code> and <code>Ibeta</code>
N   * can be calculated using only <code>Ia</code> and <code>Ib</code>.
N   *
N   * The function operates on a single sample of data and each call to the function returns the processed output.
N   * The library provides separate functions for Q31 and floating-point data types.
N   * \par Algorithm
N   * \image html clarkeFormula.gif
N   * where <code>Ia</code> and <code>Ib</code> are the instantaneous stator phases and
N   * <code>pIalpha</code> and <code>pIbeta</code> are the two coordinates of time invariant vector.
N   * \par Fixed-Point Behavior
N   * Care must be taken when using the Q31 version of the Clarke transform.
N   * In particular, the overflow and saturation behavior of the accumulator used must be considered.
N   * Refer to the function specific documentation below for usage guidelines.
N   */
N
N  /**
N   * @addtogroup clarke
N   * @{
N   */
N
N  /**
N   *
N   * @brief  Floating-point Clarke transform
N   * @param[in]       Ia       input three-phase coordinate <code>a</code>
N   * @param[in]       Ib       input three-phase coordinate <code>b</code>
N   * @param[out]      *pIalpha points to output two-phase orthogonal vector axis alpha
N   * @param[out]      *pIbeta  points to output two-phase orthogonal vector axis beta
N   * @return none.
N   */
N
N  static __INLINE void arm_clarke_f32(
X  static __inline void arm_clarke_f32(
N  float32_t Ia,
N  float32_t Ib,
N  float32_t * pIalpha,
N  float32_t * pIbeta)
N  {
N    /* Calculate pIalpha using the equation, pIalpha = Ia */
N    *pIalpha = Ia;
N
N    /* Calculate pIbeta using the equation, pIbeta = (1/sqrt(3)) * Ia + (2/sqrt(3)) * Ib */
N    *pIbeta =
N      ((float32_t) 0.57735026919 * Ia + (float32_t) 1.15470053838 * Ib);
N
N  }
N
N  /**
N   * @brief  Clarke transform for Q31 version
N   * @param[in]       Ia       input three-phase coordinate <code>a</code>
N   * @param[in]       Ib       input three-phase coordinate <code>b</code>
N   * @param[out]      *pIalpha points to output two-phase orthogonal vector axis alpha
N   * @param[out]      *pIbeta  points to output two-phase orthogonal vector axis beta
N   * @return none.
N   *
N   * <b>Scaling and Overflow Behavior:</b>
N   * \par
N   * The function is implemented using an internal 32-bit accumulator.
N   * The accumulator maintains 1.31 format by truncating lower 31 bits of the intermediate multiplication in 2.62 format.
N   * There is saturation on the addition, hence there is no risk of overflow.
N   */
N
N  static __INLINE void arm_clarke_q31(
X  static __inline void arm_clarke_q31(
N  q31_t Ia,
N  q31_t Ib,
N  q31_t * pIalpha,
N  q31_t * pIbeta)
N  {
N    q31_t product1, product2;                    /* Temporary variables used to store intermediate results */
N
N    /* Calculating pIalpha from Ia by equation pIalpha = Ia */
N    *pIalpha = Ia;
N
N    /* Intermediate product is calculated by (1/(sqrt(3)) * Ia) */
N    product1 = (q31_t) (((q63_t) Ia * 0x24F34E8B) >> 30);
N
N    /* Intermediate product is calculated by (2/sqrt(3) * Ib) */
N    product2 = (q31_t) (((q63_t) Ib * 0x49E69D16) >> 30);
N
N    /* pIbeta is calculated by adding the intermediate products */
N    *pIbeta = __QADD(product1, product2);
X    *pIbeta = __qadd(product1, product2);
N  }
N
N  /**
N   * @} end of clarke group
N   */
N
N  /**
N   * @brief  Converts the elements of the Q7 vector to Q31 vector.
N   * @param[in]  *pSrc     input pointer
N   * @param[out]  *pDst    output pointer
N   * @param[in]  blockSize number of samples to process
N   * @return none.
N   */
N  void arm_q7_to_q31(
N  q7_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N
N
N
N  /**
N   * @ingroup groupController
N   */
N
N  /**
N   * @defgroup inv_clarke Vector Inverse Clarke Transform
N   * Inverse Clarke transform converts the two-coordinate time invariant vector into instantaneous stator phases.
N   *
N   * The function operates on a single sample of data and each call to the function returns the processed output.
N   * The library provides separate functions for Q31 and floating-point data types.
N   * \par Algorithm
N   * \image html clarkeInvFormula.gif
N   * where <code>pIa</code> and <code>pIb</code> are the instantaneous stator phases and
N   * <code>Ialpha</code> and <code>Ibeta</code> are the two coordinates of time invariant vector.
N   * \par Fixed-Point Behavior
N   * Care must be taken when using the Q31 version of the Clarke transform.
N   * In particular, the overflow and saturation behavior of the accumulator used must be considered.
N   * Refer to the function specific documentation below for usage guidelines.
N   */
N
N  /**
N   * @addtogroup inv_clarke
N   * @{
N   */
N
N   /**
N   * @brief  Floating-point Inverse Clarke transform
N   * @param[in]       Ialpha  input two-phase orthogonal vector axis alpha
N   * @param[in]       Ibeta   input two-phase orthogonal vector axis beta
N   * @param[out]      *pIa    points to output three-phase coordinate <code>a</code>
N   * @param[out]      *pIb    points to output three-phase coordinate <code>b</code>
N   * @return none.
N   */
N
N
N  static __INLINE void arm_inv_clarke_f32(
X  static __inline void arm_inv_clarke_f32(
N  float32_t Ialpha,
N  float32_t Ibeta,
N  float32_t * pIa,
N  float32_t * pIb)
N  {
N    /* Calculating pIa from Ialpha by equation pIa = Ialpha */
N    *pIa = Ialpha;
N
N    /* Calculating pIb from Ialpha and Ibeta by equation pIb = -(1/2) * Ialpha + (sqrt(3)/2) * Ibeta */
N    *pIb = -0.5 * Ialpha + (float32_t) 0.8660254039 *Ibeta;
N
N  }
N
N  /**
N   * @brief  Inverse Clarke transform for Q31 version
N   * @param[in]       Ialpha  input two-phase orthogonal vector axis alpha
N   * @param[in]       Ibeta   input two-phase orthogonal vector axis beta
N   * @param[out]      *pIa    points to output three-phase coordinate <code>a</code>
N   * @param[out]      *pIb    points to output three-phase coordinate <code>b</code>
N   * @return none.
N   *
N   * <b>Scaling and Overflow Behavior:</b>
N   * \par
N   * The function is implemented using an internal 32-bit accumulator.
N   * The accumulator maintains 1.31 format by truncating lower 31 bits of the intermediate multiplication in 2.62 format.
N   * There is saturation on the subtraction, hence there is no risk of overflow.
N   */
N
N  static __INLINE void arm_inv_clarke_q31(
X  static __inline void arm_inv_clarke_q31(
N  q31_t Ialpha,
N  q31_t Ibeta,
N  q31_t * pIa,
N  q31_t * pIb)
N  {
N    q31_t product1, product2;                    /* Temporary variables used to store intermediate results */
N
N    /* Calculating pIa from Ialpha by equation pIa = Ialpha */
N    *pIa = Ialpha;
N
N    /* Intermediate product is calculated by (1/(2*sqrt(3)) * Ia) */
N    product1 = (q31_t) (((q63_t) (Ialpha) * (0x40000000)) >> 31);
N
N    /* Intermediate product is calculated by (1/sqrt(3) * pIb) */
N    product2 = (q31_t) (((q63_t) (Ibeta) * (0x6ED9EBA1)) >> 31);
N
N    /* pIb is calculated by subtracting the products */
N    *pIb = __QSUB(product2, product1);
X    *pIb = __qsub(product2, product1);
N
N  }
N
N  /**
N   * @} end of inv_clarke group
N   */
N
N  /**
N   * @brief  Converts the elements of the Q7 vector to Q15 vector.
N   * @param[in]  *pSrc     input pointer
N   * @param[out] *pDst     output pointer
N   * @param[in]  blockSize number of samples to process
N   * @return none.
N   */
N  void arm_q7_to_q15(
N  q7_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N
N
N  /**
N   * @ingroup groupController
N   */
N
N  /**
N   * @defgroup park Vector Park Transform
N   *
N   * Forward Park transform converts the input two-coordinate vector to flux and torque components.
N   * The Park transform can be used to realize the transformation of the <code>Ialpha</code> and the <code>Ibeta</code> currents
N   * from the stationary to the moving reference frame and control the spatial relationship between
N   * the stator vector current and rotor flux vector.
N   * If we consider the d axis aligned with the rotor flux, the diagram below shows the
N   * current vector and the relationship from the two reference frames:
N   * \image html park.gif "Stator current space vector and its component in (a,b) and in the d,q rotating reference frame"
N   *
N   * The function operates on a single sample of data and each call to the function returns the processed output.
N   * The library provides separate functions for Q31 and floating-point data types.
N   * \par Algorithm
N   * \image html parkFormula.gif
N   * where <code>Ialpha</code> and <code>Ibeta</code> are the stator vector components,
N   * <code>pId</code> and <code>pIq</code> are rotor vector components and <code>cosVal</code> and <code>sinVal</code> are the
N   * cosine and sine values of theta (rotor flux position).
N   * \par Fixed-Point Behavior
N   * Care must be taken when using the Q31 version of the Park transform.
N   * In particular, the overflow and saturation behavior of the accumulator used must be considered.
N   * Refer to the function specific documentation below for usage guidelines.
N   */
N
N  /**
N   * @addtogroup park
N   * @{
N   */
N
N  /**
N   * @brief Floating-point Park transform
N   * @param[in]       Ialpha input two-phase vector coordinate alpha
N   * @param[in]       Ibeta  input two-phase vector coordinate beta
N   * @param[out]      *pId   points to output	rotor reference frame d
N   * @param[out]      *pIq   points to output	rotor reference frame q
N   * @param[in]       sinVal sine value of rotation angle theta
N   * @param[in]       cosVal cosine value of rotation angle theta
N   * @return none.
N   *
N   * The function implements the forward Park transform.
N   *
N   */
N
N  static __INLINE void arm_park_f32(
X  static __inline void arm_park_f32(
N  float32_t Ialpha,
N  float32_t Ibeta,
N  float32_t * pId,
N  float32_t * pIq,
N  float32_t sinVal,
N  float32_t cosVal)
N  {
N    /* Calculate pId using the equation, pId = Ialpha * cosVal + Ibeta * sinVal */
N    *pId = Ialpha * cosVal + Ibeta * sinVal;
N
N    /* Calculate pIq using the equation, pIq = - Ialpha * sinVal + Ibeta * cosVal */
N    *pIq = -Ialpha * sinVal + Ibeta * cosVal;
N
N  }
N
N  /**
N   * @brief  Park transform for Q31 version
N   * @param[in]       Ialpha input two-phase vector coordinate alpha
N   * @param[in]       Ibeta  input two-phase vector coordinate beta
N   * @param[out]      *pId   points to output rotor reference frame d
N   * @param[out]      *pIq   points to output rotor reference frame q
N   * @param[in]       sinVal sine value of rotation angle theta
N   * @param[in]       cosVal cosine value of rotation angle theta
N   * @return none.
N   *
N   * <b>Scaling and Overflow Behavior:</b>
N   * \par
N   * The function is implemented using an internal 32-bit accumulator.
N   * The accumulator maintains 1.31 format by truncating lower 31 bits of the intermediate multiplication in 2.62 format.
N   * There is saturation on the addition and subtraction, hence there is no risk of overflow.
N   */
N
N
N  static __INLINE void arm_park_q31(
X  static __inline void arm_park_q31(
N  q31_t Ialpha,
N  q31_t Ibeta,
N  q31_t * pId,
N  q31_t * pIq,
N  q31_t sinVal,
N  q31_t cosVal)
N  {
N    q31_t product1, product2;                    /* Temporary variables used to store intermediate results */
N    q31_t product3, product4;                    /* Temporary variables used to store intermediate results */
N
N    /* Intermediate product is calculated by (Ialpha * cosVal) */
N    product1 = (q31_t) (((q63_t) (Ialpha) * (cosVal)) >> 31);
N
N    /* Intermediate product is calculated by (Ibeta * sinVal) */
N    product2 = (q31_t) (((q63_t) (Ibeta) * (sinVal)) >> 31);
N
N
N    /* Intermediate product is calculated by (Ialpha * sinVal) */
N    product3 = (q31_t) (((q63_t) (Ialpha) * (sinVal)) >> 31);
N
N    /* Intermediate product is calculated by (Ibeta * cosVal) */
N    product4 = (q31_t) (((q63_t) (Ibeta) * (cosVal)) >> 31);
N
N    /* Calculate pId by adding the two intermediate products 1 and 2 */
N    *pId = __QADD(product1, product2);
X    *pId = __qadd(product1, product2);
N
N    /* Calculate pIq by subtracting the two intermediate products 3 from 4 */
N    *pIq = __QSUB(product4, product3);
X    *pIq = __qsub(product4, product3);
N  }
N
N  /**
N   * @} end of park group
N   */
N
N  /**
N   * @brief  Converts the elements of the Q7 vector to floating-point vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[out]  *pDst is output pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @return none.
N   */
N  void arm_q7_to_float(
N  q7_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @ingroup groupController
N   */
N
N  /**
N   * @defgroup inv_park Vector Inverse Park transform
N   * Inverse Park transform converts the input flux and torque components to two-coordinate vector.
N   *
N   * The function operates on a single sample of data and each call to the function returns the processed output.
N   * The library provides separate functions for Q31 and floating-point data types.
N   * \par Algorithm
N   * \image html parkInvFormula.gif
N   * where <code>pIalpha</code> and <code>pIbeta</code> are the stator vector components,
N   * <code>Id</code> and <code>Iq</code> are rotor vector components and <code>cosVal</code> and <code>sinVal</code> are the
N   * cosine and sine values of theta (rotor flux position).
N   * \par Fixed-Point Behavior
N   * Care must be taken when using the Q31 version of the Park transform.
N   * In particular, the overflow and saturation behavior of the accumulator used must be considered.
N   * Refer to the function specific documentation below for usage guidelines.
N   */
N
N  /**
N   * @addtogroup inv_park
N   * @{
N   */
N
N   /**
N   * @brief  Floating-point Inverse Park transform
N   * @param[in]       Id        input coordinate of rotor reference frame d
N   * @param[in]       Iq        input coordinate of rotor reference frame q
N   * @param[out]      *pIalpha  points to output two-phase orthogonal vector axis alpha
N   * @param[out]      *pIbeta   points to output two-phase orthogonal vector axis beta
N   * @param[in]       sinVal    sine value of rotation angle theta
N   * @param[in]       cosVal    cosine value of rotation angle theta
N   * @return none.
N   */
N
N  static __INLINE void arm_inv_park_f32(
X  static __inline void arm_inv_park_f32(
N  float32_t Id,
N  float32_t Iq,
N  float32_t * pIalpha,
N  float32_t * pIbeta,
N  float32_t sinVal,
N  float32_t cosVal)
N  {
N    /* Calculate pIalpha using the equation, pIalpha = Id * cosVal - Iq * sinVal */
N    *pIalpha = Id * cosVal - Iq * sinVal;
N
N    /* Calculate pIbeta using the equation, pIbeta = Id * sinVal + Iq * cosVal */
N    *pIbeta = Id * sinVal + Iq * cosVal;
N
N  }
N
N
N  /**
N   * @brief  Inverse Park transform for	Q31 version
N   * @param[in]       Id        input coordinate of rotor reference frame d
N   * @param[in]       Iq        input coordinate of rotor reference frame q
N   * @param[out]      *pIalpha  points to output two-phase orthogonal vector axis alpha
N   * @param[out]      *pIbeta   points to output two-phase orthogonal vector axis beta
N   * @param[in]       sinVal    sine value of rotation angle theta
N   * @param[in]       cosVal    cosine value of rotation angle theta
N   * @return none.
N   *
N   * <b>Scaling and Overflow Behavior:</b>
N   * \par
N   * The function is implemented using an internal 32-bit accumulator.
N   * The accumulator maintains 1.31 format by truncating lower 31 bits of the intermediate multiplication in 2.62 format.
N   * There is saturation on the addition, hence there is no risk of overflow.
N   */
N
N
N  static __INLINE void arm_inv_park_q31(
X  static __inline void arm_inv_park_q31(
N  q31_t Id,
N  q31_t Iq,
N  q31_t * pIalpha,
N  q31_t * pIbeta,
N  q31_t sinVal,
N  q31_t cosVal)
N  {
N    q31_t product1, product2;                    /* Temporary variables used to store intermediate results */
N    q31_t product3, product4;                    /* Temporary variables used to store intermediate results */
N
N    /* Intermediate product is calculated by (Id * cosVal) */
N    product1 = (q31_t) (((q63_t) (Id) * (cosVal)) >> 31);
N
N    /* Intermediate product is calculated by (Iq * sinVal) */
N    product2 = (q31_t) (((q63_t) (Iq) * (sinVal)) >> 31);
N
N
N    /* Intermediate product is calculated by (Id * sinVal) */
N    product3 = (q31_t) (((q63_t) (Id) * (sinVal)) >> 31);
N
N    /* Intermediate product is calculated by (Iq * cosVal) */
N    product4 = (q31_t) (((q63_t) (Iq) * (cosVal)) >> 31);
N
N    /* Calculate pIalpha by using the two intermediate products 1 and 2 */
N    *pIalpha = __QSUB(product1, product2);
X    *pIalpha = __qsub(product1, product2);
N
N    /* Calculate pIbeta by using the two intermediate products 3 and 4 */
N    *pIbeta = __QADD(product4, product3);
X    *pIbeta = __qadd(product4, product3);
N
N  }
N
N  /**
N   * @} end of Inverse park group
N   */
N
N
N  /**
N   * @brief  Converts the elements of the Q31 vector to floating-point vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[out]  *pDst is output pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @return none.
N   */
N  void arm_q31_to_float(
N  q31_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @ingroup groupInterpolation
N   */
N
N  /**
N   * @defgroup LinearInterpolate Linear Interpolation
N   *
N   * Linear interpolation is a method of curve fitting using linear polynomials.
N   * Linear interpolation works by effectively drawing a straight line between two neighboring samples and returning the appropriate point along that line
N   *
N   * \par
N   * \image html LinearInterp.gif "Linear interpolation"
N   *
N   * \par
N   * A  Linear Interpolate function calculates an output value(y), for the input(x)
N   * using linear interpolation of the input values x0, x1( nearest input values) and the output values y0 and y1(nearest output values)
N   *
N   * \par Algorithm:
N   * <pre>
N   *       y = y0 + (x - x0) * ((y1 - y0)/(x1-x0))
N   *       where x0, x1 are nearest values of input x
N   *             y0, y1 are nearest values to output y
N   * </pre>
N   *
N   * \par
N   * This set of functions implements Linear interpolation process
N   * for Q7, Q15, Q31, and floating-point data types.  The functions operate on a single
N   * sample of data and each call to the function returns a single processed value.
N   * <code>S</code> points to an instance of the Linear Interpolate function data structure.
N   * <code>x</code> is the input sample value. The functions returns the output value.
N   *
N   * \par
N   * if x is outside of the table boundary, Linear interpolation returns first value of the table
N   * if x is below input range and returns last value of table if x is above range.
N   */
N
N  /**
N   * @addtogroup LinearInterpolate
N   * @{
N   */
N
N  /**
N   * @brief  Process function for the floating-point Linear Interpolation Function.
N   * @param[in,out] *S is an instance of the floating-point Linear Interpolation structure
N   * @param[in] x input sample to process
N   * @return y processed output sample.
N   *
N   */
N
N  static __INLINE float32_t arm_linear_interp_f32(
X  static __inline float32_t arm_linear_interp_f32(
N  arm_linear_interp_instance_f32 * S,
N  float32_t x)
N  {
N
N    float32_t y;
N    float32_t x0, x1;                            /* Nearest input values */
N    float32_t y0, y1;                            /* Nearest output values */
N    float32_t xSpacing = S->xSpacing;            /* spacing between input values */
N    int32_t i;                                   /* Index variable */
N    float32_t *pYData = S->pYData;               /* pointer to output table */
N
N    /* Calculation of index */
N    i = (int32_t) ((x - S->x1) / xSpacing);
N
N    if(i < 0)
N    {
N      /* Iniatilize output for below specified range as least output value of table */
N      y = pYData[0];
N    }
N    else if((uint32_t)i >= S->nValues)
N    {
N      /* Iniatilize output for above specified range as last output value of table */
N      y = pYData[S->nValues - 1];
N    }
N    else
N    {
N      /* Calculation of nearest input values */
N      x0 = S->x1 + i * xSpacing;
N      x1 = S->x1 + (i + 1) * xSpacing;
N
N      /* Read of nearest output values */
N      y0 = pYData[i];
N      y1 = pYData[i + 1];
N
N      /* Calculation of output */
N      y = y0 + (x - x0) * ((y1 - y0) / (x1 - x0));
N
N    }
N
N    /* returns output value */
N    return (y);
N  }
N
N   /**
N   *
N   * @brief  Process function for the Q31 Linear Interpolation Function.
N   * @param[in] *pYData  pointer to Q31 Linear Interpolation table
N   * @param[in] x input sample to process
N   * @param[in] nValues number of table values
N   * @return y processed output sample.
N   *
N   * \par
N   * Input sample <code>x</code> is in 12.20 format which contains 12 bits for table index and 20 bits for fractional part.
N   * This function can support maximum of table size 2^12.
N   *
N   */
N
N
N  static __INLINE q31_t arm_linear_interp_q31(
X  static __inline q31_t arm_linear_interp_q31(
N  q31_t * pYData,
N  q31_t x,
N  uint32_t nValues)
N  {
N    q31_t y;                                     /* output */
N    q31_t y0, y1;                                /* Nearest output values */
N    q31_t fract;                                 /* fractional part */
N    int32_t index;                               /* Index to read nearest output values */
N
N    /* Input is in 12.20 format */
N    /* 12 bits for the table index */
N    /* Index value calculation */
N    index = ((x & 0xFFF00000) >> 20);
N
N    if(index >= (int32_t)(nValues - 1))
N    {
N      return (pYData[nValues - 1]);
N    }
N    else if(index < 0)
N    {
N      return (pYData[0]);
N    }
N    else
N    {
N
N      /* 20 bits for the fractional part */
N      /* shift left by 11 to keep fract in 1.31 format */
N      fract = (x & 0x000FFFFF) << 11;
N
N      /* Read two nearest output values from the index in 1.31(q31) format */
N      y0 = pYData[index];
N      y1 = pYData[index + 1u];
N
N      /* Calculation of y0 * (1-fract) and y is in 2.30 format */
N      y = ((q31_t) ((q63_t) y0 * (0x7FFFFFFF - fract) >> 32));
N
N      /* Calculation of y0 * (1-fract) + y1 *fract and y is in 2.30 format */
N      y += ((q31_t) (((q63_t) y1 * fract) >> 32));
N
N      /* Convert y to 1.31 format */
N      return (y << 1u);
N
N    }
N
N  }
N
N  /**
N   *
N   * @brief  Process function for the Q15 Linear Interpolation Function.
N   * @param[in] *pYData  pointer to Q15 Linear Interpolation table
N   * @param[in] x input sample to process
N   * @param[in] nValues number of table values
N   * @return y processed output sample.
N   *
N   * \par
N   * Input sample <code>x</code> is in 12.20 format which contains 12 bits for table index and 20 bits for fractional part.
N   * This function can support maximum of table size 2^12.
N   *
N   */
N
N
N  static __INLINE q15_t arm_linear_interp_q15(
X  static __inline q15_t arm_linear_interp_q15(
N  q15_t * pYData,
N  q31_t x,
N  uint32_t nValues)
N  {
N    q63_t y;                                     /* output */
N    q15_t y0, y1;                                /* Nearest output values */
N    q31_t fract;                                 /* fractional part */
N    int32_t index;                               /* Index to read nearest output values */
N
N    /* Input is in 12.20 format */
N    /* 12 bits for the table index */
N    /* Index value calculation */
N    index = ((x & 0xFFF00000) >> 20u);
N
N    if(index >= (int32_t)(nValues - 1))
N    {
N      return (pYData[nValues - 1]);
N    }
N    else if(index < 0)
N    {
N      return (pYData[0]);
N    }
N    else
N    {
N      /* 20 bits for the fractional part */
N      /* fract is in 12.20 format */
N      fract = (x & 0x000FFFFF);
N
N      /* Read two nearest output values from the index */
N      y0 = pYData[index];
N      y1 = pYData[index + 1u];
N
N      /* Calculation of y0 * (1-fract) and y is in 13.35 format */
N      y = ((q63_t) y0 * (0xFFFFF - fract));
N
N      /* Calculation of (y0 * (1-fract) + y1 * fract) and y is in 13.35 format */
N      y += ((q63_t) y1 * (fract));
N
N      /* convert y to 1.15 format */
N      return (y >> 20);
N    }
N
N
N  }
N
N  /**
N   *
N   * @brief  Process function for the Q7 Linear Interpolation Function.
N   * @param[in] *pYData  pointer to Q7 Linear Interpolation table
N   * @param[in] x input sample to process
N   * @param[in] nValues number of table values
N   * @return y processed output sample.
N   *
N   * \par
N   * Input sample <code>x</code> is in 12.20 format which contains 12 bits for table index and 20 bits for fractional part.
N   * This function can support maximum of table size 2^12.
N   */
N
N
N  static __INLINE q7_t arm_linear_interp_q7(
X  static __inline q7_t arm_linear_interp_q7(
N  q7_t * pYData,
N  q31_t x,
N  uint32_t nValues)
N  {
N    q31_t y;                                     /* output */
N    q7_t y0, y1;                                 /* Nearest output values */
N    q31_t fract;                                 /* fractional part */
N    uint32_t index;                              /* Index to read nearest output values */
N
N    /* Input is in 12.20 format */
N    /* 12 bits for the table index */
N    /* Index value calculation */
N    if (x < 0)
N    {
N      return (pYData[0]);
N    }
N    index = (x >> 20) & 0xfff;
N
N
N    if(index >= (nValues - 1))
N    {
N      return (pYData[nValues - 1]);
N    }
N    else
N    {
N
N      /* 20 bits for the fractional part */
N      /* fract is in 12.20 format */
N      fract = (x & 0x000FFFFF);
N
N      /* Read two nearest output values from the index and are in 1.7(q7) format */
N      y0 = pYData[index];
N      y1 = pYData[index + 1u];
N
N      /* Calculation of y0 * (1-fract ) and y is in 13.27(q27) format */
N      y = ((y0 * (0xFFFFF - fract)));
N
N      /* Calculation of y1 * fract + y0 * (1-fract) and y is in 13.27(q27) format */
N      y += (y1 * fract);
N
N      /* convert y to 1.7(q7) format */
N      return (y >> 20u);
N
N    }
N
N  }
N  /**
N   * @} end of LinearInterpolate group
N   */
N
N  /**
N   * @brief  Fast approximation to the trigonometric sine function for floating-point data.
N   * @param[in] x input value in radians.
N   * @return  sin(x).
N   */
N
N  float32_t arm_sin_f32(
N  float32_t x);
N
N  /**
N   * @brief  Fast approximation to the trigonometric sine function for Q31 data.
N   * @param[in] x Scaled input value in radians.
N   * @return  sin(x).
N   */
N
N  q31_t arm_sin_q31(
N  q31_t x);
N
N  /**
N   * @brief  Fast approximation to the trigonometric sine function for Q15 data.
N   * @param[in] x Scaled input value in radians.
N   * @return  sin(x).
N   */
N
N  q15_t arm_sin_q15(
N  q15_t x);
N
N  /**
N   * @brief  Fast approximation to the trigonometric cosine function for floating-point data.
N   * @param[in] x input value in radians.
N   * @return  cos(x).
N   */
N
N  float32_t arm_cos_f32(
N  float32_t x);
N
N  /**
N   * @brief Fast approximation to the trigonometric cosine function for Q31 data.
N   * @param[in] x Scaled input value in radians.
N   * @return  cos(x).
N   */
N
N  q31_t arm_cos_q31(
N  q31_t x);
N
N  /**
N   * @brief  Fast approximation to the trigonometric cosine function for Q15 data.
N   * @param[in] x Scaled input value in radians.
N   * @return  cos(x).
N   */
N
N  q15_t arm_cos_q15(
N  q15_t x);
N
N
N  /**
N   * @ingroup groupFastMath
N   */
N
N
N  /**
N   * @defgroup SQRT Square Root
N   *
N   * Computes the square root of a number.
N   * There are separate functions for Q15, Q31, and floating-point data types.
N   * The square root function is computed using the Newton-Raphson algorithm.
N   * This is an iterative algorithm of the form:
N   * <pre>
N   *      x1 = x0 - f(x0)/f'(x0)
N   * </pre>
N   * where <code>x1</code> is the current estimate,
N   * <code>x0</code> is the previous estimate, and
N   * <code>f'(x0)</code> is the derivative of <code>f()</code> evaluated at <code>x0</code>.
N   * For the square root function, the algorithm reduces to:
N   * <pre>
N   *     x0 = in/2                         [initial guess]
N   *     x1 = 1/2 * ( x0 + in / x0)        [each iteration]
N   * </pre>
N   */
N
N
N  /**
N   * @addtogroup SQRT
N   * @{
N   */
N
N  /**
N   * @brief  Floating-point square root function.
N   * @param[in]  in     input value.
N   * @param[out] *pOut  square root of input value.
N   * @return The function returns ARM_MATH_SUCCESS if input value is positive value or ARM_MATH_ARGUMENT_ERROR if
N   * <code>in</code> is negative value and returns zero output for negative values.
N   */
N
N  static __INLINE arm_status arm_sqrt_f32(
X  static __inline arm_status arm_sqrt_f32(
N  float32_t in,
N  float32_t * pOut)
N  {
N    if(in > 0)
N    {
N
N//      #if __FPU_USED
N#if (__FPU_USED == 1) && defined ( __CC_ARM   )
X#if (1 == 1) && 1L
N      *pOut = __sqrtf(in);
N#else
S      *pOut = sqrtf(in);
N#endif
N
N      return (ARM_MATH_SUCCESS);
N    }
N    else
N    {
N      *pOut = 0.0f;
N      return (ARM_MATH_ARGUMENT_ERROR);
N    }
N
N  }
N
N
N  /**
N   * @brief Q31 square root function.
N   * @param[in]   in    input value.  The range of the input value is [0 +1) or 0x00000000 to 0x7FFFFFFF.
N   * @param[out]  *pOut square root of input value.
N   * @return The function returns ARM_MATH_SUCCESS if input value is positive value or ARM_MATH_ARGUMENT_ERROR if
N   * <code>in</code> is negative value and returns zero output for negative values.
N   */
N  arm_status arm_sqrt_q31(
N  q31_t in,
N  q31_t * pOut);
N
N  /**
N   * @brief  Q15 square root function.
N   * @param[in]   in     input value.  The range of the input value is [0 +1) or 0x0000 to 0x7FFF.
N   * @param[out]  *pOut  square root of input value.
N   * @return The function returns ARM_MATH_SUCCESS if input value is positive value or ARM_MATH_ARGUMENT_ERROR if
N   * <code>in</code> is negative value and returns zero output for negative values.
N   */
N  arm_status arm_sqrt_q15(
N  q15_t in,
N  q15_t * pOut);
N
N  /**
N   * @} end of SQRT group
N   */
N
N
N
N
N
N
N  /**
N   * @brief floating-point Circular write function.
N   */
N
N  static __INLINE void arm_circularWrite_f32(
X  static __inline void arm_circularWrite_f32(
N  int32_t * circBuffer,
N  int32_t L,
N  uint16_t * writeOffset,
N  int32_t bufferInc,
N  const int32_t * src,
N  int32_t srcInc,
N  uint32_t blockSize)
N  {
N    uint32_t i = 0u;
N    int32_t wOffset;
N
N    /* Copy the value of Index pointer that points
N     * to the current location where the input samples to be copied */
N    wOffset = *writeOffset;
N
N    /* Loop over the blockSize */
N    i = blockSize;
N
N    while(i > 0u)
N    {
N      /* copy the input sample to the circular buffer */
N      circBuffer[wOffset] = *src;
N
N      /* Update the input pointer */
N      src += srcInc;
N
N      /* Circularly update wOffset.  Watch out for positive and negative value */
N      wOffset += bufferInc;
N      if(wOffset >= L)
N        wOffset -= L;
N
N      /* Decrement the loop counter */
N      i--;
N    }
N
N    /* Update the index pointer */
N    *writeOffset = wOffset;
N  }
N
N
N
N  /**
N   * @brief floating-point Circular Read function.
N   */
N  static __INLINE void arm_circularRead_f32(
X  static __inline void arm_circularRead_f32(
N  int32_t * circBuffer,
N  int32_t L,
N  int32_t * readOffset,
N  int32_t bufferInc,
N  int32_t * dst,
N  int32_t * dst_base,
N  int32_t dst_length,
N  int32_t dstInc,
N  uint32_t blockSize)
N  {
N    uint32_t i = 0u;
N    int32_t rOffset, dst_end;
N
N    /* Copy the value of Index pointer that points
N     * to the current location from where the input samples to be read */
N    rOffset = *readOffset;
N    dst_end = (int32_t) (dst_base + dst_length);
N
N    /* Loop over the blockSize */
N    i = blockSize;
N
N    while(i > 0u)
N    {
N      /* copy the sample from the circular buffer to the destination buffer */
N      *dst = circBuffer[rOffset];
N
N      /* Update the input pointer */
N      dst += dstInc;
N
N      if(dst == (int32_t *) dst_end)
N      {
N        dst = dst_base;
N      }
N
N      /* Circularly update rOffset.  Watch out for positive and negative value  */
N      rOffset += bufferInc;
N
N      if(rOffset >= L)
N      {
N        rOffset -= L;
N      }
N
N      /* Decrement the loop counter */
N      i--;
N    }
N
N    /* Update the index pointer */
N    *readOffset = rOffset;
N  }
N
N  /**
N   * @brief Q15 Circular write function.
N   */
N
N  static __INLINE void arm_circularWrite_q15(
X  static __inline void arm_circularWrite_q15(
N  q15_t * circBuffer,
N  int32_t L,
N  uint16_t * writeOffset,
N  int32_t bufferInc,
N  const q15_t * src,
N  int32_t srcInc,
N  uint32_t blockSize)
N  {
N    uint32_t i = 0u;
N    int32_t wOffset;
N
N    /* Copy the value of Index pointer that points
N     * to the current location where the input samples to be copied */
N    wOffset = *writeOffset;
N
N    /* Loop over the blockSize */
N    i = blockSize;
N
N    while(i > 0u)
N    {
N      /* copy the input sample to the circular buffer */
N      circBuffer[wOffset] = *src;
N
N      /* Update the input pointer */
N      src += srcInc;
N
N      /* Circularly update wOffset.  Watch out for positive and negative value */
N      wOffset += bufferInc;
N      if(wOffset >= L)
N        wOffset -= L;
N
N      /* Decrement the loop counter */
N      i--;
N    }
N
N    /* Update the index pointer */
N    *writeOffset = wOffset;
N  }
N
N
N
N  /**
N   * @brief Q15 Circular Read function.
N   */
N  static __INLINE void arm_circularRead_q15(
X  static __inline void arm_circularRead_q15(
N  q15_t * circBuffer,
N  int32_t L,
N  int32_t * readOffset,
N  int32_t bufferInc,
N  q15_t * dst,
N  q15_t * dst_base,
N  int32_t dst_length,
N  int32_t dstInc,
N  uint32_t blockSize)
N  {
N    uint32_t i = 0;
N    int32_t rOffset, dst_end;
N
N    /* Copy the value of Index pointer that points
N     * to the current location from where the input samples to be read */
N    rOffset = *readOffset;
N
N    dst_end = (int32_t) (dst_base + dst_length);
N
N    /* Loop over the blockSize */
N    i = blockSize;
N
N    while(i > 0u)
N    {
N      /* copy the sample from the circular buffer to the destination buffer */
N      *dst = circBuffer[rOffset];
N
N      /* Update the input pointer */
N      dst += dstInc;
N
N      if(dst == (q15_t *) dst_end)
N      {
N        dst = dst_base;
N      }
N
N      /* Circularly update wOffset.  Watch out for positive and negative value */
N      rOffset += bufferInc;
N
N      if(rOffset >= L)
N      {
N        rOffset -= L;
N      }
N
N      /* Decrement the loop counter */
N      i--;
N    }
N
N    /* Update the index pointer */
N    *readOffset = rOffset;
N  }
N
N
N  /**
N   * @brief Q7 Circular write function.
N   */
N
N  static __INLINE void arm_circularWrite_q7(
X  static __inline void arm_circularWrite_q7(
N  q7_t * circBuffer,
N  int32_t L,
N  uint16_t * writeOffset,
N  int32_t bufferInc,
N  const q7_t * src,
N  int32_t srcInc,
N  uint32_t blockSize)
N  {
N    uint32_t i = 0u;
N    int32_t wOffset;
N
N    /* Copy the value of Index pointer that points
N     * to the current location where the input samples to be copied */
N    wOffset = *writeOffset;
N
N    /* Loop over the blockSize */
N    i = blockSize;
N
N    while(i > 0u)
N    {
N      /* copy the input sample to the circular buffer */
N      circBuffer[wOffset] = *src;
N
N      /* Update the input pointer */
N      src += srcInc;
N
N      /* Circularly update wOffset.  Watch out for positive and negative value */
N      wOffset += bufferInc;
N      if(wOffset >= L)
N        wOffset -= L;
N
N      /* Decrement the loop counter */
N      i--;
N    }
N
N    /* Update the index pointer */
N    *writeOffset = wOffset;
N  }
N
N
N
N  /**
N   * @brief Q7 Circular Read function.
N   */
N  static __INLINE void arm_circularRead_q7(
X  static __inline void arm_circularRead_q7(
N  q7_t * circBuffer,
N  int32_t L,
N  int32_t * readOffset,
N  int32_t bufferInc,
N  q7_t * dst,
N  q7_t * dst_base,
N  int32_t dst_length,
N  int32_t dstInc,
N  uint32_t blockSize)
N  {
N    uint32_t i = 0;
N    int32_t rOffset, dst_end;
N
N    /* Copy the value of Index pointer that points
N     * to the current location from where the input samples to be read */
N    rOffset = *readOffset;
N
N    dst_end = (int32_t) (dst_base + dst_length);
N
N    /* Loop over the blockSize */
N    i = blockSize;
N
N    while(i > 0u)
N    {
N      /* copy the sample from the circular buffer to the destination buffer */
N      *dst = circBuffer[rOffset];
N
N      /* Update the input pointer */
N      dst += dstInc;
N
N      if(dst == (q7_t *) dst_end)
N      {
N        dst = dst_base;
N      }
N
N      /* Circularly update rOffset.  Watch out for positive and negative value */
N      rOffset += bufferInc;
N
N      if(rOffset >= L)
N      {
N        rOffset -= L;
N      }
N
N      /* Decrement the loop counter */
N      i--;
N    }
N
N    /* Update the index pointer */
N    *readOffset = rOffset;
N  }
N
N
N  /**
N   * @brief  Sum of the squares of the elements of a Q31 vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @param[out]  *pResult is output value.
N   * @return none.
N   */
N
N  void arm_power_q31(
N  q31_t * pSrc,
N  uint32_t blockSize,
N  q63_t * pResult);
N
N  /**
N   * @brief  Sum of the squares of the elements of a floating-point vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @param[out]  *pResult is output value.
N   * @return none.
N   */
N
N  void arm_power_f32(
N  float32_t * pSrc,
N  uint32_t blockSize,
N  float32_t * pResult);
N
N  /**
N   * @brief  Sum of the squares of the elements of a Q15 vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @param[out]  *pResult is output value.
N   * @return none.
N   */
N
N  void arm_power_q15(
N  q15_t * pSrc,
N  uint32_t blockSize,
N  q63_t * pResult);
N
N  /**
N   * @brief  Sum of the squares of the elements of a Q7 vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @param[out]  *pResult is output value.
N   * @return none.
N   */
N
N  void arm_power_q7(
N  q7_t * pSrc,
N  uint32_t blockSize,
N  q31_t * pResult);
N
N  /**
N   * @brief  Mean value of a Q7 vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @param[out]  *pResult is output value.
N   * @return none.
N   */
N
N  void arm_mean_q7(
N  q7_t * pSrc,
N  uint32_t blockSize,
N  q7_t * pResult);
N
N  /**
N   * @brief  Mean value of a Q15 vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @param[out]  *pResult is output value.
N   * @return none.
N   */
N  void arm_mean_q15(
N  q15_t * pSrc,
N  uint32_t blockSize,
N  q15_t * pResult);
N
N  /**
N   * @brief  Mean value of a Q31 vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @param[out]  *pResult is output value.
N   * @return none.
N   */
N  void arm_mean_q31(
N  q31_t * pSrc,
N  uint32_t blockSize,
N  q31_t * pResult);
N
N  /**
N   * @brief  Mean value of a floating-point vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @param[out]  *pResult is output value.
N   * @return none.
N   */
N  void arm_mean_f32(
N  float32_t * pSrc,
N  uint32_t blockSize,
N  float32_t * pResult);
N
N  /**
N   * @brief  Variance of the elements of a floating-point vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @param[out]  *pResult is output value.
N   * @return none.
N   */
N
N  void arm_var_f32(
N  float32_t * pSrc,
N  uint32_t blockSize,
N  float32_t * pResult);
N
N  /**
N   * @brief  Variance of the elements of a Q31 vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @param[out]  *pResult is output value.
N   * @return none.
N   */
N
N  void arm_var_q31(
N  q31_t * pSrc,
N  uint32_t blockSize,
N  q31_t * pResult);
N
N  /**
N   * @brief  Variance of the elements of a Q15 vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @param[out]  *pResult is output value.
N   * @return none.
N   */
N
N  void arm_var_q15(
N  q15_t * pSrc,
N  uint32_t blockSize,
N  q15_t * pResult);
N
N  /**
N   * @brief  Root Mean Square of the elements of a floating-point vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @param[out]  *pResult is output value.
N   * @return none.
N   */
N
N  void arm_rms_f32(
N  float32_t * pSrc,
N  uint32_t blockSize,
N  float32_t * pResult);
N
N  /**
N   * @brief  Root Mean Square of the elements of a Q31 vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @param[out]  *pResult is output value.
N   * @return none.
N   */
N
N  void arm_rms_q31(
N  q31_t * pSrc,
N  uint32_t blockSize,
N  q31_t * pResult);
N
N  /**
N   * @brief  Root Mean Square of the elements of a Q15 vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @param[out]  *pResult is output value.
N   * @return none.
N   */
N
N  void arm_rms_q15(
N  q15_t * pSrc,
N  uint32_t blockSize,
N  q15_t * pResult);
N
N  /**
N   * @brief  Standard deviation of the elements of a floating-point vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @param[out]  *pResult is output value.
N   * @return none.
N   */
N
N  void arm_std_f32(
N  float32_t * pSrc,
N  uint32_t blockSize,
N  float32_t * pResult);
N
N  /**
N   * @brief  Standard deviation of the elements of a Q31 vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @param[out]  *pResult is output value.
N   * @return none.
N   */
N
N  void arm_std_q31(
N  q31_t * pSrc,
N  uint32_t blockSize,
N  q31_t * pResult);
N
N  /**
N   * @brief  Standard deviation of the elements of a Q15 vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @param[out]  *pResult is output value.
N   * @return none.
N   */
N
N  void arm_std_q15(
N  q15_t * pSrc,
N  uint32_t blockSize,
N  q15_t * pResult);
N
N  /**
N   * @brief  Floating-point complex magnitude
N   * @param[in]  *pSrc points to the complex input vector
N   * @param[out]  *pDst points to the real output vector
N   * @param[in]  numSamples number of complex samples in the input vector
N   * @return none.
N   */
N
N  void arm_cmplx_mag_f32(
N  float32_t * pSrc,
N  float32_t * pDst,
N  uint32_t numSamples);
N
N  /**
N   * @brief  Q31 complex magnitude
N   * @param[in]  *pSrc points to the complex input vector
N   * @param[out]  *pDst points to the real output vector
N   * @param[in]  numSamples number of complex samples in the input vector
N   * @return none.
N   */
N
N  void arm_cmplx_mag_q31(
N  q31_t * pSrc,
N  q31_t * pDst,
N  uint32_t numSamples);
N
N  /**
N   * @brief  Q15 complex magnitude
N   * @param[in]  *pSrc points to the complex input vector
N   * @param[out]  *pDst points to the real output vector
N   * @param[in]  numSamples number of complex samples in the input vector
N   * @return none.
N   */
N
N  void arm_cmplx_mag_q15(
N  q15_t * pSrc,
N  q15_t * pDst,
N  uint32_t numSamples);
N
N  /**
N   * @brief  Q15 complex dot product
N   * @param[in]  *pSrcA points to the first input vector
N   * @param[in]  *pSrcB points to the second input vector
N   * @param[in]  numSamples number of complex samples in each vector
N   * @param[out]  *realResult real part of the result returned here
N   * @param[out]  *imagResult imaginary part of the result returned here
N   * @return none.
N   */
N
N  void arm_cmplx_dot_prod_q15(
N  q15_t * pSrcA,
N  q15_t * pSrcB,
N  uint32_t numSamples,
N  q31_t * realResult,
N  q31_t * imagResult);
N
N  /**
N   * @brief  Q31 complex dot product
N   * @param[in]  *pSrcA points to the first input vector
N   * @param[in]  *pSrcB points to the second input vector
N   * @param[in]  numSamples number of complex samples in each vector
N   * @param[out]  *realResult real part of the result returned here
N   * @param[out]  *imagResult imaginary part of the result returned here
N   * @return none.
N   */
N
N  void arm_cmplx_dot_prod_q31(
N  q31_t * pSrcA,
N  q31_t * pSrcB,
N  uint32_t numSamples,
N  q63_t * realResult,
N  q63_t * imagResult);
N
N  /**
N   * @brief  Floating-point complex dot product
N   * @param[in]  *pSrcA points to the first input vector
N   * @param[in]  *pSrcB points to the second input vector
N   * @param[in]  numSamples number of complex samples in each vector
N   * @param[out]  *realResult real part of the result returned here
N   * @param[out]  *imagResult imaginary part of the result returned here
N   * @return none.
N   */
N
N  void arm_cmplx_dot_prod_f32(
N  float32_t * pSrcA,
N  float32_t * pSrcB,
N  uint32_t numSamples,
N  float32_t * realResult,
N  float32_t * imagResult);
N
N  /**
N   * @brief  Q15 complex-by-real multiplication
N   * @param[in]  *pSrcCmplx points to the complex input vector
N   * @param[in]  *pSrcReal points to the real input vector
N   * @param[out]  *pCmplxDst points to the complex output vector
N   * @param[in]  numSamples number of samples in each vector
N   * @return none.
N   */
N
N  void arm_cmplx_mult_real_q15(
N  q15_t * pSrcCmplx,
N  q15_t * pSrcReal,
N  q15_t * pCmplxDst,
N  uint32_t numSamples);
N
N  /**
N   * @brief  Q31 complex-by-real multiplication
N   * @param[in]  *pSrcCmplx points to the complex input vector
N   * @param[in]  *pSrcReal points to the real input vector
N   * @param[out]  *pCmplxDst points to the complex output vector
N   * @param[in]  numSamples number of samples in each vector
N   * @return none.
N   */
N
N  void arm_cmplx_mult_real_q31(
N  q31_t * pSrcCmplx,
N  q31_t * pSrcReal,
N  q31_t * pCmplxDst,
N  uint32_t numSamples);
N
N  /**
N   * @brief  Floating-point complex-by-real multiplication
N   * @param[in]  *pSrcCmplx points to the complex input vector
N   * @param[in]  *pSrcReal points to the real input vector
N   * @param[out]  *pCmplxDst points to the complex output vector
N   * @param[in]  numSamples number of samples in each vector
N   * @return none.
N   */
N
N  void arm_cmplx_mult_real_f32(
N  float32_t * pSrcCmplx,
N  float32_t * pSrcReal,
N  float32_t * pCmplxDst,
N  uint32_t numSamples);
N
N  /**
N   * @brief  Minimum value of a Q7 vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @param[out]  *result is output pointer
N   * @param[in]  index is the array index of the minimum value in the input buffer.
N   * @return none.
N   */
N
N  void arm_min_q7(
N  q7_t * pSrc,
N  uint32_t blockSize,
N  q7_t * result,
N  uint32_t * index);
N
N  /**
N   * @brief  Minimum value of a Q15 vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @param[out]  *pResult is output pointer
N   * @param[in]  *pIndex is the array index of the minimum value in the input buffer.
N   * @return none.
N   */
N
N  void arm_min_q15(
N  q15_t * pSrc,
N  uint32_t blockSize,
N  q15_t * pResult,
N  uint32_t * pIndex);
N
N  /**
N   * @brief  Minimum value of a Q31 vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @param[out]  *pResult is output pointer
N   * @param[out]  *pIndex is the array index of the minimum value in the input buffer.
N   * @return none.
N   */
N  void arm_min_q31(
N  q31_t * pSrc,
N  uint32_t blockSize,
N  q31_t * pResult,
N  uint32_t * pIndex);
N
N  /**
N   * @brief  Minimum value of a floating-point vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @param[out]  *pResult is output pointer
N   * @param[out]  *pIndex is the array index of the minimum value in the input buffer.
N   * @return none.
N   */
N
N  void arm_min_f32(
N  float32_t * pSrc,
N  uint32_t blockSize,
N  float32_t * pResult,
N  uint32_t * pIndex);
N
N/**
N * @brief Maximum value of a Q7 vector.
N * @param[in]       *pSrc points to the input buffer
N * @param[in]       blockSize length of the input vector
N * @param[out]      *pResult maximum value returned here
N * @param[out]      *pIndex index of maximum value returned here
N * @return none.
N */
N
N  void arm_max_q7(
N  q7_t * pSrc,
N  uint32_t blockSize,
N  q7_t * pResult,
N  uint32_t * pIndex);
N
N/**
N * @brief Maximum value of a Q15 vector.
N * @param[in]       *pSrc points to the input buffer
N * @param[in]       blockSize length of the input vector
N * @param[out]      *pResult maximum value returned here
N * @param[out]      *pIndex index of maximum value returned here
N * @return none.
N */
N
N  void arm_max_q15(
N  q15_t * pSrc,
N  uint32_t blockSize,
N  q15_t * pResult,
N  uint32_t * pIndex);
N
N/**
N * @brief Maximum value of a Q31 vector.
N * @param[in]       *pSrc points to the input buffer
N * @param[in]       blockSize length of the input vector
N * @param[out]      *pResult maximum value returned here
N * @param[out]      *pIndex index of maximum value returned here
N * @return none.
N */
N
N  void arm_max_q31(
N  q31_t * pSrc,
N  uint32_t blockSize,
N  q31_t * pResult,
N  uint32_t * pIndex);
N
N/**
N * @brief Maximum value of a floating-point vector.
N * @param[in]       *pSrc points to the input buffer
N * @param[in]       blockSize length of the input vector
N * @param[out]      *pResult maximum value returned here
N * @param[out]      *pIndex index of maximum value returned here
N * @return none.
N */
N
N  void arm_max_f32(
N  float32_t * pSrc,
N  uint32_t blockSize,
N  float32_t * pResult,
N  uint32_t * pIndex);
N
N  /**
N   * @brief  Q15 complex-by-complex multiplication
N   * @param[in]  *pSrcA points to the first input vector
N   * @param[in]  *pSrcB points to the second input vector
N   * @param[out]  *pDst  points to the output vector
N   * @param[in]  numSamples number of complex samples in each vector
N   * @return none.
N   */
N
N  void arm_cmplx_mult_cmplx_q15(
N  q15_t * pSrcA,
N  q15_t * pSrcB,
N  q15_t * pDst,
N  uint32_t numSamples);
N
N  /**
N   * @brief  Q31 complex-by-complex multiplication
N   * @param[in]  *pSrcA points to the first input vector
N   * @param[in]  *pSrcB points to the second input vector
N   * @param[out]  *pDst  points to the output vector
N   * @param[in]  numSamples number of complex samples in each vector
N   * @return none.
N   */
N
N  void arm_cmplx_mult_cmplx_q31(
N  q31_t * pSrcA,
N  q31_t * pSrcB,
N  q31_t * pDst,
N  uint32_t numSamples);
N
N  /**
N   * @brief  Floating-point complex-by-complex multiplication
N   * @param[in]  *pSrcA points to the first input vector
N   * @param[in]  *pSrcB points to the second input vector
N   * @param[out]  *pDst  points to the output vector
N   * @param[in]  numSamples number of complex samples in each vector
N   * @return none.
N   */
N
N  void arm_cmplx_mult_cmplx_f32(
N  float32_t * pSrcA,
N  float32_t * pSrcB,
N  float32_t * pDst,
N  uint32_t numSamples);
N
N  /**
N   * @brief Converts the elements of the floating-point vector to Q31 vector.
N   * @param[in]       *pSrc points to the floating-point input vector
N   * @param[out]      *pDst points to the Q31 output vector
N   * @param[in]       blockSize length of the input vector
N   * @return none.
N   */
N  void arm_float_to_q31(
N  float32_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Converts the elements of the floating-point vector to Q15 vector.
N   * @param[in]       *pSrc points to the floating-point input vector
N   * @param[out]      *pDst points to the Q15 output vector
N   * @param[in]       blockSize length of the input vector
N   * @return          none
N   */
N  void arm_float_to_q15(
N  float32_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief Converts the elements of the floating-point vector to Q7 vector.
N   * @param[in]       *pSrc points to the floating-point input vector
N   * @param[out]      *pDst points to the Q7 output vector
N   * @param[in]       blockSize length of the input vector
N   * @return          none
N   */
N  void arm_float_to_q7(
N  float32_t * pSrc,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Converts the elements of the Q31 vector to Q15 vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[out]  *pDst is output pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @return none.
N   */
N  void arm_q31_to_q15(
N  q31_t * pSrc,
N  q15_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Converts the elements of the Q31 vector to Q7 vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[out]  *pDst is output pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @return none.
N   */
N  void arm_q31_to_q7(
N  q31_t * pSrc,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N  /**
N   * @brief  Converts the elements of the Q15 vector to floating-point vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[out]  *pDst is output pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @return none.
N   */
N  void arm_q15_to_float(
N  q15_t * pSrc,
N  float32_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Converts the elements of the Q15 vector to Q31 vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[out]  *pDst is output pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @return none.
N   */
N  void arm_q15_to_q31(
N  q15_t * pSrc,
N  q31_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @brief  Converts the elements of the Q15 vector to Q7 vector.
N   * @param[in]  *pSrc is input pointer
N   * @param[out]  *pDst is output pointer
N   * @param[in]  blockSize is the number of samples to process
N   * @return none.
N   */
N  void arm_q15_to_q7(
N  q15_t * pSrc,
N  q7_t * pDst,
N  uint32_t blockSize);
N
N
N  /**
N   * @ingroup groupInterpolation
N   */
N
N  /**
N   * @defgroup BilinearInterpolate Bilinear Interpolation
N   *
N   * Bilinear interpolation is an extension of linear interpolation applied to a two dimensional grid.
N   * The underlying function <code>f(x, y)</code> is sampled on a regular grid and the interpolation process
N   * determines values between the grid points.
N   * Bilinear interpolation is equivalent to two step linear interpolation, first in the x-dimension and then in the y-dimension.
N   * Bilinear interpolation is often used in image processing to rescale images.
N   * The CMSIS DSP library provides bilinear interpolation functions for Q7, Q15, Q31, and floating-point data types.
N   *
N   * <b>Algorithm</b>
N   * \par
N   * The instance structure used by the bilinear interpolation functions describes a two dimensional data table.
N   * For floating-point, the instance structure is defined as:
N   * <pre>
N   *   typedef struct
N   *   {
N   *     uint16_t numRows;
N   *     uint16_t numCols;
N   *     float32_t *pData;
N   * } arm_bilinear_interp_instance_f32;
N   * </pre>
N   *
N   * \par
N   * where <code>numRows</code> specifies the number of rows in the table;
N   * <code>numCols</code> specifies the number of columns in the table;
N   * and <code>pData</code> points to an array of size <code>numRows*numCols</code> values.
N   * The data table <code>pTable</code> is organized in row order and the supplied data values fall on integer indexes.
N   * That is, table element (x,y) is located at <code>pTable[x + y*numCols]</code> where x and y are integers.
N   *
N   * \par
N   * Let <code>(x, y)</code> specify the desired interpolation point.  Then define:
N   * <pre>
N   *     XF = floor(x)
N   *     YF = floor(y)
N   * </pre>
N   * \par
N   * The interpolated output point is computed as:
N   * <pre>
N   *  f(x, y) = f(XF, YF) * (1-(x-XF)) * (1-(y-YF))
N   *           + f(XF+1, YF) * (x-XF)*(1-(y-YF))
N   *           + f(XF, YF+1) * (1-(x-XF))*(y-YF)
N   *           + f(XF+1, YF+1) * (x-XF)*(y-YF)
N   * </pre>
N   * Note that the coordinates (x, y) contain integer and fractional components.
N   * The integer components specify which portion of the table to use while the
N   * fractional components control the interpolation processor.
N   *
N   * \par
N   * if (x,y) are outside of the table boundary, Bilinear interpolation returns zero output.
N   */
N
N  /**
N   * @addtogroup BilinearInterpolate
N   * @{
N   */
N
N  /**
N  *
N  * @brief  Floating-point bilinear interpolation.
N  * @param[in,out] *S points to an instance of the interpolation structure.
N  * @param[in] X interpolation coordinate.
N  * @param[in] Y interpolation coordinate.
N  * @return out interpolated value.
N  */
N
N
N  static __INLINE float32_t arm_bilinear_interp_f32(
X  static __inline float32_t arm_bilinear_interp_f32(
N  const arm_bilinear_interp_instance_f32 * S,
N  float32_t X,
N  float32_t Y)
N  {
N    float32_t out;
N    float32_t f00, f01, f10, f11;
N    float32_t *pData = S->pData;
N    int32_t xIndex, yIndex, index;
N    float32_t xdiff, ydiff;
N    float32_t b1, b2, b3, b4;
N
N    xIndex = (int32_t) X;
N    yIndex = (int32_t) Y;
N
N    /* Care taken for table outside boundary */
N    /* Returns zero output when values are outside table boundary */
N    if(xIndex < 0 || xIndex > (S->numRows - 1) || yIndex < 0
N       || yIndex > (S->numCols - 1))
N    {
N      return (0);
N    }
N
N    /* Calculation of index for two nearest points in X-direction */
N    index = (xIndex - 1) + (yIndex - 1) * S->numCols;
N
N
N    /* Read two nearest points in X-direction */
N    f00 = pData[index];
N    f01 = pData[index + 1];
N
N    /* Calculation of index for two nearest points in Y-direction */
N    index = (xIndex - 1) + (yIndex) * S->numCols;
N
N
N    /* Read two nearest points in Y-direction */
N    f10 = pData[index];
N    f11 = pData[index + 1];
N
N    /* Calculation of intermediate values */
N    b1 = f00;
N    b2 = f01 - f00;
N    b3 = f10 - f00;
N    b4 = f00 - f01 - f10 + f11;
N
N    /* Calculation of fractional part in X */
N    xdiff = X - xIndex;
N
N    /* Calculation of fractional part in Y */
N    ydiff = Y - yIndex;
N
N    /* Calculation of bi-linear interpolated output */
N    out = b1 + b2 * xdiff + b3 * ydiff + b4 * xdiff * ydiff;
N
N    /* return to application */
N    return (out);
N
N  }
N
N  /**
N  *
N  * @brief  Q31 bilinear interpolation.
N  * @param[in,out] *S points to an instance of the interpolation structure.
N  * @param[in] X interpolation coordinate in 12.20 format.
N  * @param[in] Y interpolation coordinate in 12.20 format.
N  * @return out interpolated value.
N  */
N
N  static __INLINE q31_t arm_bilinear_interp_q31(
X  static __inline q31_t arm_bilinear_interp_q31(
N  arm_bilinear_interp_instance_q31 * S,
N  q31_t X,
N  q31_t Y)
N  {
N    q31_t out;                                   /* Temporary output */
N    q31_t acc = 0;                               /* output */
N    q31_t xfract, yfract;                        /* X, Y fractional parts */
N    q31_t x1, x2, y1, y2;                        /* Nearest output values */
N    int32_t rI, cI;                              /* Row and column indices */
N    q31_t *pYData = S->pData;                    /* pointer to output table values */
N    uint32_t nCols = S->numCols;                 /* num of rows */
N
N
N    /* Input is in 12.20 format */
N    /* 12 bits for the table index */
N    /* Index value calculation */
N    rI = ((X & 0xFFF00000) >> 20u);
N
N    /* Input is in 12.20 format */
N    /* 12 bits for the table index */
N    /* Index value calculation */
N    cI = ((Y & 0xFFF00000) >> 20u);
N
N    /* Care taken for table outside boundary */
N    /* Returns zero output when values are outside table boundary */
N    if(rI < 0 || rI > (S->numRows - 1) || cI < 0 || cI > (S->numCols - 1))
N    {
N      return (0);
N    }
N
N    /* 20 bits for the fractional part */
N    /* shift left xfract by 11 to keep 1.31 format */
N    xfract = (X & 0x000FFFFF) << 11u;
N
N    /* Read two nearest output values from the index */
N    x1 = pYData[(rI) + nCols * (cI)];
N    x2 = pYData[(rI) + nCols * (cI) + 1u];
N
N    /* 20 bits for the fractional part */
N    /* shift left yfract by 11 to keep 1.31 format */
N    yfract = (Y & 0x000FFFFF) << 11u;
N
N    /* Read two nearest output values from the index */
N    y1 = pYData[(rI) + nCols * (cI + 1)];
N    y2 = pYData[(rI) + nCols * (cI + 1) + 1u];
N
N    /* Calculation of x1 * (1-xfract ) * (1-yfract) and acc is in 3.29(q29) format */
N    out = ((q31_t) (((q63_t) x1 * (0x7FFFFFFF - xfract)) >> 32));
N    acc = ((q31_t) (((q63_t) out * (0x7FFFFFFF - yfract)) >> 32));
N
N    /* x2 * (xfract) * (1-yfract)  in 3.29(q29) and adding to acc */
N    out = ((q31_t) ((q63_t) x2 * (0x7FFFFFFF - yfract) >> 32));
N    acc += ((q31_t) ((q63_t) out * (xfract) >> 32));
N
N    /* y1 * (1 - xfract) * (yfract)  in 3.29(q29) and adding to acc */
N    out = ((q31_t) ((q63_t) y1 * (0x7FFFFFFF - xfract) >> 32));
N    acc += ((q31_t) ((q63_t) out * (yfract) >> 32));
N
N    /* y2 * (xfract) * (yfract)  in 3.29(q29) and adding to acc */
N    out = ((q31_t) ((q63_t) y2 * (xfract) >> 32));
N    acc += ((q31_t) ((q63_t) out * (yfract) >> 32));
N
N    /* Convert acc to 1.31(q31) format */
N    return (acc << 2u);
N
N  }
N
N  /**
N  * @brief  Q15 bilinear interpolation.
N  * @param[in,out] *S points to an instance of the interpolation structure.
N  * @param[in] X interpolation coordinate in 12.20 format.
N  * @param[in] Y interpolation coordinate in 12.20 format.
N  * @return out interpolated value.
N  */
N
N  static __INLINE q15_t arm_bilinear_interp_q15(
X  static __inline q15_t arm_bilinear_interp_q15(
N  arm_bilinear_interp_instance_q15 * S,
N  q31_t X,
N  q31_t Y)
N  {
N    q63_t acc = 0;                               /* output */
N    q31_t out;                                   /* Temporary output */
N    q15_t x1, x2, y1, y2;                        /* Nearest output values */
N    q31_t xfract, yfract;                        /* X, Y fractional parts */
N    int32_t rI, cI;                              /* Row and column indices */
N    q15_t *pYData = S->pData;                    /* pointer to output table values */
N    uint32_t nCols = S->numCols;                 /* num of rows */
N
N    /* Input is in 12.20 format */
N    /* 12 bits for the table index */
N    /* Index value calculation */
N    rI = ((X & 0xFFF00000) >> 20);
N
N    /* Input is in 12.20 format */
N    /* 12 bits for the table index */
N    /* Index value calculation */
N    cI = ((Y & 0xFFF00000) >> 20);
N
N    /* Care taken for table outside boundary */
N    /* Returns zero output when values are outside table boundary */
N    if(rI < 0 || rI > (S->numRows - 1) || cI < 0 || cI > (S->numCols - 1))
N    {
N      return (0);
N    }
N
N    /* 20 bits for the fractional part */
N    /* xfract should be in 12.20 format */
N    xfract = (X & 0x000FFFFF);
N
N    /* Read two nearest output values from the index */
N    x1 = pYData[(rI) + nCols * (cI)];
N    x2 = pYData[(rI) + nCols * (cI) + 1u];
N
N
N    /* 20 bits for the fractional part */
N    /* yfract should be in 12.20 format */
N    yfract = (Y & 0x000FFFFF);
N
N    /* Read two nearest output values from the index */
N    y1 = pYData[(rI) + nCols * (cI + 1)];
N    y2 = pYData[(rI) + nCols * (cI + 1) + 1u];
N
N    /* Calculation of x1 * (1-xfract ) * (1-yfract) and acc is in 13.51 format */
N
N    /* x1 is in 1.15(q15), xfract in 12.20 format and out is in 13.35 format */
N    /* convert 13.35 to 13.31 by right shifting  and out is in 1.31 */
N    out = (q31_t) (((q63_t) x1 * (0xFFFFF - xfract)) >> 4u);
N    acc = ((q63_t) out * (0xFFFFF - yfract));
N
N    /* x2 * (xfract) * (1-yfract)  in 1.51 and adding to acc */
N    out = (q31_t) (((q63_t) x2 * (0xFFFFF - yfract)) >> 4u);
N    acc += ((q63_t) out * (xfract));
N
N    /* y1 * (1 - xfract) * (yfract)  in 1.51 and adding to acc */
N    out = (q31_t) (((q63_t) y1 * (0xFFFFF - xfract)) >> 4u);
N    acc += ((q63_t) out * (yfract));
N
N    /* y2 * (xfract) * (yfract)  in 1.51 and adding to acc */
N    out = (q31_t) (((q63_t) y2 * (xfract)) >> 4u);
N    acc += ((q63_t) out * (yfract));
N
N    /* acc is in 13.51 format and down shift acc by 36 times */
N    /* Convert out to 1.15 format */
N    return (acc >> 36);
N
N  }
N
N  /**
N  * @brief  Q7 bilinear interpolation.
N  * @param[in,out] *S points to an instance of the interpolation structure.
N  * @param[in] X interpolation coordinate in 12.20 format.
N  * @param[in] Y interpolation coordinate in 12.20 format.
N  * @return out interpolated value.
N  */
N
N  static __INLINE q7_t arm_bilinear_interp_q7(
X  static __inline q7_t arm_bilinear_interp_q7(
N  arm_bilinear_interp_instance_q7 * S,
N  q31_t X,
N  q31_t Y)
N  {
N    q63_t acc = 0;                               /* output */
N    q31_t out;                                   /* Temporary output */
N    q31_t xfract, yfract;                        /* X, Y fractional parts */
N    q7_t x1, x2, y1, y2;                         /* Nearest output values */
N    int32_t rI, cI;                              /* Row and column indices */
N    q7_t *pYData = S->pData;                     /* pointer to output table values */
N    uint32_t nCols = S->numCols;                 /* num of rows */
N
N    /* Input is in 12.20 format */
N    /* 12 bits for the table index */
N    /* Index value calculation */
N    rI = ((X & 0xFFF00000) >> 20);
N
N    /* Input is in 12.20 format */
N    /* 12 bits for the table index */
N    /* Index value calculation */
N    cI = ((Y & 0xFFF00000) >> 20);
N
N    /* Care taken for table outside boundary */
N    /* Returns zero output when values are outside table boundary */
N    if(rI < 0 || rI > (S->numRows - 1) || cI < 0 || cI > (S->numCols - 1))
N    {
N      return (0);
N    }
N
N    /* 20 bits for the fractional part */
N    /* xfract should be in 12.20 format */
N    xfract = (X & 0x000FFFFF);
N
N    /* Read two nearest output values from the index */
N    x1 = pYData[(rI) + nCols * (cI)];
N    x2 = pYData[(rI) + nCols * (cI) + 1u];
N
N
N    /* 20 bits for the fractional part */
N    /* yfract should be in 12.20 format */
N    yfract = (Y & 0x000FFFFF);
N
N    /* Read two nearest output values from the index */
N    y1 = pYData[(rI) + nCols * (cI + 1)];
N    y2 = pYData[(rI) + nCols * (cI + 1) + 1u];
N
N    /* Calculation of x1 * (1-xfract ) * (1-yfract) and acc is in 16.47 format */
N    out = ((x1 * (0xFFFFF - xfract)));
N    acc = (((q63_t) out * (0xFFFFF - yfract)));
N
N    /* x2 * (xfract) * (1-yfract)  in 2.22 and adding to acc */
N    out = ((x2 * (0xFFFFF - yfract)));
N    acc += (((q63_t) out * (xfract)));
N
N    /* y1 * (1 - xfract) * (yfract)  in 2.22 and adding to acc */
N    out = ((y1 * (0xFFFFF - xfract)));
N    acc += (((q63_t) out * (yfract)));
N
N    /* y2 * (xfract) * (yfract)  in 2.22 and adding to acc */
N    out = ((y2 * (yfract)));
N    acc += (((q63_t) out * (xfract)));
N
N    /* acc in 16.47 format and down shift by 40 to convert to 1.7 format */
N    return (acc >> 40);
N
N  }
N
N  /**
N   * @} end of BilinearInterpolate group
N   */
N   
N
N//SMMLAR
N#define multAcc_32x32_keep32_R(a, x, y) \
N    a = (q31_t) (((((q63_t) a) << 32) + ((q63_t) x * y) + 0x80000000LL ) >> 32)
X#define multAcc_32x32_keep32_R(a, x, y)     a = (q31_t) (((((q63_t) a) << 32) + ((q63_t) x * y) + 0x80000000LL ) >> 32)
N
N//SMMLSR
N#define multSub_32x32_keep32_R(a, x, y) \
N    a = (q31_t) (((((q63_t) a) << 32) - ((q63_t) x * y) + 0x80000000LL ) >> 32)
X#define multSub_32x32_keep32_R(a, x, y)     a = (q31_t) (((((q63_t) a) << 32) - ((q63_t) x * y) + 0x80000000LL ) >> 32)
N
N//SMMULR
N#define mult_32x32_keep32_R(a, x, y) \
N    a = (q31_t) (((q63_t) x * y + 0x80000000LL ) >> 32)
X#define mult_32x32_keep32_R(a, x, y)     a = (q31_t) (((q63_t) x * y + 0x80000000LL ) >> 32)
N
N//SMMLA
N#define multAcc_32x32_keep32(a, x, y) \
N    a += (q31_t) (((q63_t) x * y) >> 32)
X#define multAcc_32x32_keep32(a, x, y)     a += (q31_t) (((q63_t) x * y) >> 32)
N
N//SMMLS
N#define multSub_32x32_keep32(a, x, y) \
N    a -= (q31_t) (((q63_t) x * y) >> 32)
X#define multSub_32x32_keep32(a, x, y)     a -= (q31_t) (((q63_t) x * y) >> 32)
N
N//SMMUL
N#define mult_32x32_keep32(a, x, y) \
N    a = (q31_t) (((q63_t) x * y ) >> 32)
X#define mult_32x32_keep32(a, x, y)     a = (q31_t) (((q63_t) x * y ) >> 32)
N
N
N#if defined ( __CC_ARM ) //Keil
X#if 1L 
N
N//Enter low optimization region - place directly above function definition
N    #ifdef ARM_MATH_CM4
N      #define LOW_OPTIMIZATION_ENTER \
N         _Pragma ("push")         \
N         _Pragma ("O1")
X      #define LOW_OPTIMIZATION_ENTER          _Pragma ("push")                  _Pragma ("O1")
N    #else
S      #define LOW_OPTIMIZATION_ENTER 
N    #endif
N
N//Exit low optimization region - place directly after end of function definition
N    #ifdef ARM_MATH_CM4
N      #define LOW_OPTIMIZATION_EXIT \
N         _Pragma ("pop")
X      #define LOW_OPTIMIZATION_EXIT          _Pragma ("pop")
N    #else
S      #define LOW_OPTIMIZATION_EXIT  
N    #endif
N
N//Enter low optimization region - place directly above function definition
N  #define IAR_ONLY_LOW_OPTIMIZATION_ENTER
N
N//Exit low optimization region - place directly after end of function definition
N  #define IAR_ONLY_LOW_OPTIMIZATION_EXIT
N
N#elif defined(__ICCARM__) //IAR
S
S//Enter low optimization region - place directly above function definition
S    #ifdef ARM_MATH_CM4
S      #define LOW_OPTIMIZATION_ENTER \
S         _Pragma ("optimize=low")
X      #define LOW_OPTIMIZATION_ENTER          _Pragma ("optimize=low")
S    #else
S      #define LOW_OPTIMIZATION_ENTER   
S    #endif
S
S//Exit low optimization region - place directly after end of function definition
S  #define LOW_OPTIMIZATION_EXIT
S
S//Enter low optimization region - place directly above function definition
S    #ifdef ARM_MATH_CM4
S      #define IAR_ONLY_LOW_OPTIMIZATION_ENTER \
S         _Pragma ("optimize=low")
X      #define IAR_ONLY_LOW_OPTIMIZATION_ENTER          _Pragma ("optimize=low")
S    #else
S      #define IAR_ONLY_LOW_OPTIMIZATION_ENTER   
S    #endif
S
S//Exit low optimization region - place directly after end of function definition
S  #define IAR_ONLY_LOW_OPTIMIZATION_EXIT
S
S#elif defined(__GNUC__)
S
S  #define LOW_OPTIMIZATION_ENTER __attribute__(( optimize("-O1") ))
S
S  #define LOW_OPTIMIZATION_EXIT
S
S  #define IAR_ONLY_LOW_OPTIMIZATION_ENTER
S
S  #define IAR_ONLY_LOW_OPTIMIZATION_EXIT
S
S#elif defined(__CSMC__)		// Cosmic
S
S#define LOW_OPTIMIZATION_ENTER
S#define LOW_OPTIMIZATION_EXIT
S#define IAR_ONLY_LOW_OPTIMIZATION_ENTER
S#define IAR_ONLY_LOW_OPTIMIZATION_EXIT
S
N#endif
N
Nextern void arm_bitreversal_32(
N    uint32_t * pSrc,
N    const uint16_t bitRevLen,
N    const uint16_t * pBitRevTable);
N
N
N#ifdef	__cplusplus
S}
N#endif
N
N
N
N
N#endif /* _ARM_MATH_H */
N
N/**
N *
N * End of file.
N */
L 42 "src\TransformFunctions\arm_rfft_init_q31.c" 2
N#include "arm_common_tables.h"
L 1 ".\inc\arm_common_tables.h" 1
N/* ----------------------------------------------------------------------
N* Copyright (C) 2010-2014 ARM Limited. All rights reserved.
N*
N* $Date:        31. July 2014
N* $Revision: 	V1.4.4
N*
N* Project: 	    CMSIS DSP Library
N* Title:	    arm_common_tables.h
N*
N* Description:	This file has extern declaration for common tables like Bitreverse, reciprocal etc which are used across different functions
N*
N* Target Processor: Cortex-M4/Cortex-M3
N*
N* Redistribution and use in source and binary forms, with or without
N* modification, are permitted provided that the following conditions
N* are met:
N*   - Redistributions of source code must retain the above copyright
N*     notice, this list of conditions and the following disclaimer.
N*   - Redistributions in binary form must reproduce the above copyright
N*     notice, this list of conditions and the following disclaimer in
N*     the documentation and/or other materials provided with the
N*     distribution.
N*   - Neither the name of ARM LIMITED nor the names of its contributors
N*     may be used to endorse or promote products derived from this
N*     software without specific prior written permission.
N*
N* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
N* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
N* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
N* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
N* COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
N* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
N* BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
N* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N* CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N* LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
N* ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N* POSSIBILITY OF SUCH DAMAGE.
N* -------------------------------------------------------------------- */
N
N#ifndef _ARM_COMMON_TABLES_H
N#define _ARM_COMMON_TABLES_H
N
N#include "arm_math.h"
N
Nextern const uint16_t armBitRevTable[1024];
Nextern const q15_t armRecipTableQ15[64];
Nextern const q31_t armRecipTableQ31[64];
N//extern const q31_t realCoefAQ31[1024];
N//extern const q31_t realCoefBQ31[1024];
Nextern const float32_t twiddleCoef_16[32];
Nextern const float32_t twiddleCoef_32[64];
Nextern const float32_t twiddleCoef_64[128];
Nextern const float32_t twiddleCoef_128[256];
Nextern const float32_t twiddleCoef_256[512];
Nextern const float32_t twiddleCoef_512[1024];
Nextern const float32_t twiddleCoef_1024[2048];
Nextern const float32_t twiddleCoef_2048[4096];
Nextern const float32_t twiddleCoef_4096[8192];
N#define twiddleCoef twiddleCoef_4096
Nextern const q31_t twiddleCoef_16_q31[24];
Nextern const q31_t twiddleCoef_32_q31[48];
Nextern const q31_t twiddleCoef_64_q31[96];
Nextern const q31_t twiddleCoef_128_q31[192];
Nextern const q31_t twiddleCoef_256_q31[384];
Nextern const q31_t twiddleCoef_512_q31[768];
Nextern const q31_t twiddleCoef_1024_q31[1536];
Nextern const q31_t twiddleCoef_2048_q31[3072];
Nextern const q31_t twiddleCoef_4096_q31[6144];
Nextern const q15_t twiddleCoef_16_q15[24];
Nextern const q15_t twiddleCoef_32_q15[48];
Nextern const q15_t twiddleCoef_64_q15[96];
Nextern const q15_t twiddleCoef_128_q15[192];
Nextern const q15_t twiddleCoef_256_q15[384];
Nextern const q15_t twiddleCoef_512_q15[768];
Nextern const q15_t twiddleCoef_1024_q15[1536];
Nextern const q15_t twiddleCoef_2048_q15[3072];
Nextern const q15_t twiddleCoef_4096_q15[6144];
Nextern const float32_t twiddleCoef_rfft_32[32];
Nextern const float32_t twiddleCoef_rfft_64[64];
Nextern const float32_t twiddleCoef_rfft_128[128];
Nextern const float32_t twiddleCoef_rfft_256[256];
Nextern const float32_t twiddleCoef_rfft_512[512];
Nextern const float32_t twiddleCoef_rfft_1024[1024];
Nextern const float32_t twiddleCoef_rfft_2048[2048];
Nextern const float32_t twiddleCoef_rfft_4096[4096];
N
N
N/* floating-point bit reversal tables */
N#define ARMBITREVINDEXTABLE__16_TABLE_LENGTH ((uint16_t)20  )
N#define ARMBITREVINDEXTABLE__32_TABLE_LENGTH ((uint16_t)48  )
N#define ARMBITREVINDEXTABLE__64_TABLE_LENGTH ((uint16_t)56  )
N#define ARMBITREVINDEXTABLE_128_TABLE_LENGTH ((uint16_t)208 )
N#define ARMBITREVINDEXTABLE_256_TABLE_LENGTH ((uint16_t)440 )
N#define ARMBITREVINDEXTABLE_512_TABLE_LENGTH ((uint16_t)448 )
N#define ARMBITREVINDEXTABLE1024_TABLE_LENGTH ((uint16_t)1800)
N#define ARMBITREVINDEXTABLE2048_TABLE_LENGTH ((uint16_t)3808)
N#define ARMBITREVINDEXTABLE4096_TABLE_LENGTH ((uint16_t)4032)
N
Nextern const uint16_t armBitRevIndexTable16[ARMBITREVINDEXTABLE__16_TABLE_LENGTH];
Xextern const uint16_t armBitRevIndexTable16[((uint16_t)20 )];
Nextern const uint16_t armBitRevIndexTable32[ARMBITREVINDEXTABLE__32_TABLE_LENGTH];
Xextern const uint16_t armBitRevIndexTable32[((uint16_t)48 )];
Nextern const uint16_t armBitRevIndexTable64[ARMBITREVINDEXTABLE__64_TABLE_LENGTH];
Xextern const uint16_t armBitRevIndexTable64[((uint16_t)56 )];
Nextern const uint16_t armBitRevIndexTable128[ARMBITREVINDEXTABLE_128_TABLE_LENGTH];
Xextern const uint16_t armBitRevIndexTable128[((uint16_t)208 )];
Nextern const uint16_t armBitRevIndexTable256[ARMBITREVINDEXTABLE_256_TABLE_LENGTH];
Xextern const uint16_t armBitRevIndexTable256[((uint16_t)440 )];
Nextern const uint16_t armBitRevIndexTable512[ARMBITREVINDEXTABLE_512_TABLE_LENGTH];
Xextern const uint16_t armBitRevIndexTable512[((uint16_t)448 )];
Nextern const uint16_t armBitRevIndexTable1024[ARMBITREVINDEXTABLE1024_TABLE_LENGTH];
Xextern const uint16_t armBitRevIndexTable1024[((uint16_t)1800)];
Nextern const uint16_t armBitRevIndexTable2048[ARMBITREVINDEXTABLE2048_TABLE_LENGTH];
Xextern const uint16_t armBitRevIndexTable2048[((uint16_t)3808)];
Nextern const uint16_t armBitRevIndexTable4096[ARMBITREVINDEXTABLE4096_TABLE_LENGTH];
Xextern const uint16_t armBitRevIndexTable4096[((uint16_t)4032)];
N
N/* fixed-point bit reversal tables */
N#define ARMBITREVINDEXTABLE_FIXED___16_TABLE_LENGTH ((uint16_t)12  )
N#define ARMBITREVINDEXTABLE_FIXED___32_TABLE_LENGTH ((uint16_t)24  )
N#define ARMBITREVINDEXTABLE_FIXED___64_TABLE_LENGTH ((uint16_t)56  )
N#define ARMBITREVINDEXTABLE_FIXED__128_TABLE_LENGTH ((uint16_t)112 )
N#define ARMBITREVINDEXTABLE_FIXED__256_TABLE_LENGTH ((uint16_t)240 )
N#define ARMBITREVINDEXTABLE_FIXED__512_TABLE_LENGTH ((uint16_t)480 )
N#define ARMBITREVINDEXTABLE_FIXED_1024_TABLE_LENGTH ((uint16_t)992 )
N#define ARMBITREVINDEXTABLE_FIXED_2048_TABLE_LENGTH ((uint16_t)1984)
N#define ARMBITREVINDEXTABLE_FIXED_4096_TABLE_LENGTH ((uint16_t)4032)
N
Nextern const uint16_t armBitRevIndexTable_fixed_16[ARMBITREVINDEXTABLE_FIXED___16_TABLE_LENGTH];
Xextern const uint16_t armBitRevIndexTable_fixed_16[((uint16_t)12 )];
Nextern const uint16_t armBitRevIndexTable_fixed_32[ARMBITREVINDEXTABLE_FIXED___32_TABLE_LENGTH];
Xextern const uint16_t armBitRevIndexTable_fixed_32[((uint16_t)24 )];
Nextern const uint16_t armBitRevIndexTable_fixed_64[ARMBITREVINDEXTABLE_FIXED___64_TABLE_LENGTH];
Xextern const uint16_t armBitRevIndexTable_fixed_64[((uint16_t)56 )];
Nextern const uint16_t armBitRevIndexTable_fixed_128[ARMBITREVINDEXTABLE_FIXED__128_TABLE_LENGTH];
Xextern const uint16_t armBitRevIndexTable_fixed_128[((uint16_t)112 )];
Nextern const uint16_t armBitRevIndexTable_fixed_256[ARMBITREVINDEXTABLE_FIXED__256_TABLE_LENGTH];
Xextern const uint16_t armBitRevIndexTable_fixed_256[((uint16_t)240 )];
Nextern const uint16_t armBitRevIndexTable_fixed_512[ARMBITREVINDEXTABLE_FIXED__512_TABLE_LENGTH];
Xextern const uint16_t armBitRevIndexTable_fixed_512[((uint16_t)480 )];
Nextern const uint16_t armBitRevIndexTable_fixed_1024[ARMBITREVINDEXTABLE_FIXED_1024_TABLE_LENGTH];
Xextern const uint16_t armBitRevIndexTable_fixed_1024[((uint16_t)992 )];
Nextern const uint16_t armBitRevIndexTable_fixed_2048[ARMBITREVINDEXTABLE_FIXED_2048_TABLE_LENGTH];
Xextern const uint16_t armBitRevIndexTable_fixed_2048[((uint16_t)1984)];
Nextern const uint16_t armBitRevIndexTable_fixed_4096[ARMBITREVINDEXTABLE_FIXED_4096_TABLE_LENGTH];
Xextern const uint16_t armBitRevIndexTable_fixed_4096[((uint16_t)4032)];
N
N/* Tables for Fast Math Sine and Cosine */
Nextern const float32_t sinTable_f32[FAST_MATH_TABLE_SIZE + 1];
Xextern const float32_t sinTable_f32[512 + 1];
Nextern const q31_t sinTable_q31[FAST_MATH_TABLE_SIZE + 1];
Xextern const q31_t sinTable_q31[512 + 1];
Nextern const q15_t sinTable_q15[FAST_MATH_TABLE_SIZE + 1];
Xextern const q15_t sinTable_q15[512 + 1];
N
N#endif /*  ARM_COMMON_TABLES_H */
L 43 "src\TransformFunctions\arm_rfft_init_q31.c" 2
N#include "arm_const_structs.h"
L 1 ".\inc\arm_const_structs.h" 1
N/* ----------------------------------------------------------------------
N* Copyright (C) 2010-2014 ARM Limited. All rights reserved.
N*
N* $Date:        31. July 2014
N* $Revision: 	V1.4.4
N*
N* Project: 	    CMSIS DSP Library
N* Title:	    arm_const_structs.h
N*
N* Description:	This file has constant structs that are initialized for
N*              user convenience.  For example, some can be given as
N*              arguments to the arm_cfft_f32() function.
N*
N* Target Processor: Cortex-M4/Cortex-M3
N*
N* Redistribution and use in source and binary forms, with or without
N* modification, are permitted provided that the following conditions
N* are met:
N*   - Redistributions of source code must retain the above copyright
N*     notice, this list of conditions and the following disclaimer.
N*   - Redistributions in binary form must reproduce the above copyright
N*     notice, this list of conditions and the following disclaimer in
N*     the documentation and/or other materials provided with the
N*     distribution.
N*   - Neither the name of ARM LIMITED nor the names of its contributors
N*     may be used to endorse or promote products derived from this
N*     software without specific prior written permission.
N*
N* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
N* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
N* LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
N* FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
N* COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
N* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
N* BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
N* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
N* CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
N* LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
N* ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
N* POSSIBILITY OF SUCH DAMAGE.
N* -------------------------------------------------------------------- */
N
N#ifndef _ARM_CONST_STRUCTS_H
N#define _ARM_CONST_STRUCTS_H
N
N#include "arm_math.h"
N#include "arm_common_tables.h"
N
N   extern const arm_cfft_instance_f32 arm_cfft_sR_f32_len16;
N   extern const arm_cfft_instance_f32 arm_cfft_sR_f32_len32;
N   extern const arm_cfft_instance_f32 arm_cfft_sR_f32_len64;
N   extern const arm_cfft_instance_f32 arm_cfft_sR_f32_len128;
N   extern const arm_cfft_instance_f32 arm_cfft_sR_f32_len256;
N   extern const arm_cfft_instance_f32 arm_cfft_sR_f32_len512;
N   extern const arm_cfft_instance_f32 arm_cfft_sR_f32_len1024;
N   extern const arm_cfft_instance_f32 arm_cfft_sR_f32_len2048;
N   extern const arm_cfft_instance_f32 arm_cfft_sR_f32_len4096;
N
N   extern const arm_cfft_instance_q31 arm_cfft_sR_q31_len16;
N   extern const arm_cfft_instance_q31 arm_cfft_sR_q31_len32;
N   extern const arm_cfft_instance_q31 arm_cfft_sR_q31_len64;
N   extern const arm_cfft_instance_q31 arm_cfft_sR_q31_len128;
N   extern const arm_cfft_instance_q31 arm_cfft_sR_q31_len256;
N   extern const arm_cfft_instance_q31 arm_cfft_sR_q31_len512;
N   extern const arm_cfft_instance_q31 arm_cfft_sR_q31_len1024;
N   extern const arm_cfft_instance_q31 arm_cfft_sR_q31_len2048;
N   extern const arm_cfft_instance_q31 arm_cfft_sR_q31_len4096;
N
N   extern const arm_cfft_instance_q15 arm_cfft_sR_q15_len16;
N   extern const arm_cfft_instance_q15 arm_cfft_sR_q15_len32;
N   extern const arm_cfft_instance_q15 arm_cfft_sR_q15_len64;
N   extern const arm_cfft_instance_q15 arm_cfft_sR_q15_len128;
N   extern const arm_cfft_instance_q15 arm_cfft_sR_q15_len256;
N   extern const arm_cfft_instance_q15 arm_cfft_sR_q15_len512;
N   extern const arm_cfft_instance_q15 arm_cfft_sR_q15_len1024;
N   extern const arm_cfft_instance_q15 arm_cfft_sR_q15_len2048;
N   extern const arm_cfft_instance_q15 arm_cfft_sR_q15_len4096;
N
N#endif
L 44 "src\TransformFunctions\arm_rfft_init_q31.c" 2
N
N/**    
N* @ingroup groupTransforms    
N*/
N
N/**    
N* @addtogroup RealFFT    
N* @{    
N*/
N
N/**    
N* \par    
N* Generation fixed-point realCoefAQ31 array in Q31 format:    
N* \par    
N* n = 4096    
N* <pre>for (i = 0; i < n; i++)    
N* {    
N*    pATable[2 * i] = 0.5 * (1.0 - sin (2 * PI / (double) (2 * n) * (double) i));    
N*    pATable[2 * i + 1] = 0.5 * (-1.0 * cos (2 * PI / (double) (2 * n) * (double) i));    
N* }</pre>    
N* \par    
N* Convert to fixed point Q31 format    
N*     round(pATable[i] * pow(2, 31))    
N*/
N
N
Nstatic const q31_t realCoefAQ31[8192] = {
N    0x40000000, 0xc0000000, 0x3ff36f02, 0xc000013c,
N    0x3fe6de05, 0xc00004ef, 0x3fda4d09, 0xc0000b1a,
N    0x3fcdbc0f, 0xc00013bd, 0x3fc12b16, 0xc0001ed8,
N    0x3fb49a1f, 0xc0002c6a, 0x3fa8092c, 0xc0003c74,
N    0x3f9b783c, 0xc0004ef5, 0x3f8ee750, 0xc00063ee,
N    0x3f825668, 0xc0007b5f, 0x3f75c585, 0xc0009547,
N    0x3f6934a8, 0xc000b1a7, 0x3f5ca3d0, 0xc000d07e,
N    0x3f5012fe, 0xc000f1ce, 0x3f438234, 0xc0011594,
N    0x3f36f170, 0xc0013bd3, 0x3f2a60b4, 0xc0016489,
N    0x3f1dd001, 0xc0018fb6, 0x3f113f56, 0xc001bd5c,
N    0x3f04aeb5, 0xc001ed78, 0x3ef81e1d, 0xc002200d,
N    0x3eeb8d8f, 0xc0025519, 0x3edefd0c, 0xc0028c9c,
N    0x3ed26c94, 0xc002c697, 0x3ec5dc28, 0xc003030a,
N    0x3eb94bc8, 0xc00341f4, 0x3eacbb74, 0xc0038356,
N    0x3ea02b2e, 0xc003c72f, 0x3e939af5, 0xc0040d80,
N    0x3e870aca, 0xc0045648, 0x3e7a7aae, 0xc004a188,
N    0x3e6deaa1, 0xc004ef3f, 0x3e615aa3, 0xc0053f6e,
N    0x3e54cab5, 0xc0059214, 0x3e483ad8, 0xc005e731,
N    0x3e3bab0b, 0xc0063ec6, 0x3e2f1b50, 0xc00698d3,
N    0x3e228ba7, 0xc006f556, 0x3e15fc11, 0xc0075452,
N    0x3e096c8d, 0xc007b5c4, 0x3dfcdd1d, 0xc00819ae,
N    0x3df04dc0, 0xc008800f, 0x3de3be78, 0xc008e8e8,
N    0x3dd72f45, 0xc0095438, 0x3dcaa027, 0xc009c1ff,
N    0x3dbe111e, 0xc00a323d, 0x3db1822c, 0xc00aa4f3,
N    0x3da4f351, 0xc00b1a20, 0x3d98648d, 0xc00b91c4,
N    0x3d8bd5e1, 0xc00c0be0, 0x3d7f474d, 0xc00c8872,
N    0x3d72b8d2, 0xc00d077c, 0x3d662a70, 0xc00d88fd,
N    0x3d599c28, 0xc00e0cf5, 0x3d4d0df9, 0xc00e9364,
N    0x3d407fe6, 0xc00f1c4a, 0x3d33f1ed, 0xc00fa7a8,
N    0x3d276410, 0xc010357c, 0x3d1ad650, 0xc010c5c7,
N    0x3d0e48ab, 0xc011588a, 0x3d01bb24, 0xc011edc3,
N    0x3cf52dbb, 0xc0128574, 0x3ce8a06f, 0xc0131f9b,
N    0x3cdc1342, 0xc013bc39, 0x3ccf8634, 0xc0145b4e,
N    0x3cc2f945, 0xc014fcda, 0x3cb66c77, 0xc015a0dd,
N    0x3ca9dfc8, 0xc0164757, 0x3c9d533b, 0xc016f047,
N    0x3c90c6cf, 0xc0179bae, 0x3c843a85, 0xc018498c,
N    0x3c77ae5e, 0xc018f9e1, 0x3c6b2259, 0xc019acac,
N    0x3c5e9678, 0xc01a61ee, 0x3c520aba, 0xc01b19a7,
N    0x3c457f21, 0xc01bd3d6, 0x3c38f3ac, 0xc01c907c,
N    0x3c2c685d, 0xc01d4f99, 0x3c1fdd34, 0xc01e112b,
N    0x3c135231, 0xc01ed535, 0x3c06c754, 0xc01f9bb5,
N    0x3bfa3c9f, 0xc02064ab, 0x3bedb212, 0xc0213018,
N    0x3be127ac, 0xc021fdfb, 0x3bd49d70, 0xc022ce54,
N    0x3bc8135c, 0xc023a124, 0x3bbb8973, 0xc024766a,
N    0x3baeffb3, 0xc0254e27, 0x3ba2761e, 0xc0262859,
N    0x3b95ecb4, 0xc0270502, 0x3b896375, 0xc027e421,
N    0x3b7cda63, 0xc028c5b6, 0x3b70517d, 0xc029a9c1,
N    0x3b63c8c4, 0xc02a9042, 0x3b574039, 0xc02b7939,
N    0x3b4ab7db, 0xc02c64a6, 0x3b3e2fac, 0xc02d5289,
N    0x3b31a7ac, 0xc02e42e2, 0x3b251fdc, 0xc02f35b1,
N    0x3b18983b, 0xc0302af5, 0x3b0c10cb, 0xc03122b0,
N    0x3aff898c, 0xc0321ce0, 0x3af3027e, 0xc0331986,
N    0x3ae67ba2, 0xc03418a2, 0x3ad9f4f8, 0xc0351a33,
N    0x3acd6e81, 0xc0361e3a, 0x3ac0e83d, 0xc03724b6,
N    0x3ab4622d, 0xc0382da8, 0x3aa7dc52, 0xc0393910,
N    0x3a9b56ab, 0xc03a46ed, 0x3a8ed139, 0xc03b573f,
N    0x3a824bfd, 0xc03c6a07, 0x3a75c6f8, 0xc03d7f44,
N    0x3a694229, 0xc03e96f6, 0x3a5cbd91, 0xc03fb11d,
N    0x3a503930, 0xc040cdba, 0x3a43b508, 0xc041eccc,
N    0x3a373119, 0xc0430e53, 0x3a2aad62, 0xc044324f,
N    0x3a1e29e5, 0xc04558c0, 0x3a11a6a3, 0xc04681a6,
N    0x3a05239a, 0xc047ad01, 0x39f8a0cd, 0xc048dad1,
N    0x39ec1e3b, 0xc04a0b16, 0x39df9be6, 0xc04b3dcf,
N    0x39d319cc, 0xc04c72fe, 0x39c697f0, 0xc04daaa1,
N    0x39ba1651, 0xc04ee4b8, 0x39ad94f0, 0xc0502145,
N    0x39a113cd, 0xc0516045, 0x399492ea, 0xc052a1bb,
N    0x39881245, 0xc053e5a5, 0x397b91e1, 0xc0552c03,
N    0x396f11bc, 0xc05674d6, 0x396291d9, 0xc057c01d,
N    0x39561237, 0xc0590dd8, 0x394992d7, 0xc05a5e07,
N    0x393d13b8, 0xc05bb0ab, 0x393094dd, 0xc05d05c3,
N    0x39241645, 0xc05e5d4e, 0x391797f0, 0xc05fb74e,
N    0x390b19e0, 0xc06113c2, 0x38fe9c15, 0xc06272aa,
N    0x38f21e8e, 0xc063d405, 0x38e5a14d, 0xc06537d4,
N    0x38d92452, 0xc0669e18, 0x38cca79e, 0xc06806ce,
N    0x38c02b31, 0xc06971f9, 0x38b3af0c, 0xc06adf97,
N    0x38a7332e, 0xc06c4fa8, 0x389ab799, 0xc06dc22e,
N    0x388e3c4d, 0xc06f3726, 0x3881c14b, 0xc070ae92,
N    0x38754692, 0xc0722871, 0x3868cc24, 0xc073a4c3,
N    0x385c5201, 0xc0752389, 0x384fd829, 0xc076a4c2,
N    0x38435e9d, 0xc078286e, 0x3836e55d, 0xc079ae8c,
N    0x382a6c6a, 0xc07b371e, 0x381df3c5, 0xc07cc223,
N    0x38117b6d, 0xc07e4f9b, 0x38050364, 0xc07fdf85,
N    0x37f88ba9, 0xc08171e2, 0x37ec143e, 0xc08306b2,
N    0x37df9d22, 0xc0849df4, 0x37d32657, 0xc08637a9,
N    0x37c6afdc, 0xc087d3d0, 0x37ba39b3, 0xc089726a,
N    0x37adc3db, 0xc08b1376, 0x37a14e55, 0xc08cb6f5,
N    0x3794d922, 0xc08e5ce5, 0x37886442, 0xc0900548,
N    0x377befb5, 0xc091b01d, 0x376f7b7d, 0xc0935d64,
N    0x37630799, 0xc0950d1d, 0x3756940a, 0xc096bf48,
N    0x374a20d0, 0xc09873e4, 0x373daded, 0xc09a2af3,
N    0x37313b60, 0xc09be473, 0x3724c92a, 0xc09da065,
N    0x3718574b, 0xc09f5ec8, 0x370be5c4, 0xc0a11f9d,
N    0x36ff7496, 0xc0a2e2e3, 0x36f303c0, 0xc0a4a89b,
N    0x36e69344, 0xc0a670c4, 0x36da2321, 0xc0a83b5e,
N    0x36cdb359, 0xc0aa086a, 0x36c143ec, 0xc0abd7e6,
N    0x36b4d4d9, 0xc0ada9d4, 0x36a86623, 0xc0af7e33,
N    0x369bf7c9, 0xc0b15502, 0x368f89cb, 0xc0b32e42,
N    0x36831c2b, 0xc0b509f3, 0x3676aee8, 0xc0b6e815,
N    0x366a4203, 0xc0b8c8a7, 0x365dd57d, 0xc0baabaa,
N    0x36516956, 0xc0bc911d, 0x3644fd8f, 0xc0be7901,
N    0x36389228, 0xc0c06355, 0x362c2721, 0xc0c25019,
N    0x361fbc7b, 0xc0c43f4d, 0x36135237, 0xc0c630f2,
N    0x3606e854, 0xc0c82506, 0x35fa7ed4, 0xc0ca1b8a,
N    0x35ee15b7, 0xc0cc147f, 0x35e1acfd, 0xc0ce0fe3,
N    0x35d544a7, 0xc0d00db6, 0x35c8dcb6, 0xc0d20dfa,
N    0x35bc7529, 0xc0d410ad, 0x35b00e02, 0xc0d615cf,
N    0x35a3a740, 0xc0d81d61, 0x359740e5, 0xc0da2762,
N    0x358adaf0, 0xc0dc33d2, 0x357e7563, 0xc0de42b2,
N    0x3572103d, 0xc0e05401, 0x3565ab80, 0xc0e267be,
N    0x3559472b, 0xc0e47deb, 0x354ce33f, 0xc0e69686,
N    0x35407fbd, 0xc0e8b190, 0x35341ca5, 0xc0eacf09,
N    0x3527b9f7, 0xc0eceef1, 0x351b57b5, 0xc0ef1147,
N    0x350ef5de, 0xc0f1360b, 0x35029473, 0xc0f35d3e,
N    0x34f63374, 0xc0f586df, 0x34e9d2e3, 0xc0f7b2ee,
N    0x34dd72be, 0xc0f9e16b, 0x34d11308, 0xc0fc1257,
N    0x34c4b3c0, 0xc0fe45b0, 0x34b854e7, 0xc1007b77,
N    0x34abf67e, 0xc102b3ac, 0x349f9884, 0xc104ee4f,
N    0x34933afa, 0xc1072b5f, 0x3486dde1, 0xc1096add,
N    0x347a8139, 0xc10bacc8, 0x346e2504, 0xc10df120,
N    0x3461c940, 0xc11037e6, 0x34556def, 0xc1128119,
N    0x34491311, 0xc114ccb9, 0x343cb8a7, 0xc1171ac6,
N    0x34305eb0, 0xc1196b3f, 0x3424052f, 0xc11bbe26,
N    0x3417ac22, 0xc11e1379, 0x340b538b, 0xc1206b39,
N    0x33fefb6a, 0xc122c566, 0x33f2a3bf, 0xc12521ff,
N    0x33e64c8c, 0xc1278104, 0x33d9f5cf, 0xc129e276,
N    0x33cd9f8b, 0xc12c4653, 0x33c149bf, 0xc12eac9d,
N    0x33b4f46c, 0xc1311553, 0x33a89f92, 0xc1338075,
N    0x339c4b32, 0xc135ee02, 0x338ff74d, 0xc1385dfb,
N    0x3383a3e2, 0xc13ad060, 0x337750f2, 0xc13d4530,
N    0x336afe7e, 0xc13fbc6c, 0x335eac86, 0xc1423613,
N    0x33525b0b, 0xc144b225, 0x33460a0d, 0xc14730a3,
N    0x3339b98d, 0xc149b18b, 0x332d698a, 0xc14c34df,
N    0x33211a07, 0xc14eba9d, 0x3314cb02, 0xc15142c6,
N    0x33087c7d, 0xc153cd5a, 0x32fc2e77, 0xc1565a58,
N    0x32efe0f2, 0xc158e9c1, 0x32e393ef, 0xc15b7b94,
N    0x32d7476c, 0xc15e0fd1, 0x32cafb6b, 0xc160a678,
N    0x32beafed, 0xc1633f8a, 0x32b264f2, 0xc165db05,
N    0x32a61a7a, 0xc16878eb, 0x3299d085, 0xc16b193a,
N    0x328d8715, 0xc16dbbf3, 0x32813e2a, 0xc1706115,
N    0x3274f5c3, 0xc17308a1, 0x3268ade3, 0xc175b296,
N    0x325c6688, 0xc1785ef4, 0x32501fb5, 0xc17b0dbb,
N    0x3243d968, 0xc17dbeec, 0x323793a3, 0xc1807285,
N    0x322b4e66, 0xc1832888, 0x321f09b1, 0xc185e0f3,
N    0x3212c585, 0xc1889bc6, 0x320681e3, 0xc18b5903,
N    0x31fa3ecb, 0xc18e18a7, 0x31edfc3d, 0xc190dab4,
N    0x31e1ba3a, 0xc1939f29, 0x31d578c2, 0xc1966606,
N    0x31c937d6, 0xc1992f4c, 0x31bcf777, 0xc19bfaf9,
N    0x31b0b7a4, 0xc19ec90d, 0x31a4785e, 0xc1a1998a,
N    0x319839a6, 0xc1a46c6e, 0x318bfb7d, 0xc1a741b9,
N    0x317fbde2, 0xc1aa196c, 0x317380d6, 0xc1acf386,
N    0x31674459, 0xc1afd007, 0x315b086d, 0xc1b2aef0,
N    0x314ecd11, 0xc1b5903f, 0x31429247, 0xc1b873f5,
N    0x3136580d, 0xc1bb5a11, 0x312a1e66, 0xc1be4294,
N    0x311de551, 0xc1c12d7e, 0x3111accf, 0xc1c41ace,
N    0x310574e0, 0xc1c70a84, 0x30f93d86, 0xc1c9fca0,
N    0x30ed06bf, 0xc1ccf122, 0x30e0d08d, 0xc1cfe80a,
N    0x30d49af1, 0xc1d2e158, 0x30c865ea, 0xc1d5dd0c,
N    0x30bc317a, 0xc1d8db25, 0x30affda0, 0xc1dbdba3,
N    0x30a3ca5d, 0xc1dede87, 0x309797b2, 0xc1e1e3d0,
N    0x308b659f, 0xc1e4eb7e, 0x307f3424, 0xc1e7f591,
N    0x30730342, 0xc1eb0209, 0x3066d2fa, 0xc1ee10e5,
N    0x305aa34c, 0xc1f12227, 0x304e7438, 0xc1f435cc,
N    0x304245c0, 0xc1f74bd6, 0x303617e2, 0xc1fa6445,
N    0x3029eaa1, 0xc1fd7f17, 0x301dbdfb, 0xc2009c4e,
N    0x301191f3, 0xc203bbe8, 0x30056687, 0xc206dde6,
N    0x2ff93bba, 0xc20a0248, 0x2fed118a, 0xc20d290d,
N    0x2fe0e7f9, 0xc2105236, 0x2fd4bf08, 0xc2137dc2,
N    0x2fc896b5, 0xc216abb1, 0x2fbc6f03, 0xc219dc03,
N    0x2fb047f2, 0xc21d0eb8, 0x2fa42181, 0xc22043d0,
N    0x2f97fbb2, 0xc2237b4b, 0x2f8bd685, 0xc226b528,
N    0x2f7fb1fa, 0xc229f167, 0x2f738e12, 0xc22d3009,
N    0x2f676ace, 0xc230710d, 0x2f5b482d, 0xc233b473,
N    0x2f4f2630, 0xc236fa3b, 0x2f4304d8, 0xc23a4265,
N    0x2f36e426, 0xc23d8cf1, 0x2f2ac419, 0xc240d9de,
N    0x2f1ea4b2, 0xc244292c, 0x2f1285f2, 0xc2477adc,
N    0x2f0667d9, 0xc24aceed, 0x2efa4a67, 0xc24e255e,
N    0x2eee2d9d, 0xc2517e31, 0x2ee2117c, 0xc254d965,
N    0x2ed5f604, 0xc25836f9, 0x2ec9db35, 0xc25b96ee,
N    0x2ebdc110, 0xc25ef943, 0x2eb1a796, 0xc2625df8,
N    0x2ea58ec6, 0xc265c50e, 0x2e9976a1, 0xc2692e83,
N    0x2e8d5f29, 0xc26c9a58, 0x2e81485c, 0xc270088e,
N    0x2e75323c, 0xc2737922, 0x2e691cc9, 0xc276ec16,
N    0x2e5d0804, 0xc27a616a, 0x2e50f3ed, 0xc27dd91c,
N    0x2e44e084, 0xc281532e, 0x2e38cdcb, 0xc284cf9f,
N    0x2e2cbbc1, 0xc2884e6e, 0x2e20aa67, 0xc28bcf9c,
N    0x2e1499bd, 0xc28f5329, 0x2e0889c4, 0xc292d914,
N    0x2dfc7a7c, 0xc296615d, 0x2df06be6, 0xc299ec05,
N    0x2de45e03, 0xc29d790a, 0x2dd850d2, 0xc2a1086d,
N    0x2dcc4454, 0xc2a49a2e, 0x2dc0388a, 0xc2a82e4d,
N    0x2db42d74, 0xc2abc4c9, 0x2da82313, 0xc2af5da2,
N    0x2d9c1967, 0xc2b2f8d8, 0x2d901070, 0xc2b6966c,
N    0x2d84082f, 0xc2ba365c, 0x2d7800a5, 0xc2bdd8a9,
N    0x2d6bf9d1, 0xc2c17d52, 0x2d5ff3b5, 0xc2c52459,
N    0x2d53ee51, 0xc2c8cdbb, 0x2d47e9a5, 0xc2cc7979,
N    0x2d3be5b1, 0xc2d02794, 0x2d2fe277, 0xc2d3d80a,
N    0x2d23dff7, 0xc2d78add, 0x2d17de31, 0xc2db400a,
N    0x2d0bdd25, 0xc2def794, 0x2cffdcd4, 0xc2e2b178,
N    0x2cf3dd3f, 0xc2e66db8, 0x2ce7de66, 0xc2ea2c53,
N    0x2cdbe04a, 0xc2eded49, 0x2ccfe2ea, 0xc2f1b099,
N    0x2cc3e648, 0xc2f57644, 0x2cb7ea63, 0xc2f93e4a,
N    0x2cabef3d, 0xc2fd08a9, 0x2c9ff4d6, 0xc300d563,
N    0x2c93fb2e, 0xc304a477, 0x2c880245, 0xc30875e5,
N    0x2c7c0a1d, 0xc30c49ad, 0x2c7012b5, 0xc3101fce,
N    0x2c641c0e, 0xc313f848, 0x2c582629, 0xc317d31c,
N    0x2c4c3106, 0xc31bb049, 0x2c403ca5, 0xc31f8fcf,
N    0x2c344908, 0xc32371ae, 0x2c28562d, 0xc32755e5,
N    0x2c1c6417, 0xc32b3c75, 0x2c1072c4, 0xc32f255e,
N    0x2c048237, 0xc333109e, 0x2bf8926f, 0xc336fe37,
N    0x2beca36c, 0xc33aee27, 0x2be0b52f, 0xc33ee070,
N    0x2bd4c7ba, 0xc342d510, 0x2bc8db0b, 0xc346cc07,
N    0x2bbcef23, 0xc34ac556, 0x2bb10404, 0xc34ec0fc,
N    0x2ba519ad, 0xc352bef9, 0x2b99301f, 0xc356bf4d,
N    0x2b8d475b, 0xc35ac1f7, 0x2b815f60, 0xc35ec6f8,
N    0x2b75782f, 0xc362ce50, 0x2b6991ca, 0xc366d7fd,
N    0x2b5dac2f, 0xc36ae401, 0x2b51c760, 0xc36ef25b,
N    0x2b45e35d, 0xc373030a, 0x2b3a0027, 0xc377160f,
N    0x2b2e1dbe, 0xc37b2b6a, 0x2b223c22, 0xc37f4319,
N    0x2b165b54, 0xc3835d1e, 0x2b0a7b54, 0xc3877978,
N    0x2afe9c24, 0xc38b9827, 0x2af2bdc3, 0xc38fb92a,
N    0x2ae6e031, 0xc393dc82, 0x2adb0370, 0xc398022f,
N    0x2acf277f, 0xc39c2a2f, 0x2ac34c60, 0xc3a05484,
N    0x2ab77212, 0xc3a4812c, 0x2aab9896, 0xc3a8b028,
N    0x2a9fbfed, 0xc3ace178, 0x2a93e817, 0xc3b1151b,
N    0x2a881114, 0xc3b54b11, 0x2a7c3ae5, 0xc3b9835a,
N    0x2a70658a, 0xc3bdbdf6, 0x2a649105, 0xc3c1fae5,
N    0x2a58bd54, 0xc3c63a26, 0x2a4cea79, 0xc3ca7bba,
N    0x2a411874, 0xc3cebfa0, 0x2a354746, 0xc3d305d8,
N    0x2a2976ef, 0xc3d74e62, 0x2a1da770, 0xc3db993e,
N    0x2a11d8c8, 0xc3dfe66c, 0x2a060af9, 0xc3e435ea,
N    0x29fa3e03, 0xc3e887bb, 0x29ee71e6, 0xc3ecdbdc,
N    0x29e2a6a3, 0xc3f1324e, 0x29d6dc3b, 0xc3f58b10,
N    0x29cb12ad, 0xc3f9e624, 0x29bf49fa, 0xc3fe4388,
N    0x29b38223, 0xc402a33c, 0x29a7bb28, 0xc4070540,
N    0x299bf509, 0xc40b6994, 0x29902fc7, 0xc40fd037,
N    0x29846b63, 0xc414392b, 0x2978a7dd, 0xc418a46d,
N    0x296ce535, 0xc41d11ff, 0x2961236c, 0xc42181e0,
N    0x29556282, 0xc425f410, 0x2949a278, 0xc42a688f,
N    0x293de34e, 0xc42edf5c, 0x29322505, 0xc4335877,
N    0x2926679c, 0xc437d3e1, 0x291aab16, 0xc43c5199,
N    0x290eef71, 0xc440d19e, 0x290334af, 0xc44553f2,
N    0x28f77acf, 0xc449d892, 0x28ebc1d3, 0xc44e5f80,
N    0x28e009ba, 0xc452e8bc, 0x28d45286, 0xc4577444,
N    0x28c89c37, 0xc45c0219, 0x28bce6cd, 0xc460923b,
N    0x28b13248, 0xc46524a9, 0x28a57ea9, 0xc469b963,
N    0x2899cbf1, 0xc46e5069, 0x288e1a20, 0xc472e9bc,
N    0x28826936, 0xc477855a, 0x2876b934, 0xc47c2344,
N    0x286b0a1a, 0xc480c379, 0x285f5be9, 0xc48565f9,
N    0x2853aea1, 0xc48a0ac4, 0x28480243, 0xc48eb1db,
N    0x283c56cf, 0xc4935b3c, 0x2830ac45, 0xc49806e7,
N    0x282502a7, 0xc49cb4dd, 0x281959f4, 0xc4a1651c,
N    0x280db22d, 0xc4a617a6, 0x28020b52, 0xc4aacc7a,
N    0x27f66564, 0xc4af8397, 0x27eac063, 0xc4b43cfd,
N    0x27df1c50, 0xc4b8f8ad, 0x27d3792b, 0xc4bdb6a6,
N    0x27c7d6f4, 0xc4c276e8, 0x27bc35ad, 0xc4c73972,
N    0x27b09555, 0xc4cbfe45, 0x27a4f5ed, 0xc4d0c560,
N    0x27995776, 0xc4d58ec3, 0x278db9ef, 0xc4da5a6f,
N    0x27821d59, 0xc4df2862, 0x277681b6, 0xc4e3f89c,
N    0x276ae704, 0xc4e8cb1e, 0x275f4d45, 0xc4ed9fe7,
N    0x2753b479, 0xc4f276f7, 0x27481ca1, 0xc4f7504e,
N    0x273c85bc, 0xc4fc2bec, 0x2730efcc, 0xc50109d0,
N    0x27255ad1, 0xc505e9fb, 0x2719c6cb, 0xc50acc6b,
N    0x270e33bb, 0xc50fb121, 0x2702a1a1, 0xc514981d,
N    0x26f7107e, 0xc519815f, 0x26eb8052, 0xc51e6ce6,
N    0x26dff11d, 0xc5235ab2, 0x26d462e1, 0xc5284ac3,
N    0x26c8d59c, 0xc52d3d18, 0x26bd4951, 0xc53231b3,
N    0x26b1bdff, 0xc5372891, 0x26a633a6, 0xc53c21b4,
N    0x269aaa48, 0xc5411d1b, 0x268f21e5, 0xc5461ac6,
N    0x26839a7c, 0xc54b1ab4, 0x26781410, 0xc5501ce5,
N    0x266c8e9f, 0xc555215a, 0x26610a2a, 0xc55a2812,
N    0x265586b3, 0xc55f310d, 0x264a0438, 0xc5643c4a,
N    0x263e82bc, 0xc56949ca, 0x2633023e, 0xc56e598c,
N    0x262782be, 0xc5736b90, 0x261c043d, 0xc5787fd6,
N    0x261086bc, 0xc57d965d, 0x26050a3b, 0xc582af26,
N    0x25f98ebb, 0xc587ca31, 0x25ee143b, 0xc58ce77c,
N    0x25e29abc, 0xc5920708, 0x25d72240, 0xc59728d5,
N    0x25cbaac5, 0xc59c4ce3, 0x25c0344d, 0xc5a17330,
N    0x25b4bed8, 0xc5a69bbe, 0x25a94a67, 0xc5abc68c,
N    0x259dd6f9, 0xc5b0f399, 0x25926490, 0xc5b622e6,
N    0x2586f32c, 0xc5bb5472, 0x257b82cd, 0xc5c0883d,
N    0x25701374, 0xc5c5be47, 0x2564a521, 0xc5caf690,
N    0x255937d5, 0xc5d03118, 0x254dcb8f, 0xc5d56ddd,
N    0x25426051, 0xc5daace1, 0x2536f61b, 0xc5dfee22,
N    0x252b8cee, 0xc5e531a1, 0x252024c9, 0xc5ea775e,
N    0x2514bdad, 0xc5efbf58, 0x2509579b, 0xc5f5098f,
N    0x24fdf294, 0xc5fa5603, 0x24f28e96, 0xc5ffa4b3,
N    0x24e72ba4, 0xc604f5a0, 0x24dbc9bd, 0xc60a48c9,
N    0x24d068e2, 0xc60f9e2e, 0x24c50914, 0xc614f5cf,
N    0x24b9aa52, 0xc61a4fac, 0x24ae4c9d, 0xc61fabc4,
N    0x24a2eff6, 0xc6250a18, 0x2497945d, 0xc62a6aa6,
N    0x248c39d3, 0xc62fcd6f, 0x2480e057, 0xc6353273,
N    0x247587eb, 0xc63a99b1, 0x246a308f, 0xc6400329,
N    0x245eda43, 0xc6456edb, 0x24538507, 0xc64adcc7,
N    0x244830dd, 0xc6504ced, 0x243cddc4, 0xc655bf4c,
N    0x24318bbe, 0xc65b33e4, 0x24263ac9, 0xc660aab5,
N    0x241aeae8, 0xc66623be, 0x240f9c1a, 0xc66b9f01,
N    0x24044e60, 0xc6711c7b, 0x23f901ba, 0xc6769c2e,
N    0x23edb628, 0xc67c1e18, 0x23e26bac, 0xc681a23a,
N    0x23d72245, 0xc6872894, 0x23cbd9f4, 0xc68cb124,
N    0x23c092b9, 0xc6923bec, 0x23b54c95, 0xc697c8eb,
N    0x23aa0788, 0xc69d5820, 0x239ec393, 0xc6a2e98b,
N    0x239380b6, 0xc6a87d2d, 0x23883ef2, 0xc6ae1304,
N    0x237cfe47, 0xc6b3ab12, 0x2371beb5, 0xc6b94554,
N    0x2366803c, 0xc6bee1cd, 0x235b42df, 0xc6c4807a,
N    0x2350069b, 0xc6ca215c, 0x2344cb73, 0xc6cfc472,
N    0x23399167, 0xc6d569be, 0x232e5876, 0xc6db113d,
N    0x232320a2, 0xc6e0baf0, 0x2317e9eb, 0xc6e666d7,
N    0x230cb451, 0xc6ec14f2, 0x23017fd5, 0xc6f1c540,
N    0x22f64c77, 0xc6f777c1, 0x22eb1a37, 0xc6fd2c75,
N    0x22dfe917, 0xc702e35c, 0x22d4b916, 0xc7089c75,
N    0x22c98a35, 0xc70e57c0, 0x22be5c74, 0xc714153e,
N    0x22b32fd4, 0xc719d4ed, 0x22a80456, 0xc71f96ce,
N    0x229cd9f8, 0xc7255ae0, 0x2291b0bd, 0xc72b2123,
N    0x228688a4, 0xc730e997, 0x227b61af, 0xc736b43c,
N    0x22703bdc, 0xc73c8111, 0x2265172e, 0xc7425016,
N    0x2259f3a3, 0xc748214c, 0x224ed13d, 0xc74df4b1,
N    0x2243affc, 0xc753ca46, 0x22388fe1, 0xc759a20a,
N    0x222d70eb, 0xc75f7bfe, 0x2222531c, 0xc7655820,
N    0x22173674, 0xc76b3671, 0x220c1af3, 0xc77116f0,
N    0x22010099, 0xc776f99d, 0x21f5e768, 0xc77cde79,
N    0x21eacf5f, 0xc782c582, 0x21dfb87f, 0xc788aeb9,
N    0x21d4a2c8, 0xc78e9a1d, 0x21c98e3b, 0xc79487ae,
N    0x21be7ad8, 0xc79a776c, 0x21b368a0, 0xc7a06957,
N    0x21a85793, 0xc7a65d6e, 0x219d47b1, 0xc7ac53b1,
N    0x219238fb, 0xc7b24c20, 0x21872b72, 0xc7b846ba,
N    0x217c1f15, 0xc7be4381, 0x217113e5, 0xc7c44272,
N    0x216609e3, 0xc7ca438f, 0x215b0110, 0xc7d046d6,
N    0x214ff96a, 0xc7d64c47, 0x2144f2f3, 0xc7dc53e3,
N    0x2139edac, 0xc7e25daa, 0x212ee995, 0xc7e8699a,
N    0x2123e6ad, 0xc7ee77b3, 0x2118e4f6, 0xc7f487f6,
N    0x210de470, 0xc7fa9a62, 0x2102e51c, 0xc800aef7,
N    0x20f7e6f9, 0xc806c5b5, 0x20ecea09, 0xc80cde9b,
N    0x20e1ee4b, 0xc812f9a9, 0x20d6f3c1, 0xc81916df,
N    0x20cbfa6a, 0xc81f363d, 0x20c10247, 0xc82557c3,
N    0x20b60b58, 0xc82b7b70, 0x20ab159e, 0xc831a143,
N    0x20a0211a, 0xc837c93e, 0x20952dcb, 0xc83df35f,
N    0x208a3bb2, 0xc8441fa6, 0x207f4acf, 0xc84a4e14,
N    0x20745b24, 0xc8507ea7, 0x20696cb0, 0xc856b160,
N    0x205e7f74, 0xc85ce63e, 0x2053936f, 0xc8631d42,
N    0x2048a8a4, 0xc869566a, 0x203dbf11, 0xc86f91b7,
N    0x2032d6b8, 0xc875cf28, 0x2027ef99, 0xc87c0ebd,
N    0x201d09b4, 0xc8825077, 0x2012250a, 0xc8889454,
N    0x2007419b, 0xc88eda54, 0x1ffc5f67, 0xc8952278,
N    0x1ff17e70, 0xc89b6cbf, 0x1fe69eb4, 0xc8a1b928,
N    0x1fdbc036, 0xc8a807b4, 0x1fd0e2f5, 0xc8ae5862,
N    0x1fc606f1, 0xc8b4ab32, 0x1fbb2c2c, 0xc8bb0023,
N    0x1fb052a5, 0xc8c15736, 0x1fa57a5d, 0xc8c7b06b,
N    0x1f9aa354, 0xc8ce0bc0, 0x1f8fcd8b, 0xc8d46936,
N    0x1f84f902, 0xc8dac8cd, 0x1f7a25ba, 0xc8e12a84,
N    0x1f6f53b3, 0xc8e78e5b, 0x1f6482ed, 0xc8edf452,
N    0x1f59b369, 0xc8f45c68, 0x1f4ee527, 0xc8fac69e,
N    0x1f441828, 0xc90132f2, 0x1f394c6b, 0xc907a166,
N    0x1f2e81f3, 0xc90e11f7, 0x1f23b8be, 0xc91484a8,
N    0x1f18f0ce, 0xc91af976, 0x1f0e2a22, 0xc9217062,
N    0x1f0364bc, 0xc927e96b, 0x1ef8a09b, 0xc92e6492,
N    0x1eedddc0, 0xc934e1d6, 0x1ee31c2b, 0xc93b6137,
N    0x1ed85bdd, 0xc941e2b4, 0x1ecd9cd7, 0xc948664d,
N    0x1ec2df18, 0xc94eec03, 0x1eb822a1, 0xc95573d4,
N    0x1ead6773, 0xc95bfdc1, 0x1ea2ad8d, 0xc96289c9,
N    0x1e97f4f1, 0xc96917ec, 0x1e8d3d9e, 0xc96fa82a,
N    0x1e828796, 0xc9763a83, 0x1e77d2d8, 0xc97ccef5,
N    0x1e6d1f65, 0xc9836582, 0x1e626d3e, 0xc989fe29,
N    0x1e57bc62, 0xc99098e9, 0x1e4d0cd2, 0xc99735c2,
N    0x1e425e8f, 0xc99dd4b4, 0x1e37b199, 0xc9a475bf,
N    0x1e2d05f1, 0xc9ab18e3, 0x1e225b96, 0xc9b1be1e,
N    0x1e17b28a, 0xc9b86572, 0x1e0d0acc, 0xc9bf0edd,
N    0x1e02645d, 0xc9c5ba60, 0x1df7bf3e, 0xc9cc67fa,
N    0x1ded1b6e, 0xc9d317ab, 0x1de278ef, 0xc9d9c973,
N    0x1dd7d7c1, 0xc9e07d51, 0x1dcd37e4, 0xc9e73346,
N    0x1dc29958, 0xc9edeb50, 0x1db7fc1e, 0xc9f4a570,
N    0x1dad6036, 0xc9fb61a5, 0x1da2c5a2, 0xca021fef,
N    0x1d982c60, 0xca08e04f, 0x1d8d9472, 0xca0fa2c3,
N    0x1d82fdd8, 0xca16674b, 0x1d786892, 0xca1d2de7,
N    0x1d6dd4a2, 0xca23f698, 0x1d634206, 0xca2ac15b,
N    0x1d58b0c0, 0xca318e32, 0x1d4e20d0, 0xca385d1d,
N    0x1d439236, 0xca3f2e19, 0x1d3904f4, 0xca460129,
N    0x1d2e7908, 0xca4cd64b, 0x1d23ee74, 0xca53ad7e,
N    0x1d196538, 0xca5a86c4, 0x1d0edd55, 0xca61621b,
N    0x1d0456ca, 0xca683f83, 0x1cf9d199, 0xca6f1efc,
N    0x1cef4dc2, 0xca760086, 0x1ce4cb44, 0xca7ce420,
N    0x1cda4a21, 0xca83c9ca, 0x1ccfca59, 0xca8ab184,
N    0x1cc54bec, 0xca919b4e, 0x1cbacedb, 0xca988727,
N    0x1cb05326, 0xca9f750f, 0x1ca5d8cd, 0xcaa66506,
N    0x1c9b5fd2, 0xcaad570c, 0x1c90e834, 0xcab44b1f,
N    0x1c8671f3, 0xcabb4141, 0x1c7bfd11, 0xcac23971,
N    0x1c71898d, 0xcac933ae, 0x1c671768, 0xcad02ff8,
N    0x1c5ca6a2, 0xcad72e4f, 0x1c52373c, 0xcade2eb3,
N    0x1c47c936, 0xcae53123, 0x1c3d5c91, 0xcaec35a0,
N    0x1c32f14d, 0xcaf33c28, 0x1c28876a, 0xcafa44bc,
N    0x1c1e1ee9, 0xcb014f5b, 0x1c13b7c9, 0xcb085c05,
N    0x1c09520d, 0xcb0f6aba, 0x1bfeedb3, 0xcb167b79,
N    0x1bf48abd, 0xcb1d8e43, 0x1bea292b, 0xcb24a316,
N    0x1bdfc8fc, 0xcb2bb9f4, 0x1bd56a32, 0xcb32d2da,
N    0x1bcb0cce, 0xcb39edca, 0x1bc0b0ce, 0xcb410ac3,
N    0x1bb65634, 0xcb4829c4, 0x1babfd01, 0xcb4f4acd,
N    0x1ba1a534, 0xcb566ddf, 0x1b974ece, 0xcb5d92f8,
N    0x1b8cf9cf, 0xcb64ba19, 0x1b82a638, 0xcb6be341,
N    0x1b785409, 0xcb730e70, 0x1b6e0342, 0xcb7a3ba5,
N    0x1b63b3e5, 0xcb816ae1, 0x1b5965f1, 0xcb889c23,
N    0x1b4f1967, 0xcb8fcf6b, 0x1b44ce46, 0xcb9704b9,
N    0x1b3a8491, 0xcb9e3c0b, 0x1b303c46, 0xcba57563,
N    0x1b25f566, 0xcbacb0bf, 0x1b1baff2, 0xcbb3ee20,
N    0x1b116beb, 0xcbbb2d85, 0x1b072950, 0xcbc26eee,
N    0x1afce821, 0xcbc9b25a, 0x1af2a860, 0xcbd0f7ca,
N    0x1ae86a0d, 0xcbd83f3d, 0x1ade2d28, 0xcbdf88b3,
N    0x1ad3f1b1, 0xcbe6d42b, 0x1ac9b7a9, 0xcbee21a5,
N    0x1abf7f11, 0xcbf57121, 0x1ab547e8, 0xcbfcc29f,
N    0x1aab122f, 0xcc04161e, 0x1aa0dde7, 0xcc0b6b9e,
N    0x1a96ab0f, 0xcc12c31f, 0x1a8c79a9, 0xcc1a1ca0,
N    0x1a8249b4, 0xcc217822, 0x1a781b31, 0xcc28d5a3,
N    0x1a6dee21, 0xcc303524, 0x1a63c284, 0xcc3796a5,
N    0x1a599859, 0xcc3efa25, 0x1a4f6fa3, 0xcc465fa3,
N    0x1a454860, 0xcc4dc720, 0x1a3b2292, 0xcc55309b,
N    0x1a30fe38, 0xcc5c9c14, 0x1a26db54, 0xcc64098b,
N    0x1a1cb9e5, 0xcc6b78ff, 0x1a1299ec, 0xcc72ea70,
N    0x1a087b69, 0xcc7a5dde, 0x19fe5e5e, 0xcc81d349,
N    0x19f442c9, 0xcc894aaf, 0x19ea28ac, 0xcc90c412,
N    0x19e01006, 0xcc983f70, 0x19d5f8d9, 0xcc9fbcca,
N    0x19cbe325, 0xcca73c1e, 0x19c1cee9, 0xccaebd6e,
N    0x19b7bc27, 0xccb640b8, 0x19adaadf, 0xccbdc5fc,
N    0x19a39b11, 0xccc54d3a, 0x19998cbe, 0xccccd671,
N    0x198f7fe6, 0xccd461a2, 0x19857489, 0xccdbeecc,
N    0x197b6aa8, 0xcce37def, 0x19716243, 0xcceb0f0a,
N    0x19675b5a, 0xccf2a21d, 0x195d55ef, 0xccfa3729,
N    0x19535201, 0xcd01ce2b, 0x19494f90, 0xcd096725,
N    0x193f4e9e, 0xcd110216, 0x19354f2a, 0xcd189efe,
N    0x192b5135, 0xcd203ddc, 0x192154bf, 0xcd27deb0,
N    0x191759c9, 0xcd2f817b, 0x190d6053, 0xcd37263a,
N    0x1903685d, 0xcd3eccef, 0x18f971e8, 0xcd467599,
N    0x18ef7cf4, 0xcd4e2037, 0x18e58982, 0xcd55ccca,
N    0x18db9792, 0xcd5d7b50, 0x18d1a724, 0xcd652bcb,
N    0x18c7b838, 0xcd6cde39, 0x18bdcad0, 0xcd74929a,
N    0x18b3deeb, 0xcd7c48ee, 0x18a9f48a, 0xcd840134,
N    0x18a00bae, 0xcd8bbb6d, 0x18962456, 0xcd937798,
N    0x188c3e83, 0xcd9b35b4, 0x18825a35, 0xcda2f5c2,
N    0x1878776d, 0xcdaab7c0, 0x186e962b, 0xcdb27bb0,
N    0x1864b670, 0xcdba4190, 0x185ad83c, 0xcdc20960,
N    0x1850fb8e, 0xcdc9d320, 0x18472069, 0xcdd19ed0,
N    0x183d46cc, 0xcdd96c6f, 0x18336eb7, 0xcde13bfd,
N    0x1829982b, 0xcde90d79, 0x181fc328, 0xcdf0e0e4,
N    0x1815efae, 0xcdf8b63d, 0x180c1dbf, 0xce008d84,
N    0x18024d59, 0xce0866b8, 0x17f87e7f, 0xce1041d9,
N    0x17eeb130, 0xce181ee8, 0x17e4e56c, 0xce1ffde2,
N    0x17db1b34, 0xce27dec9, 0x17d15288, 0xce2fc19c,
N    0x17c78b68, 0xce37a65b, 0x17bdc5d6, 0xce3f8d05,
N    0x17b401d1, 0xce47759a, 0x17aa3f5a, 0xce4f6019,
N    0x17a07e70, 0xce574c84, 0x1796bf16, 0xce5f3ad8,
N    0x178d014a, 0xce672b16, 0x1783450d, 0xce6f1d3d,
N    0x17798a60, 0xce77114e, 0x176fd143, 0xce7f0748,
N    0x176619b6, 0xce86ff2a, 0x175c63ba, 0xce8ef8f4,
N    0x1752af4f, 0xce96f4a7, 0x1748fc75, 0xce9ef241,
N    0x173f4b2e, 0xcea6f1c2, 0x17359b78, 0xceaef32b,
N    0x172bed55, 0xceb6f67a, 0x172240c5, 0xcebefbb0,
N    0x171895c9, 0xcec702cb, 0x170eec60, 0xcecf0bcd,
N    0x1705448b, 0xced716b4, 0x16fb9e4b, 0xcedf2380,
N    0x16f1f99f, 0xcee73231, 0x16e85689, 0xceef42c7,
N    0x16deb508, 0xcef75541, 0x16d5151d, 0xceff699f,
N    0x16cb76c9, 0xcf077fe1, 0x16c1da0b, 0xcf0f9805,
N    0x16b83ee4, 0xcf17b20d, 0x16aea555, 0xcf1fcdf8,
N    0x16a50d5d, 0xcf27ebc5, 0x169b76fe, 0xcf300b74,
N    0x1691e237, 0xcf382d05, 0x16884f09, 0xcf405077,
N    0x167ebd74, 0xcf4875ca, 0x16752d79, 0xcf509cfe,
N    0x166b9f18, 0xcf58c613, 0x16621251, 0xcf60f108,
N    0x16588725, 0xcf691ddd, 0x164efd94, 0xcf714c91,
N    0x1645759f, 0xcf797d24, 0x163bef46, 0xcf81af97,
N    0x16326a88, 0xcf89e3e8, 0x1628e767, 0xcf921a17,
N    0x161f65e4, 0xcf9a5225, 0x1615e5fd, 0xcfa28c10,
N    0x160c67b4, 0xcfaac7d8, 0x1602eb0a, 0xcfb3057d,
N    0x15f96ffd, 0xcfbb4500, 0x15eff690, 0xcfc3865e,
N    0x15e67ec1, 0xcfcbc999, 0x15dd0892, 0xcfd40eaf,
N    0x15d39403, 0xcfdc55a1, 0x15ca2115, 0xcfe49e6d,
N    0x15c0afc6, 0xcfece915, 0x15b74019, 0xcff53597,
N    0x15add20d, 0xcffd83f4, 0x15a465a3, 0xd005d42a,
N    0x159afadb, 0xd00e2639, 0x159191b5, 0xd0167a22,
N    0x15882a32, 0xd01ecfe4, 0x157ec452, 0xd027277e,
N    0x15756016, 0xd02f80f1, 0x156bfd7d, 0xd037dc3b,
N    0x15629c89, 0xd040395d, 0x15593d3a, 0xd0489856,
N    0x154fdf8f, 0xd050f926, 0x15468389, 0xd0595bcd,
N    0x153d292a, 0xd061c04a, 0x1533d070, 0xd06a269d,
N    0x152a795d, 0xd0728ec6, 0x152123f0, 0xd07af8c4,
N    0x1517d02b, 0xd0836497, 0x150e7e0d, 0xd08bd23f,
N    0x15052d97, 0xd09441bb, 0x14fbdec9, 0xd09cb30b,
N    0x14f291a4, 0xd0a5262f, 0x14e94627, 0xd0ad9b26,
N    0x14dffc54, 0xd0b611f1, 0x14d6b42b, 0xd0be8a8d,
N    0x14cd6dab, 0xd0c704fd, 0x14c428d6, 0xd0cf813e,
N    0x14bae5ab, 0xd0d7ff51, 0x14b1a42c, 0xd0e07f36,
N    0x14a86458, 0xd0e900ec, 0x149f2630, 0xd0f18472,
N    0x1495e9b3, 0xd0fa09c9, 0x148caee4, 0xd10290f0,
N    0x148375c1, 0xd10b19e7, 0x147a3e4b, 0xd113a4ad,
N    0x14710883, 0xd11c3142, 0x1467d469, 0xd124bfa6,
N    0x145ea1fd, 0xd12d4fd9, 0x14557140, 0xd135e1d9,
N    0x144c4232, 0xd13e75a8, 0x144314d3, 0xd1470b44,
N    0x1439e923, 0xd14fa2ad, 0x1430bf24, 0xd1583be2,
N    0x142796d5, 0xd160d6e5, 0x141e7037, 0xd16973b3,
N    0x14154b4a, 0xd172124d, 0x140c280e, 0xd17ab2b3,
N    0x14030684, 0xd18354e4, 0x13f9e6ad, 0xd18bf8e0,
N    0x13f0c887, 0xd1949ea6, 0x13e7ac15, 0xd19d4636,
N    0x13de9156, 0xd1a5ef90, 0x13d5784a, 0xd1ae9ab4,
N    0x13cc60f2, 0xd1b747a0, 0x13c34b4f, 0xd1bff656,
N    0x13ba3760, 0xd1c8a6d4, 0x13b12526, 0xd1d1591a,
N    0x13a814a2, 0xd1da0d28, 0x139f05d3, 0xd1e2c2fd,
N    0x1395f8ba, 0xd1eb7a9a, 0x138ced57, 0xd1f433fd,
N    0x1383e3ab, 0xd1fcef27, 0x137adbb6, 0xd205ac17,
N    0x1371d579, 0xd20e6acc, 0x1368d0f3, 0xd2172b48,
N    0x135fce26, 0xd21fed88, 0x1356cd11, 0xd228b18d,
N    0x134dcdb4, 0xd2317756, 0x1344d011, 0xd23a3ee4,
N    0x133bd427, 0xd2430835, 0x1332d9f7, 0xd24bd34a,
N    0x1329e181, 0xd254a021, 0x1320eac6, 0xd25d6ebc,
N    0x1317f5c6, 0xd2663f19, 0x130f0280, 0xd26f1138,
N    0x130610f7, 0xd277e518, 0x12fd2129, 0xd280babb,
N    0x12f43318, 0xd289921e, 0x12eb46c3, 0xd2926b41,
N    0x12e25c2b, 0xd29b4626, 0x12d97350, 0xd2a422ca,
N    0x12d08c33, 0xd2ad012e, 0x12c7a6d4, 0xd2b5e151,
N    0x12bec333, 0xd2bec333, 0x12b5e151, 0xd2c7a6d4,
N    0x12ad012e, 0xd2d08c33, 0x12a422ca, 0xd2d97350,
N    0x129b4626, 0xd2e25c2b, 0x12926b41, 0xd2eb46c3,
N    0x1289921e, 0xd2f43318, 0x1280babb, 0xd2fd2129,
N    0x1277e518, 0xd30610f7, 0x126f1138, 0xd30f0280,
N    0x12663f19, 0xd317f5c6, 0x125d6ebc, 0xd320eac6,
N    0x1254a021, 0xd329e181, 0x124bd34a, 0xd332d9f7,
N    0x12430835, 0xd33bd427, 0x123a3ee4, 0xd344d011,
N    0x12317756, 0xd34dcdb4, 0x1228b18d, 0xd356cd11,
N    0x121fed88, 0xd35fce26, 0x12172b48, 0xd368d0f3,
N    0x120e6acc, 0xd371d579, 0x1205ac17, 0xd37adbb6,
N    0x11fcef27, 0xd383e3ab, 0x11f433fd, 0xd38ced57,
N    0x11eb7a9a, 0xd395f8ba, 0x11e2c2fd, 0xd39f05d3,
N    0x11da0d28, 0xd3a814a2, 0x11d1591a, 0xd3b12526,
N    0x11c8a6d4, 0xd3ba3760, 0x11bff656, 0xd3c34b4f,
N    0x11b747a0, 0xd3cc60f2, 0x11ae9ab4, 0xd3d5784a,
N    0x11a5ef90, 0xd3de9156, 0x119d4636, 0xd3e7ac15,
N    0x11949ea6, 0xd3f0c887, 0x118bf8e0, 0xd3f9e6ad,
N    0x118354e4, 0xd4030684, 0x117ab2b3, 0xd40c280e,
N    0x1172124d, 0xd4154b4a, 0x116973b3, 0xd41e7037,
N    0x1160d6e5, 0xd42796d5, 0x11583be2, 0xd430bf24,
N    0x114fa2ad, 0xd439e923, 0x11470b44, 0xd44314d3,
N    0x113e75a8, 0xd44c4232, 0x1135e1d9, 0xd4557140,
N    0x112d4fd9, 0xd45ea1fd, 0x1124bfa6, 0xd467d469,
N    0x111c3142, 0xd4710883, 0x1113a4ad, 0xd47a3e4b,
N    0x110b19e7, 0xd48375c1, 0x110290f0, 0xd48caee4,
N    0x10fa09c9, 0xd495e9b3, 0x10f18472, 0xd49f2630,
N    0x10e900ec, 0xd4a86458, 0x10e07f36, 0xd4b1a42c,
N    0x10d7ff51, 0xd4bae5ab, 0x10cf813e, 0xd4c428d6,
N    0x10c704fd, 0xd4cd6dab, 0x10be8a8d, 0xd4d6b42b,
N    0x10b611f1, 0xd4dffc54, 0x10ad9b26, 0xd4e94627,
N    0x10a5262f, 0xd4f291a4, 0x109cb30b, 0xd4fbdec9,
N    0x109441bb, 0xd5052d97, 0x108bd23f, 0xd50e7e0d,
N    0x10836497, 0xd517d02b, 0x107af8c4, 0xd52123f0,
N    0x10728ec6, 0xd52a795d, 0x106a269d, 0xd533d070,
N    0x1061c04a, 0xd53d292a, 0x10595bcd, 0xd5468389,
N    0x1050f926, 0xd54fdf8f, 0x10489856, 0xd5593d3a,
N    0x1040395d, 0xd5629c89, 0x1037dc3b, 0xd56bfd7d,
N    0x102f80f1, 0xd5756016, 0x1027277e, 0xd57ec452,
N    0x101ecfe4, 0xd5882a32, 0x10167a22, 0xd59191b5,
N    0x100e2639, 0xd59afadb, 0x1005d42a, 0xd5a465a3,
N    0xffd83f4, 0xd5add20d, 0xff53597, 0xd5b74019,
N    0xfece915, 0xd5c0afc6, 0xfe49e6d, 0xd5ca2115,
N    0xfdc55a1, 0xd5d39403, 0xfd40eaf, 0xd5dd0892,
N    0xfcbc999, 0xd5e67ec1, 0xfc3865e, 0xd5eff690,
N    0xfbb4500, 0xd5f96ffd, 0xfb3057d, 0xd602eb0a,
N    0xfaac7d8, 0xd60c67b4, 0xfa28c10, 0xd615e5fd,
N    0xf9a5225, 0xd61f65e4, 0xf921a17, 0xd628e767,
N    0xf89e3e8, 0xd6326a88, 0xf81af97, 0xd63bef46,
N    0xf797d24, 0xd645759f, 0xf714c91, 0xd64efd94,
N    0xf691ddd, 0xd6588725, 0xf60f108, 0xd6621251,
N    0xf58c613, 0xd66b9f18, 0xf509cfe, 0xd6752d79,
N    0xf4875ca, 0xd67ebd74, 0xf405077, 0xd6884f09,
N    0xf382d05, 0xd691e237, 0xf300b74, 0xd69b76fe,
N    0xf27ebc5, 0xd6a50d5d, 0xf1fcdf8, 0xd6aea555,
N    0xf17b20d, 0xd6b83ee4, 0xf0f9805, 0xd6c1da0b,
N    0xf077fe1, 0xd6cb76c9, 0xeff699f, 0xd6d5151d,
N    0xef75541, 0xd6deb508, 0xeef42c7, 0xd6e85689,
N    0xee73231, 0xd6f1f99f, 0xedf2380, 0xd6fb9e4b,
N    0xed716b4, 0xd705448b, 0xecf0bcd, 0xd70eec60,
N    0xec702cb, 0xd71895c9, 0xebefbb0, 0xd72240c5,
N    0xeb6f67a, 0xd72bed55, 0xeaef32b, 0xd7359b78,
N    0xea6f1c2, 0xd73f4b2e, 0xe9ef241, 0xd748fc75,
N    0xe96f4a7, 0xd752af4f, 0xe8ef8f4, 0xd75c63ba,
N    0xe86ff2a, 0xd76619b6, 0xe7f0748, 0xd76fd143,
N    0xe77114e, 0xd7798a60, 0xe6f1d3d, 0xd783450d,
N    0xe672b16, 0xd78d014a, 0xe5f3ad8, 0xd796bf16,
N    0xe574c84, 0xd7a07e70, 0xe4f6019, 0xd7aa3f5a,
N    0xe47759a, 0xd7b401d1, 0xe3f8d05, 0xd7bdc5d6,
N    0xe37a65b, 0xd7c78b68, 0xe2fc19c, 0xd7d15288,
N    0xe27dec9, 0xd7db1b34, 0xe1ffde2, 0xd7e4e56c,
N    0xe181ee8, 0xd7eeb130, 0xe1041d9, 0xd7f87e7f,
N    0xe0866b8, 0xd8024d59, 0xe008d84, 0xd80c1dbf,
N    0xdf8b63d, 0xd815efae, 0xdf0e0e4, 0xd81fc328,
N    0xde90d79, 0xd829982b, 0xde13bfd, 0xd8336eb7,
N    0xdd96c6f, 0xd83d46cc, 0xdd19ed0, 0xd8472069,
N    0xdc9d320, 0xd850fb8e, 0xdc20960, 0xd85ad83c,
N    0xdba4190, 0xd864b670, 0xdb27bb0, 0xd86e962b,
N    0xdaab7c0, 0xd878776d, 0xda2f5c2, 0xd8825a35,
N    0xd9b35b4, 0xd88c3e83, 0xd937798, 0xd8962456,
N    0xd8bbb6d, 0xd8a00bae, 0xd840134, 0xd8a9f48a,
N    0xd7c48ee, 0xd8b3deeb, 0xd74929a, 0xd8bdcad0,
N    0xd6cde39, 0xd8c7b838, 0xd652bcb, 0xd8d1a724,
N    0xd5d7b50, 0xd8db9792, 0xd55ccca, 0xd8e58982,
N    0xd4e2037, 0xd8ef7cf4, 0xd467599, 0xd8f971e8,
N    0xd3eccef, 0xd903685d, 0xd37263a, 0xd90d6053,
N    0xd2f817b, 0xd91759c9, 0xd27deb0, 0xd92154bf,
N    0xd203ddc, 0xd92b5135, 0xd189efe, 0xd9354f2a,
N    0xd110216, 0xd93f4e9e, 0xd096725, 0xd9494f90,
N    0xd01ce2b, 0xd9535201, 0xcfa3729, 0xd95d55ef,
N    0xcf2a21d, 0xd9675b5a, 0xceb0f0a, 0xd9716243,
N    0xce37def, 0xd97b6aa8, 0xcdbeecc, 0xd9857489,
N    0xcd461a2, 0xd98f7fe6, 0xcccd671, 0xd9998cbe,
N    0xcc54d3a, 0xd9a39b11, 0xcbdc5fc, 0xd9adaadf,
N    0xcb640b8, 0xd9b7bc27, 0xcaebd6e, 0xd9c1cee9,
N    0xca73c1e, 0xd9cbe325, 0xc9fbcca, 0xd9d5f8d9,
N    0xc983f70, 0xd9e01006, 0xc90c412, 0xd9ea28ac,
N    0xc894aaf, 0xd9f442c9, 0xc81d349, 0xd9fe5e5e,
N    0xc7a5dde, 0xda087b69, 0xc72ea70, 0xda1299ec,
N    0xc6b78ff, 0xda1cb9e5, 0xc64098b, 0xda26db54,
N    0xc5c9c14, 0xda30fe38, 0xc55309b, 0xda3b2292,
N    0xc4dc720, 0xda454860, 0xc465fa3, 0xda4f6fa3,
N    0xc3efa25, 0xda599859, 0xc3796a5, 0xda63c284,
N    0xc303524, 0xda6dee21, 0xc28d5a3, 0xda781b31,
N    0xc217822, 0xda8249b4, 0xc1a1ca0, 0xda8c79a9,
N    0xc12c31f, 0xda96ab0f, 0xc0b6b9e, 0xdaa0dde7,
N    0xc04161e, 0xdaab122f, 0xbfcc29f, 0xdab547e8,
N    0xbf57121, 0xdabf7f11, 0xbee21a5, 0xdac9b7a9,
N    0xbe6d42b, 0xdad3f1b1, 0xbdf88b3, 0xdade2d28,
N    0xbd83f3d, 0xdae86a0d, 0xbd0f7ca, 0xdaf2a860,
N    0xbc9b25a, 0xdafce821, 0xbc26eee, 0xdb072950,
N    0xbbb2d85, 0xdb116beb, 0xbb3ee20, 0xdb1baff2,
N    0xbacb0bf, 0xdb25f566, 0xba57563, 0xdb303c46,
N    0xb9e3c0b, 0xdb3a8491, 0xb9704b9, 0xdb44ce46,
N    0xb8fcf6b, 0xdb4f1967, 0xb889c23, 0xdb5965f1,
N    0xb816ae1, 0xdb63b3e5, 0xb7a3ba5, 0xdb6e0342,
N    0xb730e70, 0xdb785409, 0xb6be341, 0xdb82a638,
N    0xb64ba19, 0xdb8cf9cf, 0xb5d92f8, 0xdb974ece,
N    0xb566ddf, 0xdba1a534, 0xb4f4acd, 0xdbabfd01,
N    0xb4829c4, 0xdbb65634, 0xb410ac3, 0xdbc0b0ce,
N    0xb39edca, 0xdbcb0cce, 0xb32d2da, 0xdbd56a32,
N    0xb2bb9f4, 0xdbdfc8fc, 0xb24a316, 0xdbea292b,
N    0xb1d8e43, 0xdbf48abd, 0xb167b79, 0xdbfeedb3,
N    0xb0f6aba, 0xdc09520d, 0xb085c05, 0xdc13b7c9,
N    0xb014f5b, 0xdc1e1ee9, 0xafa44bc, 0xdc28876a,
N    0xaf33c28, 0xdc32f14d, 0xaec35a0, 0xdc3d5c91,
N    0xae53123, 0xdc47c936, 0xade2eb3, 0xdc52373c,
N    0xad72e4f, 0xdc5ca6a2, 0xad02ff8, 0xdc671768,
N    0xac933ae, 0xdc71898d, 0xac23971, 0xdc7bfd11,
N    0xabb4141, 0xdc8671f3, 0xab44b1f, 0xdc90e834,
N    0xaad570c, 0xdc9b5fd2, 0xaa66506, 0xdca5d8cd,
N    0xa9f750f, 0xdcb05326, 0xa988727, 0xdcbacedb,
N    0xa919b4e, 0xdcc54bec, 0xa8ab184, 0xdccfca59,
N    0xa83c9ca, 0xdcda4a21, 0xa7ce420, 0xdce4cb44,
N    0xa760086, 0xdcef4dc2, 0xa6f1efc, 0xdcf9d199,
N    0xa683f83, 0xdd0456ca, 0xa61621b, 0xdd0edd55,
N    0xa5a86c4, 0xdd196538, 0xa53ad7e, 0xdd23ee74,
N    0xa4cd64b, 0xdd2e7908, 0xa460129, 0xdd3904f4,
N    0xa3f2e19, 0xdd439236, 0xa385d1d, 0xdd4e20d0,
N    0xa318e32, 0xdd58b0c0, 0xa2ac15b, 0xdd634206,
N    0xa23f698, 0xdd6dd4a2, 0xa1d2de7, 0xdd786892,
N    0xa16674b, 0xdd82fdd8, 0xa0fa2c3, 0xdd8d9472,
N    0xa08e04f, 0xdd982c60, 0xa021fef, 0xdda2c5a2,
N    0x9fb61a5, 0xddad6036, 0x9f4a570, 0xddb7fc1e,
N    0x9edeb50, 0xddc29958, 0x9e73346, 0xddcd37e4,
N    0x9e07d51, 0xddd7d7c1, 0x9d9c973, 0xdde278ef,
N    0x9d317ab, 0xdded1b6e, 0x9cc67fa, 0xddf7bf3e,
N    0x9c5ba60, 0xde02645d, 0x9bf0edd, 0xde0d0acc,
N    0x9b86572, 0xde17b28a, 0x9b1be1e, 0xde225b96,
N    0x9ab18e3, 0xde2d05f1, 0x9a475bf, 0xde37b199,
N    0x99dd4b4, 0xde425e8f, 0x99735c2, 0xde4d0cd2,
N    0x99098e9, 0xde57bc62, 0x989fe29, 0xde626d3e,
N    0x9836582, 0xde6d1f65, 0x97ccef5, 0xde77d2d8,
N    0x9763a83, 0xde828796, 0x96fa82a, 0xde8d3d9e,
N    0x96917ec, 0xde97f4f1, 0x96289c9, 0xdea2ad8d,
N    0x95bfdc1, 0xdead6773, 0x95573d4, 0xdeb822a1,
N    0x94eec03, 0xdec2df18, 0x948664d, 0xdecd9cd7,
N    0x941e2b4, 0xded85bdd, 0x93b6137, 0xdee31c2b,
N    0x934e1d6, 0xdeedddc0, 0x92e6492, 0xdef8a09b,
N    0x927e96b, 0xdf0364bc, 0x9217062, 0xdf0e2a22,
N    0x91af976, 0xdf18f0ce, 0x91484a8, 0xdf23b8be,
N    0x90e11f7, 0xdf2e81f3, 0x907a166, 0xdf394c6b,
N    0x90132f2, 0xdf441828, 0x8fac69e, 0xdf4ee527,
N    0x8f45c68, 0xdf59b369, 0x8edf452, 0xdf6482ed,
N    0x8e78e5b, 0xdf6f53b3, 0x8e12a84, 0xdf7a25ba,
N    0x8dac8cd, 0xdf84f902, 0x8d46936, 0xdf8fcd8b,
N    0x8ce0bc0, 0xdf9aa354, 0x8c7b06b, 0xdfa57a5d,
N    0x8c15736, 0xdfb052a5, 0x8bb0023, 0xdfbb2c2c,
N    0x8b4ab32, 0xdfc606f1, 0x8ae5862, 0xdfd0e2f5,
N    0x8a807b4, 0xdfdbc036, 0x8a1b928, 0xdfe69eb4,
N    0x89b6cbf, 0xdff17e70, 0x8952278, 0xdffc5f67,
N    0x88eda54, 0xe007419b, 0x8889454, 0xe012250a,
N    0x8825077, 0xe01d09b4, 0x87c0ebd, 0xe027ef99,
N    0x875cf28, 0xe032d6b8, 0x86f91b7, 0xe03dbf11,
N    0x869566a, 0xe048a8a4, 0x8631d42, 0xe053936f,
N    0x85ce63e, 0xe05e7f74, 0x856b160, 0xe0696cb0,
N    0x8507ea7, 0xe0745b24, 0x84a4e14, 0xe07f4acf,
N    0x8441fa6, 0xe08a3bb2, 0x83df35f, 0xe0952dcb,
N    0x837c93e, 0xe0a0211a, 0x831a143, 0xe0ab159e,
N    0x82b7b70, 0xe0b60b58, 0x82557c3, 0xe0c10247,
N    0x81f363d, 0xe0cbfa6a, 0x81916df, 0xe0d6f3c1,
N    0x812f9a9, 0xe0e1ee4b, 0x80cde9b, 0xe0ecea09,
N    0x806c5b5, 0xe0f7e6f9, 0x800aef7, 0xe102e51c,
N    0x7fa9a62, 0xe10de470, 0x7f487f6, 0xe118e4f6,
N    0x7ee77b3, 0xe123e6ad, 0x7e8699a, 0xe12ee995,
N    0x7e25daa, 0xe139edac, 0x7dc53e3, 0xe144f2f3,
N    0x7d64c47, 0xe14ff96a, 0x7d046d6, 0xe15b0110,
N    0x7ca438f, 0xe16609e3, 0x7c44272, 0xe17113e5,
N    0x7be4381, 0xe17c1f15, 0x7b846ba, 0xe1872b72,
N    0x7b24c20, 0xe19238fb, 0x7ac53b1, 0xe19d47b1,
N    0x7a65d6e, 0xe1a85793, 0x7a06957, 0xe1b368a0,
N    0x79a776c, 0xe1be7ad8, 0x79487ae, 0xe1c98e3b,
N    0x78e9a1d, 0xe1d4a2c8, 0x788aeb9, 0xe1dfb87f,
N    0x782c582, 0xe1eacf5f, 0x77cde79, 0xe1f5e768,
N    0x776f99d, 0xe2010099, 0x77116f0, 0xe20c1af3,
N    0x76b3671, 0xe2173674, 0x7655820, 0xe222531c,
N    0x75f7bfe, 0xe22d70eb, 0x759a20a, 0xe2388fe1,
N    0x753ca46, 0xe243affc, 0x74df4b1, 0xe24ed13d,
N    0x748214c, 0xe259f3a3, 0x7425016, 0xe265172e,
N    0x73c8111, 0xe2703bdc, 0x736b43c, 0xe27b61af,
N    0x730e997, 0xe28688a4, 0x72b2123, 0xe291b0bd,
N    0x7255ae0, 0xe29cd9f8, 0x71f96ce, 0xe2a80456,
N    0x719d4ed, 0xe2b32fd4, 0x714153e, 0xe2be5c74,
N    0x70e57c0, 0xe2c98a35, 0x7089c75, 0xe2d4b916,
N    0x702e35c, 0xe2dfe917, 0x6fd2c75, 0xe2eb1a37,
N    0x6f777c1, 0xe2f64c77, 0x6f1c540, 0xe3017fd5,
N    0x6ec14f2, 0xe30cb451, 0x6e666d7, 0xe317e9eb,
N    0x6e0baf0, 0xe32320a2, 0x6db113d, 0xe32e5876,
N    0x6d569be, 0xe3399167, 0x6cfc472, 0xe344cb73,
N    0x6ca215c, 0xe350069b, 0x6c4807a, 0xe35b42df,
N    0x6bee1cd, 0xe366803c, 0x6b94554, 0xe371beb5,
N    0x6b3ab12, 0xe37cfe47, 0x6ae1304, 0xe3883ef2,
N    0x6a87d2d, 0xe39380b6, 0x6a2e98b, 0xe39ec393,
N    0x69d5820, 0xe3aa0788, 0x697c8eb, 0xe3b54c95,
N    0x6923bec, 0xe3c092b9, 0x68cb124, 0xe3cbd9f4,
N    0x6872894, 0xe3d72245, 0x681a23a, 0xe3e26bac,
N    0x67c1e18, 0xe3edb628, 0x6769c2e, 0xe3f901ba,
N    0x6711c7b, 0xe4044e60, 0x66b9f01, 0xe40f9c1a,
N    0x66623be, 0xe41aeae8, 0x660aab5, 0xe4263ac9,
N    0x65b33e4, 0xe4318bbe, 0x655bf4c, 0xe43cddc4,
N    0x6504ced, 0xe44830dd, 0x64adcc7, 0xe4538507,
N    0x6456edb, 0xe45eda43, 0x6400329, 0xe46a308f,
N    0x63a99b1, 0xe47587eb, 0x6353273, 0xe480e057,
N    0x62fcd6f, 0xe48c39d3, 0x62a6aa6, 0xe497945d,
N    0x6250a18, 0xe4a2eff6, 0x61fabc4, 0xe4ae4c9d,
N    0x61a4fac, 0xe4b9aa52, 0x614f5cf, 0xe4c50914,
N    0x60f9e2e, 0xe4d068e2, 0x60a48c9, 0xe4dbc9bd,
N    0x604f5a0, 0xe4e72ba4, 0x5ffa4b3, 0xe4f28e96,
N    0x5fa5603, 0xe4fdf294, 0x5f5098f, 0xe509579b,
N    0x5efbf58, 0xe514bdad, 0x5ea775e, 0xe52024c9,
N    0x5e531a1, 0xe52b8cee, 0x5dfee22, 0xe536f61b,
N    0x5daace1, 0xe5426051, 0x5d56ddd, 0xe54dcb8f,
N    0x5d03118, 0xe55937d5, 0x5caf690, 0xe564a521,
N    0x5c5be47, 0xe5701374, 0x5c0883d, 0xe57b82cd,
N    0x5bb5472, 0xe586f32c, 0x5b622e6, 0xe5926490,
N    0x5b0f399, 0xe59dd6f9, 0x5abc68c, 0xe5a94a67,
N    0x5a69bbe, 0xe5b4bed8, 0x5a17330, 0xe5c0344d,
N    0x59c4ce3, 0xe5cbaac5, 0x59728d5, 0xe5d72240,
N    0x5920708, 0xe5e29abc, 0x58ce77c, 0xe5ee143b,
N    0x587ca31, 0xe5f98ebb, 0x582af26, 0xe6050a3b,
N    0x57d965d, 0xe61086bc, 0x5787fd6, 0xe61c043d,
N    0x5736b90, 0xe62782be, 0x56e598c, 0xe633023e,
N    0x56949ca, 0xe63e82bc, 0x5643c4a, 0xe64a0438,
N    0x55f310d, 0xe65586b3, 0x55a2812, 0xe6610a2a,
N    0x555215a, 0xe66c8e9f, 0x5501ce5, 0xe6781410,
N    0x54b1ab4, 0xe6839a7c, 0x5461ac6, 0xe68f21e5,
N    0x5411d1b, 0xe69aaa48, 0x53c21b4, 0xe6a633a6,
N    0x5372891, 0xe6b1bdff, 0x53231b3, 0xe6bd4951,
N    0x52d3d18, 0xe6c8d59c, 0x5284ac3, 0xe6d462e1,
N    0x5235ab2, 0xe6dff11d, 0x51e6ce6, 0xe6eb8052,
N    0x519815f, 0xe6f7107e, 0x514981d, 0xe702a1a1,
N    0x50fb121, 0xe70e33bb, 0x50acc6b, 0xe719c6cb,
N    0x505e9fb, 0xe7255ad1, 0x50109d0, 0xe730efcc,
N    0x4fc2bec, 0xe73c85bc, 0x4f7504e, 0xe7481ca1,
N    0x4f276f7, 0xe753b479, 0x4ed9fe7, 0xe75f4d45,
N    0x4e8cb1e, 0xe76ae704, 0x4e3f89c, 0xe77681b6,
N    0x4df2862, 0xe7821d59, 0x4da5a6f, 0xe78db9ef,
N    0x4d58ec3, 0xe7995776, 0x4d0c560, 0xe7a4f5ed,
N    0x4cbfe45, 0xe7b09555, 0x4c73972, 0xe7bc35ad,
N    0x4c276e8, 0xe7c7d6f4, 0x4bdb6a6, 0xe7d3792b,
N    0x4b8f8ad, 0xe7df1c50, 0x4b43cfd, 0xe7eac063,
N    0x4af8397, 0xe7f66564, 0x4aacc7a, 0xe8020b52,
N    0x4a617a6, 0xe80db22d, 0x4a1651c, 0xe81959f4,
N    0x49cb4dd, 0xe82502a7, 0x49806e7, 0xe830ac45,
N    0x4935b3c, 0xe83c56cf, 0x48eb1db, 0xe8480243,
N    0x48a0ac4, 0xe853aea1, 0x48565f9, 0xe85f5be9,
N    0x480c379, 0xe86b0a1a, 0x47c2344, 0xe876b934,
N    0x477855a, 0xe8826936, 0x472e9bc, 0xe88e1a20,
N    0x46e5069, 0xe899cbf1, 0x469b963, 0xe8a57ea9,
N    0x46524a9, 0xe8b13248, 0x460923b, 0xe8bce6cd,
N    0x45c0219, 0xe8c89c37, 0x4577444, 0xe8d45286,
N    0x452e8bc, 0xe8e009ba, 0x44e5f80, 0xe8ebc1d3,
N    0x449d892, 0xe8f77acf, 0x44553f2, 0xe90334af,
N    0x440d19e, 0xe90eef71, 0x43c5199, 0xe91aab16,
N    0x437d3e1, 0xe926679c, 0x4335877, 0xe9322505,
N    0x42edf5c, 0xe93de34e, 0x42a688f, 0xe949a278,
N    0x425f410, 0xe9556282, 0x42181e0, 0xe961236c,
N    0x41d11ff, 0xe96ce535, 0x418a46d, 0xe978a7dd,
N    0x414392b, 0xe9846b63, 0x40fd037, 0xe9902fc7,
N    0x40b6994, 0xe99bf509, 0x4070540, 0xe9a7bb28,
N    0x402a33c, 0xe9b38223, 0x3fe4388, 0xe9bf49fa,
N    0x3f9e624, 0xe9cb12ad, 0x3f58b10, 0xe9d6dc3b,
N    0x3f1324e, 0xe9e2a6a3, 0x3ecdbdc, 0xe9ee71e6,
N    0x3e887bb, 0xe9fa3e03, 0x3e435ea, 0xea060af9,
N    0x3dfe66c, 0xea11d8c8, 0x3db993e, 0xea1da770,
N    0x3d74e62, 0xea2976ef, 0x3d305d8, 0xea354746,
N    0x3cebfa0, 0xea411874, 0x3ca7bba, 0xea4cea79,
N    0x3c63a26, 0xea58bd54, 0x3c1fae5, 0xea649105,
N    0x3bdbdf6, 0xea70658a, 0x3b9835a, 0xea7c3ae5,
N    0x3b54b11, 0xea881114, 0x3b1151b, 0xea93e817,
N    0x3ace178, 0xea9fbfed, 0x3a8b028, 0xeaab9896,
N    0x3a4812c, 0xeab77212, 0x3a05484, 0xeac34c60,
N    0x39c2a2f, 0xeacf277f, 0x398022f, 0xeadb0370,
N    0x393dc82, 0xeae6e031, 0x38fb92a, 0xeaf2bdc3,
N    0x38b9827, 0xeafe9c24, 0x3877978, 0xeb0a7b54,
N    0x3835d1e, 0xeb165b54, 0x37f4319, 0xeb223c22,
N    0x37b2b6a, 0xeb2e1dbe, 0x377160f, 0xeb3a0027,
N    0x373030a, 0xeb45e35d, 0x36ef25b, 0xeb51c760,
N    0x36ae401, 0xeb5dac2f, 0x366d7fd, 0xeb6991ca,
N    0x362ce50, 0xeb75782f, 0x35ec6f8, 0xeb815f60,
N    0x35ac1f7, 0xeb8d475b, 0x356bf4d, 0xeb99301f,
N    0x352bef9, 0xeba519ad, 0x34ec0fc, 0xebb10404,
N    0x34ac556, 0xebbcef23, 0x346cc07, 0xebc8db0b,
N    0x342d510, 0xebd4c7ba, 0x33ee070, 0xebe0b52f,
N    0x33aee27, 0xebeca36c, 0x336fe37, 0xebf8926f,
N    0x333109e, 0xec048237, 0x32f255e, 0xec1072c4,
N    0x32b3c75, 0xec1c6417, 0x32755e5, 0xec28562d,
N    0x32371ae, 0xec344908, 0x31f8fcf, 0xec403ca5,
N    0x31bb049, 0xec4c3106, 0x317d31c, 0xec582629,
N    0x313f848, 0xec641c0e, 0x3101fce, 0xec7012b5,
N    0x30c49ad, 0xec7c0a1d, 0x30875e5, 0xec880245,
N    0x304a477, 0xec93fb2e, 0x300d563, 0xec9ff4d6,
N    0x2fd08a9, 0xecabef3d, 0x2f93e4a, 0xecb7ea63,
N    0x2f57644, 0xecc3e648, 0x2f1b099, 0xeccfe2ea,
N    0x2eded49, 0xecdbe04a, 0x2ea2c53, 0xece7de66,
N    0x2e66db8, 0xecf3dd3f, 0x2e2b178, 0xecffdcd4,
N    0x2def794, 0xed0bdd25, 0x2db400a, 0xed17de31,
N    0x2d78add, 0xed23dff7, 0x2d3d80a, 0xed2fe277,
N    0x2d02794, 0xed3be5b1, 0x2cc7979, 0xed47e9a5,
N    0x2c8cdbb, 0xed53ee51, 0x2c52459, 0xed5ff3b5,
N    0x2c17d52, 0xed6bf9d1, 0x2bdd8a9, 0xed7800a5,
N    0x2ba365c, 0xed84082f, 0x2b6966c, 0xed901070,
N    0x2b2f8d8, 0xed9c1967, 0x2af5da2, 0xeda82313,
N    0x2abc4c9, 0xedb42d74, 0x2a82e4d, 0xedc0388a,
N    0x2a49a2e, 0xedcc4454, 0x2a1086d, 0xedd850d2,
N    0x29d790a, 0xede45e03, 0x299ec05, 0xedf06be6,
N    0x296615d, 0xedfc7a7c, 0x292d914, 0xee0889c4,
N    0x28f5329, 0xee1499bd, 0x28bcf9c, 0xee20aa67,
N    0x2884e6e, 0xee2cbbc1, 0x284cf9f, 0xee38cdcb,
N    0x281532e, 0xee44e084, 0x27dd91c, 0xee50f3ed,
N    0x27a616a, 0xee5d0804, 0x276ec16, 0xee691cc9,
N    0x2737922, 0xee75323c, 0x270088e, 0xee81485c,
N    0x26c9a58, 0xee8d5f29, 0x2692e83, 0xee9976a1,
N    0x265c50e, 0xeea58ec6, 0x2625df8, 0xeeb1a796,
N    0x25ef943, 0xeebdc110, 0x25b96ee, 0xeec9db35,
N    0x25836f9, 0xeed5f604, 0x254d965, 0xeee2117c,
N    0x2517e31, 0xeeee2d9d, 0x24e255e, 0xeefa4a67,
N    0x24aceed, 0xef0667d9, 0x2477adc, 0xef1285f2,
N    0x244292c, 0xef1ea4b2, 0x240d9de, 0xef2ac419,
N    0x23d8cf1, 0xef36e426, 0x23a4265, 0xef4304d8,
N    0x236fa3b, 0xef4f2630, 0x233b473, 0xef5b482d,
N    0x230710d, 0xef676ace, 0x22d3009, 0xef738e12,
N    0x229f167, 0xef7fb1fa, 0x226b528, 0xef8bd685,
N    0x2237b4b, 0xef97fbb2, 0x22043d0, 0xefa42181,
N    0x21d0eb8, 0xefb047f2, 0x219dc03, 0xefbc6f03,
N    0x216abb1, 0xefc896b5, 0x2137dc2, 0xefd4bf08,
N    0x2105236, 0xefe0e7f9, 0x20d290d, 0xefed118a,
N    0x20a0248, 0xeff93bba, 0x206dde6, 0xf0056687,
N    0x203bbe8, 0xf01191f3, 0x2009c4e, 0xf01dbdfb,
N    0x1fd7f17, 0xf029eaa1, 0x1fa6445, 0xf03617e2,
N    0x1f74bd6, 0xf04245c0, 0x1f435cc, 0xf04e7438,
N    0x1f12227, 0xf05aa34c, 0x1ee10e5, 0xf066d2fa,
N    0x1eb0209, 0xf0730342, 0x1e7f591, 0xf07f3424,
N    0x1e4eb7e, 0xf08b659f, 0x1e1e3d0, 0xf09797b2,
N    0x1dede87, 0xf0a3ca5d, 0x1dbdba3, 0xf0affda0,
N    0x1d8db25, 0xf0bc317a, 0x1d5dd0c, 0xf0c865ea,
N    0x1d2e158, 0xf0d49af1, 0x1cfe80a, 0xf0e0d08d,
N    0x1ccf122, 0xf0ed06bf, 0x1c9fca0, 0xf0f93d86,
N    0x1c70a84, 0xf10574e0, 0x1c41ace, 0xf111accf,
N    0x1c12d7e, 0xf11de551, 0x1be4294, 0xf12a1e66,
N    0x1bb5a11, 0xf136580d, 0x1b873f5, 0xf1429247,
N    0x1b5903f, 0xf14ecd11, 0x1b2aef0, 0xf15b086d,
N    0x1afd007, 0xf1674459, 0x1acf386, 0xf17380d6,
N    0x1aa196c, 0xf17fbde2, 0x1a741b9, 0xf18bfb7d,
N    0x1a46c6e, 0xf19839a6, 0x1a1998a, 0xf1a4785e,
N    0x19ec90d, 0xf1b0b7a4, 0x19bfaf9, 0xf1bcf777,
N    0x1992f4c, 0xf1c937d6, 0x1966606, 0xf1d578c2,
N    0x1939f29, 0xf1e1ba3a, 0x190dab4, 0xf1edfc3d,
N    0x18e18a7, 0xf1fa3ecb, 0x18b5903, 0xf20681e3,
N    0x1889bc6, 0xf212c585, 0x185e0f3, 0xf21f09b1,
N    0x1832888, 0xf22b4e66, 0x1807285, 0xf23793a3,
N    0x17dbeec, 0xf243d968, 0x17b0dbb, 0xf2501fb5,
N    0x1785ef4, 0xf25c6688, 0x175b296, 0xf268ade3,
N    0x17308a1, 0xf274f5c3, 0x1706115, 0xf2813e2a,
N    0x16dbbf3, 0xf28d8715, 0x16b193a, 0xf299d085,
N    0x16878eb, 0xf2a61a7a, 0x165db05, 0xf2b264f2,
N    0x1633f8a, 0xf2beafed, 0x160a678, 0xf2cafb6b,
N    0x15e0fd1, 0xf2d7476c, 0x15b7b94, 0xf2e393ef,
N    0x158e9c1, 0xf2efe0f2, 0x1565a58, 0xf2fc2e77,
N    0x153cd5a, 0xf3087c7d, 0x15142c6, 0xf314cb02,
N    0x14eba9d, 0xf3211a07, 0x14c34df, 0xf32d698a,
N    0x149b18b, 0xf339b98d, 0x14730a3, 0xf3460a0d,
N    0x144b225, 0xf3525b0b, 0x1423613, 0xf35eac86,
N    0x13fbc6c, 0xf36afe7e, 0x13d4530, 0xf37750f2,
N    0x13ad060, 0xf383a3e2, 0x1385dfb, 0xf38ff74d,
N    0x135ee02, 0xf39c4b32, 0x1338075, 0xf3a89f92,
N    0x1311553, 0xf3b4f46c, 0x12eac9d, 0xf3c149bf,
N    0x12c4653, 0xf3cd9f8b, 0x129e276, 0xf3d9f5cf,
N    0x1278104, 0xf3e64c8c, 0x12521ff, 0xf3f2a3bf,
N    0x122c566, 0xf3fefb6a, 0x1206b39, 0xf40b538b,
N    0x11e1379, 0xf417ac22, 0x11bbe26, 0xf424052f,
N    0x1196b3f, 0xf4305eb0, 0x1171ac6, 0xf43cb8a7,
N    0x114ccb9, 0xf4491311, 0x1128119, 0xf4556def,
N    0x11037e6, 0xf461c940, 0x10df120, 0xf46e2504,
N    0x10bacc8, 0xf47a8139, 0x1096add, 0xf486dde1,
N    0x1072b5f, 0xf4933afa, 0x104ee4f, 0xf49f9884,
N    0x102b3ac, 0xf4abf67e, 0x1007b77, 0xf4b854e7,
N    0xfe45b0, 0xf4c4b3c0, 0xfc1257, 0xf4d11308,
N    0xf9e16b, 0xf4dd72be, 0xf7b2ee, 0xf4e9d2e3,
N    0xf586df, 0xf4f63374, 0xf35d3e, 0xf5029473,
N    0xf1360b, 0xf50ef5de, 0xef1147, 0xf51b57b5,
N    0xeceef1, 0xf527b9f7, 0xeacf09, 0xf5341ca5,
N    0xe8b190, 0xf5407fbd, 0xe69686, 0xf54ce33f,
N    0xe47deb, 0xf559472b, 0xe267be, 0xf565ab80,
N    0xe05401, 0xf572103d, 0xde42b2, 0xf57e7563,
N    0xdc33d2, 0xf58adaf0, 0xda2762, 0xf59740e5,
N    0xd81d61, 0xf5a3a740, 0xd615cf, 0xf5b00e02,
N    0xd410ad, 0xf5bc7529, 0xd20dfa, 0xf5c8dcb6,
N    0xd00db6, 0xf5d544a7, 0xce0fe3, 0xf5e1acfd,
N    0xcc147f, 0xf5ee15b7, 0xca1b8a, 0xf5fa7ed4,
N    0xc82506, 0xf606e854, 0xc630f2, 0xf6135237,
N    0xc43f4d, 0xf61fbc7b, 0xc25019, 0xf62c2721,
N    0xc06355, 0xf6389228, 0xbe7901, 0xf644fd8f,
N    0xbc911d, 0xf6516956, 0xbaabaa, 0xf65dd57d,
N    0xb8c8a7, 0xf66a4203, 0xb6e815, 0xf676aee8,
N    0xb509f3, 0xf6831c2b, 0xb32e42, 0xf68f89cb,
N    0xb15502, 0xf69bf7c9, 0xaf7e33, 0xf6a86623,
N    0xada9d4, 0xf6b4d4d9, 0xabd7e6, 0xf6c143ec,
N    0xaa086a, 0xf6cdb359, 0xa83b5e, 0xf6da2321,
N    0xa670c4, 0xf6e69344, 0xa4a89b, 0xf6f303c0,
N    0xa2e2e3, 0xf6ff7496, 0xa11f9d, 0xf70be5c4,
N    0x9f5ec8, 0xf718574b, 0x9da065, 0xf724c92a,
N    0x9be473, 0xf7313b60, 0x9a2af3, 0xf73daded,
N    0x9873e4, 0xf74a20d0, 0x96bf48, 0xf756940a,
N    0x950d1d, 0xf7630799, 0x935d64, 0xf76f7b7d,
N    0x91b01d, 0xf77befb5, 0x900548, 0xf7886442,
N    0x8e5ce5, 0xf794d922, 0x8cb6f5, 0xf7a14e55,
N    0x8b1376, 0xf7adc3db, 0x89726a, 0xf7ba39b3,
N    0x87d3d0, 0xf7c6afdc, 0x8637a9, 0xf7d32657,
N    0x849df4, 0xf7df9d22, 0x8306b2, 0xf7ec143e,
N    0x8171e2, 0xf7f88ba9, 0x7fdf85, 0xf8050364,
N    0x7e4f9b, 0xf8117b6d, 0x7cc223, 0xf81df3c5,
N    0x7b371e, 0xf82a6c6a, 0x79ae8c, 0xf836e55d,
N    0x78286e, 0xf8435e9d, 0x76a4c2, 0xf84fd829,
N    0x752389, 0xf85c5201, 0x73a4c3, 0xf868cc24,
N    0x722871, 0xf8754692, 0x70ae92, 0xf881c14b,
N    0x6f3726, 0xf88e3c4d, 0x6dc22e, 0xf89ab799,
N    0x6c4fa8, 0xf8a7332e, 0x6adf97, 0xf8b3af0c,
N    0x6971f9, 0xf8c02b31, 0x6806ce, 0xf8cca79e,
N    0x669e18, 0xf8d92452, 0x6537d4, 0xf8e5a14d,
N    0x63d405, 0xf8f21e8e, 0x6272aa, 0xf8fe9c15,
N    0x6113c2, 0xf90b19e0, 0x5fb74e, 0xf91797f0,
N    0x5e5d4e, 0xf9241645, 0x5d05c3, 0xf93094dd,
N    0x5bb0ab, 0xf93d13b8, 0x5a5e07, 0xf94992d7,
N    0x590dd8, 0xf9561237, 0x57c01d, 0xf96291d9,
N    0x5674d6, 0xf96f11bc, 0x552c03, 0xf97b91e1,
N    0x53e5a5, 0xf9881245, 0x52a1bb, 0xf99492ea,
N    0x516045, 0xf9a113cd, 0x502145, 0xf9ad94f0,
N    0x4ee4b8, 0xf9ba1651, 0x4daaa1, 0xf9c697f0,
N    0x4c72fe, 0xf9d319cc, 0x4b3dcf, 0xf9df9be6,
N    0x4a0b16, 0xf9ec1e3b, 0x48dad1, 0xf9f8a0cd,
N    0x47ad01, 0xfa05239a, 0x4681a6, 0xfa11a6a3,
N    0x4558c0, 0xfa1e29e5, 0x44324f, 0xfa2aad62,
N    0x430e53, 0xfa373119, 0x41eccc, 0xfa43b508,
N    0x40cdba, 0xfa503930, 0x3fb11d, 0xfa5cbd91,
N    0x3e96f6, 0xfa694229, 0x3d7f44, 0xfa75c6f8,
N    0x3c6a07, 0xfa824bfd, 0x3b573f, 0xfa8ed139,
N    0x3a46ed, 0xfa9b56ab, 0x393910, 0xfaa7dc52,
N    0x382da8, 0xfab4622d, 0x3724b6, 0xfac0e83d,
N    0x361e3a, 0xfacd6e81, 0x351a33, 0xfad9f4f8,
N    0x3418a2, 0xfae67ba2, 0x331986, 0xfaf3027e,
N    0x321ce0, 0xfaff898c, 0x3122b0, 0xfb0c10cb,
N    0x302af5, 0xfb18983b, 0x2f35b1, 0xfb251fdc,
N    0x2e42e2, 0xfb31a7ac, 0x2d5289, 0xfb3e2fac,
N    0x2c64a6, 0xfb4ab7db, 0x2b7939, 0xfb574039,
N    0x2a9042, 0xfb63c8c4, 0x29a9c1, 0xfb70517d,
N    0x28c5b6, 0xfb7cda63, 0x27e421, 0xfb896375,
N    0x270502, 0xfb95ecb4, 0x262859, 0xfba2761e,
N    0x254e27, 0xfbaeffb3, 0x24766a, 0xfbbb8973,
N    0x23a124, 0xfbc8135c, 0x22ce54, 0xfbd49d70,
N    0x21fdfb, 0xfbe127ac, 0x213018, 0xfbedb212,
N    0x2064ab, 0xfbfa3c9f, 0x1f9bb5, 0xfc06c754,
N    0x1ed535, 0xfc135231, 0x1e112b, 0xfc1fdd34,
N    0x1d4f99, 0xfc2c685d, 0x1c907c, 0xfc38f3ac,
N    0x1bd3d6, 0xfc457f21, 0x1b19a7, 0xfc520aba,
N    0x1a61ee, 0xfc5e9678, 0x19acac, 0xfc6b2259,
N    0x18f9e1, 0xfc77ae5e, 0x18498c, 0xfc843a85,
N    0x179bae, 0xfc90c6cf, 0x16f047, 0xfc9d533b,
N    0x164757, 0xfca9dfc8, 0x15a0dd, 0xfcb66c77,
N    0x14fcda, 0xfcc2f945, 0x145b4e, 0xfccf8634,
N    0x13bc39, 0xfcdc1342, 0x131f9b, 0xfce8a06f,
N    0x128574, 0xfcf52dbb, 0x11edc3, 0xfd01bb24,
N    0x11588a, 0xfd0e48ab, 0x10c5c7, 0xfd1ad650,
N    0x10357c, 0xfd276410, 0xfa7a8, 0xfd33f1ed,
N    0xf1c4a, 0xfd407fe6, 0xe9364, 0xfd4d0df9,
N    0xe0cf5, 0xfd599c28, 0xd88fd, 0xfd662a70,
N    0xd077c, 0xfd72b8d2, 0xc8872, 0xfd7f474d,
N    0xc0be0, 0xfd8bd5e1, 0xb91c4, 0xfd98648d,
N    0xb1a20, 0xfda4f351, 0xaa4f3, 0xfdb1822c,
N    0xa323d, 0xfdbe111e, 0x9c1ff, 0xfdcaa027,
N    0x95438, 0xfdd72f45, 0x8e8e8, 0xfde3be78,
N    0x8800f, 0xfdf04dc0, 0x819ae, 0xfdfcdd1d,
N    0x7b5c4, 0xfe096c8d, 0x75452, 0xfe15fc11,
N    0x6f556, 0xfe228ba7, 0x698d3, 0xfe2f1b50,
N    0x63ec6, 0xfe3bab0b, 0x5e731, 0xfe483ad8,
N    0x59214, 0xfe54cab5, 0x53f6e, 0xfe615aa3,
N    0x4ef3f, 0xfe6deaa1, 0x4a188, 0xfe7a7aae,
N    0x45648, 0xfe870aca, 0x40d80, 0xfe939af5,
N    0x3c72f, 0xfea02b2e, 0x38356, 0xfeacbb74,
N    0x341f4, 0xfeb94bc8, 0x3030a, 0xfec5dc28,
N    0x2c697, 0xfed26c94, 0x28c9c, 0xfedefd0c,
N    0x25519, 0xfeeb8d8f, 0x2200d, 0xfef81e1d,
N    0x1ed78, 0xff04aeb5, 0x1bd5c, 0xff113f56,
N    0x18fb6, 0xff1dd001, 0x16489, 0xff2a60b4,
N    0x13bd3, 0xff36f170, 0x11594, 0xff438234,
N    0xf1ce, 0xff5012fe, 0xd07e, 0xff5ca3d0,
N    0xb1a7, 0xff6934a8, 0x9547, 0xff75c585,
N    0x7b5f, 0xff825668, 0x63ee, 0xff8ee750,
N    0x4ef5, 0xff9b783c, 0x3c74, 0xffa8092c,
N    0x2c6a, 0xffb49a1f, 0x1ed8, 0xffc12b16,
N    0x13bd, 0xffcdbc0f, 0xb1a, 0xffda4d09,
N    0x4ef, 0xffe6de05, 0x13c, 0xfff36f02,
N    0x0, 0x0, 0x13c, 0xc90fe,
N    0x4ef, 0x1921fb, 0xb1a, 0x25b2f7,
N    0x13bd, 0x3243f1, 0x1ed8, 0x3ed4ea,
N    0x2c6a, 0x4b65e1, 0x3c74, 0x57f6d4,
N    0x4ef5, 0x6487c4, 0x63ee, 0x7118b0,
N    0x7b5f, 0x7da998, 0x9547, 0x8a3a7b,
N    0xb1a7, 0x96cb58, 0xd07e, 0xa35c30,
N    0xf1ce, 0xafed02, 0x11594, 0xbc7dcc,
N    0x13bd3, 0xc90e90, 0x16489, 0xd59f4c,
N    0x18fb6, 0xe22fff, 0x1bd5c, 0xeec0aa,
N    0x1ed78, 0xfb514b, 0x2200d, 0x107e1e3,
N    0x25519, 0x1147271, 0x28c9c, 0x12102f4,
N    0x2c697, 0x12d936c, 0x3030a, 0x13a23d8,
N    0x341f4, 0x146b438, 0x38356, 0x153448c,
N    0x3c72f, 0x15fd4d2, 0x40d80, 0x16c650b,
N    0x45648, 0x178f536, 0x4a188, 0x1858552,
N    0x4ef3f, 0x192155f, 0x53f6e, 0x19ea55d,
N    0x59214, 0x1ab354b, 0x5e731, 0x1b7c528,
N    0x63ec6, 0x1c454f5, 0x698d3, 0x1d0e4b0,
N    0x6f556, 0x1dd7459, 0x75452, 0x1ea03ef,
N    0x7b5c4, 0x1f69373, 0x819ae, 0x20322e3,
N    0x8800f, 0x20fb240, 0x8e8e8, 0x21c4188,
N    0x95438, 0x228d0bb, 0x9c1ff, 0x2355fd9,
N    0xa323d, 0x241eee2, 0xaa4f3, 0x24e7dd4,
N    0xb1a20, 0x25b0caf, 0xb91c4, 0x2679b73,
N    0xc0be0, 0x2742a1f, 0xc8872, 0x280b8b3,
N    0xd077c, 0x28d472e, 0xd88fd, 0x299d590,
N    0xe0cf5, 0x2a663d8, 0xe9364, 0x2b2f207,
N    0xf1c4a, 0x2bf801a, 0xfa7a8, 0x2cc0e13,
N    0x10357c, 0x2d89bf0, 0x10c5c7, 0x2e529b0,
N    0x11588a, 0x2f1b755, 0x11edc3, 0x2fe44dc,
N    0x128574, 0x30ad245, 0x131f9b, 0x3175f91,
N    0x13bc39, 0x323ecbe, 0x145b4e, 0x33079cc,
N    0x14fcda, 0x33d06bb, 0x15a0dd, 0x3499389,
N    0x164757, 0x3562038, 0x16f047, 0x362acc5,
N    0x179bae, 0x36f3931, 0x18498c, 0x37bc57b,
N    0x18f9e1, 0x38851a2, 0x19acac, 0x394dda7,
N    0x1a61ee, 0x3a16988, 0x1b19a7, 0x3adf546,
N    0x1bd3d6, 0x3ba80df, 0x1c907c, 0x3c70c54,
N    0x1d4f99, 0x3d397a3, 0x1e112b, 0x3e022cc,
N    0x1ed535, 0x3ecadcf, 0x1f9bb5, 0x3f938ac,
N    0x2064ab, 0x405c361, 0x213018, 0x4124dee,
N    0x21fdfb, 0x41ed854, 0x22ce54, 0x42b6290,
N    0x23a124, 0x437eca4, 0x24766a, 0x444768d,
N    0x254e27, 0x451004d, 0x262859, 0x45d89e2,
N    0x270502, 0x46a134c, 0x27e421, 0x4769c8b,
N    0x28c5b6, 0x483259d, 0x29a9c1, 0x48fae83,
N    0x2a9042, 0x49c373c, 0x2b7939, 0x4a8bfc7,
N    0x2c64a6, 0x4b54825, 0x2d5289, 0x4c1d054,
N    0x2e42e2, 0x4ce5854, 0x2f35b1, 0x4dae024,
N    0x302af5, 0x4e767c5, 0x3122b0, 0x4f3ef35,
N    0x321ce0, 0x5007674, 0x331986, 0x50cfd82,
N    0x3418a2, 0x519845e, 0x351a33, 0x5260b08,
N    0x361e3a, 0x532917f, 0x3724b6, 0x53f17c3,
N    0x382da8, 0x54b9dd3, 0x393910, 0x55823ae,
N    0x3a46ed, 0x564a955, 0x3b573f, 0x5712ec7,
N    0x3c6a07, 0x57db403, 0x3d7f44, 0x58a3908,
N    0x3e96f6, 0x596bdd7, 0x3fb11d, 0x5a3426f,
N    0x40cdba, 0x5afc6d0, 0x41eccc, 0x5bc4af8,
N    0x430e53, 0x5c8cee7, 0x44324f, 0x5d5529e,
N    0x4558c0, 0x5e1d61b, 0x4681a6, 0x5ee595d,
N    0x47ad01, 0x5fadc66, 0x48dad1, 0x6075f33,
N    0x4a0b16, 0x613e1c5, 0x4b3dcf, 0x620641a,
N    0x4c72fe, 0x62ce634, 0x4daaa1, 0x6396810,
N    0x4ee4b8, 0x645e9af, 0x502145, 0x6526b10,
N    0x516045, 0x65eec33, 0x52a1bb, 0x66b6d16,
N    0x53e5a5, 0x677edbb, 0x552c03, 0x6846e1f,
N    0x5674d6, 0x690ee44, 0x57c01d, 0x69d6e27,
N    0x590dd8, 0x6a9edc9, 0x5a5e07, 0x6b66d29,
N    0x5bb0ab, 0x6c2ec48, 0x5d05c3, 0x6cf6b23,
N    0x5e5d4e, 0x6dbe9bb, 0x5fb74e, 0x6e86810,
N    0x6113c2, 0x6f4e620, 0x6272aa, 0x70163eb,
N    0x63d405, 0x70de172, 0x6537d4, 0x71a5eb3,
N    0x669e18, 0x726dbae, 0x6806ce, 0x7335862,
N    0x6971f9, 0x73fd4cf, 0x6adf97, 0x74c50f4,
N    0x6c4fa8, 0x758ccd2, 0x6dc22e, 0x7654867,
N    0x6f3726, 0x771c3b3, 0x70ae92, 0x77e3eb5,
N    0x722871, 0x78ab96e, 0x73a4c3, 0x79733dc,
N    0x752389, 0x7a3adff, 0x76a4c2, 0x7b027d7,
N    0x78286e, 0x7bca163, 0x79ae8c, 0x7c91aa3,
N    0x7b371e, 0x7d59396, 0x7cc223, 0x7e20c3b,
N    0x7e4f9b, 0x7ee8493, 0x7fdf85, 0x7fafc9c,
N    0x8171e2, 0x8077457, 0x8306b2, 0x813ebc2,
N    0x849df4, 0x82062de, 0x8637a9, 0x82cd9a9,
N    0x87d3d0, 0x8395024, 0x89726a, 0x845c64d,
N    0x8b1376, 0x8523c25, 0x8cb6f5, 0x85eb1ab,
N    0x8e5ce5, 0x86b26de, 0x900548, 0x8779bbe,
N    0x91b01d, 0x884104b, 0x935d64, 0x8908483,
N    0x950d1d, 0x89cf867, 0x96bf48, 0x8a96bf6,
N    0x9873e4, 0x8b5df30, 0x9a2af3, 0x8c25213,
N    0x9be473, 0x8cec4a0, 0x9da065, 0x8db36d6,
N    0x9f5ec8, 0x8e7a8b5, 0xa11f9d, 0x8f41a3c,
N    0xa2e2e3, 0x9008b6a, 0xa4a89b, 0x90cfc40,
N    0xa670c4, 0x9196cbc, 0xa83b5e, 0x925dcdf,
N    0xaa086a, 0x9324ca7, 0xabd7e6, 0x93ebc14,
N    0xada9d4, 0x94b2b27, 0xaf7e33, 0x95799dd,
N    0xb15502, 0x9640837, 0xb32e42, 0x9707635,
N    0xb509f3, 0x97ce3d5, 0xb6e815, 0x9895118,
N    0xb8c8a7, 0x995bdfd, 0xbaabaa, 0x9a22a83,
N    0xbc911d, 0x9ae96aa, 0xbe7901, 0x9bb0271,
N    0xc06355, 0x9c76dd8, 0xc25019, 0x9d3d8df,
N    0xc43f4d, 0x9e04385, 0xc630f2, 0x9ecadc9,
N    0xc82506, 0x9f917ac, 0xca1b8a, 0xa05812c,
N    0xcc147f, 0xa11ea49, 0xce0fe3, 0xa1e5303,
N    0xd00db6, 0xa2abb59, 0xd20dfa, 0xa37234a,
N    0xd410ad, 0xa438ad7, 0xd615cf, 0xa4ff1fe,
N    0xd81d61, 0xa5c58c0, 0xda2762, 0xa68bf1b,
N    0xdc33d2, 0xa752510, 0xde42b2, 0xa818a9d,
N    0xe05401, 0xa8defc3, 0xe267be, 0xa9a5480,
N    0xe47deb, 0xaa6b8d5, 0xe69686, 0xab31cc1,
N    0xe8b190, 0xabf8043, 0xeacf09, 0xacbe35b,
N    0xeceef1, 0xad84609, 0xef1147, 0xae4a84b,
N    0xf1360b, 0xaf10a22, 0xf35d3e, 0xafd6b8d,
N    0xf586df, 0xb09cc8c, 0xf7b2ee, 0xb162d1d,
N    0xf9e16b, 0xb228d42, 0xfc1257, 0xb2eecf8,
N    0xfe45b0, 0xb3b4c40, 0x1007b77, 0xb47ab19,
N    0x102b3ac, 0xb540982, 0x104ee4f, 0xb60677c,
N    0x1072b5f, 0xb6cc506, 0x1096add, 0xb79221f,
N    0x10bacc8, 0xb857ec7, 0x10df120, 0xb91dafc,
N    0x11037e6, 0xb9e36c0, 0x1128119, 0xbaa9211,
N    0x114ccb9, 0xbb6ecef, 0x1171ac6, 0xbc34759,
N    0x1196b3f, 0xbcfa150, 0x11bbe26, 0xbdbfad1,
N    0x11e1379, 0xbe853de, 0x1206b39, 0xbf4ac75,
N    0x122c566, 0xc010496, 0x12521ff, 0xc0d5c41,
N    0x1278104, 0xc19b374, 0x129e276, 0xc260a31,
N    0x12c4653, 0xc326075, 0x12eac9d, 0xc3eb641,
N    0x1311553, 0xc4b0b94, 0x1338075, 0xc57606e,
N    0x135ee02, 0xc63b4ce, 0x1385dfb, 0xc7008b3,
N    0x13ad060, 0xc7c5c1e, 0x13d4530, 0xc88af0e,
N    0x13fbc6c, 0xc950182, 0x1423613, 0xca1537a,
N    0x144b225, 0xcada4f5, 0x14730a3, 0xcb9f5f3,
N    0x149b18b, 0xcc64673, 0x14c34df, 0xcd29676,
N    0x14eba9d, 0xcdee5f9, 0x15142c6, 0xceb34fe,
N    0x153cd5a, 0xcf78383, 0x1565a58, 0xd03d189,
N    0x158e9c1, 0xd101f0e, 0x15b7b94, 0xd1c6c11,
N    0x15e0fd1, 0xd28b894, 0x160a678, 0xd350495,
N    0x1633f8a, 0xd415013, 0x165db05, 0xd4d9b0e,
N    0x16878eb, 0xd59e586, 0x16b193a, 0xd662f7b,
N    0x16dbbf3, 0xd7278eb, 0x1706115, 0xd7ec1d6,
N    0x17308a1, 0xd8b0a3d, 0x175b296, 0xd97521d,
N    0x1785ef4, 0xda39978, 0x17b0dbb, 0xdafe04b,
N    0x17dbeec, 0xdbc2698, 0x1807285, 0xdc86c5d,
N    0x1832888, 0xdd4b19a, 0x185e0f3, 0xde0f64f,
N    0x1889bc6, 0xded3a7b, 0x18b5903, 0xdf97e1d,
N    0x18e18a7, 0xe05c135, 0x190dab4, 0xe1203c3,
N    0x1939f29, 0xe1e45c6, 0x1966606, 0xe2a873e,
N    0x1992f4c, 0xe36c82a, 0x19bfaf9, 0xe430889,
N    0x19ec90d, 0xe4f485c, 0x1a1998a, 0xe5b87a2,
N    0x1a46c6e, 0xe67c65a, 0x1a741b9, 0xe740483,
N    0x1aa196c, 0xe80421e, 0x1acf386, 0xe8c7f2a,
N    0x1afd007, 0xe98bba7, 0x1b2aef0, 0xea4f793,
N    0x1b5903f, 0xeb132ef, 0x1b873f5, 0xebd6db9,
N    0x1bb5a11, 0xec9a7f3, 0x1be4294, 0xed5e19a,
N    0x1c12d7e, 0xee21aaf, 0x1c41ace, 0xeee5331,
N    0x1c70a84, 0xefa8b20, 0x1c9fca0, 0xf06c27a,
N    0x1ccf122, 0xf12f941, 0x1cfe80a, 0xf1f2f73,
N    0x1d2e158, 0xf2b650f, 0x1d5dd0c, 0xf379a16,
N    0x1d8db25, 0xf43ce86, 0x1dbdba3, 0xf500260,
N    0x1dede87, 0xf5c35a3, 0x1e1e3d0, 0xf68684e,
N    0x1e4eb7e, 0xf749a61, 0x1e7f591, 0xf80cbdc,
N    0x1eb0209, 0xf8cfcbe, 0x1ee10e5, 0xf992d06,
N    0x1f12227, 0xfa55cb4, 0x1f435cc, 0xfb18bc8,
N    0x1f74bd6, 0xfbdba40, 0x1fa6445, 0xfc9e81e,
N    0x1fd7f17, 0xfd6155f, 0x2009c4e, 0xfe24205,
N    0x203bbe8, 0xfee6e0d, 0x206dde6, 0xffa9979,
N    0x20a0248, 0x1006c446, 0x20d290d, 0x1012ee76,
N    0x2105236, 0x101f1807, 0x2137dc2, 0x102b40f8,
N    0x216abb1, 0x1037694b, 0x219dc03, 0x104390fd,
N    0x21d0eb8, 0x104fb80e, 0x22043d0, 0x105bde7f,
N    0x2237b4b, 0x1068044e, 0x226b528, 0x1074297b,
N    0x229f167, 0x10804e06, 0x22d3009, 0x108c71ee,
N    0x230710d, 0x10989532, 0x233b473, 0x10a4b7d3,
N    0x236fa3b, 0x10b0d9d0, 0x23a4265, 0x10bcfb28,
N    0x23d8cf1, 0x10c91bda, 0x240d9de, 0x10d53be7,
N    0x244292c, 0x10e15b4e, 0x2477adc, 0x10ed7a0e,
N    0x24aceed, 0x10f99827, 0x24e255e, 0x1105b599,
N    0x2517e31, 0x1111d263, 0x254d965, 0x111dee84,
N    0x25836f9, 0x112a09fc, 0x25b96ee, 0x113624cb,
N    0x25ef943, 0x11423ef0, 0x2625df8, 0x114e586a,
N    0x265c50e, 0x115a713a, 0x2692e83, 0x1166895f,
N    0x26c9a58, 0x1172a0d7, 0x270088e, 0x117eb7a4,
N    0x2737922, 0x118acdc4, 0x276ec16, 0x1196e337,
N    0x27a616a, 0x11a2f7fc, 0x27dd91c, 0x11af0c13,
N    0x281532e, 0x11bb1f7c, 0x284cf9f, 0x11c73235,
N    0x2884e6e, 0x11d3443f, 0x28bcf9c, 0x11df5599,
N    0x28f5329, 0x11eb6643, 0x292d914, 0x11f7763c,
N    0x296615d, 0x12038584, 0x299ec05, 0x120f941a,
N    0x29d790a, 0x121ba1fd, 0x2a1086d, 0x1227af2e,
N    0x2a49a2e, 0x1233bbac, 0x2a82e4d, 0x123fc776,
N    0x2abc4c9, 0x124bd28c, 0x2af5da2, 0x1257dced,
N    0x2b2f8d8, 0x1263e699, 0x2b6966c, 0x126fef90,
N    0x2ba365c, 0x127bf7d1, 0x2bdd8a9, 0x1287ff5b,
N    0x2c17d52, 0x1294062f, 0x2c52459, 0x12a00c4b,
N    0x2c8cdbb, 0x12ac11af, 0x2cc7979, 0x12b8165b,
N    0x2d02794, 0x12c41a4f, 0x2d3d80a, 0x12d01d89,
N    0x2d78add, 0x12dc2009, 0x2db400a, 0x12e821cf,
N    0x2def794, 0x12f422db, 0x2e2b178, 0x1300232c,
N    0x2e66db8, 0x130c22c1, 0x2ea2c53, 0x1318219a,
N    0x2eded49, 0x13241fb6, 0x2f1b099, 0x13301d16,
N    0x2f57644, 0x133c19b8, 0x2f93e4a, 0x1348159d,
N    0x2fd08a9, 0x135410c3, 0x300d563, 0x13600b2a,
N    0x304a477, 0x136c04d2, 0x30875e5, 0x1377fdbb,
N    0x30c49ad, 0x1383f5e3, 0x3101fce, 0x138fed4b,
N    0x313f848, 0x139be3f2, 0x317d31c, 0x13a7d9d7,
N    0x31bb049, 0x13b3cefa, 0x31f8fcf, 0x13bfc35b,
N    0x32371ae, 0x13cbb6f8, 0x32755e5, 0x13d7a9d3,
N    0x32b3c75, 0x13e39be9, 0x32f255e, 0x13ef8d3c,
N    0x333109e, 0x13fb7dc9, 0x336fe37, 0x14076d91,
N    0x33aee27, 0x14135c94, 0x33ee070, 0x141f4ad1,
N    0x342d510, 0x142b3846, 0x346cc07, 0x143724f5,
N    0x34ac556, 0x144310dd, 0x34ec0fc, 0x144efbfc,
N    0x352bef9, 0x145ae653, 0x356bf4d, 0x1466cfe1,
N    0x35ac1f7, 0x1472b8a5, 0x35ec6f8, 0x147ea0a0,
N    0x362ce50, 0x148a87d1, 0x366d7fd, 0x14966e36,
N    0x36ae401, 0x14a253d1, 0x36ef25b, 0x14ae38a0,
N    0x373030a, 0x14ba1ca3, 0x377160f, 0x14c5ffd9,
N    0x37b2b6a, 0x14d1e242, 0x37f4319, 0x14ddc3de,
N    0x3835d1e, 0x14e9a4ac, 0x3877978, 0x14f584ac,
N    0x38b9827, 0x150163dc, 0x38fb92a, 0x150d423d,
N    0x393dc82, 0x15191fcf, 0x398022f, 0x1524fc90,
N    0x39c2a2f, 0x1530d881, 0x3a05484, 0x153cb3a0,
N    0x3a4812c, 0x15488dee, 0x3a8b028, 0x1554676a,
N    0x3ace178, 0x15604013, 0x3b1151b, 0x156c17e9,
N    0x3b54b11, 0x1577eeec, 0x3b9835a, 0x1583c51b,
N    0x3bdbdf6, 0x158f9a76, 0x3c1fae5, 0x159b6efb,
N    0x3c63a26, 0x15a742ac, 0x3ca7bba, 0x15b31587,
N    0x3cebfa0, 0x15bee78c, 0x3d305d8, 0x15cab8ba,
N    0x3d74e62, 0x15d68911, 0x3db993e, 0x15e25890,
N    0x3dfe66c, 0x15ee2738, 0x3e435ea, 0x15f9f507,
N    0x3e887bb, 0x1605c1fd, 0x3ecdbdc, 0x16118e1a,
N    0x3f1324e, 0x161d595d, 0x3f58b10, 0x162923c5,
N    0x3f9e624, 0x1634ed53, 0x3fe4388, 0x1640b606,
N    0x402a33c, 0x164c7ddd, 0x4070540, 0x165844d8,
N    0x40b6994, 0x16640af7, 0x40fd037, 0x166fd039,
N    0x414392b, 0x167b949d, 0x418a46d, 0x16875823,
N    0x41d11ff, 0x16931acb, 0x42181e0, 0x169edc94,
N    0x425f410, 0x16aa9d7e, 0x42a688f, 0x16b65d88,
N    0x42edf5c, 0x16c21cb2, 0x4335877, 0x16cddafb,
N    0x437d3e1, 0x16d99864, 0x43c5199, 0x16e554ea,
N    0x440d19e, 0x16f1108f, 0x44553f2, 0x16fccb51,
N    0x449d892, 0x17088531, 0x44e5f80, 0x17143e2d,
N    0x452e8bc, 0x171ff646, 0x4577444, 0x172bad7a,
N    0x45c0219, 0x173763c9, 0x460923b, 0x17431933,
N    0x46524a9, 0x174ecdb8, 0x469b963, 0x175a8157,
N    0x46e5069, 0x1766340f, 0x472e9bc, 0x1771e5e0,
N    0x477855a, 0x177d96ca, 0x47c2344, 0x178946cc,
N    0x480c379, 0x1794f5e6, 0x48565f9, 0x17a0a417,
N    0x48a0ac4, 0x17ac515f, 0x48eb1db, 0x17b7fdbd,
N    0x4935b3c, 0x17c3a931, 0x49806e7, 0x17cf53bb,
N    0x49cb4dd, 0x17dafd59, 0x4a1651c, 0x17e6a60c,
N    0x4a617a6, 0x17f24dd3, 0x4aacc7a, 0x17fdf4ae,
N    0x4af8397, 0x18099a9c, 0x4b43cfd, 0x18153f9d,
N    0x4b8f8ad, 0x1820e3b0, 0x4bdb6a6, 0x182c86d5,
N    0x4c276e8, 0x1838290c, 0x4c73972, 0x1843ca53,
N    0x4cbfe45, 0x184f6aab, 0x4d0c560, 0x185b0a13,
N    0x4d58ec3, 0x1866a88a, 0x4da5a6f, 0x18724611,
N    0x4df2862, 0x187de2a7, 0x4e3f89c, 0x18897e4a,
N    0x4e8cb1e, 0x189518fc, 0x4ed9fe7, 0x18a0b2bb,
N    0x4f276f7, 0x18ac4b87, 0x4f7504e, 0x18b7e35f,
N    0x4fc2bec, 0x18c37a44, 0x50109d0, 0x18cf1034,
N    0x505e9fb, 0x18daa52f, 0x50acc6b, 0x18e63935,
N    0x50fb121, 0x18f1cc45, 0x514981d, 0x18fd5e5f,
N    0x519815f, 0x1908ef82, 0x51e6ce6, 0x19147fae,
N    0x5235ab2, 0x19200ee3, 0x5284ac3, 0x192b9d1f,
N    0x52d3d18, 0x19372a64, 0x53231b3, 0x1942b6af,
N    0x5372891, 0x194e4201, 0x53c21b4, 0x1959cc5a,
N    0x5411d1b, 0x196555b8, 0x5461ac6, 0x1970de1b,
N    0x54b1ab4, 0x197c6584, 0x5501ce5, 0x1987ebf0,
N    0x555215a, 0x19937161, 0x55a2812, 0x199ef5d6,
N    0x55f310d, 0x19aa794d, 0x5643c4a, 0x19b5fbc8,
N    0x56949ca, 0x19c17d44, 0x56e598c, 0x19ccfdc2,
N    0x5736b90, 0x19d87d42, 0x5787fd6, 0x19e3fbc3,
N    0x57d965d, 0x19ef7944, 0x582af26, 0x19faf5c5,
N    0x587ca31, 0x1a067145, 0x58ce77c, 0x1a11ebc5,
N    0x5920708, 0x1a1d6544, 0x59728d5, 0x1a28ddc0,
N    0x59c4ce3, 0x1a34553b, 0x5a17330, 0x1a3fcbb3,
N    0x5a69bbe, 0x1a4b4128, 0x5abc68c, 0x1a56b599,
N    0x5b0f399, 0x1a622907, 0x5b622e6, 0x1a6d9b70,
N    0x5bb5472, 0x1a790cd4, 0x5c0883d, 0x1a847d33,
N    0x5c5be47, 0x1a8fec8c, 0x5caf690, 0x1a9b5adf,
N    0x5d03118, 0x1aa6c82b, 0x5d56ddd, 0x1ab23471,
N    0x5daace1, 0x1abd9faf, 0x5dfee22, 0x1ac909e5,
N    0x5e531a1, 0x1ad47312, 0x5ea775e, 0x1adfdb37,
N    0x5efbf58, 0x1aeb4253, 0x5f5098f, 0x1af6a865,
N    0x5fa5603, 0x1b020d6c, 0x5ffa4b3, 0x1b0d716a,
N    0x604f5a0, 0x1b18d45c, 0x60a48c9, 0x1b243643,
N    0x60f9e2e, 0x1b2f971e, 0x614f5cf, 0x1b3af6ec,
N    0x61a4fac, 0x1b4655ae, 0x61fabc4, 0x1b51b363,
N    0x6250a18, 0x1b5d100a, 0x62a6aa6, 0x1b686ba3,
N    0x62fcd6f, 0x1b73c62d, 0x6353273, 0x1b7f1fa9,
N    0x63a99b1, 0x1b8a7815, 0x6400329, 0x1b95cf71,
N    0x6456edb, 0x1ba125bd, 0x64adcc7, 0x1bac7af9,
N    0x6504ced, 0x1bb7cf23, 0x655bf4c, 0x1bc3223c,
N    0x65b33e4, 0x1bce7442, 0x660aab5, 0x1bd9c537,
N    0x66623be, 0x1be51518, 0x66b9f01, 0x1bf063e6,
N    0x6711c7b, 0x1bfbb1a0, 0x6769c2e, 0x1c06fe46,
N    0x67c1e18, 0x1c1249d8, 0x681a23a, 0x1c1d9454,
N    0x6872894, 0x1c28ddbb, 0x68cb124, 0x1c34260c,
N    0x6923bec, 0x1c3f6d47, 0x697c8eb, 0x1c4ab36b,
N    0x69d5820, 0x1c55f878, 0x6a2e98b, 0x1c613c6d,
N    0x6a87d2d, 0x1c6c7f4a, 0x6ae1304, 0x1c77c10e,
N    0x6b3ab12, 0x1c8301b9, 0x6b94554, 0x1c8e414b,
N    0x6bee1cd, 0x1c997fc4, 0x6c4807a, 0x1ca4bd21,
N    0x6ca215c, 0x1caff965, 0x6cfc472, 0x1cbb348d,
N    0x6d569be, 0x1cc66e99, 0x6db113d, 0x1cd1a78a,
N    0x6e0baf0, 0x1cdcdf5e, 0x6e666d7, 0x1ce81615,
N    0x6ec14f2, 0x1cf34baf, 0x6f1c540, 0x1cfe802b,
N    0x6f777c1, 0x1d09b389, 0x6fd2c75, 0x1d14e5c9,
N    0x702e35c, 0x1d2016e9, 0x7089c75, 0x1d2b46ea,
N    0x70e57c0, 0x1d3675cb, 0x714153e, 0x1d41a38c,
N    0x719d4ed, 0x1d4cd02c, 0x71f96ce, 0x1d57fbaa,
N    0x7255ae0, 0x1d632608, 0x72b2123, 0x1d6e4f43,
N    0x730e997, 0x1d79775c, 0x736b43c, 0x1d849e51,
N    0x73c8111, 0x1d8fc424, 0x7425016, 0x1d9ae8d2,
N    0x748214c, 0x1da60c5d, 0x74df4b1, 0x1db12ec3,
N    0x753ca46, 0x1dbc5004, 0x759a20a, 0x1dc7701f,
N    0x75f7bfe, 0x1dd28f15, 0x7655820, 0x1dddace4,
N    0x76b3671, 0x1de8c98c, 0x77116f0, 0x1df3e50d,
N    0x776f99d, 0x1dfeff67, 0x77cde79, 0x1e0a1898,
N    0x782c582, 0x1e1530a1, 0x788aeb9, 0x1e204781,
N    0x78e9a1d, 0x1e2b5d38, 0x79487ae, 0x1e3671c5,
N    0x79a776c, 0x1e418528, 0x7a06957, 0x1e4c9760,
N    0x7a65d6e, 0x1e57a86d, 0x7ac53b1, 0x1e62b84f,
N    0x7b24c20, 0x1e6dc705, 0x7b846ba, 0x1e78d48e,
N    0x7be4381, 0x1e83e0eb, 0x7c44272, 0x1e8eec1b,
N    0x7ca438f, 0x1e99f61d, 0x7d046d6, 0x1ea4fef0,
N    0x7d64c47, 0x1eb00696, 0x7dc53e3, 0x1ebb0d0d,
N    0x7e25daa, 0x1ec61254, 0x7e8699a, 0x1ed1166b,
N    0x7ee77b3, 0x1edc1953, 0x7f487f6, 0x1ee71b0a,
N    0x7fa9a62, 0x1ef21b90, 0x800aef7, 0x1efd1ae4,
N    0x806c5b5, 0x1f081907, 0x80cde9b, 0x1f1315f7,
N    0x812f9a9, 0x1f1e11b5, 0x81916df, 0x1f290c3f,
N    0x81f363d, 0x1f340596, 0x82557c3, 0x1f3efdb9,
N    0x82b7b70, 0x1f49f4a8, 0x831a143, 0x1f54ea62,
N    0x837c93e, 0x1f5fdee6, 0x83df35f, 0x1f6ad235,
N    0x8441fa6, 0x1f75c44e, 0x84a4e14, 0x1f80b531,
N    0x8507ea7, 0x1f8ba4dc, 0x856b160, 0x1f969350,
N    0x85ce63e, 0x1fa1808c, 0x8631d42, 0x1fac6c91,
N    0x869566a, 0x1fb7575c, 0x86f91b7, 0x1fc240ef,
N    0x875cf28, 0x1fcd2948, 0x87c0ebd, 0x1fd81067,
N    0x8825077, 0x1fe2f64c, 0x8889454, 0x1feddaf6,
N    0x88eda54, 0x1ff8be65, 0x8952278, 0x2003a099,
N    0x89b6cbf, 0x200e8190, 0x8a1b928, 0x2019614c,
N    0x8a807b4, 0x20243fca, 0x8ae5862, 0x202f1d0b,
N    0x8b4ab32, 0x2039f90f, 0x8bb0023, 0x2044d3d4,
N    0x8c15736, 0x204fad5b, 0x8c7b06b, 0x205a85a3,
N    0x8ce0bc0, 0x20655cac, 0x8d46936, 0x20703275,
N    0x8dac8cd, 0x207b06fe, 0x8e12a84, 0x2085da46,
N    0x8e78e5b, 0x2090ac4d, 0x8edf452, 0x209b7d13,
N    0x8f45c68, 0x20a64c97, 0x8fac69e, 0x20b11ad9,
N    0x90132f2, 0x20bbe7d8, 0x907a166, 0x20c6b395,
N    0x90e11f7, 0x20d17e0d, 0x91484a8, 0x20dc4742,
N    0x91af976, 0x20e70f32, 0x9217062, 0x20f1d5de,
N    0x927e96b, 0x20fc9b44, 0x92e6492, 0x21075f65,
N    0x934e1d6, 0x21122240, 0x93b6137, 0x211ce3d5,
N    0x941e2b4, 0x2127a423, 0x948664d, 0x21326329,
N    0x94eec03, 0x213d20e8, 0x95573d4, 0x2147dd5f,
N    0x95bfdc1, 0x2152988d, 0x96289c9, 0x215d5273,
N    0x96917ec, 0x21680b0f, 0x96fa82a, 0x2172c262,
N    0x9763a83, 0x217d786a, 0x97ccef5, 0x21882d28,
N    0x9836582, 0x2192e09b, 0x989fe29, 0x219d92c2,
N    0x99098e9, 0x21a8439e, 0x99735c2, 0x21b2f32e,
N    0x99dd4b4, 0x21bda171, 0x9a475bf, 0x21c84e67,
N    0x9ab18e3, 0x21d2fa0f, 0x9b1be1e, 0x21dda46a,
N    0x9b86572, 0x21e84d76, 0x9bf0edd, 0x21f2f534,
N    0x9c5ba60, 0x21fd9ba3, 0x9cc67fa, 0x220840c2,
N    0x9d317ab, 0x2212e492, 0x9d9c973, 0x221d8711,
N    0x9e07d51, 0x2228283f, 0x9e73346, 0x2232c81c,
N    0x9edeb50, 0x223d66a8, 0x9f4a570, 0x224803e2,
N    0x9fb61a5, 0x22529fca, 0xa021fef, 0x225d3a5e,
N    0xa08e04f, 0x2267d3a0, 0xa0fa2c3, 0x22726b8e,
N    0xa16674b, 0x227d0228, 0xa1d2de7, 0x2287976e,
N    0xa23f698, 0x22922b5e, 0xa2ac15b, 0x229cbdfa,
N    0xa318e32, 0x22a74f40, 0xa385d1d, 0x22b1df30,
N    0xa3f2e19, 0x22bc6dca, 0xa460129, 0x22c6fb0c,
N    0xa4cd64b, 0x22d186f8, 0xa53ad7e, 0x22dc118c,
N    0xa5a86c4, 0x22e69ac8, 0xa61621b, 0x22f122ab,
N    0xa683f83, 0x22fba936, 0xa6f1efc, 0x23062e67,
N    0xa760086, 0x2310b23e, 0xa7ce420, 0x231b34bc,
N    0xa83c9ca, 0x2325b5df, 0xa8ab184, 0x233035a7,
N    0xa919b4e, 0x233ab414, 0xa988727, 0x23453125,
N    0xa9f750f, 0x234facda, 0xaa66506, 0x235a2733,
N    0xaad570c, 0x2364a02e, 0xab44b1f, 0x236f17cc,
N    0xabb4141, 0x23798e0d, 0xac23971, 0x238402ef,
N    0xac933ae, 0x238e7673, 0xad02ff8, 0x2398e898,
N    0xad72e4f, 0x23a3595e, 0xade2eb3, 0x23adc8c4,
N    0xae53123, 0x23b836ca, 0xaec35a0, 0x23c2a36f,
N    0xaf33c28, 0x23cd0eb3, 0xafa44bc, 0x23d77896,
N    0xb014f5b, 0x23e1e117, 0xb085c05, 0x23ec4837,
N    0xb0f6aba, 0x23f6adf3, 0xb167b79, 0x2401124d,
N    0xb1d8e43, 0x240b7543, 0xb24a316, 0x2415d6d5,
N    0xb2bb9f4, 0x24203704, 0xb32d2da, 0x242a95ce,
N    0xb39edca, 0x2434f332, 0xb410ac3, 0x243f4f32,
N    0xb4829c4, 0x2449a9cc, 0xb4f4acd, 0x245402ff,
N    0xb566ddf, 0x245e5acc, 0xb5d92f8, 0x2468b132,
N    0xb64ba19, 0x24730631, 0xb6be341, 0x247d59c8,
N    0xb730e70, 0x2487abf7, 0xb7a3ba5, 0x2491fcbe,
N    0xb816ae1, 0x249c4c1b, 0xb889c23, 0x24a69a0f,
N    0xb8fcf6b, 0x24b0e699, 0xb9704b9, 0x24bb31ba,
N    0xb9e3c0b, 0x24c57b6f, 0xba57563, 0x24cfc3ba,
N    0xbacb0bf, 0x24da0a9a, 0xbb3ee20, 0x24e4500e,
N    0xbbb2d85, 0x24ee9415, 0xbc26eee, 0x24f8d6b0,
N    0xbc9b25a, 0x250317df, 0xbd0f7ca, 0x250d57a0,
N    0xbd83f3d, 0x251795f3, 0xbdf88b3, 0x2521d2d8,
N    0xbe6d42b, 0x252c0e4f, 0xbee21a5, 0x25364857,
N    0xbf57121, 0x254080ef, 0xbfcc29f, 0x254ab818,
N    0xc04161e, 0x2554edd1, 0xc0b6b9e, 0x255f2219,
N    0xc12c31f, 0x256954f1, 0xc1a1ca0, 0x25738657,
N    0xc217822, 0x257db64c, 0xc28d5a3, 0x2587e4cf,
N    0xc303524, 0x259211df, 0xc3796a5, 0x259c3d7c,
N    0xc3efa25, 0x25a667a7, 0xc465fa3, 0x25b0905d,
N    0xc4dc720, 0x25bab7a0, 0xc55309b, 0x25c4dd6e,
N    0xc5c9c14, 0x25cf01c8, 0xc64098b, 0x25d924ac,
N    0xc6b78ff, 0x25e3461b, 0xc72ea70, 0x25ed6614,
N    0xc7a5dde, 0x25f78497, 0xc81d349, 0x2601a1a2,
N    0xc894aaf, 0x260bbd37, 0xc90c412, 0x2615d754,
N    0xc983f70, 0x261feffa, 0xc9fbcca, 0x262a0727,
N    0xca73c1e, 0x26341cdb, 0xcaebd6e, 0x263e3117,
N    0xcb640b8, 0x264843d9, 0xcbdc5fc, 0x26525521,
N    0xcc54d3a, 0x265c64ef, 0xcccd671, 0x26667342,
N    0xcd461a2, 0x2670801a, 0xcdbeecc, 0x267a8b77,
N    0xce37def, 0x26849558, 0xceb0f0a, 0x268e9dbd,
N    0xcf2a21d, 0x2698a4a6, 0xcfa3729, 0x26a2aa11,
N    0xd01ce2b, 0x26acadff, 0xd096725, 0x26b6b070,
N    0xd110216, 0x26c0b162, 0xd189efe, 0x26cab0d6,
N    0xd203ddc, 0x26d4aecb, 0xd27deb0, 0x26deab41,
N    0xd2f817b, 0x26e8a637, 0xd37263a, 0x26f29fad,
N    0xd3eccef, 0x26fc97a3, 0xd467599, 0x27068e18,
N    0xd4e2037, 0x2710830c, 0xd55ccca, 0x271a767e,
N    0xd5d7b50, 0x2724686e, 0xd652bcb, 0x272e58dc,
N    0xd6cde39, 0x273847c8, 0xd74929a, 0x27423530,
N    0xd7c48ee, 0x274c2115, 0xd840134, 0x27560b76,
N    0xd8bbb6d, 0x275ff452, 0xd937798, 0x2769dbaa,
N    0xd9b35b4, 0x2773c17d, 0xda2f5c2, 0x277da5cb,
N    0xdaab7c0, 0x27878893, 0xdb27bb0, 0x279169d5,
N    0xdba4190, 0x279b4990, 0xdc20960, 0x27a527c4,
N    0xdc9d320, 0x27af0472, 0xdd19ed0, 0x27b8df97,
N    0xdd96c6f, 0x27c2b934, 0xde13bfd, 0x27cc9149,
N    0xde90d79, 0x27d667d5, 0xdf0e0e4, 0x27e03cd8,
N    0xdf8b63d, 0x27ea1052, 0xe008d84, 0x27f3e241,
N    0xe0866b8, 0x27fdb2a7, 0xe1041d9, 0x28078181,
N    0xe181ee8, 0x28114ed0, 0xe1ffde2, 0x281b1a94,
N    0xe27dec9, 0x2824e4cc, 0xe2fc19c, 0x282ead78,
N    0xe37a65b, 0x28387498, 0xe3f8d05, 0x28423a2a,
N    0xe47759a, 0x284bfe2f, 0xe4f6019, 0x2855c0a6,
N    0xe574c84, 0x285f8190, 0xe5f3ad8, 0x286940ea,
N    0xe672b16, 0x2872feb6, 0xe6f1d3d, 0x287cbaf3,
N    0xe77114e, 0x288675a0, 0xe7f0748, 0x28902ebd,
N    0xe86ff2a, 0x2899e64a, 0xe8ef8f4, 0x28a39c46,
N    0xe96f4a7, 0x28ad50b1, 0xe9ef241, 0x28b7038b,
N    0xea6f1c2, 0x28c0b4d2, 0xeaef32b, 0x28ca6488,
N    0xeb6f67a, 0x28d412ab, 0xebefbb0, 0x28ddbf3b,
N    0xec702cb, 0x28e76a37, 0xecf0bcd, 0x28f113a0,
N    0xed716b4, 0x28fabb75, 0xedf2380, 0x290461b5,
N    0xee73231, 0x290e0661, 0xeef42c7, 0x2917a977,
N    0xef75541, 0x29214af8, 0xeff699f, 0x292aeae3,
N    0xf077fe1, 0x29348937, 0xf0f9805, 0x293e25f5,
N    0xf17b20d, 0x2947c11c, 0xf1fcdf8, 0x29515aab,
N    0xf27ebc5, 0x295af2a3, 0xf300b74, 0x29648902,
N    0xf382d05, 0x296e1dc9, 0xf405077, 0x2977b0f7,
N    0xf4875ca, 0x2981428c, 0xf509cfe, 0x298ad287,
N    0xf58c613, 0x299460e8, 0xf60f108, 0x299dedaf,
N    0xf691ddd, 0x29a778db, 0xf714c91, 0x29b1026c,
N    0xf797d24, 0x29ba8a61, 0xf81af97, 0x29c410ba,
N    0xf89e3e8, 0x29cd9578, 0xf921a17, 0x29d71899,
N    0xf9a5225, 0x29e09a1c, 0xfa28c10, 0x29ea1a03,
N    0xfaac7d8, 0x29f3984c, 0xfb3057d, 0x29fd14f6,
N    0xfbb4500, 0x2a069003, 0xfc3865e, 0x2a100970,
N    0xfcbc999, 0x2a19813f, 0xfd40eaf, 0x2a22f76e,
N    0xfdc55a1, 0x2a2c6bfd, 0xfe49e6d, 0x2a35deeb,
N    0xfece915, 0x2a3f503a, 0xff53597, 0x2a48bfe7,
N    0xffd83f4, 0x2a522df3, 0x1005d42a, 0x2a5b9a5d,
N    0x100e2639, 0x2a650525, 0x10167a22, 0x2a6e6e4b,
N    0x101ecfe4, 0x2a77d5ce, 0x1027277e, 0x2a813bae,
N    0x102f80f1, 0x2a8a9fea, 0x1037dc3b, 0x2a940283,
N    0x1040395d, 0x2a9d6377, 0x10489856, 0x2aa6c2c6,
N    0x1050f926, 0x2ab02071, 0x10595bcd, 0x2ab97c77,
N    0x1061c04a, 0x2ac2d6d6, 0x106a269d, 0x2acc2f90,
N    0x10728ec6, 0x2ad586a3, 0x107af8c4, 0x2adedc10,
N    0x10836497, 0x2ae82fd5, 0x108bd23f, 0x2af181f3,
N    0x109441bb, 0x2afad269, 0x109cb30b, 0x2b042137,
N    0x10a5262f, 0x2b0d6e5c, 0x10ad9b26, 0x2b16b9d9,
N    0x10b611f1, 0x2b2003ac, 0x10be8a8d, 0x2b294bd5,
N    0x10c704fd, 0x2b329255, 0x10cf813e, 0x2b3bd72a,
N    0x10d7ff51, 0x2b451a55, 0x10e07f36, 0x2b4e5bd4,
N    0x10e900ec, 0x2b579ba8, 0x10f18472, 0x2b60d9d0,
N    0x10fa09c9, 0x2b6a164d, 0x110290f0, 0x2b73511c,
N    0x110b19e7, 0x2b7c8a3f, 0x1113a4ad, 0x2b85c1b5,
N    0x111c3142, 0x2b8ef77d, 0x1124bfa6, 0x2b982b97,
N    0x112d4fd9, 0x2ba15e03, 0x1135e1d9, 0x2baa8ec0,
N    0x113e75a8, 0x2bb3bdce, 0x11470b44, 0x2bbceb2d,
N    0x114fa2ad, 0x2bc616dd, 0x11583be2, 0x2bcf40dc,
N    0x1160d6e5, 0x2bd8692b, 0x116973b3, 0x2be18fc9,
N    0x1172124d, 0x2beab4b6, 0x117ab2b3, 0x2bf3d7f2,
N    0x118354e4, 0x2bfcf97c, 0x118bf8e0, 0x2c061953,
N    0x11949ea6, 0x2c0f3779, 0x119d4636, 0x2c1853eb,
N    0x11a5ef90, 0x2c216eaa, 0x11ae9ab4, 0x2c2a87b6,
N    0x11b747a0, 0x2c339f0e, 0x11bff656, 0x2c3cb4b1,
N    0x11c8a6d4, 0x2c45c8a0, 0x11d1591a, 0x2c4edada,
N    0x11da0d28, 0x2c57eb5e, 0x11e2c2fd, 0x2c60fa2d,
N    0x11eb7a9a, 0x2c6a0746, 0x11f433fd, 0x2c7312a9,
N    0x11fcef27, 0x2c7c1c55, 0x1205ac17, 0x2c85244a,
N    0x120e6acc, 0x2c8e2a87, 0x12172b48, 0x2c972f0d,
N    0x121fed88, 0x2ca031da, 0x1228b18d, 0x2ca932ef,
N    0x12317756, 0x2cb2324c, 0x123a3ee4, 0x2cbb2fef,
N    0x12430835, 0x2cc42bd9, 0x124bd34a, 0x2ccd2609,
N    0x1254a021, 0x2cd61e7f, 0x125d6ebc, 0x2cdf153a,
N    0x12663f19, 0x2ce80a3a, 0x126f1138, 0x2cf0fd80,
N    0x1277e518, 0x2cf9ef09, 0x1280babb, 0x2d02ded7,
N    0x1289921e, 0x2d0bcce8, 0x12926b41, 0x2d14b93d,
N    0x129b4626, 0x2d1da3d5, 0x12a422ca, 0x2d268cb0,
N    0x12ad012e, 0x2d2f73cd, 0x12b5e151, 0x2d38592c,
N    0x12bec333, 0x2d413ccd, 0x12c7a6d4, 0x2d4a1eaf,
N    0x12d08c33, 0x2d52fed2, 0x12d97350, 0x2d5bdd36,
N    0x12e25c2b, 0x2d64b9da, 0x12eb46c3, 0x2d6d94bf,
N    0x12f43318, 0x2d766de2, 0x12fd2129, 0x2d7f4545,
N    0x130610f7, 0x2d881ae8, 0x130f0280, 0x2d90eec8,
N    0x1317f5c6, 0x2d99c0e7, 0x1320eac6, 0x2da29144,
N    0x1329e181, 0x2dab5fdf, 0x1332d9f7, 0x2db42cb6,
N    0x133bd427, 0x2dbcf7cb, 0x1344d011, 0x2dc5c11c,
N    0x134dcdb4, 0x2dce88aa, 0x1356cd11, 0x2dd74e73,
N    0x135fce26, 0x2de01278, 0x1368d0f3, 0x2de8d4b8,
N    0x1371d579, 0x2df19534, 0x137adbb6, 0x2dfa53e9,
N    0x1383e3ab, 0x2e0310d9, 0x138ced57, 0x2e0bcc03,
N    0x1395f8ba, 0x2e148566, 0x139f05d3, 0x2e1d3d03,
N    0x13a814a2, 0x2e25f2d8, 0x13b12526, 0x2e2ea6e6,
N    0x13ba3760, 0x2e37592c, 0x13c34b4f, 0x2e4009aa,
N    0x13cc60f2, 0x2e48b860, 0x13d5784a, 0x2e51654c,
N    0x13de9156, 0x2e5a1070, 0x13e7ac15, 0x2e62b9ca,
N    0x13f0c887, 0x2e6b615a, 0x13f9e6ad, 0x2e740720,
N    0x14030684, 0x2e7cab1c, 0x140c280e, 0x2e854d4d,
N    0x14154b4a, 0x2e8dedb3, 0x141e7037, 0x2e968c4d,
N    0x142796d5, 0x2e9f291b, 0x1430bf24, 0x2ea7c41e,
N    0x1439e923, 0x2eb05d53, 0x144314d3, 0x2eb8f4bc,
N    0x144c4232, 0x2ec18a58, 0x14557140, 0x2eca1e27,
N    0x145ea1fd, 0x2ed2b027, 0x1467d469, 0x2edb405a,
N    0x14710883, 0x2ee3cebe, 0x147a3e4b, 0x2eec5b53,
N    0x148375c1, 0x2ef4e619, 0x148caee4, 0x2efd6f10,
N    0x1495e9b3, 0x2f05f637, 0x149f2630, 0x2f0e7b8e,
N    0x14a86458, 0x2f16ff14, 0x14b1a42c, 0x2f1f80ca,
N    0x14bae5ab, 0x2f2800af, 0x14c428d6, 0x2f307ec2,
N    0x14cd6dab, 0x2f38fb03, 0x14d6b42b, 0x2f417573,
N    0x14dffc54, 0x2f49ee0f, 0x14e94627, 0x2f5264da,
N    0x14f291a4, 0x2f5ad9d1, 0x14fbdec9, 0x2f634cf5,
N    0x15052d97, 0x2f6bbe45, 0x150e7e0d, 0x2f742dc1,
N    0x1517d02b, 0x2f7c9b69, 0x152123f0, 0x2f85073c,
N    0x152a795d, 0x2f8d713a, 0x1533d070, 0x2f95d963,
N    0x153d292a, 0x2f9e3fb6, 0x15468389, 0x2fa6a433,
N    0x154fdf8f, 0x2faf06da, 0x15593d3a, 0x2fb767aa,
N    0x15629c89, 0x2fbfc6a3, 0x156bfd7d, 0x2fc823c5,
N    0x15756016, 0x2fd07f0f, 0x157ec452, 0x2fd8d882,
N    0x15882a32, 0x2fe1301c, 0x159191b5, 0x2fe985de,
N    0x159afadb, 0x2ff1d9c7, 0x15a465a3, 0x2ffa2bd6,
N    0x15add20d, 0x30027c0c, 0x15b74019, 0x300aca69,
N    0x15c0afc6, 0x301316eb, 0x15ca2115, 0x301b6193,
N    0x15d39403, 0x3023aa5f, 0x15dd0892, 0x302bf151,
N    0x15e67ec1, 0x30343667, 0x15eff690, 0x303c79a2,
N    0x15f96ffd, 0x3044bb00, 0x1602eb0a, 0x304cfa83,
N    0x160c67b4, 0x30553828, 0x1615e5fd, 0x305d73f0,
N    0x161f65e4, 0x3065addb, 0x1628e767, 0x306de5e9,
N    0x16326a88, 0x30761c18, 0x163bef46, 0x307e5069,
N    0x1645759f, 0x308682dc, 0x164efd94, 0x308eb36f,
N    0x16588725, 0x3096e223, 0x16621251, 0x309f0ef8,
N    0x166b9f18, 0x30a739ed, 0x16752d79, 0x30af6302,
N    0x167ebd74, 0x30b78a36, 0x16884f09, 0x30bfaf89,
N    0x1691e237, 0x30c7d2fb, 0x169b76fe, 0x30cff48c,
N    0x16a50d5d, 0x30d8143b, 0x16aea555, 0x30e03208,
N    0x16b83ee4, 0x30e84df3, 0x16c1da0b, 0x30f067fb,
N    0x16cb76c9, 0x30f8801f, 0x16d5151d, 0x31009661,
N    0x16deb508, 0x3108aabf, 0x16e85689, 0x3110bd39,
N    0x16f1f99f, 0x3118cdcf, 0x16fb9e4b, 0x3120dc80,
N    0x1705448b, 0x3128e94c, 0x170eec60, 0x3130f433,
N    0x171895c9, 0x3138fd35, 0x172240c5, 0x31410450,
N    0x172bed55, 0x31490986, 0x17359b78, 0x31510cd5,
N    0x173f4b2e, 0x31590e3e, 0x1748fc75, 0x31610dbf,
N    0x1752af4f, 0x31690b59, 0x175c63ba, 0x3171070c,
N    0x176619b6, 0x317900d6, 0x176fd143, 0x3180f8b8,
N    0x17798a60, 0x3188eeb2, 0x1783450d, 0x3190e2c3,
N    0x178d014a, 0x3198d4ea, 0x1796bf16, 0x31a0c528,
N    0x17a07e70, 0x31a8b37c, 0x17aa3f5a, 0x31b09fe7,
N    0x17b401d1, 0x31b88a66, 0x17bdc5d6, 0x31c072fb,
N    0x17c78b68, 0x31c859a5, 0x17d15288, 0x31d03e64,
N    0x17db1b34, 0x31d82137, 0x17e4e56c, 0x31e0021e,
N    0x17eeb130, 0x31e7e118, 0x17f87e7f, 0x31efbe27,
N    0x18024d59, 0x31f79948, 0x180c1dbf, 0x31ff727c,
N    0x1815efae, 0x320749c3, 0x181fc328, 0x320f1f1c,
N    0x1829982b, 0x3216f287, 0x18336eb7, 0x321ec403,
N    0x183d46cc, 0x32269391, 0x18472069, 0x322e6130,
N    0x1850fb8e, 0x32362ce0, 0x185ad83c, 0x323df6a0,
N    0x1864b670, 0x3245be70, 0x186e962b, 0x324d8450,
N    0x1878776d, 0x32554840, 0x18825a35, 0x325d0a3e,
N    0x188c3e83, 0x3264ca4c, 0x18962456, 0x326c8868,
N    0x18a00bae, 0x32744493, 0x18a9f48a, 0x327bfecc,
N    0x18b3deeb, 0x3283b712, 0x18bdcad0, 0x328b6d66,
N    0x18c7b838, 0x329321c7, 0x18d1a724, 0x329ad435,
N    0x18db9792, 0x32a284b0, 0x18e58982, 0x32aa3336,
N    0x18ef7cf4, 0x32b1dfc9, 0x18f971e8, 0x32b98a67,
N    0x1903685d, 0x32c13311, 0x190d6053, 0x32c8d9c6,
N    0x191759c9, 0x32d07e85, 0x192154bf, 0x32d82150,
N    0x192b5135, 0x32dfc224, 0x19354f2a, 0x32e76102,
N    0x193f4e9e, 0x32eefdea, 0x19494f90, 0x32f698db,
N    0x19535201, 0x32fe31d5, 0x195d55ef, 0x3305c8d7,
N    0x19675b5a, 0x330d5de3, 0x19716243, 0x3314f0f6,
N    0x197b6aa8, 0x331c8211, 0x19857489, 0x33241134,
N    0x198f7fe6, 0x332b9e5e, 0x19998cbe, 0x3333298f,
N    0x19a39b11, 0x333ab2c6, 0x19adaadf, 0x33423a04,
N    0x19b7bc27, 0x3349bf48, 0x19c1cee9, 0x33514292,
N    0x19cbe325, 0x3358c3e2, 0x19d5f8d9, 0x33604336,
N    0x19e01006, 0x3367c090, 0x19ea28ac, 0x336f3bee,
N    0x19f442c9, 0x3376b551, 0x19fe5e5e, 0x337e2cb7,
N    0x1a087b69, 0x3385a222, 0x1a1299ec, 0x338d1590,
N    0x1a1cb9e5, 0x33948701, 0x1a26db54, 0x339bf675,
N    0x1a30fe38, 0x33a363ec, 0x1a3b2292, 0x33aacf65,
N    0x1a454860, 0x33b238e0, 0x1a4f6fa3, 0x33b9a05d,
N    0x1a599859, 0x33c105db, 0x1a63c284, 0x33c8695b,
N    0x1a6dee21, 0x33cfcadc, 0x1a781b31, 0x33d72a5d,
N    0x1a8249b4, 0x33de87de, 0x1a8c79a9, 0x33e5e360,
N    0x1a96ab0f, 0x33ed3ce1, 0x1aa0dde7, 0x33f49462,
N    0x1aab122f, 0x33fbe9e2, 0x1ab547e8, 0x34033d61,
N    0x1abf7f11, 0x340a8edf, 0x1ac9b7a9, 0x3411de5b,
N    0x1ad3f1b1, 0x34192bd5, 0x1ade2d28, 0x3420774d,
N    0x1ae86a0d, 0x3427c0c3, 0x1af2a860, 0x342f0836,
N    0x1afce821, 0x34364da6, 0x1b072950, 0x343d9112,
N    0x1b116beb, 0x3444d27b, 0x1b1baff2, 0x344c11e0,
N    0x1b25f566, 0x34534f41, 0x1b303c46, 0x345a8a9d,
N    0x1b3a8491, 0x3461c3f5, 0x1b44ce46, 0x3468fb47,
N    0x1b4f1967, 0x34703095, 0x1b5965f1, 0x347763dd,
N    0x1b63b3e5, 0x347e951f, 0x1b6e0342, 0x3485c45b,
N    0x1b785409, 0x348cf190, 0x1b82a638, 0x34941cbf,
N    0x1b8cf9cf, 0x349b45e7, 0x1b974ece, 0x34a26d08,
N    0x1ba1a534, 0x34a99221, 0x1babfd01, 0x34b0b533,
N    0x1bb65634, 0x34b7d63c, 0x1bc0b0ce, 0x34bef53d,
N    0x1bcb0cce, 0x34c61236, 0x1bd56a32, 0x34cd2d26,
N    0x1bdfc8fc, 0x34d4460c, 0x1bea292b, 0x34db5cea,
N    0x1bf48abd, 0x34e271bd, 0x1bfeedb3, 0x34e98487,
N    0x1c09520d, 0x34f09546, 0x1c13b7c9, 0x34f7a3fb,
N    0x1c1e1ee9, 0x34feb0a5, 0x1c28876a, 0x3505bb44,
N    0x1c32f14d, 0x350cc3d8, 0x1c3d5c91, 0x3513ca60,
N    0x1c47c936, 0x351acedd, 0x1c52373c, 0x3521d14d,
N    0x1c5ca6a2, 0x3528d1b1, 0x1c671768, 0x352fd008,
N    0x1c71898d, 0x3536cc52, 0x1c7bfd11, 0x353dc68f,
N    0x1c8671f3, 0x3544bebf, 0x1c90e834, 0x354bb4e1,
N    0x1c9b5fd2, 0x3552a8f4, 0x1ca5d8cd, 0x35599afa,
N    0x1cb05326, 0x35608af1, 0x1cbacedb, 0x356778d9,
N    0x1cc54bec, 0x356e64b2, 0x1ccfca59, 0x35754e7c,
N    0x1cda4a21, 0x357c3636, 0x1ce4cb44, 0x35831be0,
N    0x1cef4dc2, 0x3589ff7a, 0x1cf9d199, 0x3590e104,
N    0x1d0456ca, 0x3597c07d, 0x1d0edd55, 0x359e9de5,
N    0x1d196538, 0x35a5793c, 0x1d23ee74, 0x35ac5282,
N    0x1d2e7908, 0x35b329b5, 0x1d3904f4, 0x35b9fed7,
N    0x1d439236, 0x35c0d1e7, 0x1d4e20d0, 0x35c7a2e3,
N    0x1d58b0c0, 0x35ce71ce, 0x1d634206, 0x35d53ea5,
N    0x1d6dd4a2, 0x35dc0968, 0x1d786892, 0x35e2d219,
N    0x1d82fdd8, 0x35e998b5, 0x1d8d9472, 0x35f05d3d,
N    0x1d982c60, 0x35f71fb1, 0x1da2c5a2, 0x35fde011,
N    0x1dad6036, 0x36049e5b, 0x1db7fc1e, 0x360b5a90,
N    0x1dc29958, 0x361214b0, 0x1dcd37e4, 0x3618ccba,
N    0x1dd7d7c1, 0x361f82af, 0x1de278ef, 0x3626368d,
N    0x1ded1b6e, 0x362ce855, 0x1df7bf3e, 0x36339806,
N    0x1e02645d, 0x363a45a0, 0x1e0d0acc, 0x3640f123,
N    0x1e17b28a, 0x36479a8e, 0x1e225b96, 0x364e41e2,
N    0x1e2d05f1, 0x3654e71d, 0x1e37b199, 0x365b8a41,
N    0x1e425e8f, 0x36622b4c, 0x1e4d0cd2, 0x3668ca3e,
N    0x1e57bc62, 0x366f6717, 0x1e626d3e, 0x367601d7,
N    0x1e6d1f65, 0x367c9a7e, 0x1e77d2d8, 0x3683310b,
N    0x1e828796, 0x3689c57d, 0x1e8d3d9e, 0x369057d6,
N    0x1e97f4f1, 0x3696e814, 0x1ea2ad8d, 0x369d7637,
N    0x1ead6773, 0x36a4023f, 0x1eb822a1, 0x36aa8c2c,
N    0x1ec2df18, 0x36b113fd, 0x1ecd9cd7, 0x36b799b3,
N    0x1ed85bdd, 0x36be1d4c, 0x1ee31c2b, 0x36c49ec9,
N    0x1eedddc0, 0x36cb1e2a, 0x1ef8a09b, 0x36d19b6e,
N    0x1f0364bc, 0x36d81695, 0x1f0e2a22, 0x36de8f9e,
N    0x1f18f0ce, 0x36e5068a, 0x1f23b8be, 0x36eb7b58,
N    0x1f2e81f3, 0x36f1ee09, 0x1f394c6b, 0x36f85e9a,
N    0x1f441828, 0x36fecd0e, 0x1f4ee527, 0x37053962,
N    0x1f59b369, 0x370ba398, 0x1f6482ed, 0x37120bae,
N    0x1f6f53b3, 0x371871a5, 0x1f7a25ba, 0x371ed57c,
N    0x1f84f902, 0x37253733, 0x1f8fcd8b, 0x372b96ca,
N    0x1f9aa354, 0x3731f440, 0x1fa57a5d, 0x37384f95,
N    0x1fb052a5, 0x373ea8ca, 0x1fbb2c2c, 0x3744ffdd,
N    0x1fc606f1, 0x374b54ce, 0x1fd0e2f5, 0x3751a79e,
N    0x1fdbc036, 0x3757f84c, 0x1fe69eb4, 0x375e46d8,
N    0x1ff17e70, 0x37649341, 0x1ffc5f67, 0x376add88,
N    0x2007419b, 0x377125ac, 0x2012250a, 0x37776bac,
N    0x201d09b4, 0x377daf89, 0x2027ef99, 0x3783f143,
N    0x2032d6b8, 0x378a30d8, 0x203dbf11, 0x37906e49,
N    0x2048a8a4, 0x3796a996, 0x2053936f, 0x379ce2be,
N    0x205e7f74, 0x37a319c2, 0x20696cb0, 0x37a94ea0,
N    0x20745b24, 0x37af8159, 0x207f4acf, 0x37b5b1ec,
N    0x208a3bb2, 0x37bbe05a, 0x20952dcb, 0x37c20ca1,
N    0x20a0211a, 0x37c836c2, 0x20ab159e, 0x37ce5ebd,
N    0x20b60b58, 0x37d48490, 0x20c10247, 0x37daa83d,
N    0x20cbfa6a, 0x37e0c9c3, 0x20d6f3c1, 0x37e6e921,
N    0x20e1ee4b, 0x37ed0657, 0x20ecea09, 0x37f32165,
N    0x20f7e6f9, 0x37f93a4b, 0x2102e51c, 0x37ff5109,
N    0x210de470, 0x3805659e, 0x2118e4f6, 0x380b780a,
N    0x2123e6ad, 0x3811884d, 0x212ee995, 0x38179666,
N    0x2139edac, 0x381da256, 0x2144f2f3, 0x3823ac1d,
N    0x214ff96a, 0x3829b3b9, 0x215b0110, 0x382fb92a,
N    0x216609e3, 0x3835bc71, 0x217113e5, 0x383bbd8e,
N    0x217c1f15, 0x3841bc7f, 0x21872b72, 0x3847b946,
N    0x219238fb, 0x384db3e0, 0x219d47b1, 0x3853ac4f,
N    0x21a85793, 0x3859a292, 0x21b368a0, 0x385f96a9,
N    0x21be7ad8, 0x38658894, 0x21c98e3b, 0x386b7852,
N    0x21d4a2c8, 0x387165e3, 0x21dfb87f, 0x38775147,
N    0x21eacf5f, 0x387d3a7e, 0x21f5e768, 0x38832187,
N    0x22010099, 0x38890663, 0x220c1af3, 0x388ee910,
N    0x22173674, 0x3894c98f, 0x2222531c, 0x389aa7e0,
N    0x222d70eb, 0x38a08402, 0x22388fe1, 0x38a65df6,
N    0x2243affc, 0x38ac35ba, 0x224ed13d, 0x38b20b4f,
N    0x2259f3a3, 0x38b7deb4, 0x2265172e, 0x38bdafea,
N    0x22703bdc, 0x38c37eef, 0x227b61af, 0x38c94bc4,
N    0x228688a4, 0x38cf1669, 0x2291b0bd, 0x38d4dedd,
N    0x229cd9f8, 0x38daa520, 0x22a80456, 0x38e06932,
N    0x22b32fd4, 0x38e62b13, 0x22be5c74, 0x38ebeac2,
N    0x22c98a35, 0x38f1a840, 0x22d4b916, 0x38f7638b,
N    0x22dfe917, 0x38fd1ca4, 0x22eb1a37, 0x3902d38b,
N    0x22f64c77, 0x3908883f, 0x23017fd5, 0x390e3ac0,
N    0x230cb451, 0x3913eb0e, 0x2317e9eb, 0x39199929,
N    0x232320a2, 0x391f4510, 0x232e5876, 0x3924eec3,
N    0x23399167, 0x392a9642, 0x2344cb73, 0x39303b8e,
N    0x2350069b, 0x3935dea4, 0x235b42df, 0x393b7f86,
N    0x2366803c, 0x39411e33, 0x2371beb5, 0x3946baac,
N    0x237cfe47, 0x394c54ee, 0x23883ef2, 0x3951ecfc,
N    0x239380b6, 0x395782d3, 0x239ec393, 0x395d1675,
N    0x23aa0788, 0x3962a7e0, 0x23b54c95, 0x39683715,
N    0x23c092b9, 0x396dc414, 0x23cbd9f4, 0x39734edc,
N    0x23d72245, 0x3978d76c, 0x23e26bac, 0x397e5dc6,
N    0x23edb628, 0x3983e1e8, 0x23f901ba, 0x398963d2,
N    0x24044e60, 0x398ee385, 0x240f9c1a, 0x399460ff,
N    0x241aeae8, 0x3999dc42, 0x24263ac9, 0x399f554b,
N    0x24318bbe, 0x39a4cc1c, 0x243cddc4, 0x39aa40b4,
N    0x244830dd, 0x39afb313, 0x24538507, 0x39b52339,
N    0x245eda43, 0x39ba9125, 0x246a308f, 0x39bffcd7,
N    0x247587eb, 0x39c5664f, 0x2480e057, 0x39cacd8d,
N    0x248c39d3, 0x39d03291, 0x2497945d, 0x39d5955a,
N    0x24a2eff6, 0x39daf5e8, 0x24ae4c9d, 0x39e0543c,
N    0x24b9aa52, 0x39e5b054, 0x24c50914, 0x39eb0a31,
N    0x24d068e2, 0x39f061d2, 0x24dbc9bd, 0x39f5b737,
N    0x24e72ba4, 0x39fb0a60, 0x24f28e96, 0x3a005b4d,
N    0x24fdf294, 0x3a05a9fd, 0x2509579b, 0x3a0af671,
N    0x2514bdad, 0x3a1040a8, 0x252024c9, 0x3a1588a2,
N    0x252b8cee, 0x3a1ace5f, 0x2536f61b, 0x3a2011de,
N    0x25426051, 0x3a25531f, 0x254dcb8f, 0x3a2a9223,
N    0x255937d5, 0x3a2fcee8, 0x2564a521, 0x3a350970,
N    0x25701374, 0x3a3a41b9, 0x257b82cd, 0x3a3f77c3,
N    0x2586f32c, 0x3a44ab8e, 0x25926490, 0x3a49dd1a,
N    0x259dd6f9, 0x3a4f0c67, 0x25a94a67, 0x3a543974,
N    0x25b4bed8, 0x3a596442, 0x25c0344d, 0x3a5e8cd0,
N    0x25cbaac5, 0x3a63b31d, 0x25d72240, 0x3a68d72b,
N    0x25e29abc, 0x3a6df8f8, 0x25ee143b, 0x3a731884,
N    0x25f98ebb, 0x3a7835cf, 0x26050a3b, 0x3a7d50da,
N    0x261086bc, 0x3a8269a3, 0x261c043d, 0x3a87802a,
N    0x262782be, 0x3a8c9470, 0x2633023e, 0x3a91a674,
N    0x263e82bc, 0x3a96b636, 0x264a0438, 0x3a9bc3b6,
N    0x265586b3, 0x3aa0cef3, 0x26610a2a, 0x3aa5d7ee,
N    0x266c8e9f, 0x3aaadea6, 0x26781410, 0x3aafe31b,
N    0x26839a7c, 0x3ab4e54c, 0x268f21e5, 0x3ab9e53a,
N    0x269aaa48, 0x3abee2e5, 0x26a633a6, 0x3ac3de4c,
N    0x26b1bdff, 0x3ac8d76f, 0x26bd4951, 0x3acdce4d,
N    0x26c8d59c, 0x3ad2c2e8, 0x26d462e1, 0x3ad7b53d,
N    0x26dff11d, 0x3adca54e, 0x26eb8052, 0x3ae1931a,
N    0x26f7107e, 0x3ae67ea1, 0x2702a1a1, 0x3aeb67e3,
N    0x270e33bb, 0x3af04edf, 0x2719c6cb, 0x3af53395,
N    0x27255ad1, 0x3afa1605, 0x2730efcc, 0x3afef630,
N    0x273c85bc, 0x3b03d414, 0x27481ca1, 0x3b08afb2,
N    0x2753b479, 0x3b0d8909, 0x275f4d45, 0x3b126019,
N    0x276ae704, 0x3b1734e2, 0x277681b6, 0x3b1c0764,
N    0x27821d59, 0x3b20d79e, 0x278db9ef, 0x3b25a591,
N    0x27995776, 0x3b2a713d, 0x27a4f5ed, 0x3b2f3aa0,
N    0x27b09555, 0x3b3401bb, 0x27bc35ad, 0x3b38c68e,
N    0x27c7d6f4, 0x3b3d8918, 0x27d3792b, 0x3b42495a,
N    0x27df1c50, 0x3b470753, 0x27eac063, 0x3b4bc303,
N    0x27f66564, 0x3b507c69, 0x28020b52, 0x3b553386,
N    0x280db22d, 0x3b59e85a, 0x281959f4, 0x3b5e9ae4,
N    0x282502a7, 0x3b634b23, 0x2830ac45, 0x3b67f919,
N    0x283c56cf, 0x3b6ca4c4, 0x28480243, 0x3b714e25,
N    0x2853aea1, 0x3b75f53c, 0x285f5be9, 0x3b7a9a07,
N    0x286b0a1a, 0x3b7f3c87, 0x2876b934, 0x3b83dcbc,
N    0x28826936, 0x3b887aa6, 0x288e1a20, 0x3b8d1644,
N    0x2899cbf1, 0x3b91af97, 0x28a57ea9, 0x3b96469d,
N    0x28b13248, 0x3b9adb57, 0x28bce6cd, 0x3b9f6dc5,
N    0x28c89c37, 0x3ba3fde7, 0x28d45286, 0x3ba88bbc,
N    0x28e009ba, 0x3bad1744, 0x28ebc1d3, 0x3bb1a080,
N    0x28f77acf, 0x3bb6276e, 0x290334af, 0x3bbaac0e,
N    0x290eef71, 0x3bbf2e62, 0x291aab16, 0x3bc3ae67,
N    0x2926679c, 0x3bc82c1f, 0x29322505, 0x3bcca789,
N    0x293de34e, 0x3bd120a4, 0x2949a278, 0x3bd59771,
N    0x29556282, 0x3bda0bf0, 0x2961236c, 0x3bde7e20,
N    0x296ce535, 0x3be2ee01, 0x2978a7dd, 0x3be75b93,
N    0x29846b63, 0x3bebc6d5, 0x29902fc7, 0x3bf02fc9,
N    0x299bf509, 0x3bf4966c, 0x29a7bb28, 0x3bf8fac0,
N    0x29b38223, 0x3bfd5cc4, 0x29bf49fa, 0x3c01bc78,
N    0x29cb12ad, 0x3c0619dc, 0x29d6dc3b, 0x3c0a74f0,
N    0x29e2a6a3, 0x3c0ecdb2, 0x29ee71e6, 0x3c132424,
N    0x29fa3e03, 0x3c177845, 0x2a060af9, 0x3c1bca16,
N    0x2a11d8c8, 0x3c201994, 0x2a1da770, 0x3c2466c2,
N    0x2a2976ef, 0x3c28b19e, 0x2a354746, 0x3c2cfa28,
N    0x2a411874, 0x3c314060, 0x2a4cea79, 0x3c358446,
N    0x2a58bd54, 0x3c39c5da, 0x2a649105, 0x3c3e051b,
N    0x2a70658a, 0x3c42420a, 0x2a7c3ae5, 0x3c467ca6,
N    0x2a881114, 0x3c4ab4ef, 0x2a93e817, 0x3c4eeae5,
N    0x2a9fbfed, 0x3c531e88, 0x2aab9896, 0x3c574fd8,
N    0x2ab77212, 0x3c5b7ed4, 0x2ac34c60, 0x3c5fab7c,
N    0x2acf277f, 0x3c63d5d1, 0x2adb0370, 0x3c67fdd1,
N    0x2ae6e031, 0x3c6c237e, 0x2af2bdc3, 0x3c7046d6,
N    0x2afe9c24, 0x3c7467d9, 0x2b0a7b54, 0x3c788688,
N    0x2b165b54, 0x3c7ca2e2, 0x2b223c22, 0x3c80bce7,
N    0x2b2e1dbe, 0x3c84d496, 0x2b3a0027, 0x3c88e9f1,
N    0x2b45e35d, 0x3c8cfcf6, 0x2b51c760, 0x3c910da5,
N    0x2b5dac2f, 0x3c951bff, 0x2b6991ca, 0x3c992803,
N    0x2b75782f, 0x3c9d31b0, 0x2b815f60, 0x3ca13908,
N    0x2b8d475b, 0x3ca53e09, 0x2b99301f, 0x3ca940b3,
N    0x2ba519ad, 0x3cad4107, 0x2bb10404, 0x3cb13f04,
N    0x2bbcef23, 0x3cb53aaa, 0x2bc8db0b, 0x3cb933f9,
N    0x2bd4c7ba, 0x3cbd2af0, 0x2be0b52f, 0x3cc11f90,
N    0x2beca36c, 0x3cc511d9, 0x2bf8926f, 0x3cc901c9,
N    0x2c048237, 0x3cccef62, 0x2c1072c4, 0x3cd0daa2,
N    0x2c1c6417, 0x3cd4c38b, 0x2c28562d, 0x3cd8aa1b,
N    0x2c344908, 0x3cdc8e52, 0x2c403ca5, 0x3ce07031,
N    0x2c4c3106, 0x3ce44fb7, 0x2c582629, 0x3ce82ce4,
N    0x2c641c0e, 0x3cec07b8, 0x2c7012b5, 0x3cefe032,
N    0x2c7c0a1d, 0x3cf3b653, 0x2c880245, 0x3cf78a1b,
N    0x2c93fb2e, 0x3cfb5b89, 0x2c9ff4d6, 0x3cff2a9d,
N    0x2cabef3d, 0x3d02f757, 0x2cb7ea63, 0x3d06c1b6,
N    0x2cc3e648, 0x3d0a89bc, 0x2ccfe2ea, 0x3d0e4f67,
N    0x2cdbe04a, 0x3d1212b7, 0x2ce7de66, 0x3d15d3ad,
N    0x2cf3dd3f, 0x3d199248, 0x2cffdcd4, 0x3d1d4e88,
N    0x2d0bdd25, 0x3d21086c, 0x2d17de31, 0x3d24bff6,
N    0x2d23dff7, 0x3d287523, 0x2d2fe277, 0x3d2c27f6,
N    0x2d3be5b1, 0x3d2fd86c, 0x2d47e9a5, 0x3d338687,
N    0x2d53ee51, 0x3d373245, 0x2d5ff3b5, 0x3d3adba7,
N    0x2d6bf9d1, 0x3d3e82ae, 0x2d7800a5, 0x3d422757,
N    0x2d84082f, 0x3d45c9a4, 0x2d901070, 0x3d496994,
N    0x2d9c1967, 0x3d4d0728, 0x2da82313, 0x3d50a25e,
N    0x2db42d74, 0x3d543b37, 0x2dc0388a, 0x3d57d1b3,
N    0x2dcc4454, 0x3d5b65d2, 0x2dd850d2, 0x3d5ef793,
N    0x2de45e03, 0x3d6286f6, 0x2df06be6, 0x3d6613fb,
N    0x2dfc7a7c, 0x3d699ea3, 0x2e0889c4, 0x3d6d26ec,
N    0x2e1499bd, 0x3d70acd7, 0x2e20aa67, 0x3d743064,
N    0x2e2cbbc1, 0x3d77b192, 0x2e38cdcb, 0x3d7b3061,
N    0x2e44e084, 0x3d7eacd2, 0x2e50f3ed, 0x3d8226e4,
N    0x2e5d0804, 0x3d859e96, 0x2e691cc9, 0x3d8913ea,
N    0x2e75323c, 0x3d8c86de, 0x2e81485c, 0x3d8ff772,
N    0x2e8d5f29, 0x3d9365a8, 0x2e9976a1, 0x3d96d17d,
N    0x2ea58ec6, 0x3d9a3af2, 0x2eb1a796, 0x3d9da208,
N    0x2ebdc110, 0x3da106bd, 0x2ec9db35, 0x3da46912,
N    0x2ed5f604, 0x3da7c907, 0x2ee2117c, 0x3dab269b,
N    0x2eee2d9d, 0x3dae81cf, 0x2efa4a67, 0x3db1daa2,
N    0x2f0667d9, 0x3db53113, 0x2f1285f2, 0x3db88524,
N    0x2f1ea4b2, 0x3dbbd6d4, 0x2f2ac419, 0x3dbf2622,
N    0x2f36e426, 0x3dc2730f, 0x2f4304d8, 0x3dc5bd9b,
N    0x2f4f2630, 0x3dc905c5, 0x2f5b482d, 0x3dcc4b8d,
N    0x2f676ace, 0x3dcf8ef3, 0x2f738e12, 0x3dd2cff7,
N    0x2f7fb1fa, 0x3dd60e99, 0x2f8bd685, 0x3dd94ad8,
N    0x2f97fbb2, 0x3ddc84b5, 0x2fa42181, 0x3ddfbc30,
N    0x2fb047f2, 0x3de2f148, 0x2fbc6f03, 0x3de623fd,
N    0x2fc896b5, 0x3de9544f, 0x2fd4bf08, 0x3dec823e,
N    0x2fe0e7f9, 0x3defadca, 0x2fed118a, 0x3df2d6f3,
N    0x2ff93bba, 0x3df5fdb8, 0x30056687, 0x3df9221a,
N    0x301191f3, 0x3dfc4418, 0x301dbdfb, 0x3dff63b2,
N    0x3029eaa1, 0x3e0280e9, 0x303617e2, 0x3e059bbb,
N    0x304245c0, 0x3e08b42a, 0x304e7438, 0x3e0bca34,
N    0x305aa34c, 0x3e0eddd9, 0x3066d2fa, 0x3e11ef1b,
N    0x30730342, 0x3e14fdf7, 0x307f3424, 0x3e180a6f,
N    0x308b659f, 0x3e1b1482, 0x309797b2, 0x3e1e1c30,
N    0x30a3ca5d, 0x3e212179, 0x30affda0, 0x3e24245d,
N    0x30bc317a, 0x3e2724db, 0x30c865ea, 0x3e2a22f4,
N    0x30d49af1, 0x3e2d1ea8, 0x30e0d08d, 0x3e3017f6,
N    0x30ed06bf, 0x3e330ede, 0x30f93d86, 0x3e360360,
N    0x310574e0, 0x3e38f57c, 0x3111accf, 0x3e3be532,
N    0x311de551, 0x3e3ed282, 0x312a1e66, 0x3e41bd6c,
N    0x3136580d, 0x3e44a5ef, 0x31429247, 0x3e478c0b,
N    0x314ecd11, 0x3e4a6fc1, 0x315b086d, 0x3e4d5110,
N    0x31674459, 0x3e502ff9, 0x317380d6, 0x3e530c7a,
N    0x317fbde2, 0x3e55e694, 0x318bfb7d, 0x3e58be47,
N    0x319839a6, 0x3e5b9392, 0x31a4785e, 0x3e5e6676,
N    0x31b0b7a4, 0x3e6136f3, 0x31bcf777, 0x3e640507,
N    0x31c937d6, 0x3e66d0b4, 0x31d578c2, 0x3e6999fa,
N    0x31e1ba3a, 0x3e6c60d7, 0x31edfc3d, 0x3e6f254c,
N    0x31fa3ecb, 0x3e71e759, 0x320681e3, 0x3e74a6fd,
N    0x3212c585, 0x3e77643a, 0x321f09b1, 0x3e7a1f0d,
N    0x322b4e66, 0x3e7cd778, 0x323793a3, 0x3e7f8d7b,
N    0x3243d968, 0x3e824114, 0x32501fb5, 0x3e84f245,
N    0x325c6688, 0x3e87a10c, 0x3268ade3, 0x3e8a4d6a,
N    0x3274f5c3, 0x3e8cf75f, 0x32813e2a, 0x3e8f9eeb,
N    0x328d8715, 0x3e92440d, 0x3299d085, 0x3e94e6c6,
N    0x32a61a7a, 0x3e978715, 0x32b264f2, 0x3e9a24fb,
N    0x32beafed, 0x3e9cc076, 0x32cafb6b, 0x3e9f5988,
N    0x32d7476c, 0x3ea1f02f, 0x32e393ef, 0x3ea4846c,
N    0x32efe0f2, 0x3ea7163f, 0x32fc2e77, 0x3ea9a5a8,
N    0x33087c7d, 0x3eac32a6, 0x3314cb02, 0x3eaebd3a,
N    0x33211a07, 0x3eb14563, 0x332d698a, 0x3eb3cb21,
N    0x3339b98d, 0x3eb64e75, 0x33460a0d, 0x3eb8cf5d,
N    0x33525b0b, 0x3ebb4ddb, 0x335eac86, 0x3ebdc9ed,
N    0x336afe7e, 0x3ec04394, 0x337750f2, 0x3ec2bad0,
N    0x3383a3e2, 0x3ec52fa0, 0x338ff74d, 0x3ec7a205,
N    0x339c4b32, 0x3eca11fe, 0x33a89f92, 0x3ecc7f8b,
N    0x33b4f46c, 0x3eceeaad, 0x33c149bf, 0x3ed15363,
N    0x33cd9f8b, 0x3ed3b9ad, 0x33d9f5cf, 0x3ed61d8a,
N    0x33e64c8c, 0x3ed87efc, 0x33f2a3bf, 0x3edade01,
N    0x33fefb6a, 0x3edd3a9a, 0x340b538b, 0x3edf94c7,
N    0x3417ac22, 0x3ee1ec87, 0x3424052f, 0x3ee441da,
N    0x34305eb0, 0x3ee694c1, 0x343cb8a7, 0x3ee8e53a,
N    0x34491311, 0x3eeb3347, 0x34556def, 0x3eed7ee7,
N    0x3461c940, 0x3eefc81a, 0x346e2504, 0x3ef20ee0,
N    0x347a8139, 0x3ef45338, 0x3486dde1, 0x3ef69523,
N    0x34933afa, 0x3ef8d4a1, 0x349f9884, 0x3efb11b1,
N    0x34abf67e, 0x3efd4c54, 0x34b854e7, 0x3eff8489,
N    0x34c4b3c0, 0x3f01ba50, 0x34d11308, 0x3f03eda9,
N    0x34dd72be, 0x3f061e95, 0x34e9d2e3, 0x3f084d12,
N    0x34f63374, 0x3f0a7921, 0x35029473, 0x3f0ca2c2,
N    0x350ef5de, 0x3f0ec9f5, 0x351b57b5, 0x3f10eeb9,
N    0x3527b9f7, 0x3f13110f, 0x35341ca5, 0x3f1530f7,
N    0x35407fbd, 0x3f174e70, 0x354ce33f, 0x3f19697a,
N    0x3559472b, 0x3f1b8215, 0x3565ab80, 0x3f1d9842,
N    0x3572103d, 0x3f1fabff, 0x357e7563, 0x3f21bd4e,
N    0x358adaf0, 0x3f23cc2e, 0x359740e5, 0x3f25d89e,
N    0x35a3a740, 0x3f27e29f, 0x35b00e02, 0x3f29ea31,
N    0x35bc7529, 0x3f2bef53, 0x35c8dcb6, 0x3f2df206,
N    0x35d544a7, 0x3f2ff24a, 0x35e1acfd, 0x3f31f01d,
N    0x35ee15b7, 0x3f33eb81, 0x35fa7ed4, 0x3f35e476,
N    0x3606e854, 0x3f37dafa, 0x36135237, 0x3f39cf0e,
N    0x361fbc7b, 0x3f3bc0b3, 0x362c2721, 0x3f3dafe7,
N    0x36389228, 0x3f3f9cab, 0x3644fd8f, 0x3f4186ff,
N    0x36516956, 0x3f436ee3, 0x365dd57d, 0x3f455456,
N    0x366a4203, 0x3f473759, 0x3676aee8, 0x3f4917eb,
N    0x36831c2b, 0x3f4af60d, 0x368f89cb, 0x3f4cd1be,
N    0x369bf7c9, 0x3f4eaafe, 0x36a86623, 0x3f5081cd,
N    0x36b4d4d9, 0x3f52562c, 0x36c143ec, 0x3f54281a,
N    0x36cdb359, 0x3f55f796, 0x36da2321, 0x3f57c4a2,
N    0x36e69344, 0x3f598f3c, 0x36f303c0, 0x3f5b5765,
N    0x36ff7496, 0x3f5d1d1d, 0x370be5c4, 0x3f5ee063,
N    0x3718574b, 0x3f60a138, 0x3724c92a, 0x3f625f9b,
N    0x37313b60, 0x3f641b8d, 0x373daded, 0x3f65d50d,
N    0x374a20d0, 0x3f678c1c, 0x3756940a, 0x3f6940b8,
N    0x37630799, 0x3f6af2e3, 0x376f7b7d, 0x3f6ca29c,
N    0x377befb5, 0x3f6e4fe3, 0x37886442, 0x3f6ffab8,
N    0x3794d922, 0x3f71a31b, 0x37a14e55, 0x3f73490b,
N    0x37adc3db, 0x3f74ec8a, 0x37ba39b3, 0x3f768d96,
N    0x37c6afdc, 0x3f782c30, 0x37d32657, 0x3f79c857,
N    0x37df9d22, 0x3f7b620c, 0x37ec143e, 0x3f7cf94e,
N    0x37f88ba9, 0x3f7e8e1e, 0x38050364, 0x3f80207b,
N    0x38117b6d, 0x3f81b065, 0x381df3c5, 0x3f833ddd,
N    0x382a6c6a, 0x3f84c8e2, 0x3836e55d, 0x3f865174,
N    0x38435e9d, 0x3f87d792, 0x384fd829, 0x3f895b3e,
N    0x385c5201, 0x3f8adc77, 0x3868cc24, 0x3f8c5b3d,
N    0x38754692, 0x3f8dd78f, 0x3881c14b, 0x3f8f516e,
N    0x388e3c4d, 0x3f90c8da, 0x389ab799, 0x3f923dd2,
N    0x38a7332e, 0x3f93b058, 0x38b3af0c, 0x3f952069,
N    0x38c02b31, 0x3f968e07, 0x38cca79e, 0x3f97f932,
N    0x38d92452, 0x3f9961e8, 0x38e5a14d, 0x3f9ac82c,
N    0x38f21e8e, 0x3f9c2bfb, 0x38fe9c15, 0x3f9d8d56,
N    0x390b19e0, 0x3f9eec3e, 0x391797f0, 0x3fa048b2,
N    0x39241645, 0x3fa1a2b2, 0x393094dd, 0x3fa2fa3d,
N    0x393d13b8, 0x3fa44f55, 0x394992d7, 0x3fa5a1f9,
N    0x39561237, 0x3fa6f228, 0x396291d9, 0x3fa83fe3,
N    0x396f11bc, 0x3fa98b2a, 0x397b91e1, 0x3faad3fd,
N    0x39881245, 0x3fac1a5b, 0x399492ea, 0x3fad5e45,
N    0x39a113cd, 0x3fae9fbb, 0x39ad94f0, 0x3fafdebb,
N    0x39ba1651, 0x3fb11b48, 0x39c697f0, 0x3fb2555f,
N    0x39d319cc, 0x3fb38d02, 0x39df9be6, 0x3fb4c231,
N    0x39ec1e3b, 0x3fb5f4ea, 0x39f8a0cd, 0x3fb7252f,
N    0x3a05239a, 0x3fb852ff, 0x3a11a6a3, 0x3fb97e5a,
N    0x3a1e29e5, 0x3fbaa740, 0x3a2aad62, 0x3fbbcdb1,
N    0x3a373119, 0x3fbcf1ad, 0x3a43b508, 0x3fbe1334,
N    0x3a503930, 0x3fbf3246, 0x3a5cbd91, 0x3fc04ee3,
N    0x3a694229, 0x3fc1690a, 0x3a75c6f8, 0x3fc280bc,
N    0x3a824bfd, 0x3fc395f9, 0x3a8ed139, 0x3fc4a8c1,
N    0x3a9b56ab, 0x3fc5b913, 0x3aa7dc52, 0x3fc6c6f0,
N    0x3ab4622d, 0x3fc7d258, 0x3ac0e83d, 0x3fc8db4a,
N    0x3acd6e81, 0x3fc9e1c6, 0x3ad9f4f8, 0x3fcae5cd,
N    0x3ae67ba2, 0x3fcbe75e, 0x3af3027e, 0x3fcce67a,
N    0x3aff898c, 0x3fcde320, 0x3b0c10cb, 0x3fcedd50,
N    0x3b18983b, 0x3fcfd50b, 0x3b251fdc, 0x3fd0ca4f,
N    0x3b31a7ac, 0x3fd1bd1e, 0x3b3e2fac, 0x3fd2ad77,
N    0x3b4ab7db, 0x3fd39b5a, 0x3b574039, 0x3fd486c7,
N    0x3b63c8c4, 0x3fd56fbe, 0x3b70517d, 0x3fd6563f,
N    0x3b7cda63, 0x3fd73a4a, 0x3b896375, 0x3fd81bdf,
N    0x3b95ecb4, 0x3fd8fafe, 0x3ba2761e, 0x3fd9d7a7,
N    0x3baeffb3, 0x3fdab1d9, 0x3bbb8973, 0x3fdb8996,
N    0x3bc8135c, 0x3fdc5edc, 0x3bd49d70, 0x3fdd31ac,
N    0x3be127ac, 0x3fde0205, 0x3bedb212, 0x3fdecfe8,
N    0x3bfa3c9f, 0x3fdf9b55, 0x3c06c754, 0x3fe0644b,
N    0x3c135231, 0x3fe12acb, 0x3c1fdd34, 0x3fe1eed5,
N    0x3c2c685d, 0x3fe2b067, 0x3c38f3ac, 0x3fe36f84,
N    0x3c457f21, 0x3fe42c2a, 0x3c520aba, 0x3fe4e659,
N    0x3c5e9678, 0x3fe59e12, 0x3c6b2259, 0x3fe65354,
N    0x3c77ae5e, 0x3fe7061f, 0x3c843a85, 0x3fe7b674,
N    0x3c90c6cf, 0x3fe86452, 0x3c9d533b, 0x3fe90fb9,
N    0x3ca9dfc8, 0x3fe9b8a9, 0x3cb66c77, 0x3fea5f23,
N    0x3cc2f945, 0x3feb0326, 0x3ccf8634, 0x3feba4b2,
N    0x3cdc1342, 0x3fec43c7, 0x3ce8a06f, 0x3fece065,
N    0x3cf52dbb, 0x3fed7a8c, 0x3d01bb24, 0x3fee123d,
N    0x3d0e48ab, 0x3feea776, 0x3d1ad650, 0x3fef3a39,
N    0x3d276410, 0x3fefca84, 0x3d33f1ed, 0x3ff05858,
N    0x3d407fe6, 0x3ff0e3b6, 0x3d4d0df9, 0x3ff16c9c,
N    0x3d599c28, 0x3ff1f30b, 0x3d662a70, 0x3ff27703,
N    0x3d72b8d2, 0x3ff2f884, 0x3d7f474d, 0x3ff3778e,
N    0x3d8bd5e1, 0x3ff3f420, 0x3d98648d, 0x3ff46e3c,
N    0x3da4f351, 0x3ff4e5e0, 0x3db1822c, 0x3ff55b0d,
N    0x3dbe111e, 0x3ff5cdc3, 0x3dcaa027, 0x3ff63e01,
N    0x3dd72f45, 0x3ff6abc8, 0x3de3be78, 0x3ff71718,
N    0x3df04dc0, 0x3ff77ff1, 0x3dfcdd1d, 0x3ff7e652,
N    0x3e096c8d, 0x3ff84a3c, 0x3e15fc11, 0x3ff8abae,
N    0x3e228ba7, 0x3ff90aaa, 0x3e2f1b50, 0x3ff9672d,
N    0x3e3bab0b, 0x3ff9c13a, 0x3e483ad8, 0x3ffa18cf,
N    0x3e54cab5, 0x3ffa6dec, 0x3e615aa3, 0x3ffac092,
N    0x3e6deaa1, 0x3ffb10c1, 0x3e7a7aae, 0x3ffb5e78,
N    0x3e870aca, 0x3ffba9b8, 0x3e939af5, 0x3ffbf280,
N    0x3ea02b2e, 0x3ffc38d1, 0x3eacbb74, 0x3ffc7caa,
N    0x3eb94bc8, 0x3ffcbe0c, 0x3ec5dc28, 0x3ffcfcf6,
N    0x3ed26c94, 0x3ffd3969, 0x3edefd0c, 0x3ffd7364,
N    0x3eeb8d8f, 0x3ffdaae7, 0x3ef81e1d, 0x3ffddff3,
N    0x3f04aeb5, 0x3ffe1288, 0x3f113f56, 0x3ffe42a4,
N    0x3f1dd001, 0x3ffe704a, 0x3f2a60b4, 0x3ffe9b77,
N    0x3f36f170, 0x3ffec42d, 0x3f438234, 0x3ffeea6c,
N    0x3f5012fe, 0x3fff0e32, 0x3f5ca3d0, 0x3fff2f82,
N    0x3f6934a8, 0x3fff4e59, 0x3f75c585, 0x3fff6ab9,
N    0x3f825668, 0x3fff84a1, 0x3f8ee750, 0x3fff9c12,
N    0x3f9b783c, 0x3fffb10b, 0x3fa8092c, 0x3fffc38c,
N    0x3fb49a1f, 0x3fffd396, 0x3fc12b16, 0x3fffe128,
N    0x3fcdbc0f, 0x3fffec43, 0x3fda4d09, 0x3ffff4e6,
N    0x3fe6de05, 0x3ffffb11, 0x3ff36f02, 0x3ffffec4,
N};
N
N
N/**    
N* \par   
N* Generation of realCoefBQ31 array:    
N* \par    
N*  n = 4096        
N* <pre>for (i = 0; i < n; i++)    
N* {    
N*    pBTable[2 * i] = 0.5 * (1.0 + sin (2 * PI / (double) (2 * n) * (double) i));    
N*    pBTable[2 * i + 1] = 0.5 * (1.0 * cos (2 * PI / (double) (2 * n) * (double) i));    
N* } </pre>    
N* \par    
N* Convert to fixed point Q31 format    
N*     round(pBTable[i] * pow(2, 31))    
N*    
N*/
N
Nstatic const q31_t realCoefBQ31[8192] = {
N    0x40000000, 0x40000000, 0x400c90fe, 0x3ffffec4,
N    0x401921fb, 0x3ffffb11, 0x4025b2f7, 0x3ffff4e6,
N    0x403243f1, 0x3fffec43, 0x403ed4ea, 0x3fffe128,
N    0x404b65e1, 0x3fffd396, 0x4057f6d4, 0x3fffc38c,
N    0x406487c4, 0x3fffb10b, 0x407118b0, 0x3fff9c12,
N    0x407da998, 0x3fff84a1, 0x408a3a7b, 0x3fff6ab9,
N    0x4096cb58, 0x3fff4e59, 0x40a35c30, 0x3fff2f82,
N    0x40afed02, 0x3fff0e32, 0x40bc7dcc, 0x3ffeea6c,
N    0x40c90e90, 0x3ffec42d, 0x40d59f4c, 0x3ffe9b77,
N    0x40e22fff, 0x3ffe704a, 0x40eec0aa, 0x3ffe42a4,
N    0x40fb514b, 0x3ffe1288, 0x4107e1e3, 0x3ffddff3,
N    0x41147271, 0x3ffdaae7, 0x412102f4, 0x3ffd7364,
N    0x412d936c, 0x3ffd3969, 0x413a23d8, 0x3ffcfcf6,
N    0x4146b438, 0x3ffcbe0c, 0x4153448c, 0x3ffc7caa,
N    0x415fd4d2, 0x3ffc38d1, 0x416c650b, 0x3ffbf280,
N    0x4178f536, 0x3ffba9b8, 0x41858552, 0x3ffb5e78,
N    0x4192155f, 0x3ffb10c1, 0x419ea55d, 0x3ffac092,
N    0x41ab354b, 0x3ffa6dec, 0x41b7c528, 0x3ffa18cf,
N    0x41c454f5, 0x3ff9c13a, 0x41d0e4b0, 0x3ff9672d,
N    0x41dd7459, 0x3ff90aaa, 0x41ea03ef, 0x3ff8abae,
N    0x41f69373, 0x3ff84a3c, 0x420322e3, 0x3ff7e652,
N    0x420fb240, 0x3ff77ff1, 0x421c4188, 0x3ff71718,
N    0x4228d0bb, 0x3ff6abc8, 0x42355fd9, 0x3ff63e01,
N    0x4241eee2, 0x3ff5cdc3, 0x424e7dd4, 0x3ff55b0d,
N    0x425b0caf, 0x3ff4e5e0, 0x42679b73, 0x3ff46e3c,
N    0x42742a1f, 0x3ff3f420, 0x4280b8b3, 0x3ff3778e,
N    0x428d472e, 0x3ff2f884, 0x4299d590, 0x3ff27703,
N    0x42a663d8, 0x3ff1f30b, 0x42b2f207, 0x3ff16c9c,
N    0x42bf801a, 0x3ff0e3b6, 0x42cc0e13, 0x3ff05858,
N    0x42d89bf0, 0x3fefca84, 0x42e529b0, 0x3fef3a39,
N    0x42f1b755, 0x3feea776, 0x42fe44dc, 0x3fee123d,
N    0x430ad245, 0x3fed7a8c, 0x43175f91, 0x3fece065,
N    0x4323ecbe, 0x3fec43c7, 0x433079cc, 0x3feba4b2,
N    0x433d06bb, 0x3feb0326, 0x43499389, 0x3fea5f23,
N    0x43562038, 0x3fe9b8a9, 0x4362acc5, 0x3fe90fb9,
N    0x436f3931, 0x3fe86452, 0x437bc57b, 0x3fe7b674,
N    0x438851a2, 0x3fe7061f, 0x4394dda7, 0x3fe65354,
N    0x43a16988, 0x3fe59e12, 0x43adf546, 0x3fe4e659,
N    0x43ba80df, 0x3fe42c2a, 0x43c70c54, 0x3fe36f84,
N    0x43d397a3, 0x3fe2b067, 0x43e022cc, 0x3fe1eed5,
N    0x43ecadcf, 0x3fe12acb, 0x43f938ac, 0x3fe0644b,
N    0x4405c361, 0x3fdf9b55, 0x44124dee, 0x3fdecfe8,
N    0x441ed854, 0x3fde0205, 0x442b6290, 0x3fdd31ac,
N    0x4437eca4, 0x3fdc5edc, 0x4444768d, 0x3fdb8996,
N    0x4451004d, 0x3fdab1d9, 0x445d89e2, 0x3fd9d7a7,
N    0x446a134c, 0x3fd8fafe, 0x44769c8b, 0x3fd81bdf,
N    0x4483259d, 0x3fd73a4a, 0x448fae83, 0x3fd6563f,
N    0x449c373c, 0x3fd56fbe, 0x44a8bfc7, 0x3fd486c7,
N    0x44b54825, 0x3fd39b5a, 0x44c1d054, 0x3fd2ad77,
N    0x44ce5854, 0x3fd1bd1e, 0x44dae024, 0x3fd0ca4f,
N    0x44e767c5, 0x3fcfd50b, 0x44f3ef35, 0x3fcedd50,
N    0x45007674, 0x3fcde320, 0x450cfd82, 0x3fcce67a,
N    0x4519845e, 0x3fcbe75e, 0x45260b08, 0x3fcae5cd,
N    0x4532917f, 0x3fc9e1c6, 0x453f17c3, 0x3fc8db4a,
N    0x454b9dd3, 0x3fc7d258, 0x455823ae, 0x3fc6c6f0,
N    0x4564a955, 0x3fc5b913, 0x45712ec7, 0x3fc4a8c1,
N    0x457db403, 0x3fc395f9, 0x458a3908, 0x3fc280bc,
N    0x4596bdd7, 0x3fc1690a, 0x45a3426f, 0x3fc04ee3,
N    0x45afc6d0, 0x3fbf3246, 0x45bc4af8, 0x3fbe1334,
N    0x45c8cee7, 0x3fbcf1ad, 0x45d5529e, 0x3fbbcdb1,
N    0x45e1d61b, 0x3fbaa740, 0x45ee595d, 0x3fb97e5a,
N    0x45fadc66, 0x3fb852ff, 0x46075f33, 0x3fb7252f,
N    0x4613e1c5, 0x3fb5f4ea, 0x4620641a, 0x3fb4c231,
N    0x462ce634, 0x3fb38d02, 0x46396810, 0x3fb2555f,
N    0x4645e9af, 0x3fb11b48, 0x46526b10, 0x3fafdebb,
N    0x465eec33, 0x3fae9fbb, 0x466b6d16, 0x3fad5e45,
N    0x4677edbb, 0x3fac1a5b, 0x46846e1f, 0x3faad3fd,
N    0x4690ee44, 0x3fa98b2a, 0x469d6e27, 0x3fa83fe3,
N    0x46a9edc9, 0x3fa6f228, 0x46b66d29, 0x3fa5a1f9,
N    0x46c2ec48, 0x3fa44f55, 0x46cf6b23, 0x3fa2fa3d,
N    0x46dbe9bb, 0x3fa1a2b2, 0x46e86810, 0x3fa048b2,
N    0x46f4e620, 0x3f9eec3e, 0x470163eb, 0x3f9d8d56,
N    0x470de172, 0x3f9c2bfb, 0x471a5eb3, 0x3f9ac82c,
N    0x4726dbae, 0x3f9961e8, 0x47335862, 0x3f97f932,
N    0x473fd4cf, 0x3f968e07, 0x474c50f4, 0x3f952069,
N    0x4758ccd2, 0x3f93b058, 0x47654867, 0x3f923dd2,
N    0x4771c3b3, 0x3f90c8da, 0x477e3eb5, 0x3f8f516e,
N    0x478ab96e, 0x3f8dd78f, 0x479733dc, 0x3f8c5b3d,
N    0x47a3adff, 0x3f8adc77, 0x47b027d7, 0x3f895b3e,
N    0x47bca163, 0x3f87d792, 0x47c91aa3, 0x3f865174,
N    0x47d59396, 0x3f84c8e2, 0x47e20c3b, 0x3f833ddd,
N    0x47ee8493, 0x3f81b065, 0x47fafc9c, 0x3f80207b,
N    0x48077457, 0x3f7e8e1e, 0x4813ebc2, 0x3f7cf94e,
N    0x482062de, 0x3f7b620c, 0x482cd9a9, 0x3f79c857,
N    0x48395024, 0x3f782c30, 0x4845c64d, 0x3f768d96,
N    0x48523c25, 0x3f74ec8a, 0x485eb1ab, 0x3f73490b,
N    0x486b26de, 0x3f71a31b, 0x48779bbe, 0x3f6ffab8,
N    0x4884104b, 0x3f6e4fe3, 0x48908483, 0x3f6ca29c,
N    0x489cf867, 0x3f6af2e3, 0x48a96bf6, 0x3f6940b8,
N    0x48b5df30, 0x3f678c1c, 0x48c25213, 0x3f65d50d,
N    0x48cec4a0, 0x3f641b8d, 0x48db36d6, 0x3f625f9b,
N    0x48e7a8b5, 0x3f60a138, 0x48f41a3c, 0x3f5ee063,
N    0x49008b6a, 0x3f5d1d1d, 0x490cfc40, 0x3f5b5765,
N    0x49196cbc, 0x3f598f3c, 0x4925dcdf, 0x3f57c4a2,
N    0x49324ca7, 0x3f55f796, 0x493ebc14, 0x3f54281a,
N    0x494b2b27, 0x3f52562c, 0x495799dd, 0x3f5081cd,
N    0x49640837, 0x3f4eaafe, 0x49707635, 0x3f4cd1be,
N    0x497ce3d5, 0x3f4af60d, 0x49895118, 0x3f4917eb,
N    0x4995bdfd, 0x3f473759, 0x49a22a83, 0x3f455456,
N    0x49ae96aa, 0x3f436ee3, 0x49bb0271, 0x3f4186ff,
N    0x49c76dd8, 0x3f3f9cab, 0x49d3d8df, 0x3f3dafe7,
N    0x49e04385, 0x3f3bc0b3, 0x49ecadc9, 0x3f39cf0e,
N    0x49f917ac, 0x3f37dafa, 0x4a05812c, 0x3f35e476,
N    0x4a11ea49, 0x3f33eb81, 0x4a1e5303, 0x3f31f01d,
N    0x4a2abb59, 0x3f2ff24a, 0x4a37234a, 0x3f2df206,
N    0x4a438ad7, 0x3f2bef53, 0x4a4ff1fe, 0x3f29ea31,
N    0x4a5c58c0, 0x3f27e29f, 0x4a68bf1b, 0x3f25d89e,
N    0x4a752510, 0x3f23cc2e, 0x4a818a9d, 0x3f21bd4e,
N    0x4a8defc3, 0x3f1fabff, 0x4a9a5480, 0x3f1d9842,
N    0x4aa6b8d5, 0x3f1b8215, 0x4ab31cc1, 0x3f19697a,
N    0x4abf8043, 0x3f174e70, 0x4acbe35b, 0x3f1530f7,
N    0x4ad84609, 0x3f13110f, 0x4ae4a84b, 0x3f10eeb9,
N    0x4af10a22, 0x3f0ec9f5, 0x4afd6b8d, 0x3f0ca2c2,
N    0x4b09cc8c, 0x3f0a7921, 0x4b162d1d, 0x3f084d12,
N    0x4b228d42, 0x3f061e95, 0x4b2eecf8, 0x3f03eda9,
N    0x4b3b4c40, 0x3f01ba50, 0x4b47ab19, 0x3eff8489,
N    0x4b540982, 0x3efd4c54, 0x4b60677c, 0x3efb11b1,
N    0x4b6cc506, 0x3ef8d4a1, 0x4b79221f, 0x3ef69523,
N    0x4b857ec7, 0x3ef45338, 0x4b91dafc, 0x3ef20ee0,
N    0x4b9e36c0, 0x3eefc81a, 0x4baa9211, 0x3eed7ee7,
N    0x4bb6ecef, 0x3eeb3347, 0x4bc34759, 0x3ee8e53a,
N    0x4bcfa150, 0x3ee694c1, 0x4bdbfad1, 0x3ee441da,
N    0x4be853de, 0x3ee1ec87, 0x4bf4ac75, 0x3edf94c7,
N    0x4c010496, 0x3edd3a9a, 0x4c0d5c41, 0x3edade01,
N    0x4c19b374, 0x3ed87efc, 0x4c260a31, 0x3ed61d8a,
N    0x4c326075, 0x3ed3b9ad, 0x4c3eb641, 0x3ed15363,
N    0x4c4b0b94, 0x3eceeaad, 0x4c57606e, 0x3ecc7f8b,
N    0x4c63b4ce, 0x3eca11fe, 0x4c7008b3, 0x3ec7a205,
N    0x4c7c5c1e, 0x3ec52fa0, 0x4c88af0e, 0x3ec2bad0,
N    0x4c950182, 0x3ec04394, 0x4ca1537a, 0x3ebdc9ed,
N    0x4cada4f5, 0x3ebb4ddb, 0x4cb9f5f3, 0x3eb8cf5d,
N    0x4cc64673, 0x3eb64e75, 0x4cd29676, 0x3eb3cb21,
N    0x4cdee5f9, 0x3eb14563, 0x4ceb34fe, 0x3eaebd3a,
N    0x4cf78383, 0x3eac32a6, 0x4d03d189, 0x3ea9a5a8,
N    0x4d101f0e, 0x3ea7163f, 0x4d1c6c11, 0x3ea4846c,
N    0x4d28b894, 0x3ea1f02f, 0x4d350495, 0x3e9f5988,
N    0x4d415013, 0x3e9cc076, 0x4d4d9b0e, 0x3e9a24fb,
N    0x4d59e586, 0x3e978715, 0x4d662f7b, 0x3e94e6c6,
N    0x4d7278eb, 0x3e92440d, 0x4d7ec1d6, 0x3e8f9eeb,
N    0x4d8b0a3d, 0x3e8cf75f, 0x4d97521d, 0x3e8a4d6a,
N    0x4da39978, 0x3e87a10c, 0x4dafe04b, 0x3e84f245,
N    0x4dbc2698, 0x3e824114, 0x4dc86c5d, 0x3e7f8d7b,
N    0x4dd4b19a, 0x3e7cd778, 0x4de0f64f, 0x3e7a1f0d,
N    0x4ded3a7b, 0x3e77643a, 0x4df97e1d, 0x3e74a6fd,
N    0x4e05c135, 0x3e71e759, 0x4e1203c3, 0x3e6f254c,
N    0x4e1e45c6, 0x3e6c60d7, 0x4e2a873e, 0x3e6999fa,
N    0x4e36c82a, 0x3e66d0b4, 0x4e430889, 0x3e640507,
N    0x4e4f485c, 0x3e6136f3, 0x4e5b87a2, 0x3e5e6676,
N    0x4e67c65a, 0x3e5b9392, 0x4e740483, 0x3e58be47,
N    0x4e80421e, 0x3e55e694, 0x4e8c7f2a, 0x3e530c7a,
N    0x4e98bba7, 0x3e502ff9, 0x4ea4f793, 0x3e4d5110,
N    0x4eb132ef, 0x3e4a6fc1, 0x4ebd6db9, 0x3e478c0b,
N    0x4ec9a7f3, 0x3e44a5ef, 0x4ed5e19a, 0x3e41bd6c,
N    0x4ee21aaf, 0x3e3ed282, 0x4eee5331, 0x3e3be532,
N    0x4efa8b20, 0x3e38f57c, 0x4f06c27a, 0x3e360360,
N    0x4f12f941, 0x3e330ede, 0x4f1f2f73, 0x3e3017f6,
N    0x4f2b650f, 0x3e2d1ea8, 0x4f379a16, 0x3e2a22f4,
N    0x4f43ce86, 0x3e2724db, 0x4f500260, 0x3e24245d,
N    0x4f5c35a3, 0x3e212179, 0x4f68684e, 0x3e1e1c30,
N    0x4f749a61, 0x3e1b1482, 0x4f80cbdc, 0x3e180a6f,
N    0x4f8cfcbe, 0x3e14fdf7, 0x4f992d06, 0x3e11ef1b,
N    0x4fa55cb4, 0x3e0eddd9, 0x4fb18bc8, 0x3e0bca34,
N    0x4fbdba40, 0x3e08b42a, 0x4fc9e81e, 0x3e059bbb,
N    0x4fd6155f, 0x3e0280e9, 0x4fe24205, 0x3dff63b2,
N    0x4fee6e0d, 0x3dfc4418, 0x4ffa9979, 0x3df9221a,
N    0x5006c446, 0x3df5fdb8, 0x5012ee76, 0x3df2d6f3,
N    0x501f1807, 0x3defadca, 0x502b40f8, 0x3dec823e,
N    0x5037694b, 0x3de9544f, 0x504390fd, 0x3de623fd,
N    0x504fb80e, 0x3de2f148, 0x505bde7f, 0x3ddfbc30,
N    0x5068044e, 0x3ddc84b5, 0x5074297b, 0x3dd94ad8,
N    0x50804e06, 0x3dd60e99, 0x508c71ee, 0x3dd2cff7,
N    0x50989532, 0x3dcf8ef3, 0x50a4b7d3, 0x3dcc4b8d,
N    0x50b0d9d0, 0x3dc905c5, 0x50bcfb28, 0x3dc5bd9b,
N    0x50c91bda, 0x3dc2730f, 0x50d53be7, 0x3dbf2622,
N    0x50e15b4e, 0x3dbbd6d4, 0x50ed7a0e, 0x3db88524,
N    0x50f99827, 0x3db53113, 0x5105b599, 0x3db1daa2,
N    0x5111d263, 0x3dae81cf, 0x511dee84, 0x3dab269b,
N    0x512a09fc, 0x3da7c907, 0x513624cb, 0x3da46912,
N    0x51423ef0, 0x3da106bd, 0x514e586a, 0x3d9da208,
N    0x515a713a, 0x3d9a3af2, 0x5166895f, 0x3d96d17d,
N    0x5172a0d7, 0x3d9365a8, 0x517eb7a4, 0x3d8ff772,
N    0x518acdc4, 0x3d8c86de, 0x5196e337, 0x3d8913ea,
N    0x51a2f7fc, 0x3d859e96, 0x51af0c13, 0x3d8226e4,
N    0x51bb1f7c, 0x3d7eacd2, 0x51c73235, 0x3d7b3061,
N    0x51d3443f, 0x3d77b192, 0x51df5599, 0x3d743064,
N    0x51eb6643, 0x3d70acd7, 0x51f7763c, 0x3d6d26ec,
N    0x52038584, 0x3d699ea3, 0x520f941a, 0x3d6613fb,
N    0x521ba1fd, 0x3d6286f6, 0x5227af2e, 0x3d5ef793,
N    0x5233bbac, 0x3d5b65d2, 0x523fc776, 0x3d57d1b3,
N    0x524bd28c, 0x3d543b37, 0x5257dced, 0x3d50a25e,
N    0x5263e699, 0x3d4d0728, 0x526fef90, 0x3d496994,
N    0x527bf7d1, 0x3d45c9a4, 0x5287ff5b, 0x3d422757,
N    0x5294062f, 0x3d3e82ae, 0x52a00c4b, 0x3d3adba7,
N    0x52ac11af, 0x3d373245, 0x52b8165b, 0x3d338687,
N    0x52c41a4f, 0x3d2fd86c, 0x52d01d89, 0x3d2c27f6,
N    0x52dc2009, 0x3d287523, 0x52e821cf, 0x3d24bff6,
N    0x52f422db, 0x3d21086c, 0x5300232c, 0x3d1d4e88,
N    0x530c22c1, 0x3d199248, 0x5318219a, 0x3d15d3ad,
N    0x53241fb6, 0x3d1212b7, 0x53301d16, 0x3d0e4f67,
N    0x533c19b8, 0x3d0a89bc, 0x5348159d, 0x3d06c1b6,
N    0x535410c3, 0x3d02f757, 0x53600b2a, 0x3cff2a9d,
N    0x536c04d2, 0x3cfb5b89, 0x5377fdbb, 0x3cf78a1b,
N    0x5383f5e3, 0x3cf3b653, 0x538fed4b, 0x3cefe032,
N    0x539be3f2, 0x3cec07b8, 0x53a7d9d7, 0x3ce82ce4,
N    0x53b3cefa, 0x3ce44fb7, 0x53bfc35b, 0x3ce07031,
N    0x53cbb6f8, 0x3cdc8e52, 0x53d7a9d3, 0x3cd8aa1b,
N    0x53e39be9, 0x3cd4c38b, 0x53ef8d3c, 0x3cd0daa2,
N    0x53fb7dc9, 0x3cccef62, 0x54076d91, 0x3cc901c9,
N    0x54135c94, 0x3cc511d9, 0x541f4ad1, 0x3cc11f90,
N    0x542b3846, 0x3cbd2af0, 0x543724f5, 0x3cb933f9,
N    0x544310dd, 0x3cb53aaa, 0x544efbfc, 0x3cb13f04,
N    0x545ae653, 0x3cad4107, 0x5466cfe1, 0x3ca940b3,
N    0x5472b8a5, 0x3ca53e09, 0x547ea0a0, 0x3ca13908,
N    0x548a87d1, 0x3c9d31b0, 0x54966e36, 0x3c992803,
N    0x54a253d1, 0x3c951bff, 0x54ae38a0, 0x3c910da5,
N    0x54ba1ca3, 0x3c8cfcf6, 0x54c5ffd9, 0x3c88e9f1,
N    0x54d1e242, 0x3c84d496, 0x54ddc3de, 0x3c80bce7,
N    0x54e9a4ac, 0x3c7ca2e2, 0x54f584ac, 0x3c788688,
N    0x550163dc, 0x3c7467d9, 0x550d423d, 0x3c7046d6,
N    0x55191fcf, 0x3c6c237e, 0x5524fc90, 0x3c67fdd1,
N    0x5530d881, 0x3c63d5d1, 0x553cb3a0, 0x3c5fab7c,
N    0x55488dee, 0x3c5b7ed4, 0x5554676a, 0x3c574fd8,
N    0x55604013, 0x3c531e88, 0x556c17e9, 0x3c4eeae5,
N    0x5577eeec, 0x3c4ab4ef, 0x5583c51b, 0x3c467ca6,
N    0x558f9a76, 0x3c42420a, 0x559b6efb, 0x3c3e051b,
N    0x55a742ac, 0x3c39c5da, 0x55b31587, 0x3c358446,
N    0x55bee78c, 0x3c314060, 0x55cab8ba, 0x3c2cfa28,
N    0x55d68911, 0x3c28b19e, 0x55e25890, 0x3c2466c2,
N    0x55ee2738, 0x3c201994, 0x55f9f507, 0x3c1bca16,
N    0x5605c1fd, 0x3c177845, 0x56118e1a, 0x3c132424,
N    0x561d595d, 0x3c0ecdb2, 0x562923c5, 0x3c0a74f0,
N    0x5634ed53, 0x3c0619dc, 0x5640b606, 0x3c01bc78,
N    0x564c7ddd, 0x3bfd5cc4, 0x565844d8, 0x3bf8fac0,
N    0x56640af7, 0x3bf4966c, 0x566fd039, 0x3bf02fc9,
N    0x567b949d, 0x3bebc6d5, 0x56875823, 0x3be75b93,
N    0x56931acb, 0x3be2ee01, 0x569edc94, 0x3bde7e20,
N    0x56aa9d7e, 0x3bda0bf0, 0x56b65d88, 0x3bd59771,
N    0x56c21cb2, 0x3bd120a4, 0x56cddafb, 0x3bcca789,
N    0x56d99864, 0x3bc82c1f, 0x56e554ea, 0x3bc3ae67,
N    0x56f1108f, 0x3bbf2e62, 0x56fccb51, 0x3bbaac0e,
N    0x57088531, 0x3bb6276e, 0x57143e2d, 0x3bb1a080,
N    0x571ff646, 0x3bad1744, 0x572bad7a, 0x3ba88bbc,
N    0x573763c9, 0x3ba3fde7, 0x57431933, 0x3b9f6dc5,
N    0x574ecdb8, 0x3b9adb57, 0x575a8157, 0x3b96469d,
N    0x5766340f, 0x3b91af97, 0x5771e5e0, 0x3b8d1644,
N    0x577d96ca, 0x3b887aa6, 0x578946cc, 0x3b83dcbc,
N    0x5794f5e6, 0x3b7f3c87, 0x57a0a417, 0x3b7a9a07,
N    0x57ac515f, 0x3b75f53c, 0x57b7fdbd, 0x3b714e25,
N    0x57c3a931, 0x3b6ca4c4, 0x57cf53bb, 0x3b67f919,
N    0x57dafd59, 0x3b634b23, 0x57e6a60c, 0x3b5e9ae4,
N    0x57f24dd3, 0x3b59e85a, 0x57fdf4ae, 0x3b553386,
N    0x58099a9c, 0x3b507c69, 0x58153f9d, 0x3b4bc303,
N    0x5820e3b0, 0x3b470753, 0x582c86d5, 0x3b42495a,
N    0x5838290c, 0x3b3d8918, 0x5843ca53, 0x3b38c68e,
N    0x584f6aab, 0x3b3401bb, 0x585b0a13, 0x3b2f3aa0,
N    0x5866a88a, 0x3b2a713d, 0x58724611, 0x3b25a591,
N    0x587de2a7, 0x3b20d79e, 0x58897e4a, 0x3b1c0764,
N    0x589518fc, 0x3b1734e2, 0x58a0b2bb, 0x3b126019,
N    0x58ac4b87, 0x3b0d8909, 0x58b7e35f, 0x3b08afb2,
N    0x58c37a44, 0x3b03d414, 0x58cf1034, 0x3afef630,
N    0x58daa52f, 0x3afa1605, 0x58e63935, 0x3af53395,
N    0x58f1cc45, 0x3af04edf, 0x58fd5e5f, 0x3aeb67e3,
N    0x5908ef82, 0x3ae67ea1, 0x59147fae, 0x3ae1931a,
N    0x59200ee3, 0x3adca54e, 0x592b9d1f, 0x3ad7b53d,
N    0x59372a64, 0x3ad2c2e8, 0x5942b6af, 0x3acdce4d,
N    0x594e4201, 0x3ac8d76f, 0x5959cc5a, 0x3ac3de4c,
N    0x596555b8, 0x3abee2e5, 0x5970de1b, 0x3ab9e53a,
N    0x597c6584, 0x3ab4e54c, 0x5987ebf0, 0x3aafe31b,
N    0x59937161, 0x3aaadea6, 0x599ef5d6, 0x3aa5d7ee,
N    0x59aa794d, 0x3aa0cef3, 0x59b5fbc8, 0x3a9bc3b6,
N    0x59c17d44, 0x3a96b636, 0x59ccfdc2, 0x3a91a674,
N    0x59d87d42, 0x3a8c9470, 0x59e3fbc3, 0x3a87802a,
N    0x59ef7944, 0x3a8269a3, 0x59faf5c5, 0x3a7d50da,
N    0x5a067145, 0x3a7835cf, 0x5a11ebc5, 0x3a731884,
N    0x5a1d6544, 0x3a6df8f8, 0x5a28ddc0, 0x3a68d72b,
N    0x5a34553b, 0x3a63b31d, 0x5a3fcbb3, 0x3a5e8cd0,
N    0x5a4b4128, 0x3a596442, 0x5a56b599, 0x3a543974,
N    0x5a622907, 0x3a4f0c67, 0x5a6d9b70, 0x3a49dd1a,
N    0x5a790cd4, 0x3a44ab8e, 0x5a847d33, 0x3a3f77c3,
N    0x5a8fec8c, 0x3a3a41b9, 0x5a9b5adf, 0x3a350970,
N    0x5aa6c82b, 0x3a2fcee8, 0x5ab23471, 0x3a2a9223,
N    0x5abd9faf, 0x3a25531f, 0x5ac909e5, 0x3a2011de,
N    0x5ad47312, 0x3a1ace5f, 0x5adfdb37, 0x3a1588a2,
N    0x5aeb4253, 0x3a1040a8, 0x5af6a865, 0x3a0af671,
N    0x5b020d6c, 0x3a05a9fd, 0x5b0d716a, 0x3a005b4d,
N    0x5b18d45c, 0x39fb0a60, 0x5b243643, 0x39f5b737,
N    0x5b2f971e, 0x39f061d2, 0x5b3af6ec, 0x39eb0a31,
N    0x5b4655ae, 0x39e5b054, 0x5b51b363, 0x39e0543c,
N    0x5b5d100a, 0x39daf5e8, 0x5b686ba3, 0x39d5955a,
N    0x5b73c62d, 0x39d03291, 0x5b7f1fa9, 0x39cacd8d,
N    0x5b8a7815, 0x39c5664f, 0x5b95cf71, 0x39bffcd7,
N    0x5ba125bd, 0x39ba9125, 0x5bac7af9, 0x39b52339,
N    0x5bb7cf23, 0x39afb313, 0x5bc3223c, 0x39aa40b4,
N    0x5bce7442, 0x39a4cc1c, 0x5bd9c537, 0x399f554b,
N    0x5be51518, 0x3999dc42, 0x5bf063e6, 0x399460ff,
N    0x5bfbb1a0, 0x398ee385, 0x5c06fe46, 0x398963d2,
N    0x5c1249d8, 0x3983e1e8, 0x5c1d9454, 0x397e5dc6,
N    0x5c28ddbb, 0x3978d76c, 0x5c34260c, 0x39734edc,
N    0x5c3f6d47, 0x396dc414, 0x5c4ab36b, 0x39683715,
N    0x5c55f878, 0x3962a7e0, 0x5c613c6d, 0x395d1675,
N    0x5c6c7f4a, 0x395782d3, 0x5c77c10e, 0x3951ecfc,
N    0x5c8301b9, 0x394c54ee, 0x5c8e414b, 0x3946baac,
N    0x5c997fc4, 0x39411e33, 0x5ca4bd21, 0x393b7f86,
N    0x5caff965, 0x3935dea4, 0x5cbb348d, 0x39303b8e,
N    0x5cc66e99, 0x392a9642, 0x5cd1a78a, 0x3924eec3,
N    0x5cdcdf5e, 0x391f4510, 0x5ce81615, 0x39199929,
N    0x5cf34baf, 0x3913eb0e, 0x5cfe802b, 0x390e3ac0,
N    0x5d09b389, 0x3908883f, 0x5d14e5c9, 0x3902d38b,
N    0x5d2016e9, 0x38fd1ca4, 0x5d2b46ea, 0x38f7638b,
N    0x5d3675cb, 0x38f1a840, 0x5d41a38c, 0x38ebeac2,
N    0x5d4cd02c, 0x38e62b13, 0x5d57fbaa, 0x38e06932,
N    0x5d632608, 0x38daa520, 0x5d6e4f43, 0x38d4dedd,
N    0x5d79775c, 0x38cf1669, 0x5d849e51, 0x38c94bc4,
N    0x5d8fc424, 0x38c37eef, 0x5d9ae8d2, 0x38bdafea,
N    0x5da60c5d, 0x38b7deb4, 0x5db12ec3, 0x38b20b4f,
N    0x5dbc5004, 0x38ac35ba, 0x5dc7701f, 0x38a65df6,
N    0x5dd28f15, 0x38a08402, 0x5dddace4, 0x389aa7e0,
N    0x5de8c98c, 0x3894c98f, 0x5df3e50d, 0x388ee910,
N    0x5dfeff67, 0x38890663, 0x5e0a1898, 0x38832187,
N    0x5e1530a1, 0x387d3a7e, 0x5e204781, 0x38775147,
N    0x5e2b5d38, 0x387165e3, 0x5e3671c5, 0x386b7852,
N    0x5e418528, 0x38658894, 0x5e4c9760, 0x385f96a9,
N    0x5e57a86d, 0x3859a292, 0x5e62b84f, 0x3853ac4f,
N    0x5e6dc705, 0x384db3e0, 0x5e78d48e, 0x3847b946,
N    0x5e83e0eb, 0x3841bc7f, 0x5e8eec1b, 0x383bbd8e,
N    0x5e99f61d, 0x3835bc71, 0x5ea4fef0, 0x382fb92a,
N    0x5eb00696, 0x3829b3b9, 0x5ebb0d0d, 0x3823ac1d,
N    0x5ec61254, 0x381da256, 0x5ed1166b, 0x38179666,
N    0x5edc1953, 0x3811884d, 0x5ee71b0a, 0x380b780a,
N    0x5ef21b90, 0x3805659e, 0x5efd1ae4, 0x37ff5109,
N    0x5f081907, 0x37f93a4b, 0x5f1315f7, 0x37f32165,
N    0x5f1e11b5, 0x37ed0657, 0x5f290c3f, 0x37e6e921,
N    0x5f340596, 0x37e0c9c3, 0x5f3efdb9, 0x37daa83d,
N    0x5f49f4a8, 0x37d48490, 0x5f54ea62, 0x37ce5ebd,
N    0x5f5fdee6, 0x37c836c2, 0x5f6ad235, 0x37c20ca1,
N    0x5f75c44e, 0x37bbe05a, 0x5f80b531, 0x37b5b1ec,
N    0x5f8ba4dc, 0x37af8159, 0x5f969350, 0x37a94ea0,
N    0x5fa1808c, 0x37a319c2, 0x5fac6c91, 0x379ce2be,
N    0x5fb7575c, 0x3796a996, 0x5fc240ef, 0x37906e49,
N    0x5fcd2948, 0x378a30d8, 0x5fd81067, 0x3783f143,
N    0x5fe2f64c, 0x377daf89, 0x5feddaf6, 0x37776bac,
N    0x5ff8be65, 0x377125ac, 0x6003a099, 0x376add88,
N    0x600e8190, 0x37649341, 0x6019614c, 0x375e46d8,
N    0x60243fca, 0x3757f84c, 0x602f1d0b, 0x3751a79e,
N    0x6039f90f, 0x374b54ce, 0x6044d3d4, 0x3744ffdd,
N    0x604fad5b, 0x373ea8ca, 0x605a85a3, 0x37384f95,
N    0x60655cac, 0x3731f440, 0x60703275, 0x372b96ca,
N    0x607b06fe, 0x37253733, 0x6085da46, 0x371ed57c,
N    0x6090ac4d, 0x371871a5, 0x609b7d13, 0x37120bae,
N    0x60a64c97, 0x370ba398, 0x60b11ad9, 0x37053962,
N    0x60bbe7d8, 0x36fecd0e, 0x60c6b395, 0x36f85e9a,
N    0x60d17e0d, 0x36f1ee09, 0x60dc4742, 0x36eb7b58,
N    0x60e70f32, 0x36e5068a, 0x60f1d5de, 0x36de8f9e,
N    0x60fc9b44, 0x36d81695, 0x61075f65, 0x36d19b6e,
N    0x61122240, 0x36cb1e2a, 0x611ce3d5, 0x36c49ec9,
N    0x6127a423, 0x36be1d4c, 0x61326329, 0x36b799b3,
N    0x613d20e8, 0x36b113fd, 0x6147dd5f, 0x36aa8c2c,
N    0x6152988d, 0x36a4023f, 0x615d5273, 0x369d7637,
N    0x61680b0f, 0x3696e814, 0x6172c262, 0x369057d6,
N    0x617d786a, 0x3689c57d, 0x61882d28, 0x3683310b,
N    0x6192e09b, 0x367c9a7e, 0x619d92c2, 0x367601d7,
N    0x61a8439e, 0x366f6717, 0x61b2f32e, 0x3668ca3e,
N    0x61bda171, 0x36622b4c, 0x61c84e67, 0x365b8a41,
N    0x61d2fa0f, 0x3654e71d, 0x61dda46a, 0x364e41e2,
N    0x61e84d76, 0x36479a8e, 0x61f2f534, 0x3640f123,
N    0x61fd9ba3, 0x363a45a0, 0x620840c2, 0x36339806,
N    0x6212e492, 0x362ce855, 0x621d8711, 0x3626368d,
N    0x6228283f, 0x361f82af, 0x6232c81c, 0x3618ccba,
N    0x623d66a8, 0x361214b0, 0x624803e2, 0x360b5a90,
N    0x62529fca, 0x36049e5b, 0x625d3a5e, 0x35fde011,
N    0x6267d3a0, 0x35f71fb1, 0x62726b8e, 0x35f05d3d,
N    0x627d0228, 0x35e998b5, 0x6287976e, 0x35e2d219,
N    0x62922b5e, 0x35dc0968, 0x629cbdfa, 0x35d53ea5,
N    0x62a74f40, 0x35ce71ce, 0x62b1df30, 0x35c7a2e3,
N    0x62bc6dca, 0x35c0d1e7, 0x62c6fb0c, 0x35b9fed7,
N    0x62d186f8, 0x35b329b5, 0x62dc118c, 0x35ac5282,
N    0x62e69ac8, 0x35a5793c, 0x62f122ab, 0x359e9de5,
N    0x62fba936, 0x3597c07d, 0x63062e67, 0x3590e104,
N    0x6310b23e, 0x3589ff7a, 0x631b34bc, 0x35831be0,
N    0x6325b5df, 0x357c3636, 0x633035a7, 0x35754e7c,
N    0x633ab414, 0x356e64b2, 0x63453125, 0x356778d9,
N    0x634facda, 0x35608af1, 0x635a2733, 0x35599afa,
N    0x6364a02e, 0x3552a8f4, 0x636f17cc, 0x354bb4e1,
N    0x63798e0d, 0x3544bebf, 0x638402ef, 0x353dc68f,
N    0x638e7673, 0x3536cc52, 0x6398e898, 0x352fd008,
N    0x63a3595e, 0x3528d1b1, 0x63adc8c4, 0x3521d14d,
N    0x63b836ca, 0x351acedd, 0x63c2a36f, 0x3513ca60,
N    0x63cd0eb3, 0x350cc3d8, 0x63d77896, 0x3505bb44,
N    0x63e1e117, 0x34feb0a5, 0x63ec4837, 0x34f7a3fb,
N    0x63f6adf3, 0x34f09546, 0x6401124d, 0x34e98487,
N    0x640b7543, 0x34e271bd, 0x6415d6d5, 0x34db5cea,
N    0x64203704, 0x34d4460c, 0x642a95ce, 0x34cd2d26,
N    0x6434f332, 0x34c61236, 0x643f4f32, 0x34bef53d,
N    0x6449a9cc, 0x34b7d63c, 0x645402ff, 0x34b0b533,
N    0x645e5acc, 0x34a99221, 0x6468b132, 0x34a26d08,
N    0x64730631, 0x349b45e7, 0x647d59c8, 0x34941cbf,
N    0x6487abf7, 0x348cf190, 0x6491fcbe, 0x3485c45b,
N    0x649c4c1b, 0x347e951f, 0x64a69a0f, 0x347763dd,
N    0x64b0e699, 0x34703095, 0x64bb31ba, 0x3468fb47,
N    0x64c57b6f, 0x3461c3f5, 0x64cfc3ba, 0x345a8a9d,
N    0x64da0a9a, 0x34534f41, 0x64e4500e, 0x344c11e0,
N    0x64ee9415, 0x3444d27b, 0x64f8d6b0, 0x343d9112,
N    0x650317df, 0x34364da6, 0x650d57a0, 0x342f0836,
N    0x651795f3, 0x3427c0c3, 0x6521d2d8, 0x3420774d,
N    0x652c0e4f, 0x34192bd5, 0x65364857, 0x3411de5b,
N    0x654080ef, 0x340a8edf, 0x654ab818, 0x34033d61,
N    0x6554edd1, 0x33fbe9e2, 0x655f2219, 0x33f49462,
N    0x656954f1, 0x33ed3ce1, 0x65738657, 0x33e5e360,
N    0x657db64c, 0x33de87de, 0x6587e4cf, 0x33d72a5d,
N    0x659211df, 0x33cfcadc, 0x659c3d7c, 0x33c8695b,
N    0x65a667a7, 0x33c105db, 0x65b0905d, 0x33b9a05d,
N    0x65bab7a0, 0x33b238e0, 0x65c4dd6e, 0x33aacf65,
N    0x65cf01c8, 0x33a363ec, 0x65d924ac, 0x339bf675,
N    0x65e3461b, 0x33948701, 0x65ed6614, 0x338d1590,
N    0x65f78497, 0x3385a222, 0x6601a1a2, 0x337e2cb7,
N    0x660bbd37, 0x3376b551, 0x6615d754, 0x336f3bee,
N    0x661feffa, 0x3367c090, 0x662a0727, 0x33604336,
N    0x66341cdb, 0x3358c3e2, 0x663e3117, 0x33514292,
N    0x664843d9, 0x3349bf48, 0x66525521, 0x33423a04,
N    0x665c64ef, 0x333ab2c6, 0x66667342, 0x3333298f,
N    0x6670801a, 0x332b9e5e, 0x667a8b77, 0x33241134,
N    0x66849558, 0x331c8211, 0x668e9dbd, 0x3314f0f6,
N    0x6698a4a6, 0x330d5de3, 0x66a2aa11, 0x3305c8d7,
N    0x66acadff, 0x32fe31d5, 0x66b6b070, 0x32f698db,
N    0x66c0b162, 0x32eefdea, 0x66cab0d6, 0x32e76102,
N    0x66d4aecb, 0x32dfc224, 0x66deab41, 0x32d82150,
N    0x66e8a637, 0x32d07e85, 0x66f29fad, 0x32c8d9c6,
N    0x66fc97a3, 0x32c13311, 0x67068e18, 0x32b98a67,
N    0x6710830c, 0x32b1dfc9, 0x671a767e, 0x32aa3336,
N    0x6724686e, 0x32a284b0, 0x672e58dc, 0x329ad435,
N    0x673847c8, 0x329321c7, 0x67423530, 0x328b6d66,
N    0x674c2115, 0x3283b712, 0x67560b76, 0x327bfecc,
N    0x675ff452, 0x32744493, 0x6769dbaa, 0x326c8868,
N    0x6773c17d, 0x3264ca4c, 0x677da5cb, 0x325d0a3e,
N    0x67878893, 0x32554840, 0x679169d5, 0x324d8450,
N    0x679b4990, 0x3245be70, 0x67a527c4, 0x323df6a0,
N    0x67af0472, 0x32362ce0, 0x67b8df97, 0x322e6130,
N    0x67c2b934, 0x32269391, 0x67cc9149, 0x321ec403,
N    0x67d667d5, 0x3216f287, 0x67e03cd8, 0x320f1f1c,
N    0x67ea1052, 0x320749c3, 0x67f3e241, 0x31ff727c,
N    0x67fdb2a7, 0x31f79948, 0x68078181, 0x31efbe27,
N    0x68114ed0, 0x31e7e118, 0x681b1a94, 0x31e0021e,
N    0x6824e4cc, 0x31d82137, 0x682ead78, 0x31d03e64,
N    0x68387498, 0x31c859a5, 0x68423a2a, 0x31c072fb,
N    0x684bfe2f, 0x31b88a66, 0x6855c0a6, 0x31b09fe7,
N    0x685f8190, 0x31a8b37c, 0x686940ea, 0x31a0c528,
N    0x6872feb6, 0x3198d4ea, 0x687cbaf3, 0x3190e2c3,
N    0x688675a0, 0x3188eeb2, 0x68902ebd, 0x3180f8b8,
N    0x6899e64a, 0x317900d6, 0x68a39c46, 0x3171070c,
N    0x68ad50b1, 0x31690b59, 0x68b7038b, 0x31610dbf,
N    0x68c0b4d2, 0x31590e3e, 0x68ca6488, 0x31510cd5,
N    0x68d412ab, 0x31490986, 0x68ddbf3b, 0x31410450,
N    0x68e76a37, 0x3138fd35, 0x68f113a0, 0x3130f433,
N    0x68fabb75, 0x3128e94c, 0x690461b5, 0x3120dc80,
N    0x690e0661, 0x3118cdcf, 0x6917a977, 0x3110bd39,
N    0x69214af8, 0x3108aabf, 0x692aeae3, 0x31009661,
N    0x69348937, 0x30f8801f, 0x693e25f5, 0x30f067fb,
N    0x6947c11c, 0x30e84df3, 0x69515aab, 0x30e03208,
N    0x695af2a3, 0x30d8143b, 0x69648902, 0x30cff48c,
N    0x696e1dc9, 0x30c7d2fb, 0x6977b0f7, 0x30bfaf89,
N    0x6981428c, 0x30b78a36, 0x698ad287, 0x30af6302,
N    0x699460e8, 0x30a739ed, 0x699dedaf, 0x309f0ef8,
N    0x69a778db, 0x3096e223, 0x69b1026c, 0x308eb36f,
N    0x69ba8a61, 0x308682dc, 0x69c410ba, 0x307e5069,
N    0x69cd9578, 0x30761c18, 0x69d71899, 0x306de5e9,
N    0x69e09a1c, 0x3065addb, 0x69ea1a03, 0x305d73f0,
N    0x69f3984c, 0x30553828, 0x69fd14f6, 0x304cfa83,
N    0x6a069003, 0x3044bb00, 0x6a100970, 0x303c79a2,
N    0x6a19813f, 0x30343667, 0x6a22f76e, 0x302bf151,
N    0x6a2c6bfd, 0x3023aa5f, 0x6a35deeb, 0x301b6193,
N    0x6a3f503a, 0x301316eb, 0x6a48bfe7, 0x300aca69,
N    0x6a522df3, 0x30027c0c, 0x6a5b9a5d, 0x2ffa2bd6,
N    0x6a650525, 0x2ff1d9c7, 0x6a6e6e4b, 0x2fe985de,
N    0x6a77d5ce, 0x2fe1301c, 0x6a813bae, 0x2fd8d882,
N    0x6a8a9fea, 0x2fd07f0f, 0x6a940283, 0x2fc823c5,
N    0x6a9d6377, 0x2fbfc6a3, 0x6aa6c2c6, 0x2fb767aa,
N    0x6ab02071, 0x2faf06da, 0x6ab97c77, 0x2fa6a433,
N    0x6ac2d6d6, 0x2f9e3fb6, 0x6acc2f90, 0x2f95d963,
N    0x6ad586a3, 0x2f8d713a, 0x6adedc10, 0x2f85073c,
N    0x6ae82fd5, 0x2f7c9b69, 0x6af181f3, 0x2f742dc1,
N    0x6afad269, 0x2f6bbe45, 0x6b042137, 0x2f634cf5,
N    0x6b0d6e5c, 0x2f5ad9d1, 0x6b16b9d9, 0x2f5264da,
N    0x6b2003ac, 0x2f49ee0f, 0x6b294bd5, 0x2f417573,
N    0x6b329255, 0x2f38fb03, 0x6b3bd72a, 0x2f307ec2,
N    0x6b451a55, 0x2f2800af, 0x6b4e5bd4, 0x2f1f80ca,
N    0x6b579ba8, 0x2f16ff14, 0x6b60d9d0, 0x2f0e7b8e,
N    0x6b6a164d, 0x2f05f637, 0x6b73511c, 0x2efd6f10,
N    0x6b7c8a3f, 0x2ef4e619, 0x6b85c1b5, 0x2eec5b53,
N    0x6b8ef77d, 0x2ee3cebe, 0x6b982b97, 0x2edb405a,
N    0x6ba15e03, 0x2ed2b027, 0x6baa8ec0, 0x2eca1e27,
N    0x6bb3bdce, 0x2ec18a58, 0x6bbceb2d, 0x2eb8f4bc,
N    0x6bc616dd, 0x2eb05d53, 0x6bcf40dc, 0x2ea7c41e,
N    0x6bd8692b, 0x2e9f291b, 0x6be18fc9, 0x2e968c4d,
N    0x6beab4b6, 0x2e8dedb3, 0x6bf3d7f2, 0x2e854d4d,
N    0x6bfcf97c, 0x2e7cab1c, 0x6c061953, 0x2e740720,
N    0x6c0f3779, 0x2e6b615a, 0x6c1853eb, 0x2e62b9ca,
N    0x6c216eaa, 0x2e5a1070, 0x6c2a87b6, 0x2e51654c,
N    0x6c339f0e, 0x2e48b860, 0x6c3cb4b1, 0x2e4009aa,
N    0x6c45c8a0, 0x2e37592c, 0x6c4edada, 0x2e2ea6e6,
N    0x6c57eb5e, 0x2e25f2d8, 0x6c60fa2d, 0x2e1d3d03,
N    0x6c6a0746, 0x2e148566, 0x6c7312a9, 0x2e0bcc03,
N    0x6c7c1c55, 0x2e0310d9, 0x6c85244a, 0x2dfa53e9,
N    0x6c8e2a87, 0x2df19534, 0x6c972f0d, 0x2de8d4b8,
N    0x6ca031da, 0x2de01278, 0x6ca932ef, 0x2dd74e73,
N    0x6cb2324c, 0x2dce88aa, 0x6cbb2fef, 0x2dc5c11c,
N    0x6cc42bd9, 0x2dbcf7cb, 0x6ccd2609, 0x2db42cb6,
N    0x6cd61e7f, 0x2dab5fdf, 0x6cdf153a, 0x2da29144,
N    0x6ce80a3a, 0x2d99c0e7, 0x6cf0fd80, 0x2d90eec8,
N    0x6cf9ef09, 0x2d881ae8, 0x6d02ded7, 0x2d7f4545,
N    0x6d0bcce8, 0x2d766de2, 0x6d14b93d, 0x2d6d94bf,
N    0x6d1da3d5, 0x2d64b9da, 0x6d268cb0, 0x2d5bdd36,
N    0x6d2f73cd, 0x2d52fed2, 0x6d38592c, 0x2d4a1eaf,
N    0x6d413ccd, 0x2d413ccd, 0x6d4a1eaf, 0x2d38592c,
N    0x6d52fed2, 0x2d2f73cd, 0x6d5bdd36, 0x2d268cb0,
N    0x6d64b9da, 0x2d1da3d5, 0x6d6d94bf, 0x2d14b93d,
N    0x6d766de2, 0x2d0bcce8, 0x6d7f4545, 0x2d02ded7,
N    0x6d881ae8, 0x2cf9ef09, 0x6d90eec8, 0x2cf0fd80,
N    0x6d99c0e7, 0x2ce80a3a, 0x6da29144, 0x2cdf153a,
N    0x6dab5fdf, 0x2cd61e7f, 0x6db42cb6, 0x2ccd2609,
N    0x6dbcf7cb, 0x2cc42bd9, 0x6dc5c11c, 0x2cbb2fef,
N    0x6dce88aa, 0x2cb2324c, 0x6dd74e73, 0x2ca932ef,
N    0x6de01278, 0x2ca031da, 0x6de8d4b8, 0x2c972f0d,
N    0x6df19534, 0x2c8e2a87, 0x6dfa53e9, 0x2c85244a,
N    0x6e0310d9, 0x2c7c1c55, 0x6e0bcc03, 0x2c7312a9,
N    0x6e148566, 0x2c6a0746, 0x6e1d3d03, 0x2c60fa2d,
N    0x6e25f2d8, 0x2c57eb5e, 0x6e2ea6e6, 0x2c4edada,
N    0x6e37592c, 0x2c45c8a0, 0x6e4009aa, 0x2c3cb4b1,
N    0x6e48b860, 0x2c339f0e, 0x6e51654c, 0x2c2a87b6,
N    0x6e5a1070, 0x2c216eaa, 0x6e62b9ca, 0x2c1853eb,
N    0x6e6b615a, 0x2c0f3779, 0x6e740720, 0x2c061953,
N    0x6e7cab1c, 0x2bfcf97c, 0x6e854d4d, 0x2bf3d7f2,
N    0x6e8dedb3, 0x2beab4b6, 0x6e968c4d, 0x2be18fc9,
N    0x6e9f291b, 0x2bd8692b, 0x6ea7c41e, 0x2bcf40dc,
N    0x6eb05d53, 0x2bc616dd, 0x6eb8f4bc, 0x2bbceb2d,
N    0x6ec18a58, 0x2bb3bdce, 0x6eca1e27, 0x2baa8ec0,
N    0x6ed2b027, 0x2ba15e03, 0x6edb405a, 0x2b982b97,
N    0x6ee3cebe, 0x2b8ef77d, 0x6eec5b53, 0x2b85c1b5,
N    0x6ef4e619, 0x2b7c8a3f, 0x6efd6f10, 0x2b73511c,
N    0x6f05f637, 0x2b6a164d, 0x6f0e7b8e, 0x2b60d9d0,
N    0x6f16ff14, 0x2b579ba8, 0x6f1f80ca, 0x2b4e5bd4,
N    0x6f2800af, 0x2b451a55, 0x6f307ec2, 0x2b3bd72a,
N    0x6f38fb03, 0x2b329255, 0x6f417573, 0x2b294bd5,
N    0x6f49ee0f, 0x2b2003ac, 0x6f5264da, 0x2b16b9d9,
N    0x6f5ad9d1, 0x2b0d6e5c, 0x6f634cf5, 0x2b042137,
N    0x6f6bbe45, 0x2afad269, 0x6f742dc1, 0x2af181f3,
N    0x6f7c9b69, 0x2ae82fd5, 0x6f85073c, 0x2adedc10,
N    0x6f8d713a, 0x2ad586a3, 0x6f95d963, 0x2acc2f90,
N    0x6f9e3fb6, 0x2ac2d6d6, 0x6fa6a433, 0x2ab97c77,
N    0x6faf06da, 0x2ab02071, 0x6fb767aa, 0x2aa6c2c6,
N    0x6fbfc6a3, 0x2a9d6377, 0x6fc823c5, 0x2a940283,
N    0x6fd07f0f, 0x2a8a9fea, 0x6fd8d882, 0x2a813bae,
N    0x6fe1301c, 0x2a77d5ce, 0x6fe985de, 0x2a6e6e4b,
N    0x6ff1d9c7, 0x2a650525, 0x6ffa2bd6, 0x2a5b9a5d,
N    0x70027c0c, 0x2a522df3, 0x700aca69, 0x2a48bfe7,
N    0x701316eb, 0x2a3f503a, 0x701b6193, 0x2a35deeb,
N    0x7023aa5f, 0x2a2c6bfd, 0x702bf151, 0x2a22f76e,
N    0x70343667, 0x2a19813f, 0x703c79a2, 0x2a100970,
N    0x7044bb00, 0x2a069003, 0x704cfa83, 0x29fd14f6,
N    0x70553828, 0x29f3984c, 0x705d73f0, 0x29ea1a03,
N    0x7065addb, 0x29e09a1c, 0x706de5e9, 0x29d71899,
N    0x70761c18, 0x29cd9578, 0x707e5069, 0x29c410ba,
N    0x708682dc, 0x29ba8a61, 0x708eb36f, 0x29b1026c,
N    0x7096e223, 0x29a778db, 0x709f0ef8, 0x299dedaf,
N    0x70a739ed, 0x299460e8, 0x70af6302, 0x298ad287,
N    0x70b78a36, 0x2981428c, 0x70bfaf89, 0x2977b0f7,
N    0x70c7d2fb, 0x296e1dc9, 0x70cff48c, 0x29648902,
N    0x70d8143b, 0x295af2a3, 0x70e03208, 0x29515aab,
N    0x70e84df3, 0x2947c11c, 0x70f067fb, 0x293e25f5,
N    0x70f8801f, 0x29348937, 0x71009661, 0x292aeae3,
N    0x7108aabf, 0x29214af8, 0x7110bd39, 0x2917a977,
N    0x7118cdcf, 0x290e0661, 0x7120dc80, 0x290461b5,
N    0x7128e94c, 0x28fabb75, 0x7130f433, 0x28f113a0,
N    0x7138fd35, 0x28e76a37, 0x71410450, 0x28ddbf3b,
N    0x71490986, 0x28d412ab, 0x71510cd5, 0x28ca6488,
N    0x71590e3e, 0x28c0b4d2, 0x71610dbf, 0x28b7038b,
N    0x71690b59, 0x28ad50b1, 0x7171070c, 0x28a39c46,
N    0x717900d6, 0x2899e64a, 0x7180f8b8, 0x28902ebd,
N    0x7188eeb2, 0x288675a0, 0x7190e2c3, 0x287cbaf3,
N    0x7198d4ea, 0x2872feb6, 0x71a0c528, 0x286940ea,
N    0x71a8b37c, 0x285f8190, 0x71b09fe7, 0x2855c0a6,
N    0x71b88a66, 0x284bfe2f, 0x71c072fb, 0x28423a2a,
N    0x71c859a5, 0x28387498, 0x71d03e64, 0x282ead78,
N    0x71d82137, 0x2824e4cc, 0x71e0021e, 0x281b1a94,
N    0x71e7e118, 0x28114ed0, 0x71efbe27, 0x28078181,
N    0x71f79948, 0x27fdb2a7, 0x71ff727c, 0x27f3e241,
N    0x720749c3, 0x27ea1052, 0x720f1f1c, 0x27e03cd8,
N    0x7216f287, 0x27d667d5, 0x721ec403, 0x27cc9149,
N    0x72269391, 0x27c2b934, 0x722e6130, 0x27b8df97,
N    0x72362ce0, 0x27af0472, 0x723df6a0, 0x27a527c4,
N    0x7245be70, 0x279b4990, 0x724d8450, 0x279169d5,
N    0x72554840, 0x27878893, 0x725d0a3e, 0x277da5cb,
N    0x7264ca4c, 0x2773c17d, 0x726c8868, 0x2769dbaa,
N    0x72744493, 0x275ff452, 0x727bfecc, 0x27560b76,
N    0x7283b712, 0x274c2115, 0x728b6d66, 0x27423530,
N    0x729321c7, 0x273847c8, 0x729ad435, 0x272e58dc,
N    0x72a284b0, 0x2724686e, 0x72aa3336, 0x271a767e,
N    0x72b1dfc9, 0x2710830c, 0x72b98a67, 0x27068e18,
N    0x72c13311, 0x26fc97a3, 0x72c8d9c6, 0x26f29fad,
N    0x72d07e85, 0x26e8a637, 0x72d82150, 0x26deab41,
N    0x72dfc224, 0x26d4aecb, 0x72e76102, 0x26cab0d6,
N    0x72eefdea, 0x26c0b162, 0x72f698db, 0x26b6b070,
N    0x72fe31d5, 0x26acadff, 0x7305c8d7, 0x26a2aa11,
N    0x730d5de3, 0x2698a4a6, 0x7314f0f6, 0x268e9dbd,
N    0x731c8211, 0x26849558, 0x73241134, 0x267a8b77,
N    0x732b9e5e, 0x2670801a, 0x7333298f, 0x26667342,
N    0x733ab2c6, 0x265c64ef, 0x73423a04, 0x26525521,
N    0x7349bf48, 0x264843d9, 0x73514292, 0x263e3117,
N    0x7358c3e2, 0x26341cdb, 0x73604336, 0x262a0727,
N    0x7367c090, 0x261feffa, 0x736f3bee, 0x2615d754,
N    0x7376b551, 0x260bbd37, 0x737e2cb7, 0x2601a1a2,
N    0x7385a222, 0x25f78497, 0x738d1590, 0x25ed6614,
N    0x73948701, 0x25e3461b, 0x739bf675, 0x25d924ac,
N    0x73a363ec, 0x25cf01c8, 0x73aacf65, 0x25c4dd6e,
N    0x73b238e0, 0x25bab7a0, 0x73b9a05d, 0x25b0905d,
N    0x73c105db, 0x25a667a7, 0x73c8695b, 0x259c3d7c,
N    0x73cfcadc, 0x259211df, 0x73d72a5d, 0x2587e4cf,
N    0x73de87de, 0x257db64c, 0x73e5e360, 0x25738657,
N    0x73ed3ce1, 0x256954f1, 0x73f49462, 0x255f2219,
N    0x73fbe9e2, 0x2554edd1, 0x74033d61, 0x254ab818,
N    0x740a8edf, 0x254080ef, 0x7411de5b, 0x25364857,
N    0x74192bd5, 0x252c0e4f, 0x7420774d, 0x2521d2d8,
N    0x7427c0c3, 0x251795f3, 0x742f0836, 0x250d57a0,
N    0x74364da6, 0x250317df, 0x743d9112, 0x24f8d6b0,
N    0x7444d27b, 0x24ee9415, 0x744c11e0, 0x24e4500e,
N    0x74534f41, 0x24da0a9a, 0x745a8a9d, 0x24cfc3ba,
N    0x7461c3f5, 0x24c57b6f, 0x7468fb47, 0x24bb31ba,
N    0x74703095, 0x24b0e699, 0x747763dd, 0x24a69a0f,
N    0x747e951f, 0x249c4c1b, 0x7485c45b, 0x2491fcbe,
N    0x748cf190, 0x2487abf7, 0x74941cbf, 0x247d59c8,
N    0x749b45e7, 0x24730631, 0x74a26d08, 0x2468b132,
N    0x74a99221, 0x245e5acc, 0x74b0b533, 0x245402ff,
N    0x74b7d63c, 0x2449a9cc, 0x74bef53d, 0x243f4f32,
N    0x74c61236, 0x2434f332, 0x74cd2d26, 0x242a95ce,
N    0x74d4460c, 0x24203704, 0x74db5cea, 0x2415d6d5,
N    0x74e271bd, 0x240b7543, 0x74e98487, 0x2401124d,
N    0x74f09546, 0x23f6adf3, 0x74f7a3fb, 0x23ec4837,
N    0x74feb0a5, 0x23e1e117, 0x7505bb44, 0x23d77896,
N    0x750cc3d8, 0x23cd0eb3, 0x7513ca60, 0x23c2a36f,
N    0x751acedd, 0x23b836ca, 0x7521d14d, 0x23adc8c4,
N    0x7528d1b1, 0x23a3595e, 0x752fd008, 0x2398e898,
N    0x7536cc52, 0x238e7673, 0x753dc68f, 0x238402ef,
N    0x7544bebf, 0x23798e0d, 0x754bb4e1, 0x236f17cc,
N    0x7552a8f4, 0x2364a02e, 0x75599afa, 0x235a2733,
N    0x75608af1, 0x234facda, 0x756778d9, 0x23453125,
N    0x756e64b2, 0x233ab414, 0x75754e7c, 0x233035a7,
N    0x757c3636, 0x2325b5df, 0x75831be0, 0x231b34bc,
N    0x7589ff7a, 0x2310b23e, 0x7590e104, 0x23062e67,
N    0x7597c07d, 0x22fba936, 0x759e9de5, 0x22f122ab,
N    0x75a5793c, 0x22e69ac8, 0x75ac5282, 0x22dc118c,
N    0x75b329b5, 0x22d186f8, 0x75b9fed7, 0x22c6fb0c,
N    0x75c0d1e7, 0x22bc6dca, 0x75c7a2e3, 0x22b1df30,
N    0x75ce71ce, 0x22a74f40, 0x75d53ea5, 0x229cbdfa,
N    0x75dc0968, 0x22922b5e, 0x75e2d219, 0x2287976e,
N    0x75e998b5, 0x227d0228, 0x75f05d3d, 0x22726b8e,
N    0x75f71fb1, 0x2267d3a0, 0x75fde011, 0x225d3a5e,
N    0x76049e5b, 0x22529fca, 0x760b5a90, 0x224803e2,
N    0x761214b0, 0x223d66a8, 0x7618ccba, 0x2232c81c,
N    0x761f82af, 0x2228283f, 0x7626368d, 0x221d8711,
N    0x762ce855, 0x2212e492, 0x76339806, 0x220840c2,
N    0x763a45a0, 0x21fd9ba3, 0x7640f123, 0x21f2f534,
N    0x76479a8e, 0x21e84d76, 0x764e41e2, 0x21dda46a,
N    0x7654e71d, 0x21d2fa0f, 0x765b8a41, 0x21c84e67,
N    0x76622b4c, 0x21bda171, 0x7668ca3e, 0x21b2f32e,
N    0x766f6717, 0x21a8439e, 0x767601d7, 0x219d92c2,
N    0x767c9a7e, 0x2192e09b, 0x7683310b, 0x21882d28,
N    0x7689c57d, 0x217d786a, 0x769057d6, 0x2172c262,
N    0x7696e814, 0x21680b0f, 0x769d7637, 0x215d5273,
N    0x76a4023f, 0x2152988d, 0x76aa8c2c, 0x2147dd5f,
N    0x76b113fd, 0x213d20e8, 0x76b799b3, 0x21326329,
N    0x76be1d4c, 0x2127a423, 0x76c49ec9, 0x211ce3d5,
N    0x76cb1e2a, 0x21122240, 0x76d19b6e, 0x21075f65,
N    0x76d81695, 0x20fc9b44, 0x76de8f9e, 0x20f1d5de,
N    0x76e5068a, 0x20e70f32, 0x76eb7b58, 0x20dc4742,
N    0x76f1ee09, 0x20d17e0d, 0x76f85e9a, 0x20c6b395,
N    0x76fecd0e, 0x20bbe7d8, 0x77053962, 0x20b11ad9,
N    0x770ba398, 0x20a64c97, 0x77120bae, 0x209b7d13,
N    0x771871a5, 0x2090ac4d, 0x771ed57c, 0x2085da46,
N    0x77253733, 0x207b06fe, 0x772b96ca, 0x20703275,
N    0x7731f440, 0x20655cac, 0x77384f95, 0x205a85a3,
N    0x773ea8ca, 0x204fad5b, 0x7744ffdd, 0x2044d3d4,
N    0x774b54ce, 0x2039f90f, 0x7751a79e, 0x202f1d0b,
N    0x7757f84c, 0x20243fca, 0x775e46d8, 0x2019614c,
N    0x77649341, 0x200e8190, 0x776add88, 0x2003a099,
N    0x777125ac, 0x1ff8be65, 0x77776bac, 0x1feddaf6,
N    0x777daf89, 0x1fe2f64c, 0x7783f143, 0x1fd81067,
N    0x778a30d8, 0x1fcd2948, 0x77906e49, 0x1fc240ef,
N    0x7796a996, 0x1fb7575c, 0x779ce2be, 0x1fac6c91,
N    0x77a319c2, 0x1fa1808c, 0x77a94ea0, 0x1f969350,
N    0x77af8159, 0x1f8ba4dc, 0x77b5b1ec, 0x1f80b531,
N    0x77bbe05a, 0x1f75c44e, 0x77c20ca1, 0x1f6ad235,
N    0x77c836c2, 0x1f5fdee6, 0x77ce5ebd, 0x1f54ea62,
N    0x77d48490, 0x1f49f4a8, 0x77daa83d, 0x1f3efdb9,
N    0x77e0c9c3, 0x1f340596, 0x77e6e921, 0x1f290c3f,
N    0x77ed0657, 0x1f1e11b5, 0x77f32165, 0x1f1315f7,
N    0x77f93a4b, 0x1f081907, 0x77ff5109, 0x1efd1ae4,
N    0x7805659e, 0x1ef21b90, 0x780b780a, 0x1ee71b0a,
N    0x7811884d, 0x1edc1953, 0x78179666, 0x1ed1166b,
N    0x781da256, 0x1ec61254, 0x7823ac1d, 0x1ebb0d0d,
N    0x7829b3b9, 0x1eb00696, 0x782fb92a, 0x1ea4fef0,
N    0x7835bc71, 0x1e99f61d, 0x783bbd8e, 0x1e8eec1b,
N    0x7841bc7f, 0x1e83e0eb, 0x7847b946, 0x1e78d48e,
N    0x784db3e0, 0x1e6dc705, 0x7853ac4f, 0x1e62b84f,
N    0x7859a292, 0x1e57a86d, 0x785f96a9, 0x1e4c9760,
N    0x78658894, 0x1e418528, 0x786b7852, 0x1e3671c5,
N    0x787165e3, 0x1e2b5d38, 0x78775147, 0x1e204781,
N    0x787d3a7e, 0x1e1530a1, 0x78832187, 0x1e0a1898,
N    0x78890663, 0x1dfeff67, 0x788ee910, 0x1df3e50d,
N    0x7894c98f, 0x1de8c98c, 0x789aa7e0, 0x1dddace4,
N    0x78a08402, 0x1dd28f15, 0x78a65df6, 0x1dc7701f,
N    0x78ac35ba, 0x1dbc5004, 0x78b20b4f, 0x1db12ec3,
N    0x78b7deb4, 0x1da60c5d, 0x78bdafea, 0x1d9ae8d2,
N    0x78c37eef, 0x1d8fc424, 0x78c94bc4, 0x1d849e51,
N    0x78cf1669, 0x1d79775c, 0x78d4dedd, 0x1d6e4f43,
N    0x78daa520, 0x1d632608, 0x78e06932, 0x1d57fbaa,
N    0x78e62b13, 0x1d4cd02c, 0x78ebeac2, 0x1d41a38c,
N    0x78f1a840, 0x1d3675cb, 0x78f7638b, 0x1d2b46ea,
N    0x78fd1ca4, 0x1d2016e9, 0x7902d38b, 0x1d14e5c9,
N    0x7908883f, 0x1d09b389, 0x790e3ac0, 0x1cfe802b,
N    0x7913eb0e, 0x1cf34baf, 0x79199929, 0x1ce81615,
N    0x791f4510, 0x1cdcdf5e, 0x7924eec3, 0x1cd1a78a,
N    0x792a9642, 0x1cc66e99, 0x79303b8e, 0x1cbb348d,
N    0x7935dea4, 0x1caff965, 0x793b7f86, 0x1ca4bd21,
N    0x79411e33, 0x1c997fc4, 0x7946baac, 0x1c8e414b,
N    0x794c54ee, 0x1c8301b9, 0x7951ecfc, 0x1c77c10e,
N    0x795782d3, 0x1c6c7f4a, 0x795d1675, 0x1c613c6d,
N    0x7962a7e0, 0x1c55f878, 0x79683715, 0x1c4ab36b,
N    0x796dc414, 0x1c3f6d47, 0x79734edc, 0x1c34260c,
N    0x7978d76c, 0x1c28ddbb, 0x797e5dc6, 0x1c1d9454,
N    0x7983e1e8, 0x1c1249d8, 0x798963d2, 0x1c06fe46,
N    0x798ee385, 0x1bfbb1a0, 0x799460ff, 0x1bf063e6,
N    0x7999dc42, 0x1be51518, 0x799f554b, 0x1bd9c537,
N    0x79a4cc1c, 0x1bce7442, 0x79aa40b4, 0x1bc3223c,
N    0x79afb313, 0x1bb7cf23, 0x79b52339, 0x1bac7af9,
N    0x79ba9125, 0x1ba125bd, 0x79bffcd7, 0x1b95cf71,
N    0x79c5664f, 0x1b8a7815, 0x79cacd8d, 0x1b7f1fa9,
N    0x79d03291, 0x1b73c62d, 0x79d5955a, 0x1b686ba3,
N    0x79daf5e8, 0x1b5d100a, 0x79e0543c, 0x1b51b363,
N    0x79e5b054, 0x1b4655ae, 0x79eb0a31, 0x1b3af6ec,
N    0x79f061d2, 0x1b2f971e, 0x79f5b737, 0x1b243643,
N    0x79fb0a60, 0x1b18d45c, 0x7a005b4d, 0x1b0d716a,
N    0x7a05a9fd, 0x1b020d6c, 0x7a0af671, 0x1af6a865,
N    0x7a1040a8, 0x1aeb4253, 0x7a1588a2, 0x1adfdb37,
N    0x7a1ace5f, 0x1ad47312, 0x7a2011de, 0x1ac909e5,
N    0x7a25531f, 0x1abd9faf, 0x7a2a9223, 0x1ab23471,
N    0x7a2fcee8, 0x1aa6c82b, 0x7a350970, 0x1a9b5adf,
N    0x7a3a41b9, 0x1a8fec8c, 0x7a3f77c3, 0x1a847d33,
N    0x7a44ab8e, 0x1a790cd4, 0x7a49dd1a, 0x1a6d9b70,
N    0x7a4f0c67, 0x1a622907, 0x7a543974, 0x1a56b599,
N    0x7a596442, 0x1a4b4128, 0x7a5e8cd0, 0x1a3fcbb3,
N    0x7a63b31d, 0x1a34553b, 0x7a68d72b, 0x1a28ddc0,
N    0x7a6df8f8, 0x1a1d6544, 0x7a731884, 0x1a11ebc5,
N    0x7a7835cf, 0x1a067145, 0x7a7d50da, 0x19faf5c5,
N    0x7a8269a3, 0x19ef7944, 0x7a87802a, 0x19e3fbc3,
N    0x7a8c9470, 0x19d87d42, 0x7a91a674, 0x19ccfdc2,
N    0x7a96b636, 0x19c17d44, 0x7a9bc3b6, 0x19b5fbc8,
N    0x7aa0cef3, 0x19aa794d, 0x7aa5d7ee, 0x199ef5d6,
N    0x7aaadea6, 0x19937161, 0x7aafe31b, 0x1987ebf0,
N    0x7ab4e54c, 0x197c6584, 0x7ab9e53a, 0x1970de1b,
N    0x7abee2e5, 0x196555b8, 0x7ac3de4c, 0x1959cc5a,
N    0x7ac8d76f, 0x194e4201, 0x7acdce4d, 0x1942b6af,
N    0x7ad2c2e8, 0x19372a64, 0x7ad7b53d, 0x192b9d1f,
N    0x7adca54e, 0x19200ee3, 0x7ae1931a, 0x19147fae,
N    0x7ae67ea1, 0x1908ef82, 0x7aeb67e3, 0x18fd5e5f,
N    0x7af04edf, 0x18f1cc45, 0x7af53395, 0x18e63935,
N    0x7afa1605, 0x18daa52f, 0x7afef630, 0x18cf1034,
N    0x7b03d414, 0x18c37a44, 0x7b08afb2, 0x18b7e35f,
N    0x7b0d8909, 0x18ac4b87, 0x7b126019, 0x18a0b2bb,
N    0x7b1734e2, 0x189518fc, 0x7b1c0764, 0x18897e4a,
N    0x7b20d79e, 0x187de2a7, 0x7b25a591, 0x18724611,
N    0x7b2a713d, 0x1866a88a, 0x7b2f3aa0, 0x185b0a13,
N    0x7b3401bb, 0x184f6aab, 0x7b38c68e, 0x1843ca53,
N    0x7b3d8918, 0x1838290c, 0x7b42495a, 0x182c86d5,
N    0x7b470753, 0x1820e3b0, 0x7b4bc303, 0x18153f9d,
N    0x7b507c69, 0x18099a9c, 0x7b553386, 0x17fdf4ae,
N    0x7b59e85a, 0x17f24dd3, 0x7b5e9ae4, 0x17e6a60c,
N    0x7b634b23, 0x17dafd59, 0x7b67f919, 0x17cf53bb,
N    0x7b6ca4c4, 0x17c3a931, 0x7b714e25, 0x17b7fdbd,
N    0x7b75f53c, 0x17ac515f, 0x7b7a9a07, 0x17a0a417,
N    0x7b7f3c87, 0x1794f5e6, 0x7b83dcbc, 0x178946cc,
N    0x7b887aa6, 0x177d96ca, 0x7b8d1644, 0x1771e5e0,
N    0x7b91af97, 0x1766340f, 0x7b96469d, 0x175a8157,
N    0x7b9adb57, 0x174ecdb8, 0x7b9f6dc5, 0x17431933,
N    0x7ba3fde7, 0x173763c9, 0x7ba88bbc, 0x172bad7a,
N    0x7bad1744, 0x171ff646, 0x7bb1a080, 0x17143e2d,
N    0x7bb6276e, 0x17088531, 0x7bbaac0e, 0x16fccb51,
N    0x7bbf2e62, 0x16f1108f, 0x7bc3ae67, 0x16e554ea,
N    0x7bc82c1f, 0x16d99864, 0x7bcca789, 0x16cddafb,
N    0x7bd120a4, 0x16c21cb2, 0x7bd59771, 0x16b65d88,
N    0x7bda0bf0, 0x16aa9d7e, 0x7bde7e20, 0x169edc94,
N    0x7be2ee01, 0x16931acb, 0x7be75b93, 0x16875823,
N    0x7bebc6d5, 0x167b949d, 0x7bf02fc9, 0x166fd039,
N    0x7bf4966c, 0x16640af7, 0x7bf8fac0, 0x165844d8,
N    0x7bfd5cc4, 0x164c7ddd, 0x7c01bc78, 0x1640b606,
N    0x7c0619dc, 0x1634ed53, 0x7c0a74f0, 0x162923c5,
N    0x7c0ecdb2, 0x161d595d, 0x7c132424, 0x16118e1a,
N    0x7c177845, 0x1605c1fd, 0x7c1bca16, 0x15f9f507,
N    0x7c201994, 0x15ee2738, 0x7c2466c2, 0x15e25890,
N    0x7c28b19e, 0x15d68911, 0x7c2cfa28, 0x15cab8ba,
N    0x7c314060, 0x15bee78c, 0x7c358446, 0x15b31587,
N    0x7c39c5da, 0x15a742ac, 0x7c3e051b, 0x159b6efb,
N    0x7c42420a, 0x158f9a76, 0x7c467ca6, 0x1583c51b,
N    0x7c4ab4ef, 0x1577eeec, 0x7c4eeae5, 0x156c17e9,
N    0x7c531e88, 0x15604013, 0x7c574fd8, 0x1554676a,
N    0x7c5b7ed4, 0x15488dee, 0x7c5fab7c, 0x153cb3a0,
N    0x7c63d5d1, 0x1530d881, 0x7c67fdd1, 0x1524fc90,
N    0x7c6c237e, 0x15191fcf, 0x7c7046d6, 0x150d423d,
N    0x7c7467d9, 0x150163dc, 0x7c788688, 0x14f584ac,
N    0x7c7ca2e2, 0x14e9a4ac, 0x7c80bce7, 0x14ddc3de,
N    0x7c84d496, 0x14d1e242, 0x7c88e9f1, 0x14c5ffd9,
N    0x7c8cfcf6, 0x14ba1ca3, 0x7c910da5, 0x14ae38a0,
N    0x7c951bff, 0x14a253d1, 0x7c992803, 0x14966e36,
N    0x7c9d31b0, 0x148a87d1, 0x7ca13908, 0x147ea0a0,
N    0x7ca53e09, 0x1472b8a5, 0x7ca940b3, 0x1466cfe1,
N    0x7cad4107, 0x145ae653, 0x7cb13f04, 0x144efbfc,
N    0x7cb53aaa, 0x144310dd, 0x7cb933f9, 0x143724f5,
N    0x7cbd2af0, 0x142b3846, 0x7cc11f90, 0x141f4ad1,
N    0x7cc511d9, 0x14135c94, 0x7cc901c9, 0x14076d91,
N    0x7cccef62, 0x13fb7dc9, 0x7cd0daa2, 0x13ef8d3c,
N    0x7cd4c38b, 0x13e39be9, 0x7cd8aa1b, 0x13d7a9d3,
N    0x7cdc8e52, 0x13cbb6f8, 0x7ce07031, 0x13bfc35b,
N    0x7ce44fb7, 0x13b3cefa, 0x7ce82ce4, 0x13a7d9d7,
N    0x7cec07b8, 0x139be3f2, 0x7cefe032, 0x138fed4b,
N    0x7cf3b653, 0x1383f5e3, 0x7cf78a1b, 0x1377fdbb,
N    0x7cfb5b89, 0x136c04d2, 0x7cff2a9d, 0x13600b2a,
N    0x7d02f757, 0x135410c3, 0x7d06c1b6, 0x1348159d,
N    0x7d0a89bc, 0x133c19b8, 0x7d0e4f67, 0x13301d16,
N    0x7d1212b7, 0x13241fb6, 0x7d15d3ad, 0x1318219a,
N    0x7d199248, 0x130c22c1, 0x7d1d4e88, 0x1300232c,
N    0x7d21086c, 0x12f422db, 0x7d24bff6, 0x12e821cf,
N    0x7d287523, 0x12dc2009, 0x7d2c27f6, 0x12d01d89,
N    0x7d2fd86c, 0x12c41a4f, 0x7d338687, 0x12b8165b,
N    0x7d373245, 0x12ac11af, 0x7d3adba7, 0x12a00c4b,
N    0x7d3e82ae, 0x1294062f, 0x7d422757, 0x1287ff5b,
N    0x7d45c9a4, 0x127bf7d1, 0x7d496994, 0x126fef90,
N    0x7d4d0728, 0x1263e699, 0x7d50a25e, 0x1257dced,
N    0x7d543b37, 0x124bd28c, 0x7d57d1b3, 0x123fc776,
N    0x7d5b65d2, 0x1233bbac, 0x7d5ef793, 0x1227af2e,
N    0x7d6286f6, 0x121ba1fd, 0x7d6613fb, 0x120f941a,
N    0x7d699ea3, 0x12038584, 0x7d6d26ec, 0x11f7763c,
N    0x7d70acd7, 0x11eb6643, 0x7d743064, 0x11df5599,
N    0x7d77b192, 0x11d3443f, 0x7d7b3061, 0x11c73235,
N    0x7d7eacd2, 0x11bb1f7c, 0x7d8226e4, 0x11af0c13,
N    0x7d859e96, 0x11a2f7fc, 0x7d8913ea, 0x1196e337,
N    0x7d8c86de, 0x118acdc4, 0x7d8ff772, 0x117eb7a4,
N    0x7d9365a8, 0x1172a0d7, 0x7d96d17d, 0x1166895f,
N    0x7d9a3af2, 0x115a713a, 0x7d9da208, 0x114e586a,
N    0x7da106bd, 0x11423ef0, 0x7da46912, 0x113624cb,
N    0x7da7c907, 0x112a09fc, 0x7dab269b, 0x111dee84,
N    0x7dae81cf, 0x1111d263, 0x7db1daa2, 0x1105b599,
N    0x7db53113, 0x10f99827, 0x7db88524, 0x10ed7a0e,
N    0x7dbbd6d4, 0x10e15b4e, 0x7dbf2622, 0x10d53be7,
N    0x7dc2730f, 0x10c91bda, 0x7dc5bd9b, 0x10bcfb28,
N    0x7dc905c5, 0x10b0d9d0, 0x7dcc4b8d, 0x10a4b7d3,
N    0x7dcf8ef3, 0x10989532, 0x7dd2cff7, 0x108c71ee,
N    0x7dd60e99, 0x10804e06, 0x7dd94ad8, 0x1074297b,
N    0x7ddc84b5, 0x1068044e, 0x7ddfbc30, 0x105bde7f,
N    0x7de2f148, 0x104fb80e, 0x7de623fd, 0x104390fd,
N    0x7de9544f, 0x1037694b, 0x7dec823e, 0x102b40f8,
N    0x7defadca, 0x101f1807, 0x7df2d6f3, 0x1012ee76,
N    0x7df5fdb8, 0x1006c446, 0x7df9221a, 0xffa9979,
N    0x7dfc4418, 0xfee6e0d, 0x7dff63b2, 0xfe24205,
N    0x7e0280e9, 0xfd6155f, 0x7e059bbb, 0xfc9e81e,
N    0x7e08b42a, 0xfbdba40, 0x7e0bca34, 0xfb18bc8,
N    0x7e0eddd9, 0xfa55cb4, 0x7e11ef1b, 0xf992d06,
N    0x7e14fdf7, 0xf8cfcbe, 0x7e180a6f, 0xf80cbdc,
N    0x7e1b1482, 0xf749a61, 0x7e1e1c30, 0xf68684e,
N    0x7e212179, 0xf5c35a3, 0x7e24245d, 0xf500260,
N    0x7e2724db, 0xf43ce86, 0x7e2a22f4, 0xf379a16,
N    0x7e2d1ea8, 0xf2b650f, 0x7e3017f6, 0xf1f2f73,
N    0x7e330ede, 0xf12f941, 0x7e360360, 0xf06c27a,
N    0x7e38f57c, 0xefa8b20, 0x7e3be532, 0xeee5331,
N    0x7e3ed282, 0xee21aaf, 0x7e41bd6c, 0xed5e19a,
N    0x7e44a5ef, 0xec9a7f3, 0x7e478c0b, 0xebd6db9,
N    0x7e4a6fc1, 0xeb132ef, 0x7e4d5110, 0xea4f793,
N    0x7e502ff9, 0xe98bba7, 0x7e530c7a, 0xe8c7f2a,
N    0x7e55e694, 0xe80421e, 0x7e58be47, 0xe740483,
N    0x7e5b9392, 0xe67c65a, 0x7e5e6676, 0xe5b87a2,
N    0x7e6136f3, 0xe4f485c, 0x7e640507, 0xe430889,
N    0x7e66d0b4, 0xe36c82a, 0x7e6999fa, 0xe2a873e,
N    0x7e6c60d7, 0xe1e45c6, 0x7e6f254c, 0xe1203c3,
N    0x7e71e759, 0xe05c135, 0x7e74a6fd, 0xdf97e1d,
N    0x7e77643a, 0xded3a7b, 0x7e7a1f0d, 0xde0f64f,
N    0x7e7cd778, 0xdd4b19a, 0x7e7f8d7b, 0xdc86c5d,
N    0x7e824114, 0xdbc2698, 0x7e84f245, 0xdafe04b,
N    0x7e87a10c, 0xda39978, 0x7e8a4d6a, 0xd97521d,
N    0x7e8cf75f, 0xd8b0a3d, 0x7e8f9eeb, 0xd7ec1d6,
N    0x7e92440d, 0xd7278eb, 0x7e94e6c6, 0xd662f7b,
N    0x7e978715, 0xd59e586, 0x7e9a24fb, 0xd4d9b0e,
N    0x7e9cc076, 0xd415013, 0x7e9f5988, 0xd350495,
N    0x7ea1f02f, 0xd28b894, 0x7ea4846c, 0xd1c6c11,
N    0x7ea7163f, 0xd101f0e, 0x7ea9a5a8, 0xd03d189,
N    0x7eac32a6, 0xcf78383, 0x7eaebd3a, 0xceb34fe,
N    0x7eb14563, 0xcdee5f9, 0x7eb3cb21, 0xcd29676,
N    0x7eb64e75, 0xcc64673, 0x7eb8cf5d, 0xcb9f5f3,
N    0x7ebb4ddb, 0xcada4f5, 0x7ebdc9ed, 0xca1537a,
N    0x7ec04394, 0xc950182, 0x7ec2bad0, 0xc88af0e,
N    0x7ec52fa0, 0xc7c5c1e, 0x7ec7a205, 0xc7008b3,
N    0x7eca11fe, 0xc63b4ce, 0x7ecc7f8b, 0xc57606e,
N    0x7eceeaad, 0xc4b0b94, 0x7ed15363, 0xc3eb641,
N    0x7ed3b9ad, 0xc326075, 0x7ed61d8a, 0xc260a31,
N    0x7ed87efc, 0xc19b374, 0x7edade01, 0xc0d5c41,
N    0x7edd3a9a, 0xc010496, 0x7edf94c7, 0xbf4ac75,
N    0x7ee1ec87, 0xbe853de, 0x7ee441da, 0xbdbfad1,
N    0x7ee694c1, 0xbcfa150, 0x7ee8e53a, 0xbc34759,
N    0x7eeb3347, 0xbb6ecef, 0x7eed7ee7, 0xbaa9211,
N    0x7eefc81a, 0xb9e36c0, 0x7ef20ee0, 0xb91dafc,
N    0x7ef45338, 0xb857ec7, 0x7ef69523, 0xb79221f,
N    0x7ef8d4a1, 0xb6cc506, 0x7efb11b1, 0xb60677c,
N    0x7efd4c54, 0xb540982, 0x7eff8489, 0xb47ab19,
N    0x7f01ba50, 0xb3b4c40, 0x7f03eda9, 0xb2eecf8,
N    0x7f061e95, 0xb228d42, 0x7f084d12, 0xb162d1d,
N    0x7f0a7921, 0xb09cc8c, 0x7f0ca2c2, 0xafd6b8d,
N    0x7f0ec9f5, 0xaf10a22, 0x7f10eeb9, 0xae4a84b,
N    0x7f13110f, 0xad84609, 0x7f1530f7, 0xacbe35b,
N    0x7f174e70, 0xabf8043, 0x7f19697a, 0xab31cc1,
N    0x7f1b8215, 0xaa6b8d5, 0x7f1d9842, 0xa9a5480,
N    0x7f1fabff, 0xa8defc3, 0x7f21bd4e, 0xa818a9d,
N    0x7f23cc2e, 0xa752510, 0x7f25d89e, 0xa68bf1b,
N    0x7f27e29f, 0xa5c58c0, 0x7f29ea31, 0xa4ff1fe,
N    0x7f2bef53, 0xa438ad7, 0x7f2df206, 0xa37234a,
N    0x7f2ff24a, 0xa2abb59, 0x7f31f01d, 0xa1e5303,
N    0x7f33eb81, 0xa11ea49, 0x7f35e476, 0xa05812c,
N    0x7f37dafa, 0x9f917ac, 0x7f39cf0e, 0x9ecadc9,
N    0x7f3bc0b3, 0x9e04385, 0x7f3dafe7, 0x9d3d8df,
N    0x7f3f9cab, 0x9c76dd8, 0x7f4186ff, 0x9bb0271,
N    0x7f436ee3, 0x9ae96aa, 0x7f455456, 0x9a22a83,
N    0x7f473759, 0x995bdfd, 0x7f4917eb, 0x9895118,
N    0x7f4af60d, 0x97ce3d5, 0x7f4cd1be, 0x9707635,
N    0x7f4eaafe, 0x9640837, 0x7f5081cd, 0x95799dd,
N    0x7f52562c, 0x94b2b27, 0x7f54281a, 0x93ebc14,
N    0x7f55f796, 0x9324ca7, 0x7f57c4a2, 0x925dcdf,
N    0x7f598f3c, 0x9196cbc, 0x7f5b5765, 0x90cfc40,
N    0x7f5d1d1d, 0x9008b6a, 0x7f5ee063, 0x8f41a3c,
N    0x7f60a138, 0x8e7a8b5, 0x7f625f9b, 0x8db36d6,
N    0x7f641b8d, 0x8cec4a0, 0x7f65d50d, 0x8c25213,
N    0x7f678c1c, 0x8b5df30, 0x7f6940b8, 0x8a96bf6,
N    0x7f6af2e3, 0x89cf867, 0x7f6ca29c, 0x8908483,
N    0x7f6e4fe3, 0x884104b, 0x7f6ffab8, 0x8779bbe,
N    0x7f71a31b, 0x86b26de, 0x7f73490b, 0x85eb1ab,
N    0x7f74ec8a, 0x8523c25, 0x7f768d96, 0x845c64d,
N    0x7f782c30, 0x8395024, 0x7f79c857, 0x82cd9a9,
N    0x7f7b620c, 0x82062de, 0x7f7cf94e, 0x813ebc2,
N    0x7f7e8e1e, 0x8077457, 0x7f80207b, 0x7fafc9c,
N    0x7f81b065, 0x7ee8493, 0x7f833ddd, 0x7e20c3b,
N    0x7f84c8e2, 0x7d59396, 0x7f865174, 0x7c91aa3,
N    0x7f87d792, 0x7bca163, 0x7f895b3e, 0x7b027d7,
N    0x7f8adc77, 0x7a3adff, 0x7f8c5b3d, 0x79733dc,
N    0x7f8dd78f, 0x78ab96e, 0x7f8f516e, 0x77e3eb5,
N    0x7f90c8da, 0x771c3b3, 0x7f923dd2, 0x7654867,
N    0x7f93b058, 0x758ccd2, 0x7f952069, 0x74c50f4,
N    0x7f968e07, 0x73fd4cf, 0x7f97f932, 0x7335862,
N    0x7f9961e8, 0x726dbae, 0x7f9ac82c, 0x71a5eb3,
N    0x7f9c2bfb, 0x70de172, 0x7f9d8d56, 0x70163eb,
N    0x7f9eec3e, 0x6f4e620, 0x7fa048b2, 0x6e86810,
N    0x7fa1a2b2, 0x6dbe9bb, 0x7fa2fa3d, 0x6cf6b23,
N    0x7fa44f55, 0x6c2ec48, 0x7fa5a1f9, 0x6b66d29,
N    0x7fa6f228, 0x6a9edc9, 0x7fa83fe3, 0x69d6e27,
N    0x7fa98b2a, 0x690ee44, 0x7faad3fd, 0x6846e1f,
N    0x7fac1a5b, 0x677edbb, 0x7fad5e45, 0x66b6d16,
N    0x7fae9fbb, 0x65eec33, 0x7fafdebb, 0x6526b10,
N    0x7fb11b48, 0x645e9af, 0x7fb2555f, 0x6396810,
N    0x7fb38d02, 0x62ce634, 0x7fb4c231, 0x620641a,
N    0x7fb5f4ea, 0x613e1c5, 0x7fb7252f, 0x6075f33,
N    0x7fb852ff, 0x5fadc66, 0x7fb97e5a, 0x5ee595d,
N    0x7fbaa740, 0x5e1d61b, 0x7fbbcdb1, 0x5d5529e,
N    0x7fbcf1ad, 0x5c8cee7, 0x7fbe1334, 0x5bc4af8,
N    0x7fbf3246, 0x5afc6d0, 0x7fc04ee3, 0x5a3426f,
N    0x7fc1690a, 0x596bdd7, 0x7fc280bc, 0x58a3908,
N    0x7fc395f9, 0x57db403, 0x7fc4a8c1, 0x5712ec7,
N    0x7fc5b913, 0x564a955, 0x7fc6c6f0, 0x55823ae,
N    0x7fc7d258, 0x54b9dd3, 0x7fc8db4a, 0x53f17c3,
N    0x7fc9e1c6, 0x532917f, 0x7fcae5cd, 0x5260b08,
N    0x7fcbe75e, 0x519845e, 0x7fcce67a, 0x50cfd82,
N    0x7fcde320, 0x5007674, 0x7fcedd50, 0x4f3ef35,
N    0x7fcfd50b, 0x4e767c5, 0x7fd0ca4f, 0x4dae024,
N    0x7fd1bd1e, 0x4ce5854, 0x7fd2ad77, 0x4c1d054,
N    0x7fd39b5a, 0x4b54825, 0x7fd486c7, 0x4a8bfc7,
N    0x7fd56fbe, 0x49c373c, 0x7fd6563f, 0x48fae83,
N    0x7fd73a4a, 0x483259d, 0x7fd81bdf, 0x4769c8b,
N    0x7fd8fafe, 0x46a134c, 0x7fd9d7a7, 0x45d89e2,
N    0x7fdab1d9, 0x451004d, 0x7fdb8996, 0x444768d,
N    0x7fdc5edc, 0x437eca4, 0x7fdd31ac, 0x42b6290,
N    0x7fde0205, 0x41ed854, 0x7fdecfe8, 0x4124dee,
N    0x7fdf9b55, 0x405c361, 0x7fe0644b, 0x3f938ac,
N    0x7fe12acb, 0x3ecadcf, 0x7fe1eed5, 0x3e022cc,
N    0x7fe2b067, 0x3d397a3, 0x7fe36f84, 0x3c70c54,
N    0x7fe42c2a, 0x3ba80df, 0x7fe4e659, 0x3adf546,
N    0x7fe59e12, 0x3a16988, 0x7fe65354, 0x394dda7,
N    0x7fe7061f, 0x38851a2, 0x7fe7b674, 0x37bc57b,
N    0x7fe86452, 0x36f3931, 0x7fe90fb9, 0x362acc5,
N    0x7fe9b8a9, 0x3562038, 0x7fea5f23, 0x3499389,
N    0x7feb0326, 0x33d06bb, 0x7feba4b2, 0x33079cc,
N    0x7fec43c7, 0x323ecbe, 0x7fece065, 0x3175f91,
N    0x7fed7a8c, 0x30ad245, 0x7fee123d, 0x2fe44dc,
N    0x7feea776, 0x2f1b755, 0x7fef3a39, 0x2e529b0,
N    0x7fefca84, 0x2d89bf0, 0x7ff05858, 0x2cc0e13,
N    0x7ff0e3b6, 0x2bf801a, 0x7ff16c9c, 0x2b2f207,
N    0x7ff1f30b, 0x2a663d8, 0x7ff27703, 0x299d590,
N    0x7ff2f884, 0x28d472e, 0x7ff3778e, 0x280b8b3,
N    0x7ff3f420, 0x2742a1f, 0x7ff46e3c, 0x2679b73,
N    0x7ff4e5e0, 0x25b0caf, 0x7ff55b0d, 0x24e7dd4,
N    0x7ff5cdc3, 0x241eee2, 0x7ff63e01, 0x2355fd9,
N    0x7ff6abc8, 0x228d0bb, 0x7ff71718, 0x21c4188,
N    0x7ff77ff1, 0x20fb240, 0x7ff7e652, 0x20322e3,
N    0x7ff84a3c, 0x1f69373, 0x7ff8abae, 0x1ea03ef,
N    0x7ff90aaa, 0x1dd7459, 0x7ff9672d, 0x1d0e4b0,
N    0x7ff9c13a, 0x1c454f5, 0x7ffa18cf, 0x1b7c528,
N    0x7ffa6dec, 0x1ab354b, 0x7ffac092, 0x19ea55d,
N    0x7ffb10c1, 0x192155f, 0x7ffb5e78, 0x1858552,
N    0x7ffba9b8, 0x178f536, 0x7ffbf280, 0x16c650b,
N    0x7ffc38d1, 0x15fd4d2, 0x7ffc7caa, 0x153448c,
N    0x7ffcbe0c, 0x146b438, 0x7ffcfcf6, 0x13a23d8,
N    0x7ffd3969, 0x12d936c, 0x7ffd7364, 0x12102f4,
N    0x7ffdaae7, 0x1147271, 0x7ffddff3, 0x107e1e3,
N    0x7ffe1288, 0xfb514b, 0x7ffe42a4, 0xeec0aa,
N    0x7ffe704a, 0xe22fff, 0x7ffe9b77, 0xd59f4c,
N    0x7ffec42d, 0xc90e90, 0x7ffeea6c, 0xbc7dcc,
N    0x7fff0e32, 0xafed02, 0x7fff2f82, 0xa35c30,
N    0x7fff4e59, 0x96cb58, 0x7fff6ab9, 0x8a3a7b,
N    0x7fff84a1, 0x7da998, 0x7fff9c12, 0x7118b0,
N    0x7fffb10b, 0x6487c4, 0x7fffc38c, 0x57f6d4,
N    0x7fffd396, 0x4b65e1, 0x7fffe128, 0x3ed4ea,
N    0x7fffec43, 0x3243f1, 0x7ffff4e6, 0x25b2f7,
N    0x7ffffb11, 0x1921fb, 0x7ffffec4, 0xc90fe,
N    0x7fffffff, 0x0, 0x7ffffec4, 0xfff36f02,
N    0x7ffffb11, 0xffe6de05, 0x7ffff4e6, 0xffda4d09,
N    0x7fffec43, 0xffcdbc0f, 0x7fffe128, 0xffc12b16,
N    0x7fffd396, 0xffb49a1f, 0x7fffc38c, 0xffa8092c,
N    0x7fffb10b, 0xff9b783c, 0x7fff9c12, 0xff8ee750,
N    0x7fff84a1, 0xff825668, 0x7fff6ab9, 0xff75c585,
N    0x7fff4e59, 0xff6934a8, 0x7fff2f82, 0xff5ca3d0,
N    0x7fff0e32, 0xff5012fe, 0x7ffeea6c, 0xff438234,
N    0x7ffec42d, 0xff36f170, 0x7ffe9b77, 0xff2a60b4,
N    0x7ffe704a, 0xff1dd001, 0x7ffe42a4, 0xff113f56,
N    0x7ffe1288, 0xff04aeb5, 0x7ffddff3, 0xfef81e1d,
N    0x7ffdaae7, 0xfeeb8d8f, 0x7ffd7364, 0xfedefd0c,
N    0x7ffd3969, 0xfed26c94, 0x7ffcfcf6, 0xfec5dc28,
N    0x7ffcbe0c, 0xfeb94bc8, 0x7ffc7caa, 0xfeacbb74,
N    0x7ffc38d1, 0xfea02b2e, 0x7ffbf280, 0xfe939af5,
N    0x7ffba9b8, 0xfe870aca, 0x7ffb5e78, 0xfe7a7aae,
N    0x7ffb10c1, 0xfe6deaa1, 0x7ffac092, 0xfe615aa3,
N    0x7ffa6dec, 0xfe54cab5, 0x7ffa18cf, 0xfe483ad8,
N    0x7ff9c13a, 0xfe3bab0b, 0x7ff9672d, 0xfe2f1b50,
N    0x7ff90aaa, 0xfe228ba7, 0x7ff8abae, 0xfe15fc11,
N    0x7ff84a3c, 0xfe096c8d, 0x7ff7e652, 0xfdfcdd1d,
N    0x7ff77ff1, 0xfdf04dc0, 0x7ff71718, 0xfde3be78,
N    0x7ff6abc8, 0xfdd72f45, 0x7ff63e01, 0xfdcaa027,
N    0x7ff5cdc3, 0xfdbe111e, 0x7ff55b0d, 0xfdb1822c,
N    0x7ff4e5e0, 0xfda4f351, 0x7ff46e3c, 0xfd98648d,
N    0x7ff3f420, 0xfd8bd5e1, 0x7ff3778e, 0xfd7f474d,
N    0x7ff2f884, 0xfd72b8d2, 0x7ff27703, 0xfd662a70,
N    0x7ff1f30b, 0xfd599c28, 0x7ff16c9c, 0xfd4d0df9,
N    0x7ff0e3b6, 0xfd407fe6, 0x7ff05858, 0xfd33f1ed,
N    0x7fefca84, 0xfd276410, 0x7fef3a39, 0xfd1ad650,
N    0x7feea776, 0xfd0e48ab, 0x7fee123d, 0xfd01bb24,
N    0x7fed7a8c, 0xfcf52dbb, 0x7fece065, 0xfce8a06f,
N    0x7fec43c7, 0xfcdc1342, 0x7feba4b2, 0xfccf8634,
N    0x7feb0326, 0xfcc2f945, 0x7fea5f23, 0xfcb66c77,
N    0x7fe9b8a9, 0xfca9dfc8, 0x7fe90fb9, 0xfc9d533b,
N    0x7fe86452, 0xfc90c6cf, 0x7fe7b674, 0xfc843a85,
N    0x7fe7061f, 0xfc77ae5e, 0x7fe65354, 0xfc6b2259,
N    0x7fe59e12, 0xfc5e9678, 0x7fe4e659, 0xfc520aba,
N    0x7fe42c2a, 0xfc457f21, 0x7fe36f84, 0xfc38f3ac,
N    0x7fe2b067, 0xfc2c685d, 0x7fe1eed5, 0xfc1fdd34,
N    0x7fe12acb, 0xfc135231, 0x7fe0644b, 0xfc06c754,
N    0x7fdf9b55, 0xfbfa3c9f, 0x7fdecfe8, 0xfbedb212,
N    0x7fde0205, 0xfbe127ac, 0x7fdd31ac, 0xfbd49d70,
N    0x7fdc5edc, 0xfbc8135c, 0x7fdb8996, 0xfbbb8973,
N    0x7fdab1d9, 0xfbaeffb3, 0x7fd9d7a7, 0xfba2761e,
N    0x7fd8fafe, 0xfb95ecb4, 0x7fd81bdf, 0xfb896375,
N    0x7fd73a4a, 0xfb7cda63, 0x7fd6563f, 0xfb70517d,
N    0x7fd56fbe, 0xfb63c8c4, 0x7fd486c7, 0xfb574039,
N    0x7fd39b5a, 0xfb4ab7db, 0x7fd2ad77, 0xfb3e2fac,
N    0x7fd1bd1e, 0xfb31a7ac, 0x7fd0ca4f, 0xfb251fdc,
N    0x7fcfd50b, 0xfb18983b, 0x7fcedd50, 0xfb0c10cb,
N    0x7fcde320, 0xfaff898c, 0x7fcce67a, 0xfaf3027e,
N    0x7fcbe75e, 0xfae67ba2, 0x7fcae5cd, 0xfad9f4f8,
N    0x7fc9e1c6, 0xfacd6e81, 0x7fc8db4a, 0xfac0e83d,
N    0x7fc7d258, 0xfab4622d, 0x7fc6c6f0, 0xfaa7dc52,
N    0x7fc5b913, 0xfa9b56ab, 0x7fc4a8c1, 0xfa8ed139,
N    0x7fc395f9, 0xfa824bfd, 0x7fc280bc, 0xfa75c6f8,
N    0x7fc1690a, 0xfa694229, 0x7fc04ee3, 0xfa5cbd91,
N    0x7fbf3246, 0xfa503930, 0x7fbe1334, 0xfa43b508,
N    0x7fbcf1ad, 0xfa373119, 0x7fbbcdb1, 0xfa2aad62,
N    0x7fbaa740, 0xfa1e29e5, 0x7fb97e5a, 0xfa11a6a3,
N    0x7fb852ff, 0xfa05239a, 0x7fb7252f, 0xf9f8a0cd,
N    0x7fb5f4ea, 0xf9ec1e3b, 0x7fb4c231, 0xf9df9be6,
N    0x7fb38d02, 0xf9d319cc, 0x7fb2555f, 0xf9c697f0,
N    0x7fb11b48, 0xf9ba1651, 0x7fafdebb, 0xf9ad94f0,
N    0x7fae9fbb, 0xf9a113cd, 0x7fad5e45, 0xf99492ea,
N    0x7fac1a5b, 0xf9881245, 0x7faad3fd, 0xf97b91e1,
N    0x7fa98b2a, 0xf96f11bc, 0x7fa83fe3, 0xf96291d9,
N    0x7fa6f228, 0xf9561237, 0x7fa5a1f9, 0xf94992d7,
N    0x7fa44f55, 0xf93d13b8, 0x7fa2fa3d, 0xf93094dd,
N    0x7fa1a2b2, 0xf9241645, 0x7fa048b2, 0xf91797f0,
N    0x7f9eec3e, 0xf90b19e0, 0x7f9d8d56, 0xf8fe9c15,
N    0x7f9c2bfb, 0xf8f21e8e, 0x7f9ac82c, 0xf8e5a14d,
N    0x7f9961e8, 0xf8d92452, 0x7f97f932, 0xf8cca79e,
N    0x7f968e07, 0xf8c02b31, 0x7f952069, 0xf8b3af0c,
N    0x7f93b058, 0xf8a7332e, 0x7f923dd2, 0xf89ab799,
N    0x7f90c8da, 0xf88e3c4d, 0x7f8f516e, 0xf881c14b,
N    0x7f8dd78f, 0xf8754692, 0x7f8c5b3d, 0xf868cc24,
N    0x7f8adc77, 0xf85c5201, 0x7f895b3e, 0xf84fd829,
N    0x7f87d792, 0xf8435e9d, 0x7f865174, 0xf836e55d,
N    0x7f84c8e2, 0xf82a6c6a, 0x7f833ddd, 0xf81df3c5,
N    0x7f81b065, 0xf8117b6d, 0x7f80207b, 0xf8050364,
N    0x7f7e8e1e, 0xf7f88ba9, 0x7f7cf94e, 0xf7ec143e,
N    0x7f7b620c, 0xf7df9d22, 0x7f79c857, 0xf7d32657,
N    0x7f782c30, 0xf7c6afdc, 0x7f768d96, 0xf7ba39b3,
N    0x7f74ec8a, 0xf7adc3db, 0x7f73490b, 0xf7a14e55,
N    0x7f71a31b, 0xf794d922, 0x7f6ffab8, 0xf7886442,
N    0x7f6e4fe3, 0xf77befb5, 0x7f6ca29c, 0xf76f7b7d,
N    0x7f6af2e3, 0xf7630799, 0x7f6940b8, 0xf756940a,
N    0x7f678c1c, 0xf74a20d0, 0x7f65d50d, 0xf73daded,
N    0x7f641b8d, 0xf7313b60, 0x7f625f9b, 0xf724c92a,
N    0x7f60a138, 0xf718574b, 0x7f5ee063, 0xf70be5c4,
N    0x7f5d1d1d, 0xf6ff7496, 0x7f5b5765, 0xf6f303c0,
N    0x7f598f3c, 0xf6e69344, 0x7f57c4a2, 0xf6da2321,
N    0x7f55f796, 0xf6cdb359, 0x7f54281a, 0xf6c143ec,
N    0x7f52562c, 0xf6b4d4d9, 0x7f5081cd, 0xf6a86623,
N    0x7f4eaafe, 0xf69bf7c9, 0x7f4cd1be, 0xf68f89cb,
N    0x7f4af60d, 0xf6831c2b, 0x7f4917eb, 0xf676aee8,
N    0x7f473759, 0xf66a4203, 0x7f455456, 0xf65dd57d,
N    0x7f436ee3, 0xf6516956, 0x7f4186ff, 0xf644fd8f,
N    0x7f3f9cab, 0xf6389228, 0x7f3dafe7, 0xf62c2721,
N    0x7f3bc0b3, 0xf61fbc7b, 0x7f39cf0e, 0xf6135237,
N    0x7f37dafa, 0xf606e854, 0x7f35e476, 0xf5fa7ed4,
N    0x7f33eb81, 0xf5ee15b7, 0x7f31f01d, 0xf5e1acfd,
N    0x7f2ff24a, 0xf5d544a7, 0x7f2df206, 0xf5c8dcb6,
N    0x7f2bef53, 0xf5bc7529, 0x7f29ea31, 0xf5b00e02,
N    0x7f27e29f, 0xf5a3a740, 0x7f25d89e, 0xf59740e5,
N    0x7f23cc2e, 0xf58adaf0, 0x7f21bd4e, 0xf57e7563,
N    0x7f1fabff, 0xf572103d, 0x7f1d9842, 0xf565ab80,
N    0x7f1b8215, 0xf559472b, 0x7f19697a, 0xf54ce33f,
N    0x7f174e70, 0xf5407fbd, 0x7f1530f7, 0xf5341ca5,
N    0x7f13110f, 0xf527b9f7, 0x7f10eeb9, 0xf51b57b5,
N    0x7f0ec9f5, 0xf50ef5de, 0x7f0ca2c2, 0xf5029473,
N    0x7f0a7921, 0xf4f63374, 0x7f084d12, 0xf4e9d2e3,
N    0x7f061e95, 0xf4dd72be, 0x7f03eda9, 0xf4d11308,
N    0x7f01ba50, 0xf4c4b3c0, 0x7eff8489, 0xf4b854e7,
N    0x7efd4c54, 0xf4abf67e, 0x7efb11b1, 0xf49f9884,
N    0x7ef8d4a1, 0xf4933afa, 0x7ef69523, 0xf486dde1,
N    0x7ef45338, 0xf47a8139, 0x7ef20ee0, 0xf46e2504,
N    0x7eefc81a, 0xf461c940, 0x7eed7ee7, 0xf4556def,
N    0x7eeb3347, 0xf4491311, 0x7ee8e53a, 0xf43cb8a7,
N    0x7ee694c1, 0xf4305eb0, 0x7ee441da, 0xf424052f,
N    0x7ee1ec87, 0xf417ac22, 0x7edf94c7, 0xf40b538b,
N    0x7edd3a9a, 0xf3fefb6a, 0x7edade01, 0xf3f2a3bf,
N    0x7ed87efc, 0xf3e64c8c, 0x7ed61d8a, 0xf3d9f5cf,
N    0x7ed3b9ad, 0xf3cd9f8b, 0x7ed15363, 0xf3c149bf,
N    0x7eceeaad, 0xf3b4f46c, 0x7ecc7f8b, 0xf3a89f92,
N    0x7eca11fe, 0xf39c4b32, 0x7ec7a205, 0xf38ff74d,
N    0x7ec52fa0, 0xf383a3e2, 0x7ec2bad0, 0xf37750f2,
N    0x7ec04394, 0xf36afe7e, 0x7ebdc9ed, 0xf35eac86,
N    0x7ebb4ddb, 0xf3525b0b, 0x7eb8cf5d, 0xf3460a0d,
N    0x7eb64e75, 0xf339b98d, 0x7eb3cb21, 0xf32d698a,
N    0x7eb14563, 0xf3211a07, 0x7eaebd3a, 0xf314cb02,
N    0x7eac32a6, 0xf3087c7d, 0x7ea9a5a8, 0xf2fc2e77,
N    0x7ea7163f, 0xf2efe0f2, 0x7ea4846c, 0xf2e393ef,
N    0x7ea1f02f, 0xf2d7476c, 0x7e9f5988, 0xf2cafb6b,
N    0x7e9cc076, 0xf2beafed, 0x7e9a24fb, 0xf2b264f2,
N    0x7e978715, 0xf2a61a7a, 0x7e94e6c6, 0xf299d085,
N    0x7e92440d, 0xf28d8715, 0x7e8f9eeb, 0xf2813e2a,
N    0x7e8cf75f, 0xf274f5c3, 0x7e8a4d6a, 0xf268ade3,
N    0x7e87a10c, 0xf25c6688, 0x7e84f245, 0xf2501fb5,
N    0x7e824114, 0xf243d968, 0x7e7f8d7b, 0xf23793a3,
N    0x7e7cd778, 0xf22b4e66, 0x7e7a1f0d, 0xf21f09b1,
N    0x7e77643a, 0xf212c585, 0x7e74a6fd, 0xf20681e3,
N    0x7e71e759, 0xf1fa3ecb, 0x7e6f254c, 0xf1edfc3d,
N    0x7e6c60d7, 0xf1e1ba3a, 0x7e6999fa, 0xf1d578c2,
N    0x7e66d0b4, 0xf1c937d6, 0x7e640507, 0xf1bcf777,
N    0x7e6136f3, 0xf1b0b7a4, 0x7e5e6676, 0xf1a4785e,
N    0x7e5b9392, 0xf19839a6, 0x7e58be47, 0xf18bfb7d,
N    0x7e55e694, 0xf17fbde2, 0x7e530c7a, 0xf17380d6,
N    0x7e502ff9, 0xf1674459, 0x7e4d5110, 0xf15b086d,
N    0x7e4a6fc1, 0xf14ecd11, 0x7e478c0b, 0xf1429247,
N    0x7e44a5ef, 0xf136580d, 0x7e41bd6c, 0xf12a1e66,
N    0x7e3ed282, 0xf11de551, 0x7e3be532, 0xf111accf,
N    0x7e38f57c, 0xf10574e0, 0x7e360360, 0xf0f93d86,
N    0x7e330ede, 0xf0ed06bf, 0x7e3017f6, 0xf0e0d08d,
N    0x7e2d1ea8, 0xf0d49af1, 0x7e2a22f4, 0xf0c865ea,
N    0x7e2724db, 0xf0bc317a, 0x7e24245d, 0xf0affda0,
N    0x7e212179, 0xf0a3ca5d, 0x7e1e1c30, 0xf09797b2,
N    0x7e1b1482, 0xf08b659f, 0x7e180a6f, 0xf07f3424,
N    0x7e14fdf7, 0xf0730342, 0x7e11ef1b, 0xf066d2fa,
N    0x7e0eddd9, 0xf05aa34c, 0x7e0bca34, 0xf04e7438,
N    0x7e08b42a, 0xf04245c0, 0x7e059bbb, 0xf03617e2,
N    0x7e0280e9, 0xf029eaa1, 0x7dff63b2, 0xf01dbdfb,
N    0x7dfc4418, 0xf01191f3, 0x7df9221a, 0xf0056687,
N    0x7df5fdb8, 0xeff93bba, 0x7df2d6f3, 0xefed118a,
N    0x7defadca, 0xefe0e7f9, 0x7dec823e, 0xefd4bf08,
N    0x7de9544f, 0xefc896b5, 0x7de623fd, 0xefbc6f03,
N    0x7de2f148, 0xefb047f2, 0x7ddfbc30, 0xefa42181,
N    0x7ddc84b5, 0xef97fbb2, 0x7dd94ad8, 0xef8bd685,
N    0x7dd60e99, 0xef7fb1fa, 0x7dd2cff7, 0xef738e12,
N    0x7dcf8ef3, 0xef676ace, 0x7dcc4b8d, 0xef5b482d,
N    0x7dc905c5, 0xef4f2630, 0x7dc5bd9b, 0xef4304d8,
N    0x7dc2730f, 0xef36e426, 0x7dbf2622, 0xef2ac419,
N    0x7dbbd6d4, 0xef1ea4b2, 0x7db88524, 0xef1285f2,
N    0x7db53113, 0xef0667d9, 0x7db1daa2, 0xeefa4a67,
N    0x7dae81cf, 0xeeee2d9d, 0x7dab269b, 0xeee2117c,
N    0x7da7c907, 0xeed5f604, 0x7da46912, 0xeec9db35,
N    0x7da106bd, 0xeebdc110, 0x7d9da208, 0xeeb1a796,
N    0x7d9a3af2, 0xeea58ec6, 0x7d96d17d, 0xee9976a1,
N    0x7d9365a8, 0xee8d5f29, 0x7d8ff772, 0xee81485c,
N    0x7d8c86de, 0xee75323c, 0x7d8913ea, 0xee691cc9,
N    0x7d859e96, 0xee5d0804, 0x7d8226e4, 0xee50f3ed,
N    0x7d7eacd2, 0xee44e084, 0x7d7b3061, 0xee38cdcb,
N    0x7d77b192, 0xee2cbbc1, 0x7d743064, 0xee20aa67,
N    0x7d70acd7, 0xee1499bd, 0x7d6d26ec, 0xee0889c4,
N    0x7d699ea3, 0xedfc7a7c, 0x7d6613fb, 0xedf06be6,
N    0x7d6286f6, 0xede45e03, 0x7d5ef793, 0xedd850d2,
N    0x7d5b65d2, 0xedcc4454, 0x7d57d1b3, 0xedc0388a,
N    0x7d543b37, 0xedb42d74, 0x7d50a25e, 0xeda82313,
N    0x7d4d0728, 0xed9c1967, 0x7d496994, 0xed901070,
N    0x7d45c9a4, 0xed84082f, 0x7d422757, 0xed7800a5,
N    0x7d3e82ae, 0xed6bf9d1, 0x7d3adba7, 0xed5ff3b5,
N    0x7d373245, 0xed53ee51, 0x7d338687, 0xed47e9a5,
N    0x7d2fd86c, 0xed3be5b1, 0x7d2c27f6, 0xed2fe277,
N    0x7d287523, 0xed23dff7, 0x7d24bff6, 0xed17de31,
N    0x7d21086c, 0xed0bdd25, 0x7d1d4e88, 0xecffdcd4,
N    0x7d199248, 0xecf3dd3f, 0x7d15d3ad, 0xece7de66,
N    0x7d1212b7, 0xecdbe04a, 0x7d0e4f67, 0xeccfe2ea,
N    0x7d0a89bc, 0xecc3e648, 0x7d06c1b6, 0xecb7ea63,
N    0x7d02f757, 0xecabef3d, 0x7cff2a9d, 0xec9ff4d6,
N    0x7cfb5b89, 0xec93fb2e, 0x7cf78a1b, 0xec880245,
N    0x7cf3b653, 0xec7c0a1d, 0x7cefe032, 0xec7012b5,
N    0x7cec07b8, 0xec641c0e, 0x7ce82ce4, 0xec582629,
N    0x7ce44fb7, 0xec4c3106, 0x7ce07031, 0xec403ca5,
N    0x7cdc8e52, 0xec344908, 0x7cd8aa1b, 0xec28562d,
N    0x7cd4c38b, 0xec1c6417, 0x7cd0daa2, 0xec1072c4,
N    0x7cccef62, 0xec048237, 0x7cc901c9, 0xebf8926f,
N    0x7cc511d9, 0xebeca36c, 0x7cc11f90, 0xebe0b52f,
N    0x7cbd2af0, 0xebd4c7ba, 0x7cb933f9, 0xebc8db0b,
N    0x7cb53aaa, 0xebbcef23, 0x7cb13f04, 0xebb10404,
N    0x7cad4107, 0xeba519ad, 0x7ca940b3, 0xeb99301f,
N    0x7ca53e09, 0xeb8d475b, 0x7ca13908, 0xeb815f60,
N    0x7c9d31b0, 0xeb75782f, 0x7c992803, 0xeb6991ca,
N    0x7c951bff, 0xeb5dac2f, 0x7c910da5, 0xeb51c760,
N    0x7c8cfcf6, 0xeb45e35d, 0x7c88e9f1, 0xeb3a0027,
N    0x7c84d496, 0xeb2e1dbe, 0x7c80bce7, 0xeb223c22,
N    0x7c7ca2e2, 0xeb165b54, 0x7c788688, 0xeb0a7b54,
N    0x7c7467d9, 0xeafe9c24, 0x7c7046d6, 0xeaf2bdc3,
N    0x7c6c237e, 0xeae6e031, 0x7c67fdd1, 0xeadb0370,
N    0x7c63d5d1, 0xeacf277f, 0x7c5fab7c, 0xeac34c60,
N    0x7c5b7ed4, 0xeab77212, 0x7c574fd8, 0xeaab9896,
N    0x7c531e88, 0xea9fbfed, 0x7c4eeae5, 0xea93e817,
N    0x7c4ab4ef, 0xea881114, 0x7c467ca6, 0xea7c3ae5,
N    0x7c42420a, 0xea70658a, 0x7c3e051b, 0xea649105,
N    0x7c39c5da, 0xea58bd54, 0x7c358446, 0xea4cea79,
N    0x7c314060, 0xea411874, 0x7c2cfa28, 0xea354746,
N    0x7c28b19e, 0xea2976ef, 0x7c2466c2, 0xea1da770,
N    0x7c201994, 0xea11d8c8, 0x7c1bca16, 0xea060af9,
N    0x7c177845, 0xe9fa3e03, 0x7c132424, 0xe9ee71e6,
N    0x7c0ecdb2, 0xe9e2a6a3, 0x7c0a74f0, 0xe9d6dc3b,
N    0x7c0619dc, 0xe9cb12ad, 0x7c01bc78, 0xe9bf49fa,
N    0x7bfd5cc4, 0xe9b38223, 0x7bf8fac0, 0xe9a7bb28,
N    0x7bf4966c, 0xe99bf509, 0x7bf02fc9, 0xe9902fc7,
N    0x7bebc6d5, 0xe9846b63, 0x7be75b93, 0xe978a7dd,
N    0x7be2ee01, 0xe96ce535, 0x7bde7e20, 0xe961236c,
N    0x7bda0bf0, 0xe9556282, 0x7bd59771, 0xe949a278,
N    0x7bd120a4, 0xe93de34e, 0x7bcca789, 0xe9322505,
N    0x7bc82c1f, 0xe926679c, 0x7bc3ae67, 0xe91aab16,
N    0x7bbf2e62, 0xe90eef71, 0x7bbaac0e, 0xe90334af,
N    0x7bb6276e, 0xe8f77acf, 0x7bb1a080, 0xe8ebc1d3,
N    0x7bad1744, 0xe8e009ba, 0x7ba88bbc, 0xe8d45286,
N    0x7ba3fde7, 0xe8c89c37, 0x7b9f6dc5, 0xe8bce6cd,
N    0x7b9adb57, 0xe8b13248, 0x7b96469d, 0xe8a57ea9,
N    0x7b91af97, 0xe899cbf1, 0x7b8d1644, 0xe88e1a20,
N    0x7b887aa6, 0xe8826936, 0x7b83dcbc, 0xe876b934,
N    0x7b7f3c87, 0xe86b0a1a, 0x7b7a9a07, 0xe85f5be9,
N    0x7b75f53c, 0xe853aea1, 0x7b714e25, 0xe8480243,
N    0x7b6ca4c4, 0xe83c56cf, 0x7b67f919, 0xe830ac45,
N    0x7b634b23, 0xe82502a7, 0x7b5e9ae4, 0xe81959f4,
N    0x7b59e85a, 0xe80db22d, 0x7b553386, 0xe8020b52,
N    0x7b507c69, 0xe7f66564, 0x7b4bc303, 0xe7eac063,
N    0x7b470753, 0xe7df1c50, 0x7b42495a, 0xe7d3792b,
N    0x7b3d8918, 0xe7c7d6f4, 0x7b38c68e, 0xe7bc35ad,
N    0x7b3401bb, 0xe7b09555, 0x7b2f3aa0, 0xe7a4f5ed,
N    0x7b2a713d, 0xe7995776, 0x7b25a591, 0xe78db9ef,
N    0x7b20d79e, 0xe7821d59, 0x7b1c0764, 0xe77681b6,
N    0x7b1734e2, 0xe76ae704, 0x7b126019, 0xe75f4d45,
N    0x7b0d8909, 0xe753b479, 0x7b08afb2, 0xe7481ca1,
N    0x7b03d414, 0xe73c85bc, 0x7afef630, 0xe730efcc,
N    0x7afa1605, 0xe7255ad1, 0x7af53395, 0xe719c6cb,
N    0x7af04edf, 0xe70e33bb, 0x7aeb67e3, 0xe702a1a1,
N    0x7ae67ea1, 0xe6f7107e, 0x7ae1931a, 0xe6eb8052,
N    0x7adca54e, 0xe6dff11d, 0x7ad7b53d, 0xe6d462e1,
N    0x7ad2c2e8, 0xe6c8d59c, 0x7acdce4d, 0xe6bd4951,
N    0x7ac8d76f, 0xe6b1bdff, 0x7ac3de4c, 0xe6a633a6,
N    0x7abee2e5, 0xe69aaa48, 0x7ab9e53a, 0xe68f21e5,
N    0x7ab4e54c, 0xe6839a7c, 0x7aafe31b, 0xe6781410,
N    0x7aaadea6, 0xe66c8e9f, 0x7aa5d7ee, 0xe6610a2a,
N    0x7aa0cef3, 0xe65586b3, 0x7a9bc3b6, 0xe64a0438,
N    0x7a96b636, 0xe63e82bc, 0x7a91a674, 0xe633023e,
N    0x7a8c9470, 0xe62782be, 0x7a87802a, 0xe61c043d,
N    0x7a8269a3, 0xe61086bc, 0x7a7d50da, 0xe6050a3b,
N    0x7a7835cf, 0xe5f98ebb, 0x7a731884, 0xe5ee143b,
N    0x7a6df8f8, 0xe5e29abc, 0x7a68d72b, 0xe5d72240,
N    0x7a63b31d, 0xe5cbaac5, 0x7a5e8cd0, 0xe5c0344d,
N    0x7a596442, 0xe5b4bed8, 0x7a543974, 0xe5a94a67,
N    0x7a4f0c67, 0xe59dd6f9, 0x7a49dd1a, 0xe5926490,
N    0x7a44ab8e, 0xe586f32c, 0x7a3f77c3, 0xe57b82cd,
N    0x7a3a41b9, 0xe5701374, 0x7a350970, 0xe564a521,
N    0x7a2fcee8, 0xe55937d5, 0x7a2a9223, 0xe54dcb8f,
N    0x7a25531f, 0xe5426051, 0x7a2011de, 0xe536f61b,
N    0x7a1ace5f, 0xe52b8cee, 0x7a1588a2, 0xe52024c9,
N    0x7a1040a8, 0xe514bdad, 0x7a0af671, 0xe509579b,
N    0x7a05a9fd, 0xe4fdf294, 0x7a005b4d, 0xe4f28e96,
N    0x79fb0a60, 0xe4e72ba4, 0x79f5b737, 0xe4dbc9bd,
N    0x79f061d2, 0xe4d068e2, 0x79eb0a31, 0xe4c50914,
N    0x79e5b054, 0xe4b9aa52, 0x79e0543c, 0xe4ae4c9d,
N    0x79daf5e8, 0xe4a2eff6, 0x79d5955a, 0xe497945d,
N    0x79d03291, 0xe48c39d3, 0x79cacd8d, 0xe480e057,
N    0x79c5664f, 0xe47587eb, 0x79bffcd7, 0xe46a308f,
N    0x79ba9125, 0xe45eda43, 0x79b52339, 0xe4538507,
N    0x79afb313, 0xe44830dd, 0x79aa40b4, 0xe43cddc4,
N    0x79a4cc1c, 0xe4318bbe, 0x799f554b, 0xe4263ac9,
N    0x7999dc42, 0xe41aeae8, 0x799460ff, 0xe40f9c1a,
N    0x798ee385, 0xe4044e60, 0x798963d2, 0xe3f901ba,
N    0x7983e1e8, 0xe3edb628, 0x797e5dc6, 0xe3e26bac,
N    0x7978d76c, 0xe3d72245, 0x79734edc, 0xe3cbd9f4,
N    0x796dc414, 0xe3c092b9, 0x79683715, 0xe3b54c95,
N    0x7962a7e0, 0xe3aa0788, 0x795d1675, 0xe39ec393,
N    0x795782d3, 0xe39380b6, 0x7951ecfc, 0xe3883ef2,
N    0x794c54ee, 0xe37cfe47, 0x7946baac, 0xe371beb5,
N    0x79411e33, 0xe366803c, 0x793b7f86, 0xe35b42df,
N    0x7935dea4, 0xe350069b, 0x79303b8e, 0xe344cb73,
N    0x792a9642, 0xe3399167, 0x7924eec3, 0xe32e5876,
N    0x791f4510, 0xe32320a2, 0x79199929, 0xe317e9eb,
N    0x7913eb0e, 0xe30cb451, 0x790e3ac0, 0xe3017fd5,
N    0x7908883f, 0xe2f64c77, 0x7902d38b, 0xe2eb1a37,
N    0x78fd1ca4, 0xe2dfe917, 0x78f7638b, 0xe2d4b916,
N    0x78f1a840, 0xe2c98a35, 0x78ebeac2, 0xe2be5c74,
N    0x78e62b13, 0xe2b32fd4, 0x78e06932, 0xe2a80456,
N    0x78daa520, 0xe29cd9f8, 0x78d4dedd, 0xe291b0bd,
N    0x78cf1669, 0xe28688a4, 0x78c94bc4, 0xe27b61af,
N    0x78c37eef, 0xe2703bdc, 0x78bdafea, 0xe265172e,
N    0x78b7deb4, 0xe259f3a3, 0x78b20b4f, 0xe24ed13d,
N    0x78ac35ba, 0xe243affc, 0x78a65df6, 0xe2388fe1,
N    0x78a08402, 0xe22d70eb, 0x789aa7e0, 0xe222531c,
N    0x7894c98f, 0xe2173674, 0x788ee910, 0xe20c1af3,
N    0x78890663, 0xe2010099, 0x78832187, 0xe1f5e768,
N    0x787d3a7e, 0xe1eacf5f, 0x78775147, 0xe1dfb87f,
N    0x787165e3, 0xe1d4a2c8, 0x786b7852, 0xe1c98e3b,
N    0x78658894, 0xe1be7ad8, 0x785f96a9, 0xe1b368a0,
N    0x7859a292, 0xe1a85793, 0x7853ac4f, 0xe19d47b1,
N    0x784db3e0, 0xe19238fb, 0x7847b946, 0xe1872b72,
N    0x7841bc7f, 0xe17c1f15, 0x783bbd8e, 0xe17113e5,
N    0x7835bc71, 0xe16609e3, 0x782fb92a, 0xe15b0110,
N    0x7829b3b9, 0xe14ff96a, 0x7823ac1d, 0xe144f2f3,
N    0x781da256, 0xe139edac, 0x78179666, 0xe12ee995,
N    0x7811884d, 0xe123e6ad, 0x780b780a, 0xe118e4f6,
N    0x7805659e, 0xe10de470, 0x77ff5109, 0xe102e51c,
N    0x77f93a4b, 0xe0f7e6f9, 0x77f32165, 0xe0ecea09,
N    0x77ed0657, 0xe0e1ee4b, 0x77e6e921, 0xe0d6f3c1,
N    0x77e0c9c3, 0xe0cbfa6a, 0x77daa83d, 0xe0c10247,
N    0x77d48490, 0xe0b60b58, 0x77ce5ebd, 0xe0ab159e,
N    0x77c836c2, 0xe0a0211a, 0x77c20ca1, 0xe0952dcb,
N    0x77bbe05a, 0xe08a3bb2, 0x77b5b1ec, 0xe07f4acf,
N    0x77af8159, 0xe0745b24, 0x77a94ea0, 0xe0696cb0,
N    0x77a319c2, 0xe05e7f74, 0x779ce2be, 0xe053936f,
N    0x7796a996, 0xe048a8a4, 0x77906e49, 0xe03dbf11,
N    0x778a30d8, 0xe032d6b8, 0x7783f143, 0xe027ef99,
N    0x777daf89, 0xe01d09b4, 0x77776bac, 0xe012250a,
N    0x777125ac, 0xe007419b, 0x776add88, 0xdffc5f67,
N    0x77649341, 0xdff17e70, 0x775e46d8, 0xdfe69eb4,
N    0x7757f84c, 0xdfdbc036, 0x7751a79e, 0xdfd0e2f5,
N    0x774b54ce, 0xdfc606f1, 0x7744ffdd, 0xdfbb2c2c,
N    0x773ea8ca, 0xdfb052a5, 0x77384f95, 0xdfa57a5d,
N    0x7731f440, 0xdf9aa354, 0x772b96ca, 0xdf8fcd8b,
N    0x77253733, 0xdf84f902, 0x771ed57c, 0xdf7a25ba,
N    0x771871a5, 0xdf6f53b3, 0x77120bae, 0xdf6482ed,
N    0x770ba398, 0xdf59b369, 0x77053962, 0xdf4ee527,
N    0x76fecd0e, 0xdf441828, 0x76f85e9a, 0xdf394c6b,
N    0x76f1ee09, 0xdf2e81f3, 0x76eb7b58, 0xdf23b8be,
N    0x76e5068a, 0xdf18f0ce, 0x76de8f9e, 0xdf0e2a22,
N    0x76d81695, 0xdf0364bc, 0x76d19b6e, 0xdef8a09b,
N    0x76cb1e2a, 0xdeedddc0, 0x76c49ec9, 0xdee31c2b,
N    0x76be1d4c, 0xded85bdd, 0x76b799b3, 0xdecd9cd7,
N    0x76b113fd, 0xdec2df18, 0x76aa8c2c, 0xdeb822a1,
N    0x76a4023f, 0xdead6773, 0x769d7637, 0xdea2ad8d,
N    0x7696e814, 0xde97f4f1, 0x769057d6, 0xde8d3d9e,
N    0x7689c57d, 0xde828796, 0x7683310b, 0xde77d2d8,
N    0x767c9a7e, 0xde6d1f65, 0x767601d7, 0xde626d3e,
N    0x766f6717, 0xde57bc62, 0x7668ca3e, 0xde4d0cd2,
N    0x76622b4c, 0xde425e8f, 0x765b8a41, 0xde37b199,
N    0x7654e71d, 0xde2d05f1, 0x764e41e2, 0xde225b96,
N    0x76479a8e, 0xde17b28a, 0x7640f123, 0xde0d0acc,
N    0x763a45a0, 0xde02645d, 0x76339806, 0xddf7bf3e,
N    0x762ce855, 0xdded1b6e, 0x7626368d, 0xdde278ef,
N    0x761f82af, 0xddd7d7c1, 0x7618ccba, 0xddcd37e4,
N    0x761214b0, 0xddc29958, 0x760b5a90, 0xddb7fc1e,
N    0x76049e5b, 0xddad6036, 0x75fde011, 0xdda2c5a2,
N    0x75f71fb1, 0xdd982c60, 0x75f05d3d, 0xdd8d9472,
N    0x75e998b5, 0xdd82fdd8, 0x75e2d219, 0xdd786892,
N    0x75dc0968, 0xdd6dd4a2, 0x75d53ea5, 0xdd634206,
N    0x75ce71ce, 0xdd58b0c0, 0x75c7a2e3, 0xdd4e20d0,
N    0x75c0d1e7, 0xdd439236, 0x75b9fed7, 0xdd3904f4,
N    0x75b329b5, 0xdd2e7908, 0x75ac5282, 0xdd23ee74,
N    0x75a5793c, 0xdd196538, 0x759e9de5, 0xdd0edd55,
N    0x7597c07d, 0xdd0456ca, 0x7590e104, 0xdcf9d199,
N    0x7589ff7a, 0xdcef4dc2, 0x75831be0, 0xdce4cb44,
N    0x757c3636, 0xdcda4a21, 0x75754e7c, 0xdccfca59,
N    0x756e64b2, 0xdcc54bec, 0x756778d9, 0xdcbacedb,
N    0x75608af1, 0xdcb05326, 0x75599afa, 0xdca5d8cd,
N    0x7552a8f4, 0xdc9b5fd2, 0x754bb4e1, 0xdc90e834,
N    0x7544bebf, 0xdc8671f3, 0x753dc68f, 0xdc7bfd11,
N    0x7536cc52, 0xdc71898d, 0x752fd008, 0xdc671768,
N    0x7528d1b1, 0xdc5ca6a2, 0x7521d14d, 0xdc52373c,
N    0x751acedd, 0xdc47c936, 0x7513ca60, 0xdc3d5c91,
N    0x750cc3d8, 0xdc32f14d, 0x7505bb44, 0xdc28876a,
N    0x74feb0a5, 0xdc1e1ee9, 0x74f7a3fb, 0xdc13b7c9,
N    0x74f09546, 0xdc09520d, 0x74e98487, 0xdbfeedb3,
N    0x74e271bd, 0xdbf48abd, 0x74db5cea, 0xdbea292b,
N    0x74d4460c, 0xdbdfc8fc, 0x74cd2d26, 0xdbd56a32,
N    0x74c61236, 0xdbcb0cce, 0x74bef53d, 0xdbc0b0ce,
N    0x74b7d63c, 0xdbb65634, 0x74b0b533, 0xdbabfd01,
N    0x74a99221, 0xdba1a534, 0x74a26d08, 0xdb974ece,
N    0x749b45e7, 0xdb8cf9cf, 0x74941cbf, 0xdb82a638,
N    0x748cf190, 0xdb785409, 0x7485c45b, 0xdb6e0342,
N    0x747e951f, 0xdb63b3e5, 0x747763dd, 0xdb5965f1,
N    0x74703095, 0xdb4f1967, 0x7468fb47, 0xdb44ce46,
N    0x7461c3f5, 0xdb3a8491, 0x745a8a9d, 0xdb303c46,
N    0x74534f41, 0xdb25f566, 0x744c11e0, 0xdb1baff2,
N    0x7444d27b, 0xdb116beb, 0x743d9112, 0xdb072950,
N    0x74364da6, 0xdafce821, 0x742f0836, 0xdaf2a860,
N    0x7427c0c3, 0xdae86a0d, 0x7420774d, 0xdade2d28,
N    0x74192bd5, 0xdad3f1b1, 0x7411de5b, 0xdac9b7a9,
N    0x740a8edf, 0xdabf7f11, 0x74033d61, 0xdab547e8,
N    0x73fbe9e2, 0xdaab122f, 0x73f49462, 0xdaa0dde7,
N    0x73ed3ce1, 0xda96ab0f, 0x73e5e360, 0xda8c79a9,
N    0x73de87de, 0xda8249b4, 0x73d72a5d, 0xda781b31,
N    0x73cfcadc, 0xda6dee21, 0x73c8695b, 0xda63c284,
N    0x73c105db, 0xda599859, 0x73b9a05d, 0xda4f6fa3,
N    0x73b238e0, 0xda454860, 0x73aacf65, 0xda3b2292,
N    0x73a363ec, 0xda30fe38, 0x739bf675, 0xda26db54,
N    0x73948701, 0xda1cb9e5, 0x738d1590, 0xda1299ec,
N    0x7385a222, 0xda087b69, 0x737e2cb7, 0xd9fe5e5e,
N    0x7376b551, 0xd9f442c9, 0x736f3bee, 0xd9ea28ac,
N    0x7367c090, 0xd9e01006, 0x73604336, 0xd9d5f8d9,
N    0x7358c3e2, 0xd9cbe325, 0x73514292, 0xd9c1cee9,
N    0x7349bf48, 0xd9b7bc27, 0x73423a04, 0xd9adaadf,
N    0x733ab2c6, 0xd9a39b11, 0x7333298f, 0xd9998cbe,
N    0x732b9e5e, 0xd98f7fe6, 0x73241134, 0xd9857489,
N    0x731c8211, 0xd97b6aa8, 0x7314f0f6, 0xd9716243,
N    0x730d5de3, 0xd9675b5a, 0x7305c8d7, 0xd95d55ef,
N    0x72fe31d5, 0xd9535201, 0x72f698db, 0xd9494f90,
N    0x72eefdea, 0xd93f4e9e, 0x72e76102, 0xd9354f2a,
N    0x72dfc224, 0xd92b5135, 0x72d82150, 0xd92154bf,
N    0x72d07e85, 0xd91759c9, 0x72c8d9c6, 0xd90d6053,
N    0x72c13311, 0xd903685d, 0x72b98a67, 0xd8f971e8,
N    0x72b1dfc9, 0xd8ef7cf4, 0x72aa3336, 0xd8e58982,
N    0x72a284b0, 0xd8db9792, 0x729ad435, 0xd8d1a724,
N    0x729321c7, 0xd8c7b838, 0x728b6d66, 0xd8bdcad0,
N    0x7283b712, 0xd8b3deeb, 0x727bfecc, 0xd8a9f48a,
N    0x72744493, 0xd8a00bae, 0x726c8868, 0xd8962456,
N    0x7264ca4c, 0xd88c3e83, 0x725d0a3e, 0xd8825a35,
N    0x72554840, 0xd878776d, 0x724d8450, 0xd86e962b,
N    0x7245be70, 0xd864b670, 0x723df6a0, 0xd85ad83c,
N    0x72362ce0, 0xd850fb8e, 0x722e6130, 0xd8472069,
N    0x72269391, 0xd83d46cc, 0x721ec403, 0xd8336eb7,
N    0x7216f287, 0xd829982b, 0x720f1f1c, 0xd81fc328,
N    0x720749c3, 0xd815efae, 0x71ff727c, 0xd80c1dbf,
N    0x71f79948, 0xd8024d59, 0x71efbe27, 0xd7f87e7f,
N    0x71e7e118, 0xd7eeb130, 0x71e0021e, 0xd7e4e56c,
N    0x71d82137, 0xd7db1b34, 0x71d03e64, 0xd7d15288,
N    0x71c859a5, 0xd7c78b68, 0x71c072fb, 0xd7bdc5d6,
N    0x71b88a66, 0xd7b401d1, 0x71b09fe7, 0xd7aa3f5a,
N    0x71a8b37c, 0xd7a07e70, 0x71a0c528, 0xd796bf16,
N    0x7198d4ea, 0xd78d014a, 0x7190e2c3, 0xd783450d,
N    0x7188eeb2, 0xd7798a60, 0x7180f8b8, 0xd76fd143,
N    0x717900d6, 0xd76619b6, 0x7171070c, 0xd75c63ba,
N    0x71690b59, 0xd752af4f, 0x71610dbf, 0xd748fc75,
N    0x71590e3e, 0xd73f4b2e, 0x71510cd5, 0xd7359b78,
N    0x71490986, 0xd72bed55, 0x71410450, 0xd72240c5,
N    0x7138fd35, 0xd71895c9, 0x7130f433, 0xd70eec60,
N    0x7128e94c, 0xd705448b, 0x7120dc80, 0xd6fb9e4b,
N    0x7118cdcf, 0xd6f1f99f, 0x7110bd39, 0xd6e85689,
N    0x7108aabf, 0xd6deb508, 0x71009661, 0xd6d5151d,
N    0x70f8801f, 0xd6cb76c9, 0x70f067fb, 0xd6c1da0b,
N    0x70e84df3, 0xd6b83ee4, 0x70e03208, 0xd6aea555,
N    0x70d8143b, 0xd6a50d5d, 0x70cff48c, 0xd69b76fe,
N    0x70c7d2fb, 0xd691e237, 0x70bfaf89, 0xd6884f09,
N    0x70b78a36, 0xd67ebd74, 0x70af6302, 0xd6752d79,
N    0x70a739ed, 0xd66b9f18, 0x709f0ef8, 0xd6621251,
N    0x7096e223, 0xd6588725, 0x708eb36f, 0xd64efd94,
N    0x708682dc, 0xd645759f, 0x707e5069, 0xd63bef46,
N    0x70761c18, 0xd6326a88, 0x706de5e9, 0xd628e767,
N    0x7065addb, 0xd61f65e4, 0x705d73f0, 0xd615e5fd,
N    0x70553828, 0xd60c67b4, 0x704cfa83, 0xd602eb0a,
N    0x7044bb00, 0xd5f96ffd, 0x703c79a2, 0xd5eff690,
N    0x70343667, 0xd5e67ec1, 0x702bf151, 0xd5dd0892,
N    0x7023aa5f, 0xd5d39403, 0x701b6193, 0xd5ca2115,
N    0x701316eb, 0xd5c0afc6, 0x700aca69, 0xd5b74019,
N    0x70027c0c, 0xd5add20d, 0x6ffa2bd6, 0xd5a465a3,
N    0x6ff1d9c7, 0xd59afadb, 0x6fe985de, 0xd59191b5,
N    0x6fe1301c, 0xd5882a32, 0x6fd8d882, 0xd57ec452,
N    0x6fd07f0f, 0xd5756016, 0x6fc823c5, 0xd56bfd7d,
N    0x6fbfc6a3, 0xd5629c89, 0x6fb767aa, 0xd5593d3a,
N    0x6faf06da, 0xd54fdf8f, 0x6fa6a433, 0xd5468389,
N    0x6f9e3fb6, 0xd53d292a, 0x6f95d963, 0xd533d070,
N    0x6f8d713a, 0xd52a795d, 0x6f85073c, 0xd52123f0,
N    0x6f7c9b69, 0xd517d02b, 0x6f742dc1, 0xd50e7e0d,
N    0x6f6bbe45, 0xd5052d97, 0x6f634cf5, 0xd4fbdec9,
N    0x6f5ad9d1, 0xd4f291a4, 0x6f5264da, 0xd4e94627,
N    0x6f49ee0f, 0xd4dffc54, 0x6f417573, 0xd4d6b42b,
N    0x6f38fb03, 0xd4cd6dab, 0x6f307ec2, 0xd4c428d6,
N    0x6f2800af, 0xd4bae5ab, 0x6f1f80ca, 0xd4b1a42c,
N    0x6f16ff14, 0xd4a86458, 0x6f0e7b8e, 0xd49f2630,
N    0x6f05f637, 0xd495e9b3, 0x6efd6f10, 0xd48caee4,
N    0x6ef4e619, 0xd48375c1, 0x6eec5b53, 0xd47a3e4b,
N    0x6ee3cebe, 0xd4710883, 0x6edb405a, 0xd467d469,
N    0x6ed2b027, 0xd45ea1fd, 0x6eca1e27, 0xd4557140,
N    0x6ec18a58, 0xd44c4232, 0x6eb8f4bc, 0xd44314d3,
N    0x6eb05d53, 0xd439e923, 0x6ea7c41e, 0xd430bf24,
N    0x6e9f291b, 0xd42796d5, 0x6e968c4d, 0xd41e7037,
N    0x6e8dedb3, 0xd4154b4a, 0x6e854d4d, 0xd40c280e,
N    0x6e7cab1c, 0xd4030684, 0x6e740720, 0xd3f9e6ad,
N    0x6e6b615a, 0xd3f0c887, 0x6e62b9ca, 0xd3e7ac15,
N    0x6e5a1070, 0xd3de9156, 0x6e51654c, 0xd3d5784a,
N    0x6e48b860, 0xd3cc60f2, 0x6e4009aa, 0xd3c34b4f,
N    0x6e37592c, 0xd3ba3760, 0x6e2ea6e6, 0xd3b12526,
N    0x6e25f2d8, 0xd3a814a2, 0x6e1d3d03, 0xd39f05d3,
N    0x6e148566, 0xd395f8ba, 0x6e0bcc03, 0xd38ced57,
N    0x6e0310d9, 0xd383e3ab, 0x6dfa53e9, 0xd37adbb6,
N    0x6df19534, 0xd371d579, 0x6de8d4b8, 0xd368d0f3,
N    0x6de01278, 0xd35fce26, 0x6dd74e73, 0xd356cd11,
N    0x6dce88aa, 0xd34dcdb4, 0x6dc5c11c, 0xd344d011,
N    0x6dbcf7cb, 0xd33bd427, 0x6db42cb6, 0xd332d9f7,
N    0x6dab5fdf, 0xd329e181, 0x6da29144, 0xd320eac6,
N    0x6d99c0e7, 0xd317f5c6, 0x6d90eec8, 0xd30f0280,
N    0x6d881ae8, 0xd30610f7, 0x6d7f4545, 0xd2fd2129,
N    0x6d766de2, 0xd2f43318, 0x6d6d94bf, 0xd2eb46c3,
N    0x6d64b9da, 0xd2e25c2b, 0x6d5bdd36, 0xd2d97350,
N    0x6d52fed2, 0xd2d08c33, 0x6d4a1eaf, 0xd2c7a6d4,
N    0x6d413ccd, 0xd2bec333, 0x6d38592c, 0xd2b5e151,
N    0x6d2f73cd, 0xd2ad012e, 0x6d268cb0, 0xd2a422ca,
N    0x6d1da3d5, 0xd29b4626, 0x6d14b93d, 0xd2926b41,
N    0x6d0bcce8, 0xd289921e, 0x6d02ded7, 0xd280babb,
N    0x6cf9ef09, 0xd277e518, 0x6cf0fd80, 0xd26f1138,
N    0x6ce80a3a, 0xd2663f19, 0x6cdf153a, 0xd25d6ebc,
N    0x6cd61e7f, 0xd254a021, 0x6ccd2609, 0xd24bd34a,
N    0x6cc42bd9, 0xd2430835, 0x6cbb2fef, 0xd23a3ee4,
N    0x6cb2324c, 0xd2317756, 0x6ca932ef, 0xd228b18d,
N    0x6ca031da, 0xd21fed88, 0x6c972f0d, 0xd2172b48,
N    0x6c8e2a87, 0xd20e6acc, 0x6c85244a, 0xd205ac17,
N    0x6c7c1c55, 0xd1fcef27, 0x6c7312a9, 0xd1f433fd,
N    0x6c6a0746, 0xd1eb7a9a, 0x6c60fa2d, 0xd1e2c2fd,
N    0x6c57eb5e, 0xd1da0d28, 0x6c4edada, 0xd1d1591a,
N    0x6c45c8a0, 0xd1c8a6d4, 0x6c3cb4b1, 0xd1bff656,
N    0x6c339f0e, 0xd1b747a0, 0x6c2a87b6, 0xd1ae9ab4,
N    0x6c216eaa, 0xd1a5ef90, 0x6c1853eb, 0xd19d4636,
N    0x6c0f3779, 0xd1949ea6, 0x6c061953, 0xd18bf8e0,
N    0x6bfcf97c, 0xd18354e4, 0x6bf3d7f2, 0xd17ab2b3,
N    0x6beab4b6, 0xd172124d, 0x6be18fc9, 0xd16973b3,
N    0x6bd8692b, 0xd160d6e5, 0x6bcf40dc, 0xd1583be2,
N    0x6bc616dd, 0xd14fa2ad, 0x6bbceb2d, 0xd1470b44,
N    0x6bb3bdce, 0xd13e75a8, 0x6baa8ec0, 0xd135e1d9,
N    0x6ba15e03, 0xd12d4fd9, 0x6b982b97, 0xd124bfa6,
N    0x6b8ef77d, 0xd11c3142, 0x6b85c1b5, 0xd113a4ad,
N    0x6b7c8a3f, 0xd10b19e7, 0x6b73511c, 0xd10290f0,
N    0x6b6a164d, 0xd0fa09c9, 0x6b60d9d0, 0xd0f18472,
N    0x6b579ba8, 0xd0e900ec, 0x6b4e5bd4, 0xd0e07f36,
N    0x6b451a55, 0xd0d7ff51, 0x6b3bd72a, 0xd0cf813e,
N    0x6b329255, 0xd0c704fd, 0x6b294bd5, 0xd0be8a8d,
N    0x6b2003ac, 0xd0b611f1, 0x6b16b9d9, 0xd0ad9b26,
N    0x6b0d6e5c, 0xd0a5262f, 0x6b042137, 0xd09cb30b,
N    0x6afad269, 0xd09441bb, 0x6af181f3, 0xd08bd23f,
N    0x6ae82fd5, 0xd0836497, 0x6adedc10, 0xd07af8c4,
N    0x6ad586a3, 0xd0728ec6, 0x6acc2f90, 0xd06a269d,
N    0x6ac2d6d6, 0xd061c04a, 0x6ab97c77, 0xd0595bcd,
N    0x6ab02071, 0xd050f926, 0x6aa6c2c6, 0xd0489856,
N    0x6a9d6377, 0xd040395d, 0x6a940283, 0xd037dc3b,
N    0x6a8a9fea, 0xd02f80f1, 0x6a813bae, 0xd027277e,
N    0x6a77d5ce, 0xd01ecfe4, 0x6a6e6e4b, 0xd0167a22,
N    0x6a650525, 0xd00e2639, 0x6a5b9a5d, 0xd005d42a,
N    0x6a522df3, 0xcffd83f4, 0x6a48bfe7, 0xcff53597,
N    0x6a3f503a, 0xcfece915, 0x6a35deeb, 0xcfe49e6d,
N    0x6a2c6bfd, 0xcfdc55a1, 0x6a22f76e, 0xcfd40eaf,
N    0x6a19813f, 0xcfcbc999, 0x6a100970, 0xcfc3865e,
N    0x6a069003, 0xcfbb4500, 0x69fd14f6, 0xcfb3057d,
N    0x69f3984c, 0xcfaac7d8, 0x69ea1a03, 0xcfa28c10,
N    0x69e09a1c, 0xcf9a5225, 0x69d71899, 0xcf921a17,
N    0x69cd9578, 0xcf89e3e8, 0x69c410ba, 0xcf81af97,
N    0x69ba8a61, 0xcf797d24, 0x69b1026c, 0xcf714c91,
N    0x69a778db, 0xcf691ddd, 0x699dedaf, 0xcf60f108,
N    0x699460e8, 0xcf58c613, 0x698ad287, 0xcf509cfe,
N    0x6981428c, 0xcf4875ca, 0x6977b0f7, 0xcf405077,
N    0x696e1dc9, 0xcf382d05, 0x69648902, 0xcf300b74,
N    0x695af2a3, 0xcf27ebc5, 0x69515aab, 0xcf1fcdf8,
N    0x6947c11c, 0xcf17b20d, 0x693e25f5, 0xcf0f9805,
N    0x69348937, 0xcf077fe1, 0x692aeae3, 0xceff699f,
N    0x69214af8, 0xcef75541, 0x6917a977, 0xceef42c7,
N    0x690e0661, 0xcee73231, 0x690461b5, 0xcedf2380,
N    0x68fabb75, 0xced716b4, 0x68f113a0, 0xcecf0bcd,
N    0x68e76a37, 0xcec702cb, 0x68ddbf3b, 0xcebefbb0,
N    0x68d412ab, 0xceb6f67a, 0x68ca6488, 0xceaef32b,
N    0x68c0b4d2, 0xcea6f1c2, 0x68b7038b, 0xce9ef241,
N    0x68ad50b1, 0xce96f4a7, 0x68a39c46, 0xce8ef8f4,
N    0x6899e64a, 0xce86ff2a, 0x68902ebd, 0xce7f0748,
N    0x688675a0, 0xce77114e, 0x687cbaf3, 0xce6f1d3d,
N    0x6872feb6, 0xce672b16, 0x686940ea, 0xce5f3ad8,
N    0x685f8190, 0xce574c84, 0x6855c0a6, 0xce4f6019,
N    0x684bfe2f, 0xce47759a, 0x68423a2a, 0xce3f8d05,
N    0x68387498, 0xce37a65b, 0x682ead78, 0xce2fc19c,
N    0x6824e4cc, 0xce27dec9, 0x681b1a94, 0xce1ffde2,
N    0x68114ed0, 0xce181ee8, 0x68078181, 0xce1041d9,
N    0x67fdb2a7, 0xce0866b8, 0x67f3e241, 0xce008d84,
N    0x67ea1052, 0xcdf8b63d, 0x67e03cd8, 0xcdf0e0e4,
N    0x67d667d5, 0xcde90d79, 0x67cc9149, 0xcde13bfd,
N    0x67c2b934, 0xcdd96c6f, 0x67b8df97, 0xcdd19ed0,
N    0x67af0472, 0xcdc9d320, 0x67a527c4, 0xcdc20960,
N    0x679b4990, 0xcdba4190, 0x679169d5, 0xcdb27bb0,
N    0x67878893, 0xcdaab7c0, 0x677da5cb, 0xcda2f5c2,
N    0x6773c17d, 0xcd9b35b4, 0x6769dbaa, 0xcd937798,
N    0x675ff452, 0xcd8bbb6d, 0x67560b76, 0xcd840134,
N    0x674c2115, 0xcd7c48ee, 0x67423530, 0xcd74929a,
N    0x673847c8, 0xcd6cde39, 0x672e58dc, 0xcd652bcb,
N    0x6724686e, 0xcd5d7b50, 0x671a767e, 0xcd55ccca,
N    0x6710830c, 0xcd4e2037, 0x67068e18, 0xcd467599,
N    0x66fc97a3, 0xcd3eccef, 0x66f29fad, 0xcd37263a,
N    0x66e8a637, 0xcd2f817b, 0x66deab41, 0xcd27deb0,
N    0x66d4aecb, 0xcd203ddc, 0x66cab0d6, 0xcd189efe,
N    0x66c0b162, 0xcd110216, 0x66b6b070, 0xcd096725,
N    0x66acadff, 0xcd01ce2b, 0x66a2aa11, 0xccfa3729,
N    0x6698a4a6, 0xccf2a21d, 0x668e9dbd, 0xcceb0f0a,
N    0x66849558, 0xcce37def, 0x667a8b77, 0xccdbeecc,
N    0x6670801a, 0xccd461a2, 0x66667342, 0xccccd671,
N    0x665c64ef, 0xccc54d3a, 0x66525521, 0xccbdc5fc,
N    0x664843d9, 0xccb640b8, 0x663e3117, 0xccaebd6e,
N    0x66341cdb, 0xcca73c1e, 0x662a0727, 0xcc9fbcca,
N    0x661feffa, 0xcc983f70, 0x6615d754, 0xcc90c412,
N    0x660bbd37, 0xcc894aaf, 0x6601a1a2, 0xcc81d349,
N    0x65f78497, 0xcc7a5dde, 0x65ed6614, 0xcc72ea70,
N    0x65e3461b, 0xcc6b78ff, 0x65d924ac, 0xcc64098b,
N    0x65cf01c8, 0xcc5c9c14, 0x65c4dd6e, 0xcc55309b,
N    0x65bab7a0, 0xcc4dc720, 0x65b0905d, 0xcc465fa3,
N    0x65a667a7, 0xcc3efa25, 0x659c3d7c, 0xcc3796a5,
N    0x659211df, 0xcc303524, 0x6587e4cf, 0xcc28d5a3,
N    0x657db64c, 0xcc217822, 0x65738657, 0xcc1a1ca0,
N    0x656954f1, 0xcc12c31f, 0x655f2219, 0xcc0b6b9e,
N    0x6554edd1, 0xcc04161e, 0x654ab818, 0xcbfcc29f,
N    0x654080ef, 0xcbf57121, 0x65364857, 0xcbee21a5,
N    0x652c0e4f, 0xcbe6d42b, 0x6521d2d8, 0xcbdf88b3,
N    0x651795f3, 0xcbd83f3d, 0x650d57a0, 0xcbd0f7ca,
N    0x650317df, 0xcbc9b25a, 0x64f8d6b0, 0xcbc26eee,
N    0x64ee9415, 0xcbbb2d85, 0x64e4500e, 0xcbb3ee20,
N    0x64da0a9a, 0xcbacb0bf, 0x64cfc3ba, 0xcba57563,
N    0x64c57b6f, 0xcb9e3c0b, 0x64bb31ba, 0xcb9704b9,
N    0x64b0e699, 0xcb8fcf6b, 0x64a69a0f, 0xcb889c23,
N    0x649c4c1b, 0xcb816ae1, 0x6491fcbe, 0xcb7a3ba5,
N    0x6487abf7, 0xcb730e70, 0x647d59c8, 0xcb6be341,
N    0x64730631, 0xcb64ba19, 0x6468b132, 0xcb5d92f8,
N    0x645e5acc, 0xcb566ddf, 0x645402ff, 0xcb4f4acd,
N    0x6449a9cc, 0xcb4829c4, 0x643f4f32, 0xcb410ac3,
N    0x6434f332, 0xcb39edca, 0x642a95ce, 0xcb32d2da,
N    0x64203704, 0xcb2bb9f4, 0x6415d6d5, 0xcb24a316,
N    0x640b7543, 0xcb1d8e43, 0x6401124d, 0xcb167b79,
N    0x63f6adf3, 0xcb0f6aba, 0x63ec4837, 0xcb085c05,
N    0x63e1e117, 0xcb014f5b, 0x63d77896, 0xcafa44bc,
N    0x63cd0eb3, 0xcaf33c28, 0x63c2a36f, 0xcaec35a0,
N    0x63b836ca, 0xcae53123, 0x63adc8c4, 0xcade2eb3,
N    0x63a3595e, 0xcad72e4f, 0x6398e898, 0xcad02ff8,
N    0x638e7673, 0xcac933ae, 0x638402ef, 0xcac23971,
N    0x63798e0d, 0xcabb4141, 0x636f17cc, 0xcab44b1f,
N    0x6364a02e, 0xcaad570c, 0x635a2733, 0xcaa66506,
N    0x634facda, 0xca9f750f, 0x63453125, 0xca988727,
N    0x633ab414, 0xca919b4e, 0x633035a7, 0xca8ab184,
N    0x6325b5df, 0xca83c9ca, 0x631b34bc, 0xca7ce420,
N    0x6310b23e, 0xca760086, 0x63062e67, 0xca6f1efc,
N    0x62fba936, 0xca683f83, 0x62f122ab, 0xca61621b,
N    0x62e69ac8, 0xca5a86c4, 0x62dc118c, 0xca53ad7e,
N    0x62d186f8, 0xca4cd64b, 0x62c6fb0c, 0xca460129,
N    0x62bc6dca, 0xca3f2e19, 0x62b1df30, 0xca385d1d,
N    0x62a74f40, 0xca318e32, 0x629cbdfa, 0xca2ac15b,
N    0x62922b5e, 0xca23f698, 0x6287976e, 0xca1d2de7,
N    0x627d0228, 0xca16674b, 0x62726b8e, 0xca0fa2c3,
N    0x6267d3a0, 0xca08e04f, 0x625d3a5e, 0xca021fef,
N    0x62529fca, 0xc9fb61a5, 0x624803e2, 0xc9f4a570,
N    0x623d66a8, 0xc9edeb50, 0x6232c81c, 0xc9e73346,
N    0x6228283f, 0xc9e07d51, 0x621d8711, 0xc9d9c973,
N    0x6212e492, 0xc9d317ab, 0x620840c2, 0xc9cc67fa,
N    0x61fd9ba3, 0xc9c5ba60, 0x61f2f534, 0xc9bf0edd,
N    0x61e84d76, 0xc9b86572, 0x61dda46a, 0xc9b1be1e,
N    0x61d2fa0f, 0xc9ab18e3, 0x61c84e67, 0xc9a475bf,
N    0x61bda171, 0xc99dd4b4, 0x61b2f32e, 0xc99735c2,
N    0x61a8439e, 0xc99098e9, 0x619d92c2, 0xc989fe29,
N    0x6192e09b, 0xc9836582, 0x61882d28, 0xc97ccef5,
N    0x617d786a, 0xc9763a83, 0x6172c262, 0xc96fa82a,
N    0x61680b0f, 0xc96917ec, 0x615d5273, 0xc96289c9,
N    0x6152988d, 0xc95bfdc1, 0x6147dd5f, 0xc95573d4,
N    0x613d20e8, 0xc94eec03, 0x61326329, 0xc948664d,
N    0x6127a423, 0xc941e2b4, 0x611ce3d5, 0xc93b6137,
N    0x61122240, 0xc934e1d6, 0x61075f65, 0xc92e6492,
N    0x60fc9b44, 0xc927e96b, 0x60f1d5de, 0xc9217062,
N    0x60e70f32, 0xc91af976, 0x60dc4742, 0xc91484a8,
N    0x60d17e0d, 0xc90e11f7, 0x60c6b395, 0xc907a166,
N    0x60bbe7d8, 0xc90132f2, 0x60b11ad9, 0xc8fac69e,
N    0x60a64c97, 0xc8f45c68, 0x609b7d13, 0xc8edf452,
N    0x6090ac4d, 0xc8e78e5b, 0x6085da46, 0xc8e12a84,
N    0x607b06fe, 0xc8dac8cd, 0x60703275, 0xc8d46936,
N    0x60655cac, 0xc8ce0bc0, 0x605a85a3, 0xc8c7b06b,
N    0x604fad5b, 0xc8c15736, 0x6044d3d4, 0xc8bb0023,
N    0x6039f90f, 0xc8b4ab32, 0x602f1d0b, 0xc8ae5862,
N    0x60243fca, 0xc8a807b4, 0x6019614c, 0xc8a1b928,
N    0x600e8190, 0xc89b6cbf, 0x6003a099, 0xc8952278,
N    0x5ff8be65, 0xc88eda54, 0x5feddaf6, 0xc8889454,
N    0x5fe2f64c, 0xc8825077, 0x5fd81067, 0xc87c0ebd,
N    0x5fcd2948, 0xc875cf28, 0x5fc240ef, 0xc86f91b7,
N    0x5fb7575c, 0xc869566a, 0x5fac6c91, 0xc8631d42,
N    0x5fa1808c, 0xc85ce63e, 0x5f969350, 0xc856b160,
N    0x5f8ba4dc, 0xc8507ea7, 0x5f80b531, 0xc84a4e14,
N    0x5f75c44e, 0xc8441fa6, 0x5f6ad235, 0xc83df35f,
N    0x5f5fdee6, 0xc837c93e, 0x5f54ea62, 0xc831a143,
N    0x5f49f4a8, 0xc82b7b70, 0x5f3efdb9, 0xc82557c3,
N    0x5f340596, 0xc81f363d, 0x5f290c3f, 0xc81916df,
N    0x5f1e11b5, 0xc812f9a9, 0x5f1315f7, 0xc80cde9b,
N    0x5f081907, 0xc806c5b5, 0x5efd1ae4, 0xc800aef7,
N    0x5ef21b90, 0xc7fa9a62, 0x5ee71b0a, 0xc7f487f6,
N    0x5edc1953, 0xc7ee77b3, 0x5ed1166b, 0xc7e8699a,
N    0x5ec61254, 0xc7e25daa, 0x5ebb0d0d, 0xc7dc53e3,
N    0x5eb00696, 0xc7d64c47, 0x5ea4fef0, 0xc7d046d6,
N    0x5e99f61d, 0xc7ca438f, 0x5e8eec1b, 0xc7c44272,
N    0x5e83e0eb, 0xc7be4381, 0x5e78d48e, 0xc7b846ba,
N    0x5e6dc705, 0xc7b24c20, 0x5e62b84f, 0xc7ac53b1,
N    0x5e57a86d, 0xc7a65d6e, 0x5e4c9760, 0xc7a06957,
N    0x5e418528, 0xc79a776c, 0x5e3671c5, 0xc79487ae,
N    0x5e2b5d38, 0xc78e9a1d, 0x5e204781, 0xc788aeb9,
N    0x5e1530a1, 0xc782c582, 0x5e0a1898, 0xc77cde79,
N    0x5dfeff67, 0xc776f99d, 0x5df3e50d, 0xc77116f0,
N    0x5de8c98c, 0xc76b3671, 0x5dddace4, 0xc7655820,
N    0x5dd28f15, 0xc75f7bfe, 0x5dc7701f, 0xc759a20a,
N    0x5dbc5004, 0xc753ca46, 0x5db12ec3, 0xc74df4b1,
N    0x5da60c5d, 0xc748214c, 0x5d9ae8d2, 0xc7425016,
N    0x5d8fc424, 0xc73c8111, 0x5d849e51, 0xc736b43c,
N    0x5d79775c, 0xc730e997, 0x5d6e4f43, 0xc72b2123,
N    0x5d632608, 0xc7255ae0, 0x5d57fbaa, 0xc71f96ce,
N    0x5d4cd02c, 0xc719d4ed, 0x5d41a38c, 0xc714153e,
N    0x5d3675cb, 0xc70e57c0, 0x5d2b46ea, 0xc7089c75,
N    0x5d2016e9, 0xc702e35c, 0x5d14e5c9, 0xc6fd2c75,
N    0x5d09b389, 0xc6f777c1, 0x5cfe802b, 0xc6f1c540,
N    0x5cf34baf, 0xc6ec14f2, 0x5ce81615, 0xc6e666d7,
N    0x5cdcdf5e, 0xc6e0baf0, 0x5cd1a78a, 0xc6db113d,
N    0x5cc66e99, 0xc6d569be, 0x5cbb348d, 0xc6cfc472,
N    0x5caff965, 0xc6ca215c, 0x5ca4bd21, 0xc6c4807a,
N    0x5c997fc4, 0xc6bee1cd, 0x5c8e414b, 0xc6b94554,
N    0x5c8301b9, 0xc6b3ab12, 0x5c77c10e, 0xc6ae1304,
N    0x5c6c7f4a, 0xc6a87d2d, 0x5c613c6d, 0xc6a2e98b,
N    0x5c55f878, 0xc69d5820, 0x5c4ab36b, 0xc697c8eb,
N    0x5c3f6d47, 0xc6923bec, 0x5c34260c, 0xc68cb124,
N    0x5c28ddbb, 0xc6872894, 0x5c1d9454, 0xc681a23a,
N    0x5c1249d8, 0xc67c1e18, 0x5c06fe46, 0xc6769c2e,
N    0x5bfbb1a0, 0xc6711c7b, 0x5bf063e6, 0xc66b9f01,
N    0x5be51518, 0xc66623be, 0x5bd9c537, 0xc660aab5,
N    0x5bce7442, 0xc65b33e4, 0x5bc3223c, 0xc655bf4c,
N    0x5bb7cf23, 0xc6504ced, 0x5bac7af9, 0xc64adcc7,
N    0x5ba125bd, 0xc6456edb, 0x5b95cf71, 0xc6400329,
N    0x5b8a7815, 0xc63a99b1, 0x5b7f1fa9, 0xc6353273,
N    0x5b73c62d, 0xc62fcd6f, 0x5b686ba3, 0xc62a6aa6,
N    0x5b5d100a, 0xc6250a18, 0x5b51b363, 0xc61fabc4,
N    0x5b4655ae, 0xc61a4fac, 0x5b3af6ec, 0xc614f5cf,
N    0x5b2f971e, 0xc60f9e2e, 0x5b243643, 0xc60a48c9,
N    0x5b18d45c, 0xc604f5a0, 0x5b0d716a, 0xc5ffa4b3,
N    0x5b020d6c, 0xc5fa5603, 0x5af6a865, 0xc5f5098f,
N    0x5aeb4253, 0xc5efbf58, 0x5adfdb37, 0xc5ea775e,
N    0x5ad47312, 0xc5e531a1, 0x5ac909e5, 0xc5dfee22,
N    0x5abd9faf, 0xc5daace1, 0x5ab23471, 0xc5d56ddd,
N    0x5aa6c82b, 0xc5d03118, 0x5a9b5adf, 0xc5caf690,
N    0x5a8fec8c, 0xc5c5be47, 0x5a847d33, 0xc5c0883d,
N    0x5a790cd4, 0xc5bb5472, 0x5a6d9b70, 0xc5b622e6,
N    0x5a622907, 0xc5b0f399, 0x5a56b599, 0xc5abc68c,
N    0x5a4b4128, 0xc5a69bbe, 0x5a3fcbb3, 0xc5a17330,
N    0x5a34553b, 0xc59c4ce3, 0x5a28ddc0, 0xc59728d5,
N    0x5a1d6544, 0xc5920708, 0x5a11ebc5, 0xc58ce77c,
N    0x5a067145, 0xc587ca31, 0x59faf5c5, 0xc582af26,
N    0x59ef7944, 0xc57d965d, 0x59e3fbc3, 0xc5787fd6,
N    0x59d87d42, 0xc5736b90, 0x59ccfdc2, 0xc56e598c,
N    0x59c17d44, 0xc56949ca, 0x59b5fbc8, 0xc5643c4a,
N    0x59aa794d, 0xc55f310d, 0x599ef5d6, 0xc55a2812,
N    0x59937161, 0xc555215a, 0x5987ebf0, 0xc5501ce5,
N    0x597c6584, 0xc54b1ab4, 0x5970de1b, 0xc5461ac6,
N    0x596555b8, 0xc5411d1b, 0x5959cc5a, 0xc53c21b4,
N    0x594e4201, 0xc5372891, 0x5942b6af, 0xc53231b3,
N    0x59372a64, 0xc52d3d18, 0x592b9d1f, 0xc5284ac3,
N    0x59200ee3, 0xc5235ab2, 0x59147fae, 0xc51e6ce6,
N    0x5908ef82, 0xc519815f, 0x58fd5e5f, 0xc514981d,
N    0x58f1cc45, 0xc50fb121, 0x58e63935, 0xc50acc6b,
N    0x58daa52f, 0xc505e9fb, 0x58cf1034, 0xc50109d0,
N    0x58c37a44, 0xc4fc2bec, 0x58b7e35f, 0xc4f7504e,
N    0x58ac4b87, 0xc4f276f7, 0x58a0b2bb, 0xc4ed9fe7,
N    0x589518fc, 0xc4e8cb1e, 0x58897e4a, 0xc4e3f89c,
N    0x587de2a7, 0xc4df2862, 0x58724611, 0xc4da5a6f,
N    0x5866a88a, 0xc4d58ec3, 0x585b0a13, 0xc4d0c560,
N    0x584f6aab, 0xc4cbfe45, 0x5843ca53, 0xc4c73972,
N    0x5838290c, 0xc4c276e8, 0x582c86d5, 0xc4bdb6a6,
N    0x5820e3b0, 0xc4b8f8ad, 0x58153f9d, 0xc4b43cfd,
N    0x58099a9c, 0xc4af8397, 0x57fdf4ae, 0xc4aacc7a,
N    0x57f24dd3, 0xc4a617a6, 0x57e6a60c, 0xc4a1651c,
N    0x57dafd59, 0xc49cb4dd, 0x57cf53bb, 0xc49806e7,
N    0x57c3a931, 0xc4935b3c, 0x57b7fdbd, 0xc48eb1db,
N    0x57ac515f, 0xc48a0ac4, 0x57a0a417, 0xc48565f9,
N    0x5794f5e6, 0xc480c379, 0x578946cc, 0xc47c2344,
N    0x577d96ca, 0xc477855a, 0x5771e5e0, 0xc472e9bc,
N    0x5766340f, 0xc46e5069, 0x575a8157, 0xc469b963,
N    0x574ecdb8, 0xc46524a9, 0x57431933, 0xc460923b,
N    0x573763c9, 0xc45c0219, 0x572bad7a, 0xc4577444,
N    0x571ff646, 0xc452e8bc, 0x57143e2d, 0xc44e5f80,
N    0x57088531, 0xc449d892, 0x56fccb51, 0xc44553f2,
N    0x56f1108f, 0xc440d19e, 0x56e554ea, 0xc43c5199,
N    0x56d99864, 0xc437d3e1, 0x56cddafb, 0xc4335877,
N    0x56c21cb2, 0xc42edf5c, 0x56b65d88, 0xc42a688f,
N    0x56aa9d7e, 0xc425f410, 0x569edc94, 0xc42181e0,
N    0x56931acb, 0xc41d11ff, 0x56875823, 0xc418a46d,
N    0x567b949d, 0xc414392b, 0x566fd039, 0xc40fd037,
N    0x56640af7, 0xc40b6994, 0x565844d8, 0xc4070540,
N    0x564c7ddd, 0xc402a33c, 0x5640b606, 0xc3fe4388,
N    0x5634ed53, 0xc3f9e624, 0x562923c5, 0xc3f58b10,
N    0x561d595d, 0xc3f1324e, 0x56118e1a, 0xc3ecdbdc,
N    0x5605c1fd, 0xc3e887bb, 0x55f9f507, 0xc3e435ea,
N    0x55ee2738, 0xc3dfe66c, 0x55e25890, 0xc3db993e,
N    0x55d68911, 0xc3d74e62, 0x55cab8ba, 0xc3d305d8,
N    0x55bee78c, 0xc3cebfa0, 0x55b31587, 0xc3ca7bba,
N    0x55a742ac, 0xc3c63a26, 0x559b6efb, 0xc3c1fae5,
N    0x558f9a76, 0xc3bdbdf6, 0x5583c51b, 0xc3b9835a,
N    0x5577eeec, 0xc3b54b11, 0x556c17e9, 0xc3b1151b,
N    0x55604013, 0xc3ace178, 0x5554676a, 0xc3a8b028,
N    0x55488dee, 0xc3a4812c, 0x553cb3a0, 0xc3a05484,
N    0x5530d881, 0xc39c2a2f, 0x5524fc90, 0xc398022f,
N    0x55191fcf, 0xc393dc82, 0x550d423d, 0xc38fb92a,
N    0x550163dc, 0xc38b9827, 0x54f584ac, 0xc3877978,
N    0x54e9a4ac, 0xc3835d1e, 0x54ddc3de, 0xc37f4319,
N    0x54d1e242, 0xc37b2b6a, 0x54c5ffd9, 0xc377160f,
N    0x54ba1ca3, 0xc373030a, 0x54ae38a0, 0xc36ef25b,
N    0x54a253d1, 0xc36ae401, 0x54966e36, 0xc366d7fd,
N    0x548a87d1, 0xc362ce50, 0x547ea0a0, 0xc35ec6f8,
N    0x5472b8a5, 0xc35ac1f7, 0x5466cfe1, 0xc356bf4d,
N    0x545ae653, 0xc352bef9, 0x544efbfc, 0xc34ec0fc,
N    0x544310dd, 0xc34ac556, 0x543724f5, 0xc346cc07,
N    0x542b3846, 0xc342d510, 0x541f4ad1, 0xc33ee070,
N    0x54135c94, 0xc33aee27, 0x54076d91, 0xc336fe37,
N    0x53fb7dc9, 0xc333109e, 0x53ef8d3c, 0xc32f255e,
N    0x53e39be9, 0xc32b3c75, 0x53d7a9d3, 0xc32755e5,
N    0x53cbb6f8, 0xc32371ae, 0x53bfc35b, 0xc31f8fcf,
N    0x53b3cefa, 0xc31bb049, 0x53a7d9d7, 0xc317d31c,
N    0x539be3f2, 0xc313f848, 0x538fed4b, 0xc3101fce,
N    0x5383f5e3, 0xc30c49ad, 0x5377fdbb, 0xc30875e5,
N    0x536c04d2, 0xc304a477, 0x53600b2a, 0xc300d563,
N    0x535410c3, 0xc2fd08a9, 0x5348159d, 0xc2f93e4a,
N    0x533c19b8, 0xc2f57644, 0x53301d16, 0xc2f1b099,
N    0x53241fb6, 0xc2eded49, 0x5318219a, 0xc2ea2c53,
N    0x530c22c1, 0xc2e66db8, 0x5300232c, 0xc2e2b178,
N    0x52f422db, 0xc2def794, 0x52e821cf, 0xc2db400a,
N    0x52dc2009, 0xc2d78add, 0x52d01d89, 0xc2d3d80a,
N    0x52c41a4f, 0xc2d02794, 0x52b8165b, 0xc2cc7979,
N    0x52ac11af, 0xc2c8cdbb, 0x52a00c4b, 0xc2c52459,
N    0x5294062f, 0xc2c17d52, 0x5287ff5b, 0xc2bdd8a9,
N    0x527bf7d1, 0xc2ba365c, 0x526fef90, 0xc2b6966c,
N    0x5263e699, 0xc2b2f8d8, 0x5257dced, 0xc2af5da2,
N    0x524bd28c, 0xc2abc4c9, 0x523fc776, 0xc2a82e4d,
N    0x5233bbac, 0xc2a49a2e, 0x5227af2e, 0xc2a1086d,
N    0x521ba1fd, 0xc29d790a, 0x520f941a, 0xc299ec05,
N    0x52038584, 0xc296615d, 0x51f7763c, 0xc292d914,
N    0x51eb6643, 0xc28f5329, 0x51df5599, 0xc28bcf9c,
N    0x51d3443f, 0xc2884e6e, 0x51c73235, 0xc284cf9f,
N    0x51bb1f7c, 0xc281532e, 0x51af0c13, 0xc27dd91c,
N    0x51a2f7fc, 0xc27a616a, 0x5196e337, 0xc276ec16,
N    0x518acdc4, 0xc2737922, 0x517eb7a4, 0xc270088e,
N    0x5172a0d7, 0xc26c9a58, 0x5166895f, 0xc2692e83,
N    0x515a713a, 0xc265c50e, 0x514e586a, 0xc2625df8,
N    0x51423ef0, 0xc25ef943, 0x513624cb, 0xc25b96ee,
N    0x512a09fc, 0xc25836f9, 0x511dee84, 0xc254d965,
N    0x5111d263, 0xc2517e31, 0x5105b599, 0xc24e255e,
N    0x50f99827, 0xc24aceed, 0x50ed7a0e, 0xc2477adc,
N    0x50e15b4e, 0xc244292c, 0x50d53be7, 0xc240d9de,
N    0x50c91bda, 0xc23d8cf1, 0x50bcfb28, 0xc23a4265,
N    0x50b0d9d0, 0xc236fa3b, 0x50a4b7d3, 0xc233b473,
N    0x50989532, 0xc230710d, 0x508c71ee, 0xc22d3009,
N    0x50804e06, 0xc229f167, 0x5074297b, 0xc226b528,
N    0x5068044e, 0xc2237b4b, 0x505bde7f, 0xc22043d0,
N    0x504fb80e, 0xc21d0eb8, 0x504390fd, 0xc219dc03,
N    0x5037694b, 0xc216abb1, 0x502b40f8, 0xc2137dc2,
N    0x501f1807, 0xc2105236, 0x5012ee76, 0xc20d290d,
N    0x5006c446, 0xc20a0248, 0x4ffa9979, 0xc206dde6,
N    0x4fee6e0d, 0xc203bbe8, 0x4fe24205, 0xc2009c4e,
N    0x4fd6155f, 0xc1fd7f17, 0x4fc9e81e, 0xc1fa6445,
N    0x4fbdba40, 0xc1f74bd6, 0x4fb18bc8, 0xc1f435cc,
N    0x4fa55cb4, 0xc1f12227, 0x4f992d06, 0xc1ee10e5,
N    0x4f8cfcbe, 0xc1eb0209, 0x4f80cbdc, 0xc1e7f591,
N    0x4f749a61, 0xc1e4eb7e, 0x4f68684e, 0xc1e1e3d0,
N    0x4f5c35a3, 0xc1dede87, 0x4f500260, 0xc1dbdba3,
N    0x4f43ce86, 0xc1d8db25, 0x4f379a16, 0xc1d5dd0c,
N    0x4f2b650f, 0xc1d2e158, 0x4f1f2f73, 0xc1cfe80a,
N    0x4f12f941, 0xc1ccf122, 0x4f06c27a, 0xc1c9fca0,
N    0x4efa8b20, 0xc1c70a84, 0x4eee5331, 0xc1c41ace,
N    0x4ee21aaf, 0xc1c12d7e, 0x4ed5e19a, 0xc1be4294,
N    0x4ec9a7f3, 0xc1bb5a11, 0x4ebd6db9, 0xc1b873f5,
N    0x4eb132ef, 0xc1b5903f, 0x4ea4f793, 0xc1b2aef0,
N    0x4e98bba7, 0xc1afd007, 0x4e8c7f2a, 0xc1acf386,
N    0x4e80421e, 0xc1aa196c, 0x4e740483, 0xc1a741b9,
N    0x4e67c65a, 0xc1a46c6e, 0x4e5b87a2, 0xc1a1998a,
N    0x4e4f485c, 0xc19ec90d, 0x4e430889, 0xc19bfaf9,
N    0x4e36c82a, 0xc1992f4c, 0x4e2a873e, 0xc1966606,
N    0x4e1e45c6, 0xc1939f29, 0x4e1203c3, 0xc190dab4,
N    0x4e05c135, 0xc18e18a7, 0x4df97e1d, 0xc18b5903,
N    0x4ded3a7b, 0xc1889bc6, 0x4de0f64f, 0xc185e0f3,
N    0x4dd4b19a, 0xc1832888, 0x4dc86c5d, 0xc1807285,
N    0x4dbc2698, 0xc17dbeec, 0x4dafe04b, 0xc17b0dbb,
N    0x4da39978, 0xc1785ef4, 0x4d97521d, 0xc175b296,
N    0x4d8b0a3d, 0xc17308a1, 0x4d7ec1d6, 0xc1706115,
N    0x4d7278eb, 0xc16dbbf3, 0x4d662f7b, 0xc16b193a,
N    0x4d59e586, 0xc16878eb, 0x4d4d9b0e, 0xc165db05,
N    0x4d415013, 0xc1633f8a, 0x4d350495, 0xc160a678,
N    0x4d28b894, 0xc15e0fd1, 0x4d1c6c11, 0xc15b7b94,
N    0x4d101f0e, 0xc158e9c1, 0x4d03d189, 0xc1565a58,
N    0x4cf78383, 0xc153cd5a, 0x4ceb34fe, 0xc15142c6,
N    0x4cdee5f9, 0xc14eba9d, 0x4cd29676, 0xc14c34df,
N    0x4cc64673, 0xc149b18b, 0x4cb9f5f3, 0xc14730a3,
N    0x4cada4f5, 0xc144b225, 0x4ca1537a, 0xc1423613,
N    0x4c950182, 0xc13fbc6c, 0x4c88af0e, 0xc13d4530,
N    0x4c7c5c1e, 0xc13ad060, 0x4c7008b3, 0xc1385dfb,
N    0x4c63b4ce, 0xc135ee02, 0x4c57606e, 0xc1338075,
N    0x4c4b0b94, 0xc1311553, 0x4c3eb641, 0xc12eac9d,
N    0x4c326075, 0xc12c4653, 0x4c260a31, 0xc129e276,
N    0x4c19b374, 0xc1278104, 0x4c0d5c41, 0xc12521ff,
N    0x4c010496, 0xc122c566, 0x4bf4ac75, 0xc1206b39,
N    0x4be853de, 0xc11e1379, 0x4bdbfad1, 0xc11bbe26,
N    0x4bcfa150, 0xc1196b3f, 0x4bc34759, 0xc1171ac6,
N    0x4bb6ecef, 0xc114ccb9, 0x4baa9211, 0xc1128119,
N    0x4b9e36c0, 0xc11037e6, 0x4b91dafc, 0xc10df120,
N    0x4b857ec7, 0xc10bacc8, 0x4b79221f, 0xc1096add,
N    0x4b6cc506, 0xc1072b5f, 0x4b60677c, 0xc104ee4f,
N    0x4b540982, 0xc102b3ac, 0x4b47ab19, 0xc1007b77,
N    0x4b3b4c40, 0xc0fe45b0, 0x4b2eecf8, 0xc0fc1257,
N    0x4b228d42, 0xc0f9e16b, 0x4b162d1d, 0xc0f7b2ee,
N    0x4b09cc8c, 0xc0f586df, 0x4afd6b8d, 0xc0f35d3e,
N    0x4af10a22, 0xc0f1360b, 0x4ae4a84b, 0xc0ef1147,
N    0x4ad84609, 0xc0eceef1, 0x4acbe35b, 0xc0eacf09,
N    0x4abf8043, 0xc0e8b190, 0x4ab31cc1, 0xc0e69686,
N    0x4aa6b8d5, 0xc0e47deb, 0x4a9a5480, 0xc0e267be,
N    0x4a8defc3, 0xc0e05401, 0x4a818a9d, 0xc0de42b2,
N    0x4a752510, 0xc0dc33d2, 0x4a68bf1b, 0xc0da2762,
N    0x4a5c58c0, 0xc0d81d61, 0x4a4ff1fe, 0xc0d615cf,
N    0x4a438ad7, 0xc0d410ad, 0x4a37234a, 0xc0d20dfa,
N    0x4a2abb59, 0xc0d00db6, 0x4a1e5303, 0xc0ce0fe3,
N    0x4a11ea49, 0xc0cc147f, 0x4a05812c, 0xc0ca1b8a,
N    0x49f917ac, 0xc0c82506, 0x49ecadc9, 0xc0c630f2,
N    0x49e04385, 0xc0c43f4d, 0x49d3d8df, 0xc0c25019,
N    0x49c76dd8, 0xc0c06355, 0x49bb0271, 0xc0be7901,
N    0x49ae96aa, 0xc0bc911d, 0x49a22a83, 0xc0baabaa,
N    0x4995bdfd, 0xc0b8c8a7, 0x49895118, 0xc0b6e815,
N    0x497ce3d5, 0xc0b509f3, 0x49707635, 0xc0b32e42,
N    0x49640837, 0xc0b15502, 0x495799dd, 0xc0af7e33,
N    0x494b2b27, 0xc0ada9d4, 0x493ebc14, 0xc0abd7e6,
N    0x49324ca7, 0xc0aa086a, 0x4925dcdf, 0xc0a83b5e,
N    0x49196cbc, 0xc0a670c4, 0x490cfc40, 0xc0a4a89b,
N    0x49008b6a, 0xc0a2e2e3, 0x48f41a3c, 0xc0a11f9d,
N    0x48e7a8b5, 0xc09f5ec8, 0x48db36d6, 0xc09da065,
N    0x48cec4a0, 0xc09be473, 0x48c25213, 0xc09a2af3,
N    0x48b5df30, 0xc09873e4, 0x48a96bf6, 0xc096bf48,
N    0x489cf867, 0xc0950d1d, 0x48908483, 0xc0935d64,
N    0x4884104b, 0xc091b01d, 0x48779bbe, 0xc0900548,
N    0x486b26de, 0xc08e5ce5, 0x485eb1ab, 0xc08cb6f5,
N    0x48523c25, 0xc08b1376, 0x4845c64d, 0xc089726a,
N    0x48395024, 0xc087d3d0, 0x482cd9a9, 0xc08637a9,
N    0x482062de, 0xc0849df4, 0x4813ebc2, 0xc08306b2,
N    0x48077457, 0xc08171e2, 0x47fafc9c, 0xc07fdf85,
N    0x47ee8493, 0xc07e4f9b, 0x47e20c3b, 0xc07cc223,
N    0x47d59396, 0xc07b371e, 0x47c91aa3, 0xc079ae8c,
N    0x47bca163, 0xc078286e, 0x47b027d7, 0xc076a4c2,
N    0x47a3adff, 0xc0752389, 0x479733dc, 0xc073a4c3,
N    0x478ab96e, 0xc0722871, 0x477e3eb5, 0xc070ae92,
N    0x4771c3b3, 0xc06f3726, 0x47654867, 0xc06dc22e,
N    0x4758ccd2, 0xc06c4fa8, 0x474c50f4, 0xc06adf97,
N    0x473fd4cf, 0xc06971f9, 0x47335862, 0xc06806ce,
N    0x4726dbae, 0xc0669e18, 0x471a5eb3, 0xc06537d4,
N    0x470de172, 0xc063d405, 0x470163eb, 0xc06272aa,
N    0x46f4e620, 0xc06113c2, 0x46e86810, 0xc05fb74e,
N    0x46dbe9bb, 0xc05e5d4e, 0x46cf6b23, 0xc05d05c3,
N    0x46c2ec48, 0xc05bb0ab, 0x46b66d29, 0xc05a5e07,
N    0x46a9edc9, 0xc0590dd8, 0x469d6e27, 0xc057c01d,
N    0x4690ee44, 0xc05674d6, 0x46846e1f, 0xc0552c03,
N    0x4677edbb, 0xc053e5a5, 0x466b6d16, 0xc052a1bb,
N    0x465eec33, 0xc0516045, 0x46526b10, 0xc0502145,
N    0x4645e9af, 0xc04ee4b8, 0x46396810, 0xc04daaa1,
N    0x462ce634, 0xc04c72fe, 0x4620641a, 0xc04b3dcf,
N    0x4613e1c5, 0xc04a0b16, 0x46075f33, 0xc048dad1,
N    0x45fadc66, 0xc047ad01, 0x45ee595d, 0xc04681a6,
N    0x45e1d61b, 0xc04558c0, 0x45d5529e, 0xc044324f,
N    0x45c8cee7, 0xc0430e53, 0x45bc4af8, 0xc041eccc,
N    0x45afc6d0, 0xc040cdba, 0x45a3426f, 0xc03fb11d,
N    0x4596bdd7, 0xc03e96f6, 0x458a3908, 0xc03d7f44,
N    0x457db403, 0xc03c6a07, 0x45712ec7, 0xc03b573f,
N    0x4564a955, 0xc03a46ed, 0x455823ae, 0xc0393910,
N    0x454b9dd3, 0xc0382da8, 0x453f17c3, 0xc03724b6,
N    0x4532917f, 0xc0361e3a, 0x45260b08, 0xc0351a33,
N    0x4519845e, 0xc03418a2, 0x450cfd82, 0xc0331986,
N    0x45007674, 0xc0321ce0, 0x44f3ef35, 0xc03122b0,
N    0x44e767c5, 0xc0302af5, 0x44dae024, 0xc02f35b1,
N    0x44ce5854, 0xc02e42e2, 0x44c1d054, 0xc02d5289,
N    0x44b54825, 0xc02c64a6, 0x44a8bfc7, 0xc02b7939,
N    0x449c373c, 0xc02a9042, 0x448fae83, 0xc029a9c1,
N    0x4483259d, 0xc028c5b6, 0x44769c8b, 0xc027e421,
N    0x446a134c, 0xc0270502, 0x445d89e2, 0xc0262859,
N    0x4451004d, 0xc0254e27, 0x4444768d, 0xc024766a,
N    0x4437eca4, 0xc023a124, 0x442b6290, 0xc022ce54,
N    0x441ed854, 0xc021fdfb, 0x44124dee, 0xc0213018,
N    0x4405c361, 0xc02064ab, 0x43f938ac, 0xc01f9bb5,
N    0x43ecadcf, 0xc01ed535, 0x43e022cc, 0xc01e112b,
N    0x43d397a3, 0xc01d4f99, 0x43c70c54, 0xc01c907c,
N    0x43ba80df, 0xc01bd3d6, 0x43adf546, 0xc01b19a7,
N    0x43a16988, 0xc01a61ee, 0x4394dda7, 0xc019acac,
N    0x438851a2, 0xc018f9e1, 0x437bc57b, 0xc018498c,
N    0x436f3931, 0xc0179bae, 0x4362acc5, 0xc016f047,
N    0x43562038, 0xc0164757, 0x43499389, 0xc015a0dd,
N    0x433d06bb, 0xc014fcda, 0x433079cc, 0xc0145b4e,
N    0x4323ecbe, 0xc013bc39, 0x43175f91, 0xc0131f9b,
N    0x430ad245, 0xc0128574, 0x42fe44dc, 0xc011edc3,
N    0x42f1b755, 0xc011588a, 0x42e529b0, 0xc010c5c7,
N    0x42d89bf0, 0xc010357c, 0x42cc0e13, 0xc00fa7a8,
N    0x42bf801a, 0xc00f1c4a, 0x42b2f207, 0xc00e9364,
N    0x42a663d8, 0xc00e0cf5, 0x4299d590, 0xc00d88fd,
N    0x428d472e, 0xc00d077c, 0x4280b8b3, 0xc00c8872,
N    0x42742a1f, 0xc00c0be0, 0x42679b73, 0xc00b91c4,
N    0x425b0caf, 0xc00b1a20, 0x424e7dd4, 0xc00aa4f3,
N    0x4241eee2, 0xc00a323d, 0x42355fd9, 0xc009c1ff,
N    0x4228d0bb, 0xc0095438, 0x421c4188, 0xc008e8e8,
N    0x420fb240, 0xc008800f, 0x420322e3, 0xc00819ae,
N    0x41f69373, 0xc007b5c4, 0x41ea03ef, 0xc0075452,
N    0x41dd7459, 0xc006f556, 0x41d0e4b0, 0xc00698d3,
N    0x41c454f5, 0xc0063ec6, 0x41b7c528, 0xc005e731,
N    0x41ab354b, 0xc0059214, 0x419ea55d, 0xc0053f6e,
N    0x4192155f, 0xc004ef3f, 0x41858552, 0xc004a188,
N    0x4178f536, 0xc0045648, 0x416c650b, 0xc0040d80,
N    0x415fd4d2, 0xc003c72f, 0x4153448c, 0xc0038356,
N    0x4146b438, 0xc00341f4, 0x413a23d8, 0xc003030a,
N    0x412d936c, 0xc002c697, 0x412102f4, 0xc0028c9c,
N    0x41147271, 0xc0025519, 0x4107e1e3, 0xc002200d,
N    0x40fb514b, 0xc001ed78, 0x40eec0aa, 0xc001bd5c,
N    0x40e22fff, 0xc0018fb6, 0x40d59f4c, 0xc0016489,
N    0x40c90e90, 0xc0013bd3, 0x40bc7dcc, 0xc0011594,
N    0x40afed02, 0xc000f1ce, 0x40a35c30, 0xc000d07e,
N    0x4096cb58, 0xc000b1a7, 0x408a3a7b, 0xc0009547,
N    0x407da998, 0xc0007b5f, 0x407118b0, 0xc00063ee,
N    0x406487c4, 0xc0004ef5, 0x4057f6d4, 0xc0003c74,
N    0x404b65e1, 0xc0002c6a, 0x403ed4ea, 0xc0001ed8,
N    0x403243f1, 0xc00013bd, 0x4025b2f7, 0xc0000b1a,
N    0x401921fb, 0xc00004ef, 0x400c90fe, 0xc000013c,
N};
N
N/**    
N* @brief  Initialization function for the Q31 RFFT/RIFFT.   
N* @param[in, out] *S             points to an instance of the Q31 RFFT/RIFFT structure.   
N* @param[in]      fftLenReal     length of the FFT.   
N* @param[in]      ifftFlagR      flag that selects forward (ifftFlagR=0) or inverse (ifftFlagR=1) transform.   
N* @param[in]      bitReverseFlag flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output.   
N* @return		The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_ARGUMENT_ERROR if <code>fftLenReal</code> is not a supported value.   
N*    
N* \par Description:   
N* \par   
N* The parameter <code>fftLenReal</code>	Specifies length of RFFT/RIFFT Process. Supported FFT Lengths are 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192.    
N* \par    
N* The parameter <code>ifftFlagR</code> controls whether a forward or inverse transform is computed.    
N* Set(=1) ifftFlagR to calculate RIFFT, otherwise RFFT is calculated.    
N* \par    
N* The parameter <code>bitReverseFlag</code> controls whether output is in normal order or bit reversed order.    
N* Set(=1) bitReverseFlag for output to be in normal order otherwise output is in bit reversed order.   
N* \par    7
N* This function also initializes Twiddle factor table.    
N*/
N
Narm_status arm_rfft_init_q31(
N    arm_rfft_instance_q31 * S,
N    uint32_t fftLenReal,
N    uint32_t ifftFlagR,
N    uint32_t bitReverseFlag)
N{
N    /*  Initialise the default arm status */
N    arm_status status = ARM_MATH_SUCCESS;
N
N    /*  Initialize the Real FFT length */
N    S->fftLenReal = (uint16_t) fftLenReal;
N
N    /*  Initialize the Twiddle coefficientA pointer */
N    S->pTwiddleAReal = (q31_t *) realCoefAQ31;
N
N    /*  Initialize the Twiddle coefficientB pointer */
N    S->pTwiddleBReal = (q31_t *) realCoefBQ31;
N
N    /*  Initialize the Flag for selection of RFFT or RIFFT */
N    S->ifftFlagR = (uint8_t) ifftFlagR;
N
N    /*  Initialize the Flag for calculation Bit reversal or not */
N    S->bitReverseFlagR = (uint8_t) bitReverseFlag;
N
N    /*  Initialization of coef modifier depending on the FFT length */
N    switch (S->fftLenReal)
N    {
N    case 8192u:
N        S->twidCoefRModifier = 1u;
N        S->pCfft = &arm_cfft_sR_q31_len4096;
N        break;
N    case 4096u:
N        S->twidCoefRModifier = 2u;
N        S->pCfft = &arm_cfft_sR_q31_len2048;
N        break;
N    case 2048u:
N        S->twidCoefRModifier = 4u;
N        S->pCfft = &arm_cfft_sR_q31_len1024;
N        break;
N    case 1024u:
N        S->twidCoefRModifier = 8u;
N        S->pCfft = &arm_cfft_sR_q31_len512;
N        break;
N    case 512u:
N        S->twidCoefRModifier = 16u;
N        S->pCfft = &arm_cfft_sR_q31_len256;
N        break;
N    case 256u:
N        S->twidCoefRModifier = 32u;
N        S->pCfft = &arm_cfft_sR_q31_len128;
N        break;
N    case 128u:
N        S->twidCoefRModifier = 64u;
N        S->pCfft = &arm_cfft_sR_q31_len64;
N        break;
N    case 64u:
N        S->twidCoefRModifier = 128u;
N        S->pCfft = &arm_cfft_sR_q31_len32;
N        break;
N    case 32u:
N        S->twidCoefRModifier = 256u;
N        S->pCfft = &arm_cfft_sR_q31_len16;
N        break;
N    default:
N        /*  Reporting argument error if rfftSize is not valid value */
N        status = ARM_MATH_ARGUMENT_ERROR;
N        break;
N    }
N
N    /* return the status of RFFT Init function */
N    return (status);
N}
N
N/**    
N* @} end of RealFFT group    
N*/
