; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_mat_trans_q31.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_mat_trans_q31.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_mat_trans_q31.crf src\MatrixFunctions\arm_mat_trans_q31.c]
                          THUMB

                          AREA ||i.arm_mat_trans_q31||, CODE, READONLY, ALIGN=2

                  arm_mat_trans_q31 PROC
;;;59     
;;;60     arm_status arm_mat_trans_q31(
000000  b5f0              PUSH     {r4-r7,lr}
;;;61       const arm_matrix_instance_q31 * pSrc,
;;;62       arm_matrix_instance_q31 * pDst)
;;;63     {
;;;64       q31_t *pIn = pSrc->pData;                      /* input data matrix pointer  */
;;;65       q31_t *pOut = pDst->pData;                     /* output data matrix pointer  */
;;;66       q31_t *px;                                     /* Temporary output data matrix pointer */
;;;67       uint16_t nRows = pSrc->numRows;                /* number of nRows */
000002  684f              LDR      r7,[r1,#4]
000004  8801              LDRH     r1,[r0,#0]
;;;68       uint16_t nColumns = pSrc->numCols;             /* number of nColumns  */
000006  8846              LDRH     r6,[r0,#2]
000008  6842              LDR      r2,[r0,#4]            ;65
;;;69     
;;;70     #ifndef ARM_MATH_CM0_FAMILY
;;;71     
;;;72       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;73     
;;;74       uint16_t blkCnt, i = 0u, row = nRows;          /* loop counters */
00000a  2400              MOVS     r4,#0
00000c  460b              MOV      r3,r1
;;;75       arm_status status;                             /* status of matrix transpose */
;;;76     
;;;77     
;;;78     #ifdef ARM_MATH_MATRIX_CHECK
;;;79     
;;;80     
;;;81       /* Check for matrix mismatch condition */
;;;82       if((pSrc->numRows != pDst->numCols) || (pSrc->numCols != pDst->numRows))
;;;83       {
;;;84         /* Set status as ARM_MATH_SIZE_MISMATCH */
;;;85         status = ARM_MATH_SIZE_MISMATCH;
;;;86       }
;;;87       else
;;;88     #endif /*    #ifdef ARM_MATH_MATRIX_CHECK    */
;;;89     
;;;90       {
;;;91         /* Matrix transpose by exchanging the rows with columns */
;;;92         /* row loop     */
;;;93         do
;;;94         {
;;;95           /* Apply loop unrolling and exchange the columns with row elements */
;;;96           blkCnt = nColumns >> 2u;
00000e  08b5              LSRS     r5,r6,#2
                  |L1.16|
000010  4628              MOV      r0,r5
;;;97     
;;;98           /* The pointer px is set to starting address of the column being processed */
;;;99           px = pOut + i;
000012  eb070c84          ADD      r12,r7,r4,LSL #2
;;;100    
;;;101          /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.    
;;;102           ** a second loop below computes the remaining 1 to 3 samples. */
;;;103          while(blkCnt > 0u)
000016  e019              B        |L1.76|
                  |L1.24|
;;;104          {
;;;105            /* Read and store the input element in the destination */
;;;106            *px = *pIn++;
000018  f852eb04          LDR      lr,[r2],#4
;;;107    
;;;108            /* Update the pointer px to point to the next row of the transposed matrix */
;;;109            px += nRows;
00001c  f8cce000          STR      lr,[r12,#0]
000020  eb0c0c81          ADD      r12,r12,r1,LSL #2
;;;110    
;;;111            /* Read and store the input element in the destination */
;;;112            *px = *pIn++;
000024  f852eb04          LDR      lr,[r2],#4
;;;113    
;;;114            /* Update the pointer px to point to the next row of the transposed matrix */
;;;115            px += nRows;
000028  f8cce000          STR      lr,[r12,#0]
00002c  eb0c0c81          ADD      r12,r12,r1,LSL #2
;;;116    
;;;117            /* Read and store the input element in the destination */
;;;118            *px = *pIn++;
000030  f852eb04          LDR      lr,[r2],#4
;;;119    
;;;120            /* Update the pointer px to point to the next row of the transposed matrix */
;;;121            px += nRows;
000034  f8cce000          STR      lr,[r12,#0]
000038  eb0c0c81          ADD      r12,r12,r1,LSL #2
;;;122    
;;;123            /* Read and store the input element in the destination */
;;;124            *px = *pIn++;
00003c  f852eb04          LDR      lr,[r2],#4
;;;125    
;;;126            /* Update the pointer px to point to the next row of the transposed matrix */
;;;127            px += nRows;
000040  f8cce000          STR      lr,[r12,#0]
000044  1e40              SUBS     r0,r0,#1
000046  eb0c0c81          ADD      r12,r12,r1,LSL #2
;;;128    
;;;129            /* Decrement the column loop counter */
;;;130            blkCnt--;
00004a  b280              UXTH     r0,r0
                  |L1.76|
00004c  2800              CMP      r0,#0                 ;103
00004e  d1e3              BNE      |L1.24|
;;;131          }
;;;132    
;;;133          /* Perform matrix transpose for last 3 samples here. */
;;;134          blkCnt = nColumns % 0x4u;
000050  f0060003          AND      r0,r6,#3
;;;135    
;;;136          while(blkCnt > 0u)
000054  e008              B        |L1.104|
;;;137          {
;;;138            /* Read and store the input element in the destination */
;;;139            *px = *pIn++;
000056  bf00              NOP      
                  |L1.88|
000058  f852eb04          LDR      lr,[r2],#4
;;;140    
;;;141            /* Update the pointer px to point to the next row of the transposed matrix */
;;;142            px += nRows;
00005c  f8cce000          STR      lr,[r12,#0]
000060  1e40              SUBS     r0,r0,#1
000062  eb0c0c81          ADD      r12,r12,r1,LSL #2
;;;143    
;;;144            /* Decrement the column loop counter */
;;;145            blkCnt--;
000066  b280              UXTH     r0,r0
                  |L1.104|
000068  2800              CMP      r0,#0                 ;136
00006a  d1f5              BNE      |L1.88|
00006c  1c64              ADDS     r4,r4,#1              ;136
;;;146          }
;;;147    
;;;148    #else
;;;149    
;;;150      /* Run the below code for Cortex-M0 */
;;;151    
;;;152      uint16_t col, i = 0u, row = nRows;             /* loop counters */
;;;153      arm_status status;                             /* status of matrix transpose */
;;;154    
;;;155    
;;;156    #ifdef ARM_MATH_MATRIX_CHECK
;;;157    
;;;158      /* Check for matrix mismatch condition */
;;;159      if((pSrc->numRows != pDst->numCols) || (pSrc->numCols != pDst->numRows))
;;;160      {
;;;161        /* Set status as ARM_MATH_SIZE_MISMATCH */
;;;162        status = ARM_MATH_SIZE_MISMATCH;
;;;163      }
;;;164      else
;;;165    #endif /*    #ifdef ARM_MATH_MATRIX_CHECK    */
;;;166    
;;;167      {
;;;168        /* Matrix transpose by exchanging the rows with columns */
;;;169        /* row loop     */
;;;170        do
;;;171        {
;;;172          /* The pointer px is set to starting address of the column being processed */
;;;173          px = pOut + i;
;;;174    
;;;175          /* Initialize column loop counter */
;;;176          col = nColumns;
;;;177    
;;;178          while(col > 0u)
;;;179          {
;;;180            /* Read and store the input element in the destination */
;;;181            *px = *pIn++;
;;;182    
;;;183            /* Update the pointer px to point to the next row of the transposed matrix */
;;;184            px += nRows;
;;;185    
;;;186            /* Decrement the column loop counter */
;;;187            col--;
;;;188          }
;;;189    
;;;190    #endif /* #ifndef ARM_MATH_CM0_FAMILY */
;;;191    
;;;192          i++;
00006e  1e5b              SUBS     r3,r3,#1
;;;193    
;;;194          /* Decrement the row loop counter */
;;;195          row--;
000070  041b              LSLS     r3,r3,#16
000072  b2a4              UXTH     r4,r4                 ;192
000074  0c1b              LSRS     r3,r3,#16
;;;196    
;;;197        }
;;;198        while(row > 0u);            /* row loop end */
000076  d1cb              BNE      |L1.16|
;;;199    
;;;200        /* set status as ARM_MATH_SUCCESS */
;;;201        status = ARM_MATH_SUCCESS;
;;;202      }
;;;203    
;;;204      /* Return to application */
;;;205      return (status);
;;;206    }
000078  bdf0              POP      {r4-r7,pc}
;;;207    
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\MatrixFunctions\\arm_mat_trans_q31.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_mat_trans_q31_c_d7961a34____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___19_arm_mat_trans_q31_c_d7961a34____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_mat_trans_q31_c_d7961a34____REVSH|
#line 144
|__asm___19_arm_mat_trans_q31_c_d7961a34____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_mat_trans_q31_c_d7961a34____RRX|
#line 300
|__asm___19_arm_mat_trans_q31_c_d7961a34____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
