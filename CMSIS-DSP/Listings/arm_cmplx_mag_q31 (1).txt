; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_cmplx_mag_q31.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_cmplx_mag_q31.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"Z:\GoogleDrive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_cmplx_mag_q31.crf src\ComplexMathFunctions\arm_cmplx_mag_q31.c]
                          THUMB

                          AREA ||i.arm_cmplx_mag_q31||, CODE, READONLY, ALIGN=2

                  arm_cmplx_mag_q31 PROC
;;;64     
;;;65     void arm_cmplx_mag_q31(
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;66       q31_t * pSrc,
;;;67       q31_t * pDst,
;;;68       uint32_t numSamples)
;;;69     {
000004  4693              MOV      r11,r2
000006  460d              MOV      r5,r1
000008  4604              MOV      r4,r0
;;;70       q31_t real, imag;                              /* Temporary variables to hold input values */
;;;71       q31_t acc0, acc1;                              /* Accumulators */
;;;72       uint32_t blkCnt;                               /* loop counter */
;;;73     
;;;74     #ifndef ARM_MATH_CM0_FAMILY
;;;75     
;;;76       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;77       q31_t real1, real2, imag1, imag2;              /* Temporary variables to hold input values */
;;;78       q31_t out1, out2, out3, out4;                  /* Accumulators */
;;;79       q63_t mul1, mul2, mul3, mul4;                  /* Temporary variables */
;;;80     
;;;81     
;;;82       /*loop Unrolling */
;;;83       blkCnt = numSamples >> 2u;
00000a  0896              LSRS     r6,r2,#2
00000c  e03b              B        |L1.134|
00000e  bf00              NOP                            ;69
                  |L1.16|
000010  e9d40200          LDRD     r0,r2,[r4,#0]         ;69
;;;84     
;;;85       /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.        
;;;86        ** a second loop below computes the remaining 1 to 3 samples. */
;;;87       while(blkCnt > 0u)
;;;88       {
;;;89         /* read complex input from source buffer */
;;;90         real1 = pSrc[0];
;;;91         imag1 = pSrc[1];
;;;92         real2 = pSrc[2];
;;;93         imag2 = pSrc[3];
;;;94     
;;;95         /* calculate power of input values */
;;;96         mul1 = (q63_t) real1 *real1;
;;;97         mul2 = (q63_t) imag1 *imag1;
000014  e9d41302          LDRD     r1,r3,[r4,#8]
000018  fb807000          SMULL    r7,r0,r0,r0           ;96
00001c  fb827202          SMULL    r7,r2,r2,r2
;;;98         mul3 = (q63_t) real2 *real2;
000020  fb817101          SMULL    r7,r1,r1,r1
;;;99         mul4 = (q63_t) imag2 *imag2;
000024  fb837303          SMULL    r7,r3,r3,r3
;;;100    
;;;101        /* get the result to 3.29 format */
;;;102        out1 = (q31_t) (mul1 >> 33);
000028  1040              ASRS     r0,r0,#1
;;;103        out2 = (q31_t) (mul2 >> 33);
;;;104        out3 = (q31_t) (mul3 >> 33);
00002a  1049              ASRS     r1,r1,#1
;;;105        out4 = (q31_t) (mul4 >> 33);
;;;106    
;;;107        /* add real and imaginary accumulators */
;;;108        out1 = out1 + out2;
00002c  eb000262          ADD      r2,r0,r2,ASR #1
;;;109        out3 = out3 + out4;
000030  eb010063          ADD      r0,r1,r3,ASR #1
000034  9000              STR      r0,[sp,#0]
000036  e9d47004          LDRD     r7,r0,[r4,#0x10]
;;;110    
;;;111        /* read complex input from source buffer */
;;;112        real1 = pSrc[4];
;;;113        imag1 = pSrc[5];
;;;114        real2 = pSrc[6];
;;;115        imag2 = pSrc[7];
;;;116    
;;;117        /* calculate square root */
;;;118        arm_sqrt_q31(out1, &pDst[0]);
00003a  e9d49a06          LDRD     r9,r10,[r4,#0x18]
00003e  4680              MOV      r8,r0                 ;113
000040  4629              MOV      r1,r5
000042  4610              MOV      r0,r2
000044  f7fffffe          BL       arm_sqrt_q31
;;;119    
;;;120        /* calculate power of input values */
;;;121        mul1 = (q63_t) real1 *real1;
000048  fb870707          SMULL    r0,r7,r7,r7
;;;122    
;;;123        /* calculate square root */
;;;124        arm_sqrt_q31(out3, &pDst[1]);
00004c  1d29              ADDS     r1,r5,#4
00004e  9800              LDR      r0,[sp,#0]
000050  f7fffffe          BL       arm_sqrt_q31
;;;125    
;;;126        /* calculate power of input values */
;;;127        mul2 = (q63_t) imag1 *imag1;
;;;128        mul3 = (q63_t) real2 *real2;
000054  fb890109          SMULL    r0,r1,r9,r9
000058  fb880208          SMULL    r0,r2,r8,r8           ;127
;;;129        mul4 = (q63_t) imag2 *imag2;
00005c  fb8a300a          SMULL    r3,r0,r10,r10
;;;130    
;;;131        /* get the result to 3.29 format */
;;;132        out1 = (q31_t) (mul1 >> 33);
000060  107b              ASRS     r3,r7,#1
;;;133        out2 = (q31_t) (mul2 >> 33);
;;;134        out3 = (q31_t) (mul3 >> 33);
000062  1049              ASRS     r1,r1,#1
;;;135        out4 = (q31_t) (mul4 >> 33);
;;;136    
;;;137        /* add real and imaginary accumulators */
;;;138        out1 = out1 + out2;
;;;139        out3 = out3 + out4;
000064  eb010760          ADD      r7,r1,r0,ASR #1
000068  eb030262          ADD      r2,r3,r2,ASR #1       ;138
;;;140    
;;;141        /* calculate square root */
;;;142        arm_sqrt_q31(out1, &pDst[2]);
00006c  f1050108          ADD      r1,r5,#8
000070  4610              MOV      r0,r2
000072  f7fffffe          BL       arm_sqrt_q31
;;;143    
;;;144        /* increment destination by 8 to process next samples */
;;;145        pSrc += 8u;
;;;146    
;;;147        /* calculate square root */
;;;148        arm_sqrt_q31(out3, &pDst[3]);
000076  f105010c          ADD      r1,r5,#0xc
00007a  4638              MOV      r0,r7
00007c  3420              ADDS     r4,r4,#0x20
00007e  f7fffffe          BL       arm_sqrt_q31
000082  3510              ADDS     r5,r5,#0x10
000084  1e76              SUBS     r6,r6,#1
                  |L1.134|
000086  2e00              CMP      r6,#0                 ;87
000088  d1c2              BNE      |L1.16|
;;;149    
;;;150        /* increment destination by 4 to process next samples */
;;;151        pDst += 4u;
;;;152    
;;;153        /* Decrement the loop counter */
;;;154        blkCnt--;
;;;155      }
;;;156    
;;;157      /* If the numSamples is not a multiple of 4, compute any remaining output samples here.        
;;;158       ** No loop unrolling is used. */
;;;159      blkCnt = numSamples % 0x4u;
00008a  f00b0603          AND      r6,r11,#3
;;;160    
;;;161    #else
;;;162    
;;;163      /* Run the below code for Cortex-M0 */
;;;164      blkCnt = numSamples;
;;;165    
;;;166    #endif /* #ifndef ARM_MATH_CM0_FAMILY */
;;;167    
;;;168      while(blkCnt > 0u)
00008e  e00e              B        |L1.174|
                  |L1.144|
000090  e8f41002          LDRD     r1,r0,[r4],#8
;;;169      {
;;;170        /* C[0] = sqrt(A[0] * A[0] + A[1] * A[1]) */
;;;171        real = *pSrc++;
;;;172        imag = *pSrc++;
;;;173        acc0 = (q31_t) (((q63_t) real * real) >> 33);
000094  fb812101          SMULL    r2,r1,r1,r1
;;;174        acc1 = (q31_t) (((q63_t) imag * imag) >> 33);
000098  fb802000          SMULL    r2,r0,r0,r0
00009c  1049              ASRS     r1,r1,#1              ;173
;;;175        /* store the result in 2.30 format in the destination buffer. */
;;;176        arm_sqrt_q31(acc0 + acc1, pDst++);
00009e  462a              MOV      r2,r5
0000a0  eb010060          ADD      r0,r1,r0,ASR #1
0000a4  1d2d              ADDS     r5,r5,#4
0000a6  4611              MOV      r1,r2
0000a8  f7fffffe          BL       arm_sqrt_q31
0000ac  1e76              SUBS     r6,r6,#1
                  |L1.174|
0000ae  2e00              CMP      r6,#0                 ;168
0000b0  d1ee              BNE      |L1.144|
;;;177    
;;;178        /* Decrement the loop counter */
;;;179        blkCnt--;
;;;180      }
;;;181    }
0000b2  e8bd8ff8          POP      {r3-r11,pc}
;;;182    
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\ComplexMathFunctions\\arm_cmplx_mag_q31.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_cmplx_mag_q31_c_3cb67ccc____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___19_arm_cmplx_mag_q31_c_3cb67ccc____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_cmplx_mag_q31_c_3cb67ccc____REVSH|
#line 144
|__asm___19_arm_cmplx_mag_q31_c_3cb67ccc____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_cmplx_mag_q31_c_3cb67ccc____RRX|
#line 300
|__asm___19_arm_cmplx_mag_q31_c_3cb67ccc____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
