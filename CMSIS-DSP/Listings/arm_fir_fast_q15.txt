; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_fir_fast_q15.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_fir_fast_q15.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_fir_fast_q15.crf src\FilteringFunctions\arm_fir_fast_q15.c]
                          THUMB

                          AREA ||i.arm_fir_fast_q15||, CODE, READONLY, ALIGN=2

                  arm_fir_fast_q15 PROC
;;;71     
;;;72     void arm_fir_fast_q15(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;73       const arm_fir_instance_q15 * S,
;;;74       q15_t * pSrc,
;;;75       q15_t * pDst,
;;;76       uint32_t blockSize)
;;;77     {
000004  b085              SUB      sp,sp,#0x14
;;;78       q15_t *pState = S->pState;                     /* State pointer */
;;;79       q15_t *pCoeffs = S->pCoeffs;                   /* Coefficient pointer */
;;;80       q15_t *pStateCurnt;                            /* Points to the current sample of the state */
;;;81       q31_t acc0, acc1, acc2, acc3;                  /* Accumulators */
;;;82       q15_t *pb;                                     /* Temporary pointer for coefficient buffer */
;;;83       q15_t *px;                                     /* Temporary q31 pointer for SIMD state buffer accesses */
;;;84       q31_t x0, x1, x2, c0;                          /* Temporary variables to hold SIMD state and coefficient values */
;;;85       uint32_t numTaps = S->numTaps;                 /* Number of taps in the filter */
;;;86       uint32_t tapCnt, blkCnt;                       /* Loop counters */
;;;87     
;;;88     
;;;89       /* S->pState points to state array which contains previous frame (numTaps - 1) samples */
;;;90       /* pStateCurnt points to the location where the new input data should be written */
;;;91       pStateCurnt = &(S->pState[(numTaps - 1u)]);
000006  f06f0301          MVN      r3,#1
00000a  9805              LDR      r0,[sp,#0x14]         ;78
00000c  9a05              LDR      r2,[sp,#0x14]         ;79
00000e  6840              LDR      r0,[r0,#4]            ;78
000010  6892              LDR      r2,[r2,#8]            ;79
000012  9203              STR      r2,[sp,#0xc]          ;85
000014  9a05              LDR      r2,[sp,#0x14]         ;85
000016  f8b2a000          LDRH     r10,[r2,#0]           ;85
00001a  eb03024a          ADD      r2,r3,r10,LSL #1
;;;92     
;;;93       /* Apply loop unrolling and compute 4 output values simultaneously.      
;;;94        * The variables acc0 ... acc3 hold output values that are being computed:      
;;;95        *      
;;;96        *    acc0 =  b[numTaps-1] * x[n-numTaps-1] + b[numTaps-2] * x[n-numTaps-2] + b[numTaps-3] * x[n-numTaps-3] +...+ b[0] * x[0]      
;;;97        *    acc1 =  b[numTaps-1] * x[n-numTaps] +   b[numTaps-2] * x[n-numTaps-1] + b[numTaps-3] * x[n-numTaps-2] +...+ b[0] * x[1]      
;;;98        *    acc2 =  b[numTaps-1] * x[n-numTaps+1] + b[numTaps-2] * x[n-numTaps] +   b[numTaps-3] * x[n-numTaps-1] +...+ b[0] * x[2]      
;;;99        *    acc3 =  b[numTaps-1] * x[n-numTaps+2] + b[numTaps-2] * x[n-numTaps+1] + b[numTaps-3] * x[n-numTaps]   +...+ b[0] * x[3]      
;;;100       */
;;;101    
;;;102      blkCnt = blockSize >> 2;
00001e  9b08              LDR      r3,[sp,#0x20]
000020  4402              ADD      r2,r2,r0              ;91
000022  089b              LSRS     r3,r3,#2
000024  9304              STR      r3,[sp,#0x10]         ;77
000026  e07f              B        |L1.296|
                  |L1.40|
;;;103    
;;;104      /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.      
;;;105       ** a second loop below computes the remaining 1 to 3 samples. */
;;;106      while(blkCnt > 0u)
;;;107      {
;;;108        /* Copy four new input samples into the state buffer.      
;;;109         ** Use 32-bit SIMD to move the 16-bit data.  Only requires two copies. */
;;;110        *pStateCurnt++ = *pSrc++;
000028  f8313b02          LDRH     r3,[r1],#2
00002c  f8223b02          STRH     r3,[r2],#2
;;;111        *pStateCurnt++ = *pSrc++;
000030  f8313b02          LDRH     r3,[r1],#2
000034  f8223b02          STRH     r3,[r2],#2
;;;112        *pStateCurnt++ = *pSrc++;
000038  f8313b04          LDRH     r3,[r1],#4
00003c  f8223b04          STRH     r3,[r2],#4
;;;113        *pStateCurnt++ = *pSrc++;
000040  f8313c02          LDRH     r3,[r1,#-2]
000044  f8223c02          STRH     r3,[r2,#-2]
;;;114    
;;;115    
;;;116        /* Set all accumulators to zero */
;;;117        acc0 = 0;
000048  f04f0e00          MOV      lr,#0
;;;118        acc1 = 0;
;;;119        acc2 = 0;
;;;120        acc3 = 0;
00004c  f8cde000          STR      lr,[sp,#0]
;;;121    
;;;122        /* Typecast q15_t pointer to q31_t pointer for state reading in q31_t */
;;;123        px = pState;
;;;124    
;;;125        /* Typecast q15_t pointer to q31_t pointer for coefficient reading in q31_t */
;;;126        pb = pCoeffs;
000050  f8cde004          STR      lr,[sp,#4]
;;;127    
;;;128        /* Read the first two samples from the state buffer:  x[n-N], x[n-N-1] */
;;;129        x0 = *__SIMD32(px)++;
000054  1d03              ADDS     r3,r0,#4
000056  46f3              MOV      r11,lr                ;119
000058  f8dd900c          LDR      r9,[sp,#0xc]
00005c  6805              LDR      r5,[r0,#0]
;;;130    
;;;131        /* Read the third and forth samples from the state buffer: x[n-N-2], x[n-N-3] */
;;;132        x2 = *__SIMD32(px)++;
00005e  f8534b04          LDR      r4,[r3],#4
;;;133    
;;;134        /* Loop over the number of taps.  Unroll by a factor of 4.      
;;;135         ** Repeat until we've computed numTaps-(numTaps%4) coefficients. */
;;;136        tapCnt = numTaps >> 2;
000062  ea4f079a          LSR      r7,r10,#2
;;;137    
;;;138        while(tapCnt > 0)
000066  e02f              B        |L1.200|
                  |L1.104|
;;;139        {
;;;140          /* Read the first two coefficients using SIMD:  b[N] and b[N-1] coefficients */
;;;141          c0 = *__SIMD32(pb)++;
000068  f8596b04          LDR      r6,[r9],#4
;;;142    
;;;143          /* acc0 +=  b[N] * x[n-N] + b[N-1] * x[n-N-1] */
;;;144          acc0 = __SMLAD(x0, c0, acc0);
00006c  fb25ee06          SMLAD    lr,r5,r6,lr
;;;145    
;;;146          /* acc2 +=  b[N] * x[n-N-2] + b[N-1] * x[n-N-3] */
;;;147          acc2 = __SMLAD(x2, c0, acc2);
000070  fb24bb06          SMLAD    r11,r4,r6,r11
;;;148    
;;;149          /* pack  x[n-N-1] and x[n-N-2] */
;;;150    #ifndef ARM_MATH_BIG_ENDIAN
;;;151          x1 = __PKHBT(x2, x0, 0);
000074  eac40c05          PKHBT    r12,r4,r5
;;;152    #else
;;;153          x1 = __PKHBT(x0, x2, 0);
;;;154    #endif
;;;155    
;;;156          /* Read state x[n-N-4], x[n-N-5] */
;;;157          x0 = _SIMD32_OFFSET(px);
000078  f8535b04          LDR      r5,[r3],#4
;;;158    
;;;159          /* acc1 +=  b[N] * x[n-N-1] + b[N-1] * x[n-N-2] */
;;;160          acc1 = __SMLADX(x1, c0, acc1);
00007c  f8dd8000          LDR      r8,[sp,#0]
000080  fb2c8816          SMLADX   r8,r12,r6,r8
;;;161    
;;;162          /* pack  x[n-N-3] and x[n-N-4] */
;;;163    #ifndef ARM_MATH_BIG_ENDIAN
;;;164          x1 = __PKHBT(x0, x2, 0);
000084  eac50c04          PKHBT    r12,r5,r4
;;;165    #else
;;;166          x1 = __PKHBT(x2, x0, 0);
;;;167    #endif
;;;168    
;;;169          /* acc3 +=  b[N] * x[n-N-3] + b[N-1] * x[n-N-4] */
;;;170          acc3 = __SMLADX(x1, c0, acc3);
000088  f8cd8008          STR      r8,[sp,#8]
00008c  f8dd8004          LDR      r8,[sp,#4]
000090  f8cdc000          STR      r12,[sp,#0]
000094  fb2c8816          SMLADX   r8,r12,r6,r8
;;;171    
;;;172          /* Read coefficients b[N-2], b[N-3] */
;;;173          c0 = *__SIMD32(pb)++;
000098  f8cd8004          STR      r8,[sp,#4]
00009c  f8596b04          LDR      r6,[r9],#4
;;;174    
;;;175          /* acc0 +=  b[N-2] * x[n-N-2] + b[N-3] * x[n-N-3] */
;;;176          acc0 = __SMLAD(x2, c0, acc0);
0000a0  fb24ee06          SMLAD    lr,r4,r6,lr
;;;177    
;;;178          /* Read state x[n-N-6], x[n-N-7] with offset */
;;;179          x2 = _SIMD32_OFFSET(px + 2u);
0000a4  f8534b04          LDR      r4,[r3],#4
;;;180    
;;;181          /* acc2 +=  b[N-2] * x[n-N-4] + b[N-3] * x[n-N-5] */
;;;182          acc2 = __SMLAD(x0, c0, acc2);
0000a8  fb25bb06          SMLAD    r11,r5,r6,r11
;;;183    
;;;184          /* acc1 +=  b[N-2] * x[n-N-3] + b[N-3] * x[n-N-4] */
;;;185          acc1 = __SMLADX(x1, c0, acc1);
0000ac  f8dd8008          LDR      r8,[sp,#8]
0000b0  fb2c8c16          SMLADX   r12,r12,r6,r8
;;;186    
;;;187          /* pack  x[n-N-5] and x[n-N-6] */
;;;188    #ifndef ARM_MATH_BIG_ENDIAN
;;;189          x1 = __PKHBT(x2, x0, 0);
0000b4  f8cdc000          STR      r12,[sp,#0]
0000b8  eac40c05          PKHBT    r12,r4,r5
;;;190    #else
;;;191          x1 = __PKHBT(x0, x2, 0);
;;;192    #endif
;;;193    
;;;194          /* acc3 +=  b[N-2] * x[n-N-5] + b[N-3] * x[n-N-6] */
;;;195          acc3 = __SMLADX(x1, c0, acc3);
0000bc  f8dd8004          LDR      r8,[sp,#4]
0000c0  fb2c8616          SMLADX   r6,r12,r6,r8
0000c4  1e7f              SUBS     r7,r7,#1
0000c6  9601              STR      r6,[sp,#4]
                  |L1.200|
0000c8  2f00              CMP      r7,#0                 ;138
0000ca  d1cd              BNE      |L1.104|
;;;196    
;;;197          /* Update state pointer for next state reading */
;;;198          px += 4u;
;;;199    
;;;200          /* Decrement tap count */
;;;201          tapCnt--;
;;;202    
;;;203        }
;;;204    
;;;205        /* If the filter length is not a multiple of 4, compute the remaining filter taps.       
;;;206         ** This is always be 2 taps since the filter length is even. */
;;;207        if((numTaps & 0x3u) != 0u)
0000cc  ea5f768a          LSLS     r6,r10,#30
0000d0  d012              BEQ      |L1.248|
;;;208        {
;;;209    
;;;210          /* Read last two coefficients */
;;;211          c0 = *__SIMD32(pb)++;
0000d2  f8d96000          LDR      r6,[r9,#0]
;;;212    
;;;213          /* Perform the multiply-accumulates */
;;;214          acc0 = __SMLAD(x0, c0, acc0);
0000d6  fb25ee06          SMLAD    lr,r5,r6,lr
;;;215          acc2 = __SMLAD(x2, c0, acc2);
0000da  fb24bb06          SMLAD    r11,r4,r6,r11
;;;216    
;;;217          /* pack state variables */
;;;218    #ifndef ARM_MATH_BIG_ENDIAN
;;;219          x1 = __PKHBT(x2, x0, 0);
0000de  eac40505          PKHBT    r5,r4,r5
;;;220    #else
;;;221          x1 = __PKHBT(x0, x2, 0);
;;;222    #endif
;;;223    
;;;224          /* Read last state variables */
;;;225          x0 = *__SIMD32(px);
0000e2  681b              LDR      r3,[r3,#0]
;;;226    
;;;227          /* Perform the multiply-accumulates */
;;;228          acc1 = __SMLADX(x1, c0, acc1);
0000e4  9f00              LDR      r7,[sp,#0]
0000e6  fb257516          SMLADX   r5,r5,r6,r7
;;;229    
;;;230          /* pack state variables */
;;;231    #ifndef ARM_MATH_BIG_ENDIAN
;;;232          x1 = __PKHBT(x0, x2, 0);
0000ea  eac30304          PKHBT    r3,r3,r4
;;;233    #else
;;;234          x1 = __PKHBT(x2, x0, 0);
;;;235    #endif
;;;236    
;;;237          /* Perform the multiply-accumulates */
;;;238          acc3 = __SMLADX(x1, c0, acc3);
0000ee  9c01              LDR      r4,[sp,#4]
0000f0  9500              STR      r5,[sp,#0]
0000f2  fb234316          SMLADX   r3,r3,r6,r4
0000f6  9301              STR      r3,[sp,#4]
                  |L1.248|
;;;239        }
;;;240    
;;;241        /* The results in the 4 accumulators are in 2.30 format.  Convert to 1.15 with saturation.       
;;;242         ** Then store the 4 outputs in the destination buffer. */
;;;243    
;;;244    #ifndef ARM_MATH_BIG_ENDIAN
;;;245    
;;;246        *__SIMD32(pDst)++ =
0000f8  9b00              LDR      r3,[sp,#0]
0000fa  f32e34cf          SSAT     r4,#16,lr,ASR #15
0000fe  f32333cf          SSAT     r3,#16,r3,ASR #15
000102  eac44403          PKHBT    r4,r4,r3,LSL #16
000106  9b07              LDR      r3,[sp,#0x1c]
;;;247          __PKHBT(__SSAT((acc0 >> 15), 16), __SSAT((acc1 >> 15), 16), 16);
;;;248    
;;;249        *__SIMD32(pDst)++ =
000108  f32b35cf          SSAT     r5,#16,r11,ASR #15
00010c  601c              STR      r4,[r3,#0]            ;246
00010e  9c01              LDR      r4,[sp,#4]
000110  f32434cf          SSAT     r4,#16,r4,ASR #15
000114  eac54404          PKHBT    r4,r5,r4,LSL #16
000118  9b07              LDR      r3,[sp,#0x1c]
00011a  605c              STR      r4,[r3,#4]
00011c  3308              ADDS     r3,r3,#8
;;;250          __PKHBT(__SSAT((acc2 >> 15), 16), __SSAT((acc3 >> 15), 16), 16);
;;;251    
;;;252    #else
;;;253    
;;;254        *__SIMD32(pDst)++ =
;;;255          __PKHBT(__SSAT((acc1 >> 15), 16), __SSAT((acc0 >> 15), 16), 16);
;;;256    
;;;257        *__SIMD32(pDst)++ =
;;;258          __PKHBT(__SSAT((acc3 >> 15), 16), __SSAT((acc2 >> 15), 16), 16);
;;;259    
;;;260    
;;;261    #endif /*      #ifndef ARM_MATH_BIG_ENDIAN       */
;;;262    
;;;263        /* Advance the state pointer by 4 to process the next group of 4 samples */
;;;264        pState = pState + 4u;
;;;265    
;;;266        /* Decrement the loop counter */
;;;267        blkCnt--;
00011e  9307              STR      r3,[sp,#0x1c]
000120  9b04              LDR      r3,[sp,#0x10]
000122  1e5b              SUBS     r3,r3,#1
000124  3008              ADDS     r0,r0,#8
000126  9304              STR      r3,[sp,#0x10]
                  |L1.296|
000128  2b00              CMP      r3,#0                 ;106
00012a  f47faf7d          BNE      |L1.40|
;;;268      }
;;;269    
;;;270      /* If the blockSize is not a multiple of 4, compute any remaining output samples here.      
;;;271       ** No loop unrolling is used. */
;;;272      blkCnt = blockSize % 0x4u;
00012e  9b08              LDR      r3,[sp,#0x20]
000130  f0030603          AND      r6,r3,#3
;;;273      while(blkCnt > 0u)
000134  e021              B        |L1.378|
;;;274      {
;;;275        /* Copy two samples into state buffer */
;;;276        *pStateCurnt++ = *pSrc++;
000136  bf00              NOP      
                  |L1.312|
000138  f8313b02          LDRH     r3,[r1],#2
00013c  f8223b02          STRH     r3,[r2],#2
;;;277    
;;;278        /* Set the accumulator to zero */
;;;279        acc0 = 0;
;;;280    
;;;281        /* Use SIMD to hold states and coefficients */
;;;282        px = pState;
;;;283        pb = pCoeffs;
;;;284    
;;;285        tapCnt = numTaps >> 1u;
000140  f8dd300c          LDR.W    r3,[sp,#0xc]
000144  2700              MOVS     r7,#0                 ;279
000146  4604              MOV      r4,r0                 ;282
000148  ea4f055a          LSR      r5,r10,#1
                  |L1.332|
;;;286    
;;;287        do
;;;288        {
;;;289    
;;;290          acc0 += (q31_t) * px++ * *pb++;
00014c  f834cb02          LDRH     r12,[r4],#2
000150  f8338b02          LDRH     r8,[r3],#2
000154  fb1c7708          SMLABB   r7,r12,r8,r7
;;;291    	  acc0 += (q31_t) * px++ * *pb++;
000158  f834cb02          LDRH     r12,[r4],#2
00015c  f8338b02          LDRH     r8,[r3],#2
000160  fb1c7708          SMLABB   r7,r12,r8,r7
000164  1e6d              SUBS     r5,r5,#1
;;;292    
;;;293          tapCnt--;
;;;294        }
;;;295        while(tapCnt > 0u);
000166  d1f1              BNE      |L1.332|
;;;296    
;;;297        /* The result is in 2.30 format.  Convert to 1.15 with saturation.      
;;;298         ** Then store the output in the destination buffer. */
;;;299        *pDst++ = (q15_t) (__SSAT((acc0 >> 15), 16));
000168  9b07              LDR      r3,[sp,#0x1c]
00016a  f32734cf          SSAT     r4,#16,r7,ASR #15
00016e  1c80              ADDS     r0,r0,#2
000170  801c              STRH     r4,[r3,#0]
000172  9b07              LDR      r3,[sp,#0x1c]
000174  1c9b              ADDS     r3,r3,#2
000176  1e76              SUBS     r6,r6,#1
000178  9307              STR      r3,[sp,#0x1c]
                  |L1.378|
00017a  2e00              CMP      r6,#0                 ;273
00017c  d1dc              BNE      |L1.312|
;;;300    
;;;301        /* Advance state pointer by 1 for the next sample */
;;;302        pState = pState + 1u;
;;;303    
;;;304        /* Decrement the loop counter */
;;;305        blkCnt--;
;;;306      }
;;;307    
;;;308      /* Processing is complete.      
;;;309       ** Now copy the last numTaps - 1 samples to the satrt of the state buffer.      
;;;310       ** This prepares the state buffer for the next function call. */
;;;311    
;;;312      /* Points to the start of the state buffer */
;;;313      pStateCurnt = S->pState;
00017e  9905              LDR      r1,[sp,#0x14]
;;;314    
;;;315      /* Calculation of count for copying integer writes */
;;;316      tapCnt = (numTaps - 1u) >> 2;
000180  f1aa0301          SUB      r3,r10,#1
000184  089a              LSRS     r2,r3,#2
000186  6849              LDR      r1,[r1,#4]            ;313
;;;317    
;;;318      while(tapCnt > 0u)
000188  e011              B        |L1.430|
;;;319      {
;;;320        *pStateCurnt++ = *pState++;
00018a  bf00              NOP      
                  |L1.396|
00018c  f8304b02          LDRH     r4,[r0],#2
000190  f8214b02          STRH     r4,[r1],#2
;;;321        *pStateCurnt++ = *pState++;
000194  f8304b02          LDRH     r4,[r0],#2
000198  f8214b02          STRH     r4,[r1],#2
;;;322        *pStateCurnt++ = *pState++;
00019c  f8304b04          LDRH     r4,[r0],#4
0001a0  f8214b04          STRH     r4,[r1],#4
;;;323        *pStateCurnt++ = *pState++;
0001a4  f8304c02          LDRH     r4,[r0,#-2]
0001a8  f8214c02          STRH     r4,[r1,#-2]
0001ac  1e52              SUBS     r2,r2,#1
                  |L1.430|
0001ae  2a00              CMP      r2,#0                 ;318
0001b0  d1ec              BNE      |L1.396|
;;;324    
;;;325        tapCnt--;
;;;326    
;;;327      }
;;;328    
;;;329      /* Calculation of count for remaining q15_t data */
;;;330      tapCnt = (numTaps - 1u) % 0x4u;
0001b2  f0030203          AND      r2,r3,#3
;;;331    
;;;332      /* copy remaining data */
;;;333      while(tapCnt > 0u)
0001b6  e004              B        |L1.450|
                  |L1.440|
;;;334      {
;;;335        *pStateCurnt++ = *pState++;
0001b8  f8303b02          LDRH     r3,[r0],#2
0001bc  f8213b02          STRH     r3,[r1],#2
0001c0  1e52              SUBS     r2,r2,#1
                  |L1.450|
0001c2  2a00              CMP      r2,#0                 ;333
0001c4  d1f8              BNE      |L1.440|
;;;336    
;;;337        /* Decrement the loop counter */
;;;338        tapCnt--;
;;;339      }
;;;340    
;;;341    }
0001c6  b009              ADD      sp,sp,#0x24
0001c8  e8bd8ff0          POP      {r4-r11,pc}
;;;342    
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\FilteringFunctions\\arm_fir_fast_q15.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_fir_fast_q15_c_9f269210____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___18_arm_fir_fast_q15_c_9f269210____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_fir_fast_q15_c_9f269210____REVSH|
#line 144
|__asm___18_arm_fir_fast_q15_c_9f269210____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_fir_fast_q15_c_9f269210____RRX|
#line 300
|__asm___18_arm_fir_fast_q15_c_9f269210____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
