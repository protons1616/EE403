; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_lms_norm_q15.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_lms_norm_q15.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_lms_norm_q15.crf src\FilteringFunctions\arm_lms_norm_q15.c]
                          THUMB

                          AREA ||i.arm_lms_norm_q15||, CODE, READONLY, ALIGN=2

                  arm_lms_norm_q15 PROC
;;;78     
;;;79     void arm_lms_norm_q15(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;80       arm_lms_norm_instance_q15 * S,
;;;81       q15_t * pSrc,
;;;82       q15_t * pRef,
;;;83       q15_t * pOut,
;;;84       q15_t * pErr,
;;;85       uint32_t blockSize)
;;;86     {
000004  468a              MOV      r10,r1
000006  b094              SUB      sp,sp,#0x50
000008  e9d01301          LDRD     r1,r3,[r0,#4]
;;;87       q15_t *pState = S->pState;                     /* State pointer */
;;;88       q15_t *pCoeffs = S->pCoeffs;                   /* Coefficient pointer */
00000c  9a22              LDR      r2,[sp,#0x88]
;;;89       q15_t *pStateCurnt;                            /* Points to the current sample of the state */
;;;90       q15_t *px, *pb;                                /* Temporary pointers for state and coefficient buffers */
;;;91       q15_t mu = S->mu;                              /* Adaptive factor */
00000e  9313              STR      r3,[sp,#0x4c]
000010  f9b0300c          LDRSH    r3,[r0,#0xc]
;;;92       uint32_t numTaps = S->numTaps;                 /* Number of filter coefficients in the filter */
000014  9310              STR      r3,[sp,#0x40]
;;;93       uint32_t tapCnt, blkCnt;                       /* Loop counters */
;;;94       q31_t energy;                                  /* Energy of the input */
;;;95       q63_t acc;                                     /* Accumulator */
;;;96       q15_t e = 0, d = 0;                            /* error, reference data sample */
;;;97       q15_t w = 0, in;                               /* weight factor and state */
;;;98       q15_t x0;                                      /* temporary variable to hold input sample */
;;;99       //uint32_t shift = (uint32_t) S->postShift + 1u; /* Shift to be applied to the output */ 
;;;100      q15_t errorXmu, oneByEnergy;                   /* Temporary variables to store error and mu product and reciprocal of energy */
;;;101      q15_t postShift;                               /* Post shift to be applied to weight after reciprocal calculation */
;;;102      q31_t coef;                                    /* Teporary variable for coefficient */
;;;103      q31_t acc_l, acc_h;
;;;104      int32_t lShift = (15 - (int32_t) S->postShift);       /*  Post shift  */
000016  7b83              LDRB     r3,[r0,#0xe]
000018  8806              LDRH     r6,[r0,#0]            ;92
00001a  f1c3030f          RSB      r3,r3,#0xf
;;;105      int32_t uShift = (32 - lShift);
00001e  930c              STR      r3,[sp,#0x30]
000020  f1c30320          RSB      r3,r3,#0x20
;;;106    
;;;107      energy = S->energy;
000024  930f              STR      r3,[sp,#0x3c]
;;;108      x0 = S->x0;
;;;109    
;;;110      /* S->pState points to buffer which contains previous frame (numTaps - 1) samples */
;;;111      /* pStateCurnt points to the location where the new input data should be written */
;;;112      pStateCurnt = &(S->pState[(numTaps - 1u)]);
000026  f06f0401          MVN      r4,#1
00002a  f9b09014          LDRSH    r9,[r0,#0x14]         ;107
00002e  f9b03016          LDRSH    r3,[r0,#0x16]         ;108
000032  eb040446          ADD      r4,r4,r6,LSL #1
000036  eb010b04          ADD      r11,r1,r4
;;;113    
;;;114      /* Loop over blockSize number of values */
;;;115      blkCnt = blockSize;
00003a  bf00              NOP      
                  |L1.60|
00003c  ea5f0e02          MOVS     lr,r2
000040  d07e              BEQ      |L1.320|
;;;116    
;;;117    
;;;118    #ifndef ARM_MATH_CM0_FAMILY
;;;119    
;;;120      /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;121    
;;;122      while(blkCnt > 0u)
;;;123      {
;;;124        /* Copy the new input sample into the state buffer */
;;;125        *pStateCurnt++ = *pSrc;
000042  f8ba4000          LDRH     r4,[r10,#0]
000046  f82b4b02          STRH     r4,[r11],#2
;;;126    
;;;127        /* Initialize pState pointer */
;;;128        px = pState;
;;;129    
;;;130        /* Initialize coeff pointer */
;;;131        pb = (pCoeffs);
;;;132    
;;;133        /* Read the sample from input buffer */
;;;134        in = *pSrc++;
00004a  9d13              LDR      r5,[sp,#0x4c]
00004c  f83a2b02          LDRH     r2,[r10],#2
000050  460c              MOV      r4,r1                 ;128
;;;135    
;;;136        /* Update the energy calculation */
;;;137        energy -= (((q31_t) x0 * (x0)) >> 15);
000052  fb13f703          SMULBB   r7,r3,r3
000056  eba933e7          SUB      r3,r9,r7,ASR #15
;;;138        energy += (((q31_t) in * (in)) >> 15);
00005a  fb12f202          SMULBB   r2,r2,r2
00005e  eb0339e2          ADD      r9,r3,r2,ASR #15
000062  2200              MOVS     r2,#0
;;;139    
;;;140        /* Set the accumulator to zero */
;;;141        acc = 0;
;;;142    
;;;143        /* Loop unrolling.  Process 4 taps at a time. */
;;;144        tapCnt = numTaps >> 2;
000064  08b7              LSRS     r7,r6,#2
000066  4613              MOV      r3,r2                 ;138
;;;145    
;;;146        while(tapCnt > 0u)
000068  9704              STR      r7,[sp,#0x10]
00006a  e00c              B        |L1.134|
                  |L1.108|
;;;147        {
;;;148    
;;;149          /* Perform the multiply-accumulate */
;;;150    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;151    
;;;152          acc = __SMLALD(*__SIMD32(px)++, (*__SIMD32(pb)++), acc);
00006c  f8548b04          LDR      r8,[r4],#4
000070  f855cb04          LDR      r12,[r5],#4
000074  fbc823cc          SMLALD   r2,r3,r8,r12
;;;153          acc = __SMLALD(*__SIMD32(px)++, (*__SIMD32(pb)++), acc);
000078  f8548b04          LDR      r8,[r4],#4
00007c  f855cb04          LDR      r12,[r5],#4
000080  fbc823cc          SMLALD   r2,r3,r8,r12
000084  1e7f              SUBS     r7,r7,#1
                  |L1.134|
000086  2f00              CMP      r7,#0                 ;146
000088  d1f0              BNE      |L1.108|
;;;154    
;;;155    #else
;;;156    
;;;157          acc += (((q31_t) * px++ * (*pb++)));
;;;158          acc += (((q31_t) * px++ * (*pb++)));
;;;159          acc += (((q31_t) * px++ * (*pb++)));
;;;160          acc += (((q31_t) * px++ * (*pb++)));
;;;161    
;;;162    #endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE	*/
;;;163    
;;;164          /* Decrement the loop counter */
;;;165          tapCnt--;
;;;166        }
;;;167    
;;;168        /* If the filter length is not a multiple of 4, compute the remaining filter taps */
;;;169        tapCnt = numTaps % 0x4u;
00008a  f0060703          AND      r7,r6,#3
;;;170    
;;;171        while(tapCnt > 0u)
00008e  9701              STR      r7,[sp,#4]
000090  e007              B        |L1.162|
;;;172        {
;;;173          /* Perform the multiply-accumulate */
;;;174          acc += (((q31_t) * px++ * (*pb++)));
000092  bf00              NOP      
                  |L1.148|
000094  f9348b02          LDRSH    r8,[r4],#2
000098  f935cb02          LDRSH    r12,[r5],#2
00009c  fbc8238c          SMLALBB  r2,r3,r8,r12
0000a0  1e7f              SUBS     r7,r7,#1
                  |L1.162|
0000a2  2f00              CMP      r7,#0                 ;171
0000a4  d1f6              BNE      |L1.148|
;;;175    
;;;176          /* Decrement the loop counter */
;;;177          tapCnt--;
;;;178        }
;;;179    
;;;180        /* Calc lower part of acc */
;;;181        acc_l = acc & 0xffffffff;
;;;182    
;;;183        /* Calc upper part of acc */
;;;184        acc_h = (acc >> 32) & 0xffffffff;
;;;185    
;;;186        /* Apply shift for lower part of acc and upper part of acc */
;;;187        acc = (uint32_t) acc_l >> lShift | acc_h << uShift;
0000a6  9c0c              LDR      r4,[sp,#0x30]
0000a8  40e2              LSRS     r2,r2,r4
0000aa  9c0f              LDR      r4,[sp,#0x3c]
0000ac  40a3              LSLS     r3,r3,r4
0000ae  431a              ORRS     r2,r2,r3
;;;188    
;;;189        /* Converting the result to 1.15 format and saturate the output */
;;;190        acc = __SSAT(acc, 16u);
0000b0  f302030f          SSAT     r3,#16,r2
;;;191    
;;;192        /* Store the result from accumulator into the destination buffer. */
;;;193        *pOut++ = (q15_t) acc;
0000b4  9a17              LDR      r2,[sp,#0x5c]
0000b6  8013              STRH     r3,[r2,#0]
0000b8  9a17              LDR      r2,[sp,#0x5c]
;;;194    
;;;195        /* Compute and store error */
;;;196        d = *pRef++;
0000ba  9c16              LDR      r4,[sp,#0x58]
0000bc  1c92              ADDS     r2,r2,#2              ;193
0000be  9217              STR      r2,[sp,#0x5c]
0000c0  9a16              LDR      r2,[sp,#0x58]
0000c2  1ca4              ADDS     r4,r4,#2
0000c4  8812              LDRH     r2,[r2,#0]
;;;197        e = d - (q15_t) acc;
;;;198        *pErr++ = e;
0000c6  9416              STR      r4,[sp,#0x58]
0000c8  1ad2              SUBS     r2,r2,r3              ;197
0000ca  fa0ffc82          SXTH     r12,r2                ;197
0000ce  9a21              LDR      r2,[sp,#0x84]
0000d0  f8a2c000          STRH     r12,[r2,#0]
0000d4  9a21              LDR      r2,[sp,#0x84]
0000d6  1c92              ADDS     r2,r2,#2
;;;199    
;;;200        /* Calculation of 1/energy */
;;;201        postShift = arm_recip_q15((q15_t) energy + DELTA_Q15,
0000d8  2305              MOVS     r3,#5
0000da  9221              STR      r2,[sp,#0x84]
0000dc  fa03f289          SXTAH    r2,r3,r9
0000e0  ab0e              ADD      r3,sp,#0x38
0000e2  9309              STR      r3,[sp,#0x24]
0000e4  b212              SXTH     r2,r2
0000e6  2300              MOVS     r3,#0
0000e8  6905              LDR      r5,[r0,#0x10]
0000ea  2a00              CMP      r2,#0
0000ec  dd02              BLE      |L1.244|
0000ee  fab2f782          CLZ      r7,r2
0000f2  e002              B        |L1.250|
                  |L1.244|
0000f4  4254              RSBS     r4,r2,#0
0000f6  fab4f784          CLZ      r7,r4
                  |L1.250|
0000fa  3f11              SUBS     r7,r7,#0x11
0000fc  40ba              LSLS     r2,r2,r7
0000fe  b214              SXTH     r4,r2
000100  f3c42205          UBFX     r2,r4,#8,#6
000104  f64778ff          MOV      r8,#0x7fff
000108  f9352012          LDRSH    r2,[r5,r2,LSL #1]
                  |L1.268|
00010c  fb14f502          SMULBB   r5,r4,r2
000110  f34535cf          SBFX     r5,r5,#15,#16
000114  eba80505          SUB      r5,r8,r5
000118  436a              MULS     r2,r5,r2
00011a  1c5b              ADDS     r3,r3,#1
00011c  f342328f          SBFX     r2,r2,#14,#16
000120  2b02              CMP      r3,#2
000122  d3f3              BCC      |L1.268|
000124  9b09              LDR      r3,[sp,#0x24]
000126  801a              STRH     r2,[r3,#0]
;;;202                                  &oneByEnergy, S->recipTable);
;;;203    
;;;204        /* Calculation of e * mu value */
;;;205        errorXmu = (q15_t) (((q31_t) e * mu) >> 15);
000128  9a10              LDR      r2,[sp,#0x40]
00012a  fb1cf202          SMULBB   r2,r12,r2
;;;206    
;;;207        /* Calculation of (e * mu) * (1/energy) value */
;;;208        acc = (((q31_t) errorXmu * oneByEnergy) >> (15 - postShift));
00012e  f8bd3038          LDRH     r3,[sp,#0x38]
000132  13d2              ASRS     r2,r2,#15             ;205
000134  fb12f203          SMULBB   r2,r2,r3
000138  1c7f              ADDS     r7,r7,#1
00013a  f1c7030f          RSB      r3,r7,#0xf
00013e  e000              B        |L1.322|
                  |L1.320|
000140  e04b              B        |L1.474|
                  |L1.322|
000142  411a              ASRS     r2,r2,r3
;;;209    
;;;210        /* Weighting factor for the normalized version */
;;;211        w = (q15_t) __SSAT((q31_t) acc, 16);
000144  f302040f          SSAT     r4,#16,r2
;;;212    
;;;213        /* Initialize pState pointer */
;;;214        px = pState;
000148  460b              MOV      r3,r1
;;;215    
;;;216        /* Initialize coeff pointer */
;;;217        pb = (pCoeffs);
;;;218    
;;;219        /* Loop unrolling.  Process 4 taps at a time. */
;;;220        tapCnt = numTaps >> 2;
;;;221    
;;;222        /* Update filter coefficients */
;;;223        while(tapCnt > 0u)
00014a  9d04              LDR      r5,[sp,#0x10]
00014c  9a13              LDR      r2,[sp,#0x4c]
00014e  e02c              B        |L1.426|
                  |L1.336|
;;;224        {
;;;225          coef = *pb + (((q31_t) w * (*px++)) >> 15);
000150  f9337b02          LDRSH    r7,[r3],#2
000154  f9b2c000          LDRSH    r12,[r2,#0]
000158  4367              MULS     r7,r4,r7
00015a  eb0c37e7          ADD      r7,r12,r7,ASR #15
;;;226          *pb++ = (q15_t) __SSAT((coef), 16);
00015e  f307070f          SSAT     r7,#16,r7
000162  f8227b02          STRH     r7,[r2],#2
;;;227          coef = *pb + (((q31_t) w * (*px++)) >> 15);
000166  f9337b02          LDRSH    r7,[r3],#2
00016a  f932cb02          LDRSH    r12,[r2],#2
00016e  4367              MULS     r7,r4,r7
000170  eb0c37e7          ADD      r7,r12,r7,ASR #15
;;;228          *pb++ = (q15_t) __SSAT((coef), 16);
000174  f307070f          SSAT     r7,#16,r7
000178  f8227c02          STRH     r7,[r2,#-2]
;;;229          coef = *pb + (((q31_t) w * (*px++)) >> 15);
00017c  f9337b04          LDRSH    r7,[r3],#4
000180  f932cb04          LDRSH    r12,[r2],#4
000184  4367              MULS     r7,r4,r7
000186  eb0c37e7          ADD      r7,r12,r7,ASR #15
;;;230          *pb++ = (q15_t) __SSAT((coef), 16);
00018a  f307070f          SSAT     r7,#16,r7
00018e  f8227c04          STRH     r7,[r2,#-4]
;;;231          coef = *pb + (((q31_t) w * (*px++)) >> 15);
000192  f9337c02          LDRSH    r7,[r3,#-2]
000196  f932cc02          LDRSH    r12,[r2,#-2]
00019a  4367              MULS     r7,r4,r7
00019c  eb0c37e7          ADD      r7,r12,r7,ASR #15
;;;232          *pb++ = (q15_t) __SSAT((coef), 16);
0001a0  f307070f          SSAT     r7,#16,r7
0001a4  f8227c02          STRH     r7,[r2,#-2]
0001a8  1e6d              SUBS     r5,r5,#1
                  |L1.426|
0001aa  2d00              CMP      r5,#0                 ;223
0001ac  d1d0              BNE      |L1.336|
;;;233    
;;;234          /* Decrement the loop counter */
;;;235          tapCnt--;
;;;236        }
;;;237    
;;;238        /* If the filter length is not a multiple of 4, compute the remaining filter taps */
;;;239        tapCnt = numTaps % 0x4u;
;;;240    
;;;241        while(tapCnt > 0u)
0001ae  9d01              LDR      r5,[sp,#4]
0001b0  e00c              B        |L1.460|
;;;242        {
;;;243          /* Perform the multiply-accumulate */
;;;244          coef = *pb + (((q31_t) w * (*px++)) >> 15);
0001b2  bf00              NOP      
                  |L1.436|
0001b4  f9337b02          LDRSH    r7,[r3],#2
0001b8  f9b2c000          LDRSH    r12,[r2,#0]
0001bc  4367              MULS     r7,r4,r7
0001be  eb0c37e7          ADD      r7,r12,r7,ASR #15
;;;245          *pb++ = (q15_t) __SSAT((coef), 16);
0001c2  f307070f          SSAT     r7,#16,r7
0001c6  f8227b02          STRH     r7,[r2],#2
0001ca  1e6d              SUBS     r5,r5,#1
                  |L1.460|
0001cc  2d00              CMP      r5,#0                 ;241
0001ce  d1f1              BNE      |L1.436|
;;;246    
;;;247          /* Decrement the loop counter */
;;;248          tapCnt--;
;;;249        }
;;;250    
;;;251        /* Read the sample from state buffer */
;;;252        x0 = *pState;
0001d0  f9313b02          LDRSH    r3,[r1],#2
;;;253    
;;;254        /* Advance state pointer by 1 for the next sample */
;;;255        pState = pState + 1u;
;;;256    
;;;257        /* Decrement the loop counter */
;;;258        blkCnt--;
0001d4  f1ae0201          SUB      r2,lr,#1
0001d8  e730              B        |L1.60|
                  |L1.474|
;;;259      }
;;;260    
;;;261      /* Save energy and x0 values for the next frame */
;;;262      S->energy = (q15_t) energy;
0001da  f8a09014          STRH     r9,[r0,#0x14]
;;;263      S->x0 = x0;
0001de  82c3              STRH     r3,[r0,#0x16]
;;;264    
;;;265      /* Processing is complete. Now copy the last numTaps - 1 samples to the    
;;;266         satrt of the state buffer. This prepares the state buffer for the    
;;;267         next function call. */
;;;268    
;;;269      /* Points to the start of the pState buffer */
;;;270      pStateCurnt = S->pState;
0001e0  1e76              SUBS     r6,r6,#1
0001e2  6840              LDR      r0,[r0,#4]
;;;271    
;;;272      /* Calculation of count for copying integer writes */
;;;273      tapCnt = (numTaps - 1u) >> 2;
0001e4  08b2              LSRS     r2,r6,#2
;;;274    
;;;275      while(tapCnt > 0u)
0001e6  e008              B        |L1.506|
                  |L1.488|
;;;276      {
;;;277    
;;;278    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;279    
;;;280        *__SIMD32(pStateCurnt)++ = *__SIMD32(pState)++;
0001e8  f8513b04          LDR      r3,[r1],#4
0001ec  f8403b04          STR      r3,[r0],#4
;;;281        *__SIMD32(pStateCurnt)++ = *__SIMD32(pState)++;
0001f0  f8513b04          LDR      r3,[r1],#4
0001f4  f8403b04          STR      r3,[r0],#4
0001f8  1e52              SUBS     r2,r2,#1
                  |L1.506|
0001fa  2a00              CMP      r2,#0                 ;275
0001fc  d1f4              BNE      |L1.488|
;;;282    
;;;283    #else
;;;284    
;;;285        *pStateCurnt++ = *pState++;
;;;286        *pStateCurnt++ = *pState++;
;;;287        *pStateCurnt++ = *pState++;
;;;288        *pStateCurnt++ = *pState++;
;;;289    
;;;290    #endif
;;;291    
;;;292        tapCnt--;
;;;293    
;;;294      }
;;;295    
;;;296      /* Calculation of count for remaining q15_t data */
;;;297      tapCnt = (numTaps - 1u) % 0x4u;
0001fe  f0060203          AND      r2,r6,#3
;;;298    
;;;299      /* copy data */
;;;300      while(tapCnt > 0u)
000202  e004              B        |L1.526|
                  |L1.516|
;;;301      {
;;;302        *pStateCurnt++ = *pState++;
000204  f8313b02          LDRH     r3,[r1],#2
000208  f8203b02          STRH     r3,[r0],#2
00020c  1e52              SUBS     r2,r2,#1
                  |L1.526|
00020e  2a00              CMP      r2,#0                 ;300
000210  d1f8              BNE      |L1.516|
;;;303    
;;;304        /* Decrement the loop counter */
;;;305        tapCnt--;
;;;306      }
;;;307    
;;;308    #else
;;;309    
;;;310      /* Run the below code for Cortex-M0 */
;;;311    
;;;312      while(blkCnt > 0u)
;;;313      {
;;;314        /* Copy the new input sample into the state buffer */
;;;315        *pStateCurnt++ = *pSrc;
;;;316    
;;;317        /* Initialize pState pointer */
;;;318        px = pState;
;;;319    
;;;320        /* Initialize pCoeffs pointer */
;;;321        pb = pCoeffs;
;;;322    
;;;323        /* Read the sample from input buffer */
;;;324        in = *pSrc++;
;;;325    
;;;326        /* Update the energy calculation */
;;;327        energy -= (((q31_t) x0 * (x0)) >> 15);
;;;328        energy += (((q31_t) in * (in)) >> 15);
;;;329    
;;;330        /* Set the accumulator to zero */
;;;331        acc = 0;
;;;332    
;;;333        /* Loop over numTaps number of values */
;;;334        tapCnt = numTaps;
;;;335    
;;;336        while(tapCnt > 0u)
;;;337        {
;;;338          /* Perform the multiply-accumulate */
;;;339          acc += (((q31_t) * px++ * (*pb++)));
;;;340    
;;;341          /* Decrement the loop counter */
;;;342          tapCnt--;
;;;343        }
;;;344    
;;;345        /* Calc lower part of acc */
;;;346        acc_l = acc & 0xffffffff;
;;;347    
;;;348        /* Calc upper part of acc */
;;;349        acc_h = (acc >> 32) & 0xffffffff;
;;;350    
;;;351        /* Apply shift for lower part of acc and upper part of acc */
;;;352        acc = (uint32_t) acc_l >> lShift | acc_h << uShift;
;;;353    
;;;354        /* Converting the result to 1.15 format and saturate the output */
;;;355        acc = __SSAT(acc, 16u);
;;;356    
;;;357        /* Converting the result to 1.15 format */
;;;358        //acc = __SSAT((acc >> (16u - shift)), 16u); 
;;;359    
;;;360        /* Store the result from accumulator into the destination buffer. */
;;;361        *pOut++ = (q15_t) acc;
;;;362    
;;;363        /* Compute and store error */
;;;364        d = *pRef++;
;;;365        e = d - (q15_t) acc;
;;;366        *pErr++ = e;
;;;367    
;;;368        /* Calculation of 1/energy */
;;;369        postShift = arm_recip_q15((q15_t) energy + DELTA_Q15,
;;;370                                  &oneByEnergy, S->recipTable);
;;;371    
;;;372        /* Calculation of e * mu value */
;;;373        errorXmu = (q15_t) (((q31_t) e * mu) >> 15);
;;;374    
;;;375        /* Calculation of (e * mu) * (1/energy) value */
;;;376        acc = (((q31_t) errorXmu * oneByEnergy) >> (15 - postShift));
;;;377    
;;;378        /* Weighting factor for the normalized version */
;;;379        w = (q15_t) __SSAT((q31_t) acc, 16);
;;;380    
;;;381        /* Initialize pState pointer */
;;;382        px = pState;
;;;383    
;;;384        /* Initialize coeff pointer */
;;;385        pb = (pCoeffs);
;;;386    
;;;387        /* Loop over numTaps number of values */
;;;388        tapCnt = numTaps;
;;;389    
;;;390        while(tapCnt > 0u)
;;;391        {
;;;392          /* Perform the multiply-accumulate */
;;;393          coef = *pb + (((q31_t) w * (*px++)) >> 15);
;;;394          *pb++ = (q15_t) __SSAT((coef), 16);
;;;395    
;;;396          /* Decrement the loop counter */
;;;397          tapCnt--;
;;;398        }
;;;399    
;;;400        /* Read the sample from state buffer */
;;;401        x0 = *pState;
;;;402    
;;;403        /* Advance state pointer by 1 for the next sample */
;;;404        pState = pState + 1u;
;;;405    
;;;406        /* Decrement the loop counter */
;;;407        blkCnt--;
;;;408      }
;;;409    
;;;410      /* Save energy and x0 values for the next frame */
;;;411      S->energy = (q15_t) energy;
;;;412      S->x0 = x0;
;;;413    
;;;414      /* Processing is complete. Now copy the last numTaps - 1 samples to the        
;;;415         satrt of the state buffer. This prepares the state buffer for the        
;;;416         next function call. */
;;;417    
;;;418      /* Points to the start of the pState buffer */
;;;419      pStateCurnt = S->pState;
;;;420    
;;;421      /* copy (numTaps - 1u) data */
;;;422      tapCnt = (numTaps - 1u);
;;;423    
;;;424      /* copy data */
;;;425      while(tapCnt > 0u)
;;;426      {
;;;427        *pStateCurnt++ = *pState++;
;;;428    
;;;429        /* Decrement the loop counter */
;;;430        tapCnt--;
;;;431      }
;;;432    
;;;433    #endif /*   #ifndef ARM_MATH_CM0_FAMILY */
;;;434    
;;;435    }
000212  b018              ADD      sp,sp,#0x60
000214  e8bd8ff0          POP      {r4-r11,pc}
;;;436    
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\FilteringFunctions\\arm_lms_norm_q15.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_lms_norm_q15_c_0f7c2473____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___18_arm_lms_norm_q15_c_0f7c2473____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_lms_norm_q15_c_0f7c2473____REVSH|
#line 144
|__asm___18_arm_lms_norm_q15_c_0f7c2473____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_lms_norm_q15_c_0f7c2473____RRX|
#line 300
|__asm___18_arm_lms_norm_q15_c_0f7c2473____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
