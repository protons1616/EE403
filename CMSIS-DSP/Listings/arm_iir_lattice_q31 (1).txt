; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_iir_lattice_q31.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_iir_lattice_q31.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"Z:\GoogleDrive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_iir_lattice_q31.crf src\FilteringFunctions\arm_iir_lattice_q31.c]
                          THUMB

                          AREA ||i.arm_iir_lattice_q31||, CODE, READONLY, ALIGN=1

                  arm_iir_lattice_q31 PROC
;;;69     
;;;70     void arm_iir_lattice_q31(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;71       const arm_iir_lattice_instance_q31 * S,
;;;72       q31_t * pSrc,
;;;73       q31_t * pDst,
;;;74       uint32_t blockSize)
;;;75     {
000004  b084              SUB      sp,sp,#0x10
000006  4682              MOV      r10,r0
;;;76       q31_t fcurr, fnext = 0, gcurr = 0, gnext;      /* Temporary variables for lattice stages */
;;;77       q63_t acc;                                     /* Accumlator */
;;;78       uint32_t blkCnt, tapCnt;                       /* Temporary variables for counts */
;;;79       q31_t *px1, *px2, *pk, *pv;                    /* Temporary pointers for state and coef */
;;;80       uint32_t numStages = S->numStages;             /* number of stages */
000008  f8b0e000          LDRH     lr,[r0,#0]
;;;81       q31_t *pState;                                 /* State pointer */
;;;82       q31_t *pStateCurnt;                            /* State current pointer */
;;;83     
;;;84       blkCnt = blockSize;
00000c  9807              LDR      r0,[sp,#0x1c]
;;;85     
;;;86       pState = &S->pState[0];
00000e  9000              STR      r0,[sp,#0]
000010  f8da0004          LDR      r0,[r10,#4]
;;;87     
;;;88     
;;;89     #ifndef ARM_MATH_CM0_FAMILY
;;;90     
;;;91       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;92     
;;;93       /* Sample processing */
;;;94       while(blkCnt > 0u)
000014  9001              STR      r0,[sp,#4]
000016  9800              LDR      r0,[sp,#0]            ;75
000018  e0d5              B        |L1.454|
                  |L1.26|
;;;95       {
;;;96         /* Read Sample from input buffer */
;;;97         /* fN(n) = x(n) */
;;;98         fcurr = *pSrc++;
00001a  9805              LDR      r0,[sp,#0x14]
00001c  c820              LDM      r0!,{r5}
;;;99     
;;;100        /* Initialize state read pointer */
;;;101        px1 = pState;
;;;102        /* Initialize state write pointer */
;;;103        px2 = pState;
00001e  9005              STR      r0,[sp,#0x14]
000020  e9da3202          LDRD     r3,r2,[r10,#8]
;;;104        /* Set accumulator to zero */
;;;105        acc = 0;
;;;106        /* Initialize Ladder coeff pointer */
;;;107        pv = &S->pvCoeffs[0];
;;;108        /* Initialize Reflection coeff pointer */
;;;109        pk = &S->pkCoeffs[0];
;;;110    
;;;111    
;;;112        /* Process sample for first tap */
;;;113        gcurr = *px1++;
000024  9801              LDR      r0,[sp,#4]
;;;114        /* fN-1(n) = fN(n) - kN * gN-1(n-1) */
;;;115        fnext = __QSUB(fcurr, (q31_t) (((q63_t) gcurr * (*pk)) >> 31));
000026  cb40              LDM      r3!,{r6}
000028  c810              LDM      r0!,{r4}              ;113
00002a  4601              MOV      r1,r0                 ;113
00002c  fb847c06          SMULL    r7,r12,r4,r6
000030  0fff              LSRS     r7,r7,#31
000032  ea47074c          ORR      r7,r7,r12,LSL #1
000036  fa87f5a5          QSUB     r5,r5,r7
;;;116        /* gN(n) = kN * fN-1(n) + gN-1(n-1) */
;;;117        gnext = __QADD(gcurr, (q31_t) (((q63_t) fnext * (*pk++)) >> 31));
00003a  fb856706          SMULL    r6,r7,r5,r6
00003e  0ff6              LSRS     r6,r6,#31
000040  ea460647          ORR      r6,r6,r7,LSL #1
000044  fa86f484          QADD     r4,r4,r6
;;;118        /* write gN-1(n-1) into state for next sample processing */
;;;119        *px2++ = gnext;
000048  f8404c04          STR      r4,[r0,#-4]
;;;120        /* y(n) += gN(n) * vN  */
;;;121        acc += ((q63_t) gnext * *pv++);
00004c  ca40              LDM      r2!,{r6}
00004e  fb847406          SMULL    r7,r4,r4,r6
;;;122    
;;;123        /* Update f values for next coefficient processing */
;;;124        fcurr = fnext;
;;;125    
;;;126        /* Loop unrolling.  Process 4 taps at a time. */
;;;127        tapCnt = (numStages - 1u) >> 2;
000052  f1ae0601          SUB      r6,lr,#1
000056  9603              STR      r6,[sp,#0xc]
000058  08b6              LSRS     r6,r6,#2
;;;128    
;;;129        while(tapCnt > 0u)
00005a  e077              B        |L1.332|
                  |L1.92|
;;;130        {
;;;131    
;;;132          /* Process sample for 2nd, 6th .. taps */
;;;133          /* Read gN-2(n-1) from state buffer */
;;;134          gcurr = *px1++;
00005c  f851bb04          LDR      r11,[r1],#4
000060  4689              MOV      r9,r1
;;;135          /* fN-2(n) = fN-1(n) - kN-1 * gN-2(n-1) */
;;;136          fnext = __QSUB(fcurr, (q31_t) (((q63_t) gcurr * (*pk)) >> 31));
000062  cb02              LDM      r3!,{r1}
000064  fb8bc801          SMULL    r12,r8,r11,r1
000068  ea4f7cdc          LSR      r12,r12,#31
00006c  ea4c0c48          ORR      r12,r12,r8,LSL #1
000070  fa8cf5a5          QSUB     r5,r5,r12
;;;137          /* gN-1(n) = kN-1 * fN-2(n) + gN-2(n-1) */
;;;138          gnext = __QADD(gcurr, (q31_t) (((q63_t) fnext * (*pk++)) >> 31));
000074  fb851c01          SMULL    r1,r12,r5,r1
000078  0fc9              LSRS     r1,r1,#31
00007a  ea41014c          ORR      r1,r1,r12,LSL #1
00007e  fa81f18b          QADD     r1,r11,r1
;;;139          /* y(n) += gN-1(n) * vN-1  */
;;;140          /* process for gN-5(n) * vN-5, gN-9(n) * vN-9 ... */
;;;141          acc += ((q63_t) gnext * *pv++);
000082  f8d2c000          LDR      r12,[r2,#0]
;;;142          /* write gN-1(n) into state for next sample processing */
;;;143          *px2++ = gnext;
;;;144    
;;;145          /* Process sample for 3nd, 7th ...taps */
;;;146          /* Read gN-3(n-1) from state buffer */
;;;147          gcurr = *px1++;
000086  6001              STR      r1,[r0,#0]
000088  fb818c0c          SMULL    r8,r12,r1,r12         ;141
00008c  eb180707          ADDS     r7,r8,r7              ;141
000090  eb4c0b04          ADC      r11,r12,r4            ;141
;;;148          /* Process sample for 3rd, 7th .. taps */
;;;149          /* fN-3(n) = fN-2(n) - kN-2 * gN-3(n-1) */
;;;150          fcurr = __QSUB(fnext, (q31_t) (((q63_t) gcurr * (*pk)) >> 31));
000094  f8d94000          LDR      r4,[r9,#0]
000098  f853cb04          LDR      r12,[r3],#4
00009c  f8cdc008          STR      r12,[sp,#8]
0000a0  fb84c80c          SMULL    r12,r8,r4,r12
0000a4  ea4f7cdc          LSR      r12,r12,#31
0000a8  f1090104          ADD      r1,r9,#4              ;147
0000ac  ea4c0c48          ORR      r12,r12,r8,LSL #1
0000b0  fa8cf9a5          QSUB     r9,r5,r12
;;;151          /* gN-2(n) = kN-2 * fN-3(n) + gN-3(n-1) */
;;;152          gnext = __QADD(gcurr, (q31_t) (((q63_t) fcurr * (*pk++)) >> 31));
0000b4  f8ddc008          LDR      r12,[sp,#8]
0000b8  fb895c0c          SMULL    r5,r12,r9,r12
0000bc  0fed              LSRS     r5,r5,#31
0000be  ea45054c          ORR      r5,r5,r12,LSL #1
0000c2  fa85f584          QADD     r5,r4,r5
;;;153          /* y(n) += gN-2(n) * vN-2  */
;;;154          /* process for gN-6(n) * vN-6, gN-10(n) * vN-10 ... */
;;;155          acc += ((q63_t) gnext * *pv++);
0000c6  6854              LDR      r4,[r2,#4]
;;;156          /* write gN-2(n) into state for next sample processing */
;;;157          *px2++ = gnext;
;;;158    
;;;159    
;;;160          /* Process sample for 4th, 8th ...taps */
;;;161          /* Read gN-4(n-1) from state buffer */
;;;162          gcurr = *px1++;
0000c8  6045              STR      r5,[r0,#4]
0000ca  fb858404          SMULL    r8,r4,r5,r4           ;155
0000ce  eb180707          ADDS     r7,r8,r7              ;155
0000d2  eb44040b          ADC      r4,r4,r11             ;155
0000d6  46bb              MOV      r11,r7                ;155
;;;163          /* Process sample for 4th, 8th .. taps */
;;;164          /* fN-4(n) = fN-3(n) - kN-3 * gN-4(n-1) */
;;;165          fnext = __QSUB(fcurr, (q31_t) (((q63_t) gcurr * (*pk)) >> 31));
0000d8  680f              LDR      r7,[r1,#0]
0000da  f853cb04          LDR      r12,[r3],#4
0000de  fb87850c          SMULL    r8,r5,r7,r12
0000e2  ea4f78d8          LSR      r8,r8,#31
0000e6  ea480845          ORR      r8,r8,r5,LSL #1
0000ea  fa88f9a9          QSUB     r9,r9,r8
;;;166          /* gN-3(n) = kN-3 * fN-4(n) + gN-4(n-1) */
;;;167          gnext = __QADD(gcurr, (q31_t) (((q63_t) fnext * (*pk++)) >> 31));
0000ee  fb895c0c          SMULL    r5,r12,r9,r12
0000f2  0fed              LSRS     r5,r5,#31
0000f4  ea45054c          ORR      r5,r5,r12,LSL #1
0000f8  fa85f587          QADD     r5,r7,r5
;;;168          /* y(n) += gN-3(n) * vN-3  */
;;;169          /* process for gN-7(n) * vN-7, gN-11(n) * vN-11 ... */
;;;170          acc += ((q63_t) gnext * *pv++);
0000fc  6897              LDR      r7,[r2,#8]
;;;171          /* write gN-3(n) into state for next sample processing */
;;;172          *px2++ = gnext;
;;;173    
;;;174    
;;;175          /* Process sample for 5th, 9th ...taps */
;;;176          /* Read gN-5(n-1) from state buffer */
;;;177          gcurr = *px1++;
0000fe  6085              STR      r5,[r0,#8]
000100  fb858c07          SMULL    r8,r12,r5,r7          ;170
000104  eb18070b          ADDS     r7,r8,r11             ;170
000108  eb4c0b04          ADC      r11,r12,r4            ;170
;;;178          /* Process sample for 5th, 9th .. taps */
;;;179          /* fN-5(n) = fN-4(n) - kN-4 * gN-1(n-1) */
;;;180          fcurr = __QSUB(fnext, (q31_t) (((q63_t) gcurr * (*pk)) >> 31));
00010c  684c              LDR      r4,[r1,#4]
00010e  f853cb04          LDR      r12,[r3],#4
000112  fb84850c          SMULL    r8,r5,r4,r12
000116  ea4f78d8          LSR      r8,r8,#31
00011a  ea480845          ORR      r8,r8,r5,LSL #1
00011e  fa88f5a9          QSUB     r5,r9,r8
;;;181          /* gN-4(n) = kN-4 * fN-5(n) + gN-5(n-1) */
;;;182          gnext = __QADD(gcurr, (q31_t) (((q63_t) fcurr * (*pk++)) >> 31));
000122  fb85c80c          SMULL    r12,r8,r5,r12
000126  ea4f7cdc          LSR      r12,r12,#31
00012a  ea4c0c48          ORR      r12,r12,r8,LSL #1
00012e  fa8cf984          QADD     r9,r4,r12
;;;183          /* y(n) += gN-4(n) * vN-4  */
;;;184          /* process for gN-8(n) * vN-8, gN-12(n) * vN-12 ... */
;;;185          acc += ((q63_t) gnext * *pv++);
000132  68d4              LDR      r4,[r2,#0xc]
000134  300c              ADDS     r0,r0,#0xc
000136  fb898404          SMULL    r8,r4,r9,r4
00013a  3108              ADDS     r1,r1,#8
00013c  3210              ADDS     r2,r2,#0x10
00013e  eb180707          ADDS     r7,r8,r7
000142  eb44040b          ADC      r4,r4,r11
;;;186          /* write gN-4(n) into state for next sample processing */
;;;187          *px2++ = gnext;
000146  f8409b04          STR      r9,[r0],#4
00014a  1e76              SUBS     r6,r6,#1
                  |L1.332|
00014c  2e00              CMP      r6,#0                 ;129
00014e  d185              BNE      |L1.92|
;;;188    
;;;189          tapCnt--;
;;;190    
;;;191        }
;;;192    
;;;193        fnext = fcurr;
;;;194    
;;;195        /* If the filter length is not a multiple of 4, compute the remaining filter taps */
;;;196        tapCnt = (numStages - 1u) % 0x4u;
000150  f8ddc00c          LDR      r12,[sp,#0xc]
000154  462e              MOV      r6,r5                 ;193
000156  f00c0c03          AND      r12,r12,#3
;;;197    
;;;198        while(tapCnt > 0u)
00015a  e01d              B        |L1.408|
                  |L1.348|
;;;199        {
;;;200          gcurr = *px1++;
00015c  f851bb04          LDR      r11,[r1],#4
;;;201          /* Process sample for last taps */
;;;202          fnext = __QSUB(fcurr, (q31_t) (((q63_t) gcurr * (*pk)) >> 31));
000160  f8539b04          LDR      r9,[r3],#4
000164  fb8b6809          SMULL    r6,r8,r11,r9
000168  0ff6              LSRS     r6,r6,#31
00016a  ea460648          ORR      r6,r6,r8,LSL #1
00016e  fa86f6a5          QSUB     r6,r5,r6
;;;203          gnext = __QADD(gcurr, (q31_t) (((q63_t) fnext * (*pk++)) >> 31));
000172  fb865809          SMULL    r5,r8,r6,r9
000176  0fed              LSRS     r5,r5,#31
000178  ea450548          ORR      r5,r5,r8,LSL #1
00017c  fa85f98b          QADD     r9,r11,r5
;;;204          /* Output samples for last taps */
;;;205          acc += ((q63_t) gnext * *pv++);
000180  f8528b04          LDR      r8,[r2],#4
;;;206          *px2++ = gnext;
000184  f8409b04          STR      r9,[r0],#4
000188  fb898508          SMULL    r8,r5,r9,r8           ;205
00018c  eb180707          ADDS     r7,r8,r7              ;205
000190  416c              ADCS     r4,r4,r5              ;205
;;;207          fcurr = fnext;
000192  4635              MOV      r5,r6
000194  f1ac0c01          SUB      r12,r12,#1
                  |L1.408|
000198  f1bc0f00          CMP      r12,#0                ;198
00019c  d1de              BNE      |L1.348|
;;;208    
;;;209          tapCnt--;
;;;210    
;;;211        }
;;;212    
;;;213        /* y(n) += g0(n) * v0 */
;;;214        acc += (q63_t) fnext *(
00019e  6811              LDR      r1,[r2,#0]
;;;215      *pv++);
;;;216    
;;;217        *px2++ = fnext;
;;;218    
;;;219        /* write out into pDst */
;;;220        *pDst++ = (q31_t) (acc >> 31u);
0001a0  6005              STR      r5,[r0,#0]
0001a2  fb861201          SMULL    r1,r2,r6,r1           ;214
0001a6  19c9              ADDS     r1,r1,r7              ;214
0001a8  4162              ADCS     r2,r2,r4              ;214
0001aa  0fc8              LSRS     r0,r1,#31
0001ac  9906              LDR      r1,[sp,#0x18]
0001ae  ea400042          ORR      r0,r0,r2,LSL #1
0001b2  6008              STR      r0,[r1,#0]
0001b4  9806              LDR      r0,[sp,#0x18]
0001b6  1d00              ADDS     r0,r0,#4
;;;221    
;;;222        /* Advance the state pointer by 4 to process the next group of 4 samples */
;;;223        pState = pState + 1u;
0001b8  9006              STR      r0,[sp,#0x18]
0001ba  9801              LDR      r0,[sp,#4]
0001bc  1d00              ADDS     r0,r0,#4
;;;224        blkCnt--;
0001be  9001              STR      r0,[sp,#4]
0001c0  9800              LDR      r0,[sp,#0]
0001c2  1e40              SUBS     r0,r0,#1
0001c4  9000              STR      r0,[sp,#0]
                  |L1.454|
0001c6  2800              CMP      r0,#0                 ;94
0001c8  f47faf27          BNE      |L1.26|
;;;225    
;;;226      }
;;;227    
;;;228      /* Processing is complete. Now copy last S->numStages samples to start of the buffer    
;;;229         for the preperation of next frame process */
;;;230    
;;;231      /* Points to the start of the state buffer */
;;;232      pStateCurnt = &S->pState[0];
;;;233      pState = &S->pState[blockSize];
0001cc  f8da0004          LDR      r0,[r10,#4]
0001d0  9907              LDR      r1,[sp,#0x1c]
;;;234    
;;;235      tapCnt = numStages >> 2u;
0001d2  ea4f029e          LSR      r2,lr,#2
0001d6  eb000181          ADD      r1,r0,r1,LSL #2       ;233
;;;236    
;;;237      /* copy data */
;;;238      while(tapCnt > 0u)
0001da  e00c              B        |L1.502|
                  |L1.476|
;;;239      {
;;;240        *pStateCurnt++ = *pState++;
0001dc  c908              LDM      r1!,{r3}
;;;241        *pStateCurnt++ = *pState++;
;;;242        *pStateCurnt++ = *pState++;
;;;243        *pStateCurnt++ = *pState++;
0001de  1e52              SUBS     r2,r2,#1
0001e0  c008              STM      r0!,{r3}              ;240
0001e2  c908              LDM      r1!,{r3}              ;241
0001e4  c008              STM      r0!,{r3}              ;241
0001e6  f8513b08          LDR      r3,[r1],#8            ;242
0001ea  f8403b08          STR      r3,[r0],#8            ;242
0001ee  f8513c04          LDR      r3,[r1,#-4]
0001f2  f8403c04          STR      r3,[r0,#-4]
                  |L1.502|
0001f6  2a00              CMP      r2,#0                 ;238
0001f8  d1f0              BNE      |L1.476|
;;;244    
;;;245        /* Decrement the loop counter */
;;;246        tapCnt--;
;;;247    
;;;248      }
;;;249    
;;;250      /* Calculate remaining number of copies */
;;;251      tapCnt = (numStages) % 0x4u;
0001fa  f00e0203          AND      r2,lr,#3
;;;252    
;;;253      /* Copy the remaining q31_t data */
;;;254      while(tapCnt > 0u)
0001fe  e002              B        |L1.518|
                  |L1.512|
;;;255      {
;;;256        *pStateCurnt++ = *pState++;
000200  c908              LDM      r1!,{r3}
000202  1e52              SUBS     r2,r2,#1
000204  c008              STM      r0!,{r3}
                  |L1.518|
000206  2a00              CMP      r2,#0                 ;254
000208  d1fa              BNE      |L1.512|
;;;257    
;;;258        /* Decrement the loop counter */
;;;259        tapCnt--;
;;;260      };
;;;261    
;;;262    #else
;;;263    
;;;264      /* Run the below code for Cortex-M0 */
;;;265      /* Sample processing */
;;;266      while(blkCnt > 0u)
;;;267      {
;;;268        /* Read Sample from input buffer */
;;;269        /* fN(n) = x(n) */
;;;270        fcurr = *pSrc++;
;;;271    
;;;272        /* Initialize state read pointer */
;;;273        px1 = pState;
;;;274        /* Initialize state write pointer */
;;;275        px2 = pState;
;;;276        /* Set accumulator to zero */
;;;277        acc = 0;
;;;278        /* Initialize Ladder coeff pointer */
;;;279        pv = &S->pvCoeffs[0];
;;;280        /* Initialize Reflection coeff pointer */
;;;281        pk = &S->pkCoeffs[0];
;;;282    
;;;283        tapCnt = numStages;
;;;284    
;;;285        while(tapCnt > 0u)
;;;286        {
;;;287          gcurr = *px1++;
;;;288          /* Process sample */
;;;289          /* fN-1(n) = fN(n) - kN * gN-1(n-1) */
;;;290          fnext =
;;;291            clip_q63_to_q31(((q63_t) fcurr -
;;;292                             ((q31_t) (((q63_t) gcurr * (*pk)) >> 31))));
;;;293          /* gN(n) = kN * fN-1(n) + gN-1(n-1) */
;;;294          gnext =
;;;295            clip_q63_to_q31(((q63_t) gcurr +
;;;296                             ((q31_t) (((q63_t) fnext * (*pk++)) >> 31))));
;;;297          /* Output samples */
;;;298          /* y(n) += gN(n) * vN  */
;;;299          acc += ((q63_t) gnext * *pv++);
;;;300          /* write gN-1(n-1) into state for next sample processing */
;;;301          *px2++ = gnext;
;;;302          /* Update f values for next coefficient processing */
;;;303          fcurr = fnext;
;;;304    
;;;305          tapCnt--;
;;;306        }
;;;307    
;;;308        /* y(n) += g0(n) * v0 */
;;;309        acc += (q63_t) fnext *(
;;;310      *pv++);
;;;311    
;;;312        *px2++ = fnext;
;;;313    
;;;314        /* write out into pDst */
;;;315        *pDst++ = (q31_t) (acc >> 31u);
;;;316    
;;;317        /* Advance the state pointer by 1 to process the next group of samples */
;;;318        pState = pState + 1u;
;;;319        blkCnt--;
;;;320    
;;;321      }
;;;322    
;;;323      /* Processing is complete. Now copy last S->numStages samples to start of the buffer           
;;;324         for the preperation of next frame process */
;;;325    
;;;326      /* Points to the start of the state buffer */
;;;327      pStateCurnt = &S->pState[0];
;;;328      pState = &S->pState[blockSize];
;;;329    
;;;330      tapCnt = numStages;
;;;331    
;;;332      /* Copy the remaining q31_t data */
;;;333      while(tapCnt > 0u)
;;;334      {
;;;335        *pStateCurnt++ = *pState++;
;;;336    
;;;337        /* Decrement the loop counter */
;;;338        tapCnt--;
;;;339      }
;;;340    
;;;341    #endif /*   #ifndef ARM_MATH_CM0_FAMILY */
;;;342    
;;;343    }
00020a  b008              ADD      sp,sp,#0x20
00020c  e8bd8ff0          POP      {r4-r11,pc}
;;;344    
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\FilteringFunctions\\arm_iir_lattice_q31.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___21_arm_iir_lattice_q31_c_4c78cbb1____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___21_arm_iir_lattice_q31_c_4c78cbb1____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___21_arm_iir_lattice_q31_c_4c78cbb1____REVSH|
#line 144
|__asm___21_arm_iir_lattice_q31_c_4c78cbb1____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___21_arm_iir_lattice_q31_c_4c78cbb1____RRX|
#line 300
|__asm___21_arm_iir_lattice_q31_c_4c78cbb1____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
