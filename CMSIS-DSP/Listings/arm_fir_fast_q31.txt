; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_fir_fast_q31.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_fir_fast_q31.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_fir_fast_q31.crf src\FilteringFunctions\arm_fir_fast_q31.c]
                          THUMB

                          AREA ||i.arm_fir_fast_q31||, CODE, READONLY, ALIGN=1

                  arm_fir_fast_q31 PROC
;;;74     IAR_ONLY_LOW_OPTIMIZATION_ENTER
;;;75     void arm_fir_fast_q31(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;76       const arm_fir_instance_q31 * S,
;;;77       q31_t * pSrc,
;;;78       q31_t * pDst,
;;;79       uint32_t blockSize)
;;;80     {
000004  b086              SUB      sp,sp,#0x18
;;;81       q31_t *pState = S->pState;                     /* State pointer */
;;;82       q31_t *pCoeffs = S->pCoeffs;                   /* Coefficient pointer */
;;;83       q31_t *pStateCurnt;                            /* Points to the current sample of the state */
;;;84       q31_t x0, x1, x2, x3;                          /* Temporary variables to hold state */
;;;85       q31_t c0;                                      /* Temporary variable to hold coefficient value */
;;;86       q31_t *px;                                     /* Temporary pointer for state */
;;;87       q31_t *pb;                                     /* Temporary pointer for coefficient buffer */
;;;88       q31_t acc0, acc1, acc2, acc3;                  /* Accumulators */
;;;89       uint32_t numTaps = S->numTaps;                 /* Number of filter coefficients in the filter */
;;;90       uint32_t i, tapCnt, blkCnt;                    /* Loop counters */
;;;91     
;;;92       /* S->pState points to buffer which contains previous frame (numTaps - 1) samples */
;;;93       /* pStateCurnt points to the location where the new input data should be written */
;;;94       pStateCurnt = &(S->pState[(numTaps - 1u)]);
000006  f06f0203          MVN      r2,#3
00000a  9806              LDR      r0,[sp,#0x18]         ;81
00000c  e9d01001          LDRD     r1,r0,[r0,#4]         ;81
000010  9001              STR      r0,[sp,#4]            ;89
000012  9806              LDR      r0,[sp,#0x18]         ;89
000014  8800              LDRH     r0,[r0,#0]            ;89
000016  9000              STR      r0,[sp,#0]
000018  eb020080          ADD      r0,r2,r0,LSL #2
00001c  eb010e00          ADD      lr,r1,r0
;;;95     
;;;96       /* Apply loop unrolling and compute 4 output values simultaneously.    
;;;97        * The variables acc0 ... acc3 hold output values that are being computed:    
;;;98        *    
;;;99        *    acc0 =  b[numTaps-1] * x[n-numTaps-1] + b[numTaps-2] * x[n-numTaps-2] + b[numTaps-3] * x[n-numTaps-3] +...+ b[0] * x[0]    
;;;100       *    acc1 =  b[numTaps-1] * x[n-numTaps] +   b[numTaps-2] * x[n-numTaps-1] + b[numTaps-3] * x[n-numTaps-2] +...+ b[0] * x[1]    
;;;101       *    acc2 =  b[numTaps-1] * x[n-numTaps+1] + b[numTaps-2] * x[n-numTaps] +   b[numTaps-3] * x[n-numTaps-1] +...+ b[0] * x[2]    
;;;102       *    acc3 =  b[numTaps-1] * x[n-numTaps+2] + b[numTaps-2] * x[n-numTaps+1] + b[numTaps-3] * x[n-numTaps]   +...+ b[0] * x[3]    
;;;103       */
;;;104      blkCnt = blockSize >> 2;
000020  9809              LDR      r0,[sp,#0x24]
000022  0880              LSRS     r0,r0,#2
000024  9002              STR      r0,[sp,#8]            ;80
000026  e081              B        |L1.300|
                  |L1.40|
;;;105    
;;;106      /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.    
;;;107       ** a second loop below computes the remaining 1 to 3 samples. */
;;;108      while(blkCnt > 0u)
;;;109      {
;;;110        /* Copy four new input samples into the state buffer */
;;;111        *pStateCurnt++ = *pSrc++;
000028  9807              LDR      r0,[sp,#0x1c]
;;;112        *pStateCurnt++ = *pSrc++;
;;;113        *pStateCurnt++ = *pSrc++;
;;;114        *pStateCurnt++ = *pSrc++;
;;;115    
;;;116        /* Set all accumulators to zero */
;;;117        acc0 = 0;
00002a  2600              MOVS     r6,#0
;;;118        acc1 = 0;
00002c  46b1              MOV      r9,r6
00002e  6802              LDR      r2,[r0,#0]            ;111
000030  f8ce2000          STR      r2,[lr,#0]            ;111
000034  9807              LDR      r0,[sp,#0x1c]         ;112
000036  f10e0204          ADD      r2,lr,#4              ;111
;;;119        acc2 = 0;
00003a  46b2              MOV      r10,r6
00003c  6843              LDR      r3,[r0,#4]            ;112
;;;120        acc3 = 0;
00003e  46b3              MOV      r11,r6
000040  c208              STM      r2!,{r3}              ;112
000042  6883              LDR      r3,[r0,#8]            ;113
000044  c208              STM      r2!,{r3}              ;113
000046  68c3              LDR      r3,[r0,#0xc]          ;114
000048  3010              ADDS     r0,r0,#0x10           ;114
00004a  c208              STM      r2!,{r3}              ;114
00004c  4696              MOV      lr,r2                 ;114
;;;121    
;;;122        /* Initialize state pointer */
;;;123        px = pState;
;;;124    
;;;125        /* Initialize coefficient pointer */
;;;126        pb = pCoeffs;
;;;127    
;;;128        /* Read the first three samples from the state buffer:    
;;;129         *  x[n-numTaps], x[n-numTaps-1], x[n-numTaps-2] */
;;;130        x0 = *(px++);
00004e  1d0a              ADDS     r2,r1,#4
000050  9007              STR      r0,[sp,#0x1c]         ;126
000052  e8f24002          LDRD     r4,r0,[r2],#8
;;;131        x1 = *(px++);
;;;132        x2 = *(px++);
;;;133    
;;;134        /* Loop unrolling.  Process 4 taps at a time. */
;;;135        tapCnt = numTaps >> 2;
000056  9f00              LDR      r7,[sp,#0]
000058  680d              LDR      r5,[r1,#0]
00005a  08bf              LSRS     r7,r7,#2
00005c  9b01              LDR      r3,[sp,#4]            ;130
;;;136        i = tapCnt;
;;;137    
;;;138        while(i > 0u)
00005e  9703              STR      r7,[sp,#0xc]
000060  e034              B        |L1.204|
                  |L1.98|
;;;139        {
;;;140          /* Read the b[numTaps] coefficient */
;;;141          c0 = *pb;
000062  cb80              LDM      r3!,{r7}
;;;142    
;;;143          /* Read x[n-numTaps-3] sample */
;;;144          x3 = *px;
000064  f852cb04          LDR      r12,[r2],#4
;;;145    
;;;146          /* acc0 +=  b[numTaps] * x[n-numTaps] */
;;;147          multAcc_32x32_keep32_R(acc0, x0, c0);
000068  fb556617          SMMLAR   r6,r5,r7,r6
;;;148    
;;;149          /* acc1 +=  b[numTaps] * x[n-numTaps-1] */
;;;150          multAcc_32x32_keep32_R(acc1, x1, c0);
00006c  fb549817          SMMLAR   r8,r4,r7,r9
;;;151    
;;;152          /* acc2 +=  b[numTaps] * x[n-numTaps-2] */
;;;153          multAcc_32x32_keep32_R(acc2, x2, c0);
000070  fb50a917          SMMLAR   r9,r0,r7,r10
;;;154    
;;;155          /* acc3 +=  b[numTaps] * x[n-numTaps-3] */
;;;156          multAcc_32x32_keep32_R(acc3, x3, c0);
000074  fb5cba17          SMMLAR   r10,r12,r7,r11
;;;157    
;;;158          /* Read the b[numTaps-1] coefficient */
;;;159          c0 = *(pb + 1u);
000078  f8cd9014          STR      r9,[sp,#0x14]
00007c  cb80              LDM      r3!,{r7}
;;;160    
;;;161          /* Read x[n-numTaps-4] sample */
;;;162          x0 = *(px + 1u);
00007e  ca20              LDM      r2!,{r5}
;;;163    
;;;164          /* Perform the multiply-accumulates */      
;;;165          multAcc_32x32_keep32_R(acc0, x1, c0);
000080  fb546617          SMMLAR   r6,r4,r7,r6
;;;166          multAcc_32x32_keep32_R(acc1, x2, c0);
000084  fb508b17          SMMLAR   r11,r0,r7,r8
;;;167          multAcc_32x32_keep32_R(acc2, x3, c0);
000088  fb5c9817          SMMLAR   r8,r12,r7,r9
;;;168          multAcc_32x32_keep32_R(acc3, x0, c0);
00008c  fb55a917          SMMLAR   r9,r5,r7,r10
;;;169    
;;;170          /* Read the b[numTaps-2] coefficient */
;;;171          c0 = *(pb + 2u);
000090  f8cd8014          STR      r8,[sp,#0x14]
000094  f8537b08          LDR      r7,[r3],#8
;;;172    
;;;173          /* Read x[n-numTaps-5] sample */
;;;174          x1 = *(px + 2u);
000098  f8524b08          LDR      r4,[r2],#8
;;;175    
;;;176          /* Perform the multiply-accumulates */      
;;;177          multAcc_32x32_keep32_R(acc0, x2, c0);
00009c  fb506617          SMMLAR   r6,r0,r7,r6
;;;178          multAcc_32x32_keep32_R(acc1, x3, c0);
0000a0  fb5cba17          SMMLAR   r10,r12,r7,r11
;;;179          multAcc_32x32_keep32_R(acc2, x0, c0);
0000a4  fb558817          SMMLAR   r8,r5,r7,r8
;;;180          multAcc_32x32_keep32_R(acc3, x1, c0);
0000a8  fb549b17          SMMLAR   r11,r4,r7,r9
;;;181    
;;;182          /* Read the b[numTaps-3] coefficients */
;;;183          c0 = *(pb + 3u);
0000ac  f8cd8014          STR      r8,[sp,#0x14]
0000b0  f8537c04          LDR      r7,[r3,#-4]
;;;184    
;;;185          /* Read x[n-numTaps-6] sample */
;;;186          x2 = *(px + 3u);
0000b4  f8520c04          LDR      r0,[r2,#-4]
;;;187    
;;;188          /* Perform the multiply-accumulates */      
;;;189          multAcc_32x32_keep32_R(acc0, x3, c0);
0000b8  fb5c6617          SMMLAR   r6,r12,r7,r6
;;;190          multAcc_32x32_keep32_R(acc1, x0, c0);
0000bc  fb55a917          SMMLAR   r9,r5,r7,r10
;;;191          multAcc_32x32_keep32_R(acc2, x1, c0);
0000c0  fb548a17          SMMLAR   r10,r4,r7,r8
;;;192          multAcc_32x32_keep32_R(acc3, x2, c0);
0000c4  fb50bb17          SMMLAR   r11,r0,r7,r11
;;;193    
;;;194          /* update coefficient pointer */
;;;195          pb += 4u;
;;;196          px += 4u;
;;;197          
;;;198          /* Decrement the loop counter */
;;;199          i--;
0000c8  9f04              LDR      r7,[sp,#0x10]
0000ca  1e7f              SUBS     r7,r7,#1
                  |L1.204|
0000cc  9704              STR      r7,[sp,#0x10]         ;136
0000ce  2f00              CMP      r7,#0                 ;136
0000d0  d1c7              BNE      |L1.98|
;;;200        }
;;;201    
;;;202        /* If the filter length is not a multiple of 4, compute the remaining filter taps */
;;;203    
;;;204        i = numTaps - (tapCnt * 4u);
0000d2  9f03              LDR      r7,[sp,#0xc]
0000d4  f1c70c00          RSB      r12,r7,#0
0000d8  9f00              LDR      r7,[sp,#0]
0000da  eb07078c          ADD      r7,r7,r12,LSL #2
;;;205        while(i > 0u)
0000de  e00f              B        |L1.256|
                  |L1.224|
;;;206        {
;;;207          /* Read coefficients */
;;;208          c0 = *(pb++);
0000e0  cb80              LDM      r3!,{r7}
;;;209    
;;;210          /* Fetch 1 state variable */
;;;211          x3 = *(px++);
0000e2  f852cb04          LDR      r12,[r2],#4
;;;212    
;;;213          /* Perform the multiply-accumulates */      
;;;214          multAcc_32x32_keep32_R(acc0, x0, c0);
0000e6  fb556617          SMMLAR   r6,r5,r7,r6
;;;215          multAcc_32x32_keep32_R(acc1, x1, c0);
0000ea  fb549917          SMMLAR   r9,r4,r7,r9
;;;216          multAcc_32x32_keep32_R(acc2, x2, c0);
0000ee  fb50aa17          SMMLAR   r10,r0,r7,r10
;;;217          multAcc_32x32_keep32_R(acc3, x3, c0);
0000f2  fb5cbb17          SMMLAR   r11,r12,r7,r11
;;;218    
;;;219          /* Reuse the present sample states for next sample */
;;;220          x0 = x1;
0000f6  4625              MOV      r5,r4
;;;221          x1 = x2;
0000f8  4604              MOV      r4,r0
;;;222          x2 = x3;
0000fa  4660              MOV      r0,r12
;;;223    
;;;224          /* Decrement the loop counter */
;;;225          i--;
0000fc  f1a80701          SUB      r7,r8,#1
                  |L1.256|
000100  ea5f0807          MOVS     r8,r7                 ;204
000104  d1ec              BNE      |L1.224|
;;;226        }
;;;227    
;;;228        /* Advance the state pointer by 4 to process the next group of 4 samples */
;;;229        pState = pState + 4;
;;;230    
;;;231        /* The results in the 4 accumulators are in 2.30 format.  Convert to 1.31    
;;;232         ** Then store the 4 outputs in the destination buffer. */
;;;233        *pDst++ = (q31_t) (acc0 << 1);
000106  9808              LDR      r0,[sp,#0x20]
000108  0072              LSLS     r2,r6,#1
00010a  6002              STR      r2,[r0,#0]
;;;234        *pDst++ = (q31_t) (acc1 << 1);
00010c  9808              LDR      r0,[sp,#0x20]
00010e  ea4f0249          LSL      r2,r9,#1
;;;235        *pDst++ = (q31_t) (acc2 << 1);
000112  6042              STR      r2,[r0,#4]
000114  ea4f024a          LSL      r2,r10,#1
;;;236        *pDst++ = (q31_t) (acc3 << 1);
000118  6082              STR      r2,[r0,#8]
00011a  ea4f024b          LSL      r2,r11,#1
00011e  60c2              STR      r2,[r0,#0xc]
000120  3010              ADDS     r0,r0,#0x10
;;;237    
;;;238        /* Decrement the samples loop counter */
;;;239        blkCnt--;
000122  9008              STR      r0,[sp,#0x20]
000124  9802              LDR      r0,[sp,#8]
000126  1e40              SUBS     r0,r0,#1
000128  3110              ADDS     r1,r1,#0x10
00012a  9002              STR      r0,[sp,#8]
                  |L1.300|
00012c  2800              CMP      r0,#0                 ;108
00012e  f47faf7b          BNE      |L1.40|
;;;240      }
;;;241    
;;;242    
;;;243      /* If the blockSize is not a multiple of 4, compute any remaining output samples here.    
;;;244       ** No loop unrolling is used. */
;;;245      blkCnt = blockSize % 4u;
000132  9809              LDR      r0,[sp,#0x24]
000134  f0000503          AND      r5,r0,#3
;;;246    
;;;247      while(blkCnt > 0u)
000138  e018              B        |L1.364|
                  |L1.314|
;;;248      {
;;;249        /* Copy one sample at a time into state buffer */
;;;250        *pStateCurnt++ = *pSrc++;
00013a  9807              LDR      r0,[sp,#0x1c]
00013c  6802              LDR      r2,[r0,#0]
00013e  f84e2b04          STR      r2,[lr],#4
000142  9807              LDR      r0,[sp,#0x1c]
;;;251    
;;;252        /* Set the accumulator to zero */
;;;253        acc0 = 0;
;;;254    
;;;255        /* Initialize state pointer */
;;;256        px = pState;
000144  e9dd3200          LDRD     r3,r2,[sp,#0]
000148  1d00              ADDS     r0,r0,#4              ;250
00014a  9007              STR      r0,[sp,#0x1c]
00014c  2400              MOVS     r4,#0                 ;253
00014e  4608              MOV      r0,r1
                  |L1.336|
;;;257    
;;;258        /* Initialize Coefficient pointer */
;;;259        pb = (pCoeffs);
;;;260    
;;;261        i = numTaps;
;;;262    
;;;263        /* Perform the multiply-accumulates */
;;;264        do
;;;265        {
;;;266          multAcc_32x32_keep32_R(acc0, (*px++), (*(pb++)));
000150  ca80              LDM      r2!,{r7}
000152  c840              LDM      r0!,{r6}
000154  fb564417          SMMLAR   r4,r6,r7,r4
000158  1e5b              SUBS     r3,r3,#1
;;;267          i--;
;;;268        } while(i > 0u);
00015a  d1f9              BNE      |L1.336|
;;;269    
;;;270        /* The result is in 2.30 format.  Convert to 1.31    
;;;271         ** Then store the output in the destination buffer. */
;;;272        *pDst++ = (q31_t) (acc0 << 1);
00015c  9808              LDR      r0,[sp,#0x20]
00015e  0062              LSLS     r2,r4,#1
000160  1d09              ADDS     r1,r1,#4
000162  6002              STR      r2,[r0,#0]
000164  9808              LDR      r0,[sp,#0x20]
000166  1d00              ADDS     r0,r0,#4
000168  1e6d              SUBS     r5,r5,#1
00016a  9008              STR      r0,[sp,#0x20]
                  |L1.364|
00016c  2d00              CMP      r5,#0                 ;247
00016e  d1e4              BNE      |L1.314|
;;;273    
;;;274        /* Advance state pointer by 1 for the next sample */
;;;275        pState = pState + 1;
;;;276    
;;;277        /* Decrement the samples loop counter */
;;;278        blkCnt--;
;;;279      }
;;;280    
;;;281      /* Processing is complete.    
;;;282       ** Now copy the last numTaps - 1 samples to the start of the state buffer.    
;;;283       ** This prepares the state buffer for the next function call. */
;;;284    
;;;285      /* Points to the start of the state buffer */
;;;286      pStateCurnt = S->pState;
000170  9806              LDR      r0,[sp,#0x18]
;;;287    
;;;288      /* Calculate remaining number of copies */
;;;289      tapCnt = (numTaps - 1u);
000172  6842              LDR      r2,[r0,#4]
;;;290    
;;;291      /* Copy the remaining q31_t data */
;;;292      while(tapCnt > 0u)
000174  9800              LDR      r0,[sp,#0]
000176  e001              B        |L1.380|
                  |L1.376|
;;;293      {
;;;294        *pStateCurnt++ = *pState++;
000178  c908              LDM      r1!,{r3}
00017a  c208              STM      r2!,{r3}
                  |L1.380|
00017c  1e40              SUBS     r0,r0,#1
00017e  d1fb              BNE      |L1.376|
;;;295    
;;;296        /* Decrement the loop counter */
;;;297        tapCnt--;
;;;298      }
;;;299    
;;;300    
;;;301    }
000180  b00a              ADD      sp,sp,#0x28
000182  e8bd8ff0          POP      {r4-r11,pc}
;;;302    IAR_ONLY_LOW_OPTIMIZATION_EXIT
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\FilteringFunctions\\arm_fir_fast_q31.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_fir_fast_q31_c_aa7d348b____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___18_arm_fir_fast_q31_c_aa7d348b____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_fir_fast_q31_c_aa7d348b____REVSH|
#line 144
|__asm___18_arm_fir_fast_q31_c_aa7d348b____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_fir_fast_q31_c_aa7d348b____RRX|
#line 300
|__asm___18_arm_fir_fast_q31_c_aa7d348b____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
