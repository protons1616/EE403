; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_biquad_cascade_df1_q15.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_biquad_cascade_df1_q15.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_biquad_cascade_df1_q15.crf src\FilteringFunctions\arm_biquad_cascade_df1_q15.c]
                          THUMB

                          AREA ||i.arm_biquad_cascade_df1_q15||, CODE, READONLY, ALIGN=2

                  arm_biquad_cascade_df1_q15 PROC
;;;74     
;;;75     void arm_biquad_cascade_df1_q15(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;76       const arm_biquad_casd_df1_inst_q15 * S,
;;;77       q15_t * pSrc,
;;;78       q15_t * pDst,
;;;79       uint32_t blockSize)
;;;80     {
;;;81     
;;;82     
;;;83     #ifndef ARM_MATH_CM0_FAMILY
;;;84     
;;;85       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;86     
;;;87       q15_t *pIn = pSrc;                             /*  Source pointer                               */
;;;88       q15_t *pOut = pDst;                            /*  Destination pointer                          */
;;;89       q31_t in;                                      /*  Temporary variable to hold input value       */
;;;90       q31_t out;                                     /*  Temporary variable to hold output value      */
;;;91       q31_t b0;                                      /*  Temporary variable to hold bo value          */
;;;92       q31_t b1, a1;                                  /*  Filter coefficients                          */
;;;93       q31_t state_in, state_out;                     /*  Filter state variables                       */
;;;94       q31_t acc_l, acc_h;
;;;95       q63_t acc;                                     /*  Accumulator                                  */
;;;96       int32_t lShift = (15 - (int32_t) S->postShift);       /*  Post shift                                   */
000004  e9d06301          LDRD     r6,r3,[r0,#4]
000008  b084              SUB      sp,sp,#0x10           ;80
00000a  f990200c          LDRSB    r2,[r0,#0xc]
;;;97       q15_t *pState = S->pState;                     /*  State pointer                                */
;;;98       q15_t *pCoeffs = S->pCoeffs;                   /*  Coefficient pointer                          */
;;;99       uint32_t sample, stage = (uint32_t) S->numStages;     /*  Stage loop counter                           */
00000e  f9900000          LDRSB    r0,[r0,#0]
000012  9c06              LDR      r4,[sp,#0x18]
000014  f1c20b0f          RSB      r11,r2,#0xf           ;96
;;;100      int32_t uShift = (32 - lShift);
000018  9001              STR      r0,[sp,#4]
00001a  f1cb0020          RSB      r0,r11,#0x20
00001e  9000              STR      r0,[sp,#0]            ;80
;;;101    
;;;102      do
;;;103      {
;;;104        /* Read the b0 and 0 coefficients using SIMD  */
;;;105        b0 = *__SIMD32(pCoeffs)++;
;;;106    
;;;107        /* Read the b1 and b2 coefficients using SIMD */
;;;108        b1 = *__SIMD32(pCoeffs)++;
;;;109    
;;;110        /* Read the a1 and a2 coefficients using SIMD */
;;;111        a1 = *__SIMD32(pCoeffs)++;
;;;112    
;;;113        /* Read the input state values from the state buffer:  x[n-1], x[n-2] */
;;;114        state_in = *__SIMD32(pState)++;
;;;115    
;;;116        /* Read the output state values from the state buffer:  y[n-1], y[n-2] */
;;;117        state_out = *__SIMD32(pState)--;
;;;118    
;;;119        /* Apply loop unrolling and compute 2 output values simultaneously. */
;;;120        /*      The variable acc hold output values that are being computed:    
;;;121         *    
;;;122         *    acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2]    
;;;123         *    acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2]    
;;;124         */
;;;125        sample = blockSize >> 1u;
000020  9807              LDR      r0,[sp,#0x1c]
000022  0840              LSRS     r0,r0,#1
000024  f8cd000c          STR.W    r0,[sp,#0xc]
                  |L1.40|
000028  f853eb04          LDR      lr,[r3],#4            ;105
00002c  6832              LDR      r2,[r6,#0]            ;114
00002e  f853ab04          LDR      r10,[r3],#4           ;108
000032  6875              LDR      r5,[r6,#4]            ;117
000034  f8539b04          LDR      r9,[r3],#4            ;111
000038  9602              STR      r6,[sp,#8]            ;117
;;;126    
;;;127        /* First part of the processing with loop unrolling.  Compute 2 outputs at a time.    
;;;128         ** a second loop below computes the remaining 1 sample. */
;;;129        while(sample > 0u)
00003a  9e03              LDR      r6,[sp,#0xc]
00003c  e030              B        |L1.160|
;;;130        {
;;;131    
;;;132          /* Read the input */
;;;133          in = *__SIMD32(pIn)++;
00003e  bf00              NOP      
                  |L1.64|
000040  f8517b04          LDR      r7,[r1],#4
;;;134    
;;;135          /* out =  b0 * x[n] + 0 * 0 */
;;;136          out = __SMUAD(b0, in);
000044  fb2ef007          SMUAD    r0,lr,r7
;;;137    
;;;138          /* acc +=  b1 * x[n-1] +  b2 * x[n-2] + out */
;;;139          acc = __SMLALD(b1, state_in, out);
000048  ea4f7ce0          ASR      r12,r0,#31
00004c  fbca0cc2          SMLALD   r0,r12,r10,r2
;;;140          /* acc +=  a1 * y[n-1] +  a2 * y[n-2] */
;;;141          acc = __SMLALD(a1, state_out, acc);
000050  fbc90cc5          SMLALD   r0,r12,r9,r5
;;;142    
;;;143          /* The result is converted from 3.29 to 1.31 if postShift = 1, and then saturation is applied */
;;;144          /* Calc lower part of acc */
;;;145          acc_l = acc & 0xffffffff;
;;;146    
;;;147          /* Calc upper part of acc */
;;;148          acc_h = (acc >> 32) & 0xffffffff;
;;;149    
;;;150          /* Apply shift for lower part of acc and upper part of acc */
;;;151          out = (uint32_t) acc_l >> lShift | acc_h << uShift;
000054  f8dd8000          LDR      r8,[sp,#0]
000058  fa20f00b          LSR      r0,r0,r11
00005c  fa0cfc08          LSL      r12,r12,r8
000060  ea40000c          ORR      r0,r0,r12
;;;152    
;;;153          out = __SSAT(out, 16);
000064  f300000f          SSAT     r0,#16,r0
;;;154    
;;;155          /* Every time after the output is computed state should be updated. */
;;;156          /* The states should be updated as:  */
;;;157          /* Xn2 = Xn1    */
;;;158          /* Xn1 = Xn     */
;;;159          /* Yn2 = Yn1    */
;;;160          /* Yn1 = acc   */
;;;161          /* x[n-N], x[n-N-1] are packed together to make state_in of type q31 */
;;;162          /* y[n-N], y[n-N-1] are packed together to make state_out of type q31 */
;;;163    
;;;164    #ifndef  ARM_MATH_BIG_ENDIAN
;;;165    
;;;166          state_in = __PKHBT(in, state_in, 16);
000068  eac74c02          PKHBT    r12,r7,r2,LSL #16
;;;167          state_out = __PKHBT(out, state_out, 16);
00006c  eac04505          PKHBT    r5,r0,r5,LSL #16
;;;168    
;;;169    #else
;;;170    
;;;171          state_in = __PKHBT(state_in >> 16, (in >> 16), 16);
;;;172          state_out = __PKHBT(state_out >> 16, (out), 16);
;;;173    
;;;174    #endif /*      #ifndef  ARM_MATH_BIG_ENDIAN    */
;;;175    
;;;176          /* out =  b0 * x[n] + 0 * 0 */
;;;177          out = __SMUADX(b0, in);
000070  fb2ef017          SMUADX   r0,lr,r7
;;;178          /* acc +=  b1 * x[n-1] +  b2 * x[n-2] + out */
;;;179          acc = __SMLALD(b1, state_in, out);
000074  17c2              ASRS     r2,r0,#31
000076  fbca02cc          SMLALD   r0,r2,r10,r12
;;;180          /* acc +=  a1 * y[n-1] + a2 * y[n-2] */
;;;181          acc = __SMLALD(a1, state_out, acc);
00007a  fbc902c5          SMLALD   r0,r2,r9,r5
;;;182    
;;;183          /* The result is converted from 3.29 to 1.31 if postShift = 1, and then saturation is applied */
;;;184          /* Calc lower part of acc */
;;;185          acc_l = acc & 0xffffffff;
;;;186    
;;;187          /* Calc upper part of acc */
;;;188          acc_h = (acc >> 32) & 0xffffffff;
;;;189    
;;;190          /* Apply shift for lower part of acc and upper part of acc */
;;;191          out = (uint32_t) acc_l >> lShift | acc_h << uShift;
00007e  fa20f00b          LSR      r0,r0,r11
000082  fa02f208          LSL      r2,r2,r8
000086  4310              ORRS     r0,r0,r2
;;;192    
;;;193          out = __SSAT(out, 16);
000088  f300000f          SSAT     r0,#16,r0
;;;194    
;;;195          /* Store the output in the destination buffer. */
;;;196    
;;;197    #ifndef  ARM_MATH_BIG_ENDIAN
;;;198    
;;;199          *__SIMD32(pOut)++ = __PKHBT(state_out, out, 16);
00008c  eac54200          PKHBT    r2,r5,r0,LSL #16
000090  f8442b04          STR      r2,[r4],#4
;;;200    
;;;201    #else
;;;202    
;;;203          *__SIMD32(pOut)++ = __PKHBT(out, state_out >> 16, 16);
;;;204    
;;;205    #endif /*      #ifndef  ARM_MATH_BIG_ENDIAN    */
;;;206    
;;;207          /* Every time after the output is computed state should be updated. */
;;;208          /* The states should be updated as:  */
;;;209          /* Xn2 = Xn1    */
;;;210          /* Xn1 = Xn     */
;;;211          /* Yn2 = Yn1    */
;;;212          /* Yn1 = acc   */
;;;213          /* x[n-N], x[n-N-1] are packed together to make state_in of type q31 */
;;;214          /* y[n-N], y[n-N-1] are packed together to make state_out of type q31 */
;;;215    #ifndef  ARM_MATH_BIG_ENDIAN
;;;216    
;;;217          state_in = __PKHBT(in >> 16, state_in, 16);
000094  143a              ASRS     r2,r7,#16
000096  eac2420c          PKHBT    r2,r2,r12,LSL #16
;;;218          state_out = __PKHBT(out, state_out, 16);
00009a  eac04505          PKHBT    r5,r0,r5,LSL #16
00009e  1e76              SUBS     r6,r6,#1
                  |L1.160|
0000a0  2e00              CMP      r6,#0                 ;129
0000a2  d1cd              BNE      |L1.64|
;;;219    
;;;220    #else
;;;221    
;;;222          state_in = __PKHBT(state_in >> 16, in, 16);
;;;223          state_out = __PKHBT(state_out >> 16, out, 16);
;;;224    
;;;225    #endif /*      #ifndef  ARM_MATH_BIG_ENDIAN    */
;;;226    
;;;227    
;;;228          /* Decrement the loop counter */
;;;229          sample--;
;;;230    
;;;231        }
;;;232    
;;;233        /* If the blockSize is not a multiple of 2, compute any remaining output samples here.    
;;;234         ** No loop unrolling is used. */
;;;235    
;;;236        if((blockSize & 0x1u) != 0u)
0000a4  9807              LDR      r0,[sp,#0x1c]
0000a6  07c0              LSLS     r0,r0,#31
0000a8  d014              BEQ      |L1.212|
;;;237        {
;;;238          /* Read the input */
;;;239          in = *pIn++;
0000aa  f9b16000          LDRSH    r6,[r1,#0]
;;;240    
;;;241          /* out =  b0 * x[n] + 0 * 0 */
;;;242    
;;;243    #ifndef  ARM_MATH_BIG_ENDIAN
;;;244    
;;;245          out = __SMUAD(b0, in);
0000ae  fb2ef006          SMUAD    r0,lr,r6
;;;246    
;;;247    #else
;;;248    
;;;249          out = __SMUADX(b0, in);
;;;250    
;;;251    #endif /*      #ifndef  ARM_MATH_BIG_ENDIAN    */
;;;252    
;;;253          /* acc =  b1 * x[n-1] + b2 * x[n-2] + out */
;;;254          acc = __SMLALD(b1, state_in, out);
0000b2  17c1              ASRS     r1,r0,#31
0000b4  fbca01c2          SMLALD   r0,r1,r10,r2
;;;255          /* acc +=  a1 * y[n-1] + a2 * y[n-2] */
;;;256          acc = __SMLALD(a1, state_out, acc);
0000b8  fbc901c5          SMLALD   r0,r1,r9,r5
;;;257    
;;;258          /* The result is converted from 3.29 to 1.31 if postShift = 1, and then saturation is applied */
;;;259          /* Calc lower part of acc */
;;;260          acc_l = acc & 0xffffffff;
;;;261    
;;;262          /* Calc upper part of acc */
;;;263          acc_h = (acc >> 32) & 0xffffffff;
;;;264    
;;;265          /* Apply shift for lower part of acc and upper part of acc */
;;;266          out = (uint32_t) acc_l >> lShift | acc_h << uShift;
0000bc  9f00              LDR      r7,[sp,#0]
0000be  fa20f00b          LSR      r0,r0,r11
0000c2  40b9              LSLS     r1,r1,r7
0000c4  4308              ORRS     r0,r0,r1
;;;267    
;;;268          out = __SSAT(out, 16);
0000c6  f300000f          SSAT     r0,#16,r0
;;;269    
;;;270          /* Store the output in the destination buffer. */
;;;271          *pOut++ = (q15_t) out;
0000ca  8020              STRH     r0,[r4,#0]
;;;272    
;;;273          /* Every time after the output is computed state should be updated. */
;;;274          /* The states should be updated as:  */
;;;275          /* Xn2 = Xn1    */
;;;276          /* Xn1 = Xn     */
;;;277          /* Yn2 = Yn1    */
;;;278          /* Yn1 = acc   */
;;;279          /* x[n-N], x[n-N-1] are packed together to make state_in of type q31 */
;;;280          /* y[n-N], y[n-N-1] are packed together to make state_out of type q31 */
;;;281    
;;;282    #ifndef  ARM_MATH_BIG_ENDIAN
;;;283    
;;;284          state_in = __PKHBT(in, state_in, 16);
0000cc  eac64202          PKHBT    r2,r6,r2,LSL #16
;;;285          state_out = __PKHBT(out, state_out, 16);
0000d0  eac04505          PKHBT    r5,r0,r5,LSL #16
                  |L1.212|
;;;286    
;;;287    #else
;;;288    
;;;289          state_in = __PKHBT(state_in >> 16, in, 16);
;;;290          state_out = __PKHBT(state_out >> 16, out, 16);
;;;291    
;;;292    #endif /*   #ifndef  ARM_MATH_BIG_ENDIAN    */
;;;293    
;;;294        }
;;;295    
;;;296        /*  The first stage goes from the input wire to the output wire.  */
;;;297        /*  Subsequent numStages occur in-place in the output wire  */
;;;298        pIn = pDst;
;;;299    
;;;300        /* Reset the output pointer */
;;;301        pOut = pDst;
;;;302    
;;;303        /*  Store the updated state variables back into the state array */
;;;304        *__SIMD32(pState)++ = state_in;
0000d4  9802              LDR      r0,[sp,#8]
0000d6  9906              LDR      r1,[sp,#0x18]         ;301
0000d8  6002              STR      r2,[r0,#0]
;;;305        *__SIMD32(pState)++ = state_out;
0000da  9e02              LDR      r6,[sp,#8]
0000dc  460c              MOV      r4,r1                 ;301
0000de  6075              STR      r5,[r6,#4]
;;;306    
;;;307    
;;;308        /* Decrement the loop counter */
;;;309        stage--;
0000e0  9801              LDR      r0,[sp,#4]
0000e2  f1060608          ADD      r6,r6,#8
0000e6  1e40              SUBS     r0,r0,#1
;;;310    
;;;311      } while(stage > 0u);
0000e8  9001              STR      r0,[sp,#4]
0000ea  d19d              BNE      |L1.40|
;;;312    
;;;313    #else
;;;314    
;;;315      /* Run the below code for Cortex-M0 */
;;;316    
;;;317      q15_t *pIn = pSrc;                             /*  Source pointer                               */
;;;318      q15_t *pOut = pDst;                            /*  Destination pointer                          */
;;;319      q15_t b0, b1, b2, a1, a2;                      /*  Filter coefficients           */
;;;320      q15_t Xn1, Xn2, Yn1, Yn2;                      /*  Filter state variables        */
;;;321      q15_t Xn;                                      /*  temporary input               */
;;;322      q63_t acc;                                     /*  Accumulator                                  */
;;;323      int32_t shift = (15 - (int32_t) S->postShift); /*  Post shift                                   */
;;;324      q15_t *pState = S->pState;                     /*  State pointer                                */
;;;325      q15_t *pCoeffs = S->pCoeffs;                   /*  Coefficient pointer                          */
;;;326      uint32_t sample, stage = (uint32_t) S->numStages;     /*  Stage loop counter                           */
;;;327    
;;;328      do
;;;329      {
;;;330        /* Reading the coefficients */
;;;331        b0 = *pCoeffs++;
;;;332        pCoeffs++;  // skip the 0 coefficient
;;;333        b1 = *pCoeffs++;
;;;334        b2 = *pCoeffs++;
;;;335        a1 = *pCoeffs++;
;;;336        a2 = *pCoeffs++;
;;;337    
;;;338        /* Reading the state values */
;;;339        Xn1 = pState[0];
;;;340        Xn2 = pState[1];
;;;341        Yn1 = pState[2];
;;;342        Yn2 = pState[3];
;;;343    
;;;344        /*      The variables acc holds the output value that is computed:         
;;;345         *    acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2]         
;;;346         */
;;;347    
;;;348        sample = blockSize;
;;;349    
;;;350        while(sample > 0u)
;;;351        {
;;;352          /* Read the input */
;;;353          Xn = *pIn++;
;;;354    
;;;355          /* acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2] */
;;;356          /* acc =  b0 * x[n] */
;;;357          acc = (q31_t) b0 *Xn;
;;;358    
;;;359          /* acc +=  b1 * x[n-1] */
;;;360          acc += (q31_t) b1 *Xn1;
;;;361          /* acc +=  b[2] * x[n-2] */
;;;362          acc += (q31_t) b2 *Xn2;
;;;363          /* acc +=  a1 * y[n-1] */
;;;364          acc += (q31_t) a1 *Yn1;
;;;365          /* acc +=  a2 * y[n-2] */
;;;366          acc += (q31_t) a2 *Yn2;
;;;367    
;;;368          /* The result is converted to 1.31  */
;;;369          acc = __SSAT((acc >> shift), 16);
;;;370    
;;;371          /* Every time after the output is computed state should be updated. */
;;;372          /* The states should be updated as:  */
;;;373          /* Xn2 = Xn1    */
;;;374          /* Xn1 = Xn     */
;;;375          /* Yn2 = Yn1    */
;;;376          /* Yn1 = acc    */
;;;377          Xn2 = Xn1;
;;;378          Xn1 = Xn;
;;;379          Yn2 = Yn1;
;;;380          Yn1 = (q15_t) acc;
;;;381    
;;;382          /* Store the output in the destination buffer. */
;;;383          *pOut++ = (q15_t) acc;
;;;384    
;;;385          /* decrement the loop counter */
;;;386          sample--;
;;;387        }
;;;388    
;;;389        /*  The first stage goes from the input buffer to the output buffer. */
;;;390        /*  Subsequent stages occur in-place in the output buffer */
;;;391        pIn = pDst;
;;;392    
;;;393        /* Reset to destination pointer */
;;;394        pOut = pDst;
;;;395    
;;;396        /*  Store the updated state variables back into the pState array */
;;;397        *pState++ = Xn1;
;;;398        *pState++ = Xn2;
;;;399        *pState++ = Yn1;
;;;400        *pState++ = Yn2;
;;;401    
;;;402      } while(--stage);
;;;403    
;;;404    #endif /*     #ifndef ARM_MATH_CM0_FAMILY */
;;;405    
;;;406    }
0000ec  b008              ADD      sp,sp,#0x20
0000ee  e8bd8ff0          POP      {r4-r11,pc}
;;;407    
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\FilteringFunctions\\arm_biquad_cascade_df1_q15.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___28_arm_biquad_cascade_df1_q15_c_e5d707c4____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___28_arm_biquad_cascade_df1_q15_c_e5d707c4____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___28_arm_biquad_cascade_df1_q15_c_e5d707c4____REVSH|
#line 144
|__asm___28_arm_biquad_cascade_df1_q15_c_e5d707c4____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___28_arm_biquad_cascade_df1_q15_c_e5d707c4____RRX|
#line 300
|__asm___28_arm_biquad_cascade_df1_q15_c_e5d707c4____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
