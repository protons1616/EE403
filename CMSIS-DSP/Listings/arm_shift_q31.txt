; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_shift_q31.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_shift_q31.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_shift_q31.crf src\BasicMathFunctions\arm_shift_q31.c]
                          THUMB

                          AREA ||i.arm_shift_q31||, CODE, READONLY, ALIGN=2

                  arm_shift_q31 PROC
;;;83     
;;;84     void arm_shift_q31(
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;85       q31_t * pSrc,
;;;86       int8_t shiftBits,
;;;87       q31_t * pDst,
;;;88       uint32_t blockSize)
;;;89     {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;90       uint32_t blkCnt;                               /* loop counter */
;;;91       uint8_t sign = (shiftBits & 0x80);             /* Sign of shiftBits */
000008  f0010080          AND      r0,r1,#0x80
00000c  469e              MOV      lr,r3                 ;89
00000e  4615              MOV      r5,r2                 ;89
000010  ea5f0b00          MOVS     r11,r0
;;;92     
;;;93     #ifndef ARM_MATH_CM0_FAMILY
;;;94     
;;;95       q31_t in1, in2, in3, in4;                      /* Temporary input variables */
;;;96       q31_t out1, out2, out3, out4;                  /* Temporary output variables */
;;;97     
;;;98       /*loop Unrolling */
;;;99       blkCnt = blockSize >> 2u;
000014  ea4f0193          LSR      r1,r3,#2
;;;100    
;;;101    
;;;102      if(sign == 0u)
;;;103      {
;;;104        /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.    
;;;105         ** a second loop below computes the remaining 1 to 3 samples. */
;;;106        while(blkCnt > 0u)
;;;107        {
;;;108          /* C = A  << shiftBits */
;;;109          /* Shift the input and then store the results in the destination buffer. */
;;;110          in1 = *pSrc;
;;;111          in2 = *(pSrc + 1);
;;;112          out1 = in1 << shiftBits;
;;;113          in3 = *(pSrc + 2);
;;;114          out2 = in2 << shiftBits;
;;;115          in4 = *(pSrc + 3);
;;;116          if(in1 != (out1 >> shiftBits))
;;;117            out1 = 0x7FFFFFFF ^ (in1 >> 31);
;;;118    
;;;119          if(in2 != (out2 >> shiftBits))
;;;120            out2 = 0x7FFFFFFF ^ (in2 >> 31);
;;;121    
;;;122          *pDst = out1;
;;;123          out3 = in3 << shiftBits;
;;;124          *(pDst + 1) = out2;
;;;125          out4 = in4 << shiftBits;
;;;126    
;;;127          if(in3 != (out3 >> shiftBits))
;;;128            out3 = 0x7FFFFFFF ^ (in3 >> 31);
;;;129    
;;;130          if(in4 != (out4 >> shiftBits))
;;;131            out4 = 0x7FFFFFFF ^ (in4 >> 31);
;;;132    
;;;133          *(pDst + 2) = out3;
;;;134          *(pDst + 3) = out4;
;;;135    
;;;136          /* Update destination pointer to process next sampels */
;;;137          pSrc += 4u;
;;;138          pDst += 4u;
;;;139    
;;;140          /* Decrement the loop counter */
;;;141          blkCnt--;
;;;142        }
;;;143      }
;;;144      else
;;;145      {
;;;146    
;;;147        /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.    
;;;148         ** a second loop below computes the remaining 1 to 3 samples. */
;;;149        while(blkCnt > 0u)
;;;150        {
;;;151          /* C = A >>  shiftBits */
;;;152          /* Shift the input and then store the results in the destination buffer. */
;;;153          in1 = *pSrc;
;;;154          in2 = *(pSrc + 1);
;;;155          in3 = *(pSrc + 2);
;;;156          in4 = *(pSrc + 3);
;;;157    
;;;158          *pDst = (in1 >> -shiftBits);
000018  f1c60700          RSB      r7,r6,#0
00001c  d033              BEQ      |L1.134|
00001e  e03f              B        |L1.160|
                  |L1.32|
000020  e9d42300          LDRD     r2,r3,[r4,#0]         ;89
000024  fa02fc06          LSL      r12,r2,r6             ;112
000028  e9d49a02          LDRD     r9,r10,[r4,#8]        ;116
00002c  fa03f006          LSL      r0,r3,r6              ;114
000030  fa4cf806          ASR      r8,r12,r6             ;116
000034  4590              CMP      r8,r2                 ;116
000036  d003              BEQ      |L1.64|
000038  f06f4c00          MVN      r12,#0x80000000       ;117
00003c  ea8c7ce2          EOR      r12,r12,r2,ASR #31    ;117
                  |L1.64|
000040  fa40f206          ASR      r2,r0,r6              ;119
000044  429a              CMP      r2,r3                 ;119
000046  d003              BEQ      |L1.80|
000048  f06f4000          MVN      r0,#0x80000000        ;120
00004c  ea8070e3          EOR      r0,r0,r3,ASR #31      ;120
                  |L1.80|
000050  e9c5c000          STRD     r12,r0,[r5,#0]        ;123
000054  fa09f206          LSL      r2,r9,r6              ;123
000058  fa0af006          LSL      r0,r10,r6             ;125
00005c  fa42f306          ASR      r3,r2,r6              ;127
000060  454b              CMP      r3,r9                 ;127
000062  d003              BEQ      |L1.108|
000064  f06f4300          MVN      r3,#0x80000000        ;128
000068  ea8372e9          EOR      r2,r3,r9,ASR #31      ;128
                  |L1.108|
00006c  fa40f306          ASR      r3,r0,r6              ;130
000070  4553              CMP      r3,r10                ;130
000072  d003              BEQ      |L1.124|
000074  f06f4300          MVN      r3,#0x80000000        ;131
000078  ea8370ea          EOR      r0,r3,r10,ASR #31     ;131
                  |L1.124|
00007c  e9c52002          STRD     r2,r0,[r5,#8]         ;131
000080  1e49              SUBS     r1,r1,#1              ;131
000082  3410              ADDS     r4,r4,#0x10           ;131
000084  3510              ADDS     r5,r5,#0x10           ;131
                  |L1.134|
000086  2900              CMP      r1,#0                 ;106
000088  d1ca              BNE      |L1.32|
00008a  e00b              B        |L1.164|
                  |L1.140|
00008c  e8b4100d          LDM      r4!,{r0,r2,r3,r12}    ;106
000090  4138              ASRS     r0,r0,r7
;;;159          *(pDst + 1) = (in2 >> -shiftBits);
000092  413a              ASRS     r2,r2,r7
;;;160          *(pDst + 2) = (in3 >> -shiftBits);
000094  413b              ASRS     r3,r3,r7
;;;161          *(pDst + 3) = (in4 >> -shiftBits);
000096  fa4cfc07          ASR      r12,r12,r7
00009a  e8a5100d          STM      r5!,{r0,r2,r3,r12}
00009e  1e49              SUBS     r1,r1,#1
                  |L1.160|
0000a0  2900              CMP      r1,#0                 ;149
0000a2  d1f3              BNE      |L1.140|
                  |L1.164|
;;;162    
;;;163    
;;;164          pSrc += 4u;
;;;165          pDst += 4u;
;;;166    
;;;167          blkCnt--;
;;;168        }
;;;169    
;;;170      }
;;;171    
;;;172      /* If the blockSize is not a multiple of 4, compute any remaining output samples here.    
;;;173       ** No loop unrolling is used. */
;;;174      blkCnt = blockSize % 0x4u;
0000a4  f00e0003          AND      r0,lr,#3
;;;175    
;;;176    #else
;;;177    
;;;178      /* Run the below code for Cortex-M0 */
;;;179    
;;;180    
;;;181      /* Initialize blkCnt with number of samples */
;;;182      blkCnt = blockSize;
;;;183    
;;;184    #endif /* #ifndef ARM_MATH_CM0_FAMILY */
;;;185    
;;;186    
;;;187      while(blkCnt > 0u)
0000a8  e008              B        |L1.188|
;;;188      {
;;;189        /* C = A (>> or <<) shiftBits */
;;;190        /* Shift the input and then store the result in the destination buffer. */
;;;191        *pDst++ = (sign == 0u) ? clip_q63_to_q31((q63_t) * pSrc++ << shiftBits) :
0000aa  bf00              NOP      
                  |L1.172|
;;;192          (*pSrc++ >> -shiftBits);
0000ac  cc01              LDM      r4!,{r0}
0000ae  f1bb0f00          CMP      r11,#0                ;191
0000b2  d008              BEQ      |L1.198|
0000b4  4138              ASRS     r0,r0,r7
                  |L1.182|
0000b6  c501              STM      r5!,{r0}
;;;193    
;;;194        /* Decrement the loop counter */
;;;195        blkCnt--;
0000b8  f1a80001          SUB      r0,r8,#1
                  |L1.188|
0000bc  ea5f0800          MOVS     r8,r0                 ;174
0000c0  d1f4              BNE      |L1.172|
;;;196      }
;;;197    
;;;198    
;;;199    }
0000c2  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.198|
0000c6  17c1              ASRS     r1,r0,#31             ;191
0000c8  4632              MOV      r2,r6                 ;191
0000ca  f7fffffe          BL       __aeabi_llsl
0000ce  17ca              ASRS     r2,r1,#31             ;191
0000d0  ebb17fe0          CMP      r1,r0,ASR #31         ;191
0000d4  d0ef              BEQ      |L1.182|
0000d6  f06f4000          MVN      r0,#0x80000000        ;191
0000da  4050              EORS     r0,r0,r2              ;191
0000dc  e7eb              B        |L1.182|
;;;200    
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\BasicMathFunctions\\arm_shift_q31.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_arm_shift_q31_c_a226c331____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___15_arm_shift_q31_c_a226c331____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_arm_shift_q31_c_a226c331____REVSH|
#line 144
|__asm___15_arm_shift_q31_c_a226c331____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_arm_shift_q31_c_a226c331____RRX|
#line 300
|__asm___15_arm_shift_q31_c_a226c331____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
