; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_correlate_fast_opt_q15.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_correlate_fast_opt_q15.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_correlate_fast_opt_q15.crf src\FilteringFunctions\arm_correlate_fast_opt_q15.c]
                          THUMB

                          AREA ||i.arm_correlate_fast_opt_q15||, CODE, READONLY, ALIGN=2

                  arm_correlate_fast_opt_q15 PROC
;;;83     
;;;84     void arm_correlate_fast_opt_q15(
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;85       q15_t * pSrcA,
;;;86       uint32_t srcALen,
;;;87       q15_t * pSrcB,
;;;88       uint32_t srcBLen,
;;;89       q15_t * pDst,
;;;90       q15_t * pScratch)
;;;91     {
000004  b085              SUB      sp,sp,#0x14
000006  461d              MOV      r5,r3
;;;92       q15_t *pIn1;                                   /* inputA pointer               */
;;;93       q15_t *pIn2;                                   /* inputB pointer               */
;;;94       q31_t acc0, acc1, acc2, acc3;                  /* Accumulators                  */
;;;95       q15_t *py;                                     /* Intermediate inputB pointer  */
;;;96       q31_t x1, x2, x3;                              /* temporary variables for holding input and coefficient values */
;;;97       uint32_t j, blkCnt, outBlockSize;              /* loop counter                 */
;;;98       int32_t inc = 1;                               /* Destination address modifier */
000008  2301              MOVS     r3,#1
00000a  460e              MOV      r6,r1                 ;91
;;;99       uint32_t tapCnt;
;;;100      q31_t y1, y2;
;;;101      q15_t *pScr;                                   /* Intermediate pointers        */
;;;102      q15_t *pOut = pDst;                            /* output pointer               */
;;;103    #ifdef UNALIGNED_SUPPORT_DISABLE
;;;104    
;;;105      q15_t a, b;
;;;106    
;;;107    #endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE	*/
;;;108    
;;;109      /* The algorithm implementation is based on the lengths of the inputs. */
;;;110      /* srcB is always made to slide across srcA. */
;;;111      /* So srcBLen is always considered as shorter or equal to srcALen */
;;;112      /* But CORR(x, y) is reverse of CORR(y, x) */
;;;113      /* So, when srcBLen > srcALen, output pointer is made to point to the end of the output buffer */
;;;114      /* and the destination pointer modifier, inc is set to -1 */
;;;115      /* If srcALen > srcBLen, zero pad has to be done to srcB to make the two inputs of same length */
;;;116      /* But to improve the performance,        
;;;117       * we include zeroes in the output instead of zero padding either of the the inputs*/
;;;118      /* If srcALen > srcBLen,        
;;;119       * (srcALen - srcBLen) zeroes has to included in the starting of the output buffer */
;;;120      /* If srcALen < srcBLen,        
;;;121       * (srcALen - srcBLen) zeroes has to included in the ending of the output buffer */
;;;122      if(srcALen >= srcBLen)
;;;123      {
;;;124        /* Initialization of inputA pointer */
;;;125        pIn1 = (pSrcA);
;;;126    
;;;127        /* Initialization of inputB pointer */
;;;128        pIn2 = (pSrcB);
;;;129    
;;;130        /* Number of output samples is calculated */
;;;131        outBlockSize = (2u * srcALen) - 1u;
00000c  9301              STR      r3,[sp,#4]
00000e  990e              LDR      r1,[sp,#0x38]         ;98
000010  1e9b              SUBS     r3,r3,#2
000012  42ae              CMP      r6,r5                 ;122
000014  d30a              BCC      |L1.44|
000016  4607              MOV      r7,r0                 ;125
000018  4614              MOV      r4,r2                 ;128
00001a  eb030046          ADD      r0,r3,r6,LSL #1
;;;132    
;;;133        /* When srcALen > srcBLen, zero padding is done to srcB        
;;;134         * to make their lengths equal.        
;;;135         * Instead, (outBlockSize - (srcALen + srcBLen - 1))        
;;;136         * number of output samples are made zero */
;;;137        j = outBlockSize - (srcALen + (srcBLen - 1u));
00001e  1972              ADDS     r2,r6,r5
000020  1a80              SUBS     r0,r0,r2
000022  1c40              ADDS     r0,r0,#1
;;;138    
;;;139        /* Updating the pointer position to non zero value */
;;;140        pOut += j;
000024  eb010040          ADD      r0,r1,r0,LSL #1
000028  9000              STR      r0,[sp,#0]
00002a  e00a              B        |L1.66|
                  |L1.44|
;;;141    
;;;142      }
;;;143      else
;;;144      {
;;;145        /* Initialization of inputA pointer */
;;;146        pIn1 = (pSrcB);
;;;147    
;;;148        /* Initialization of inputB pointer */
;;;149        pIn2 = (pSrcA);
00002c  4604              MOV      r4,r0
;;;150    
;;;151        /* srcBLen is always considered as shorter or equal to srcALen */
;;;152        j = srcBLen;
00002e  4628              MOV      r0,r5
;;;153        srcBLen = srcALen;
000030  4635              MOV      r5,r6
;;;154        srcALen = j;
000032  4606              MOV      r6,r0
;;;155    
;;;156        /* CORR(x, y) = Reverse order(CORR(y, x)) */
;;;157        /* Hence set the destination pointer to point to the last output sample */
;;;158        pOut = pDst + ((srcALen + srcBLen) - 2u);
000034  4428              ADD      r0,r0,r5
000036  eb010040          ADD      r0,r1,r0,LSL #1
00003a  1f00              SUBS     r0,r0,#4
00003c  e9cd0300          STRD     r0,r3,[sp,#0]
000040  4617              MOV      r7,r2                 ;146
                  |L1.66|
;;;159    
;;;160        /* Destination address modifier is set to -1 */
;;;161        inc = -1;
;;;162    
;;;163      }
;;;164    
;;;165      pScr = pScratch;
;;;166    
;;;167      /* Fill (srcBLen - 1u) zeros in scratch buffer */
;;;168      arm_fill_q15(0, pScr, (srcBLen - 1u));
000042  f8dd803c          LDR      r8,[sp,#0x3c]
000046  1e6a              SUBS     r2,r5,#1
000048  4641              MOV      r1,r8
00004a  2000              MOVS     r0,#0
00004c  f7fffffe          BL       arm_fill_q15
;;;169    
;;;170      /* Update temporary scratch pointer */
;;;171      pScr += (srcBLen - 1u);
000050  eb080045          ADD      r0,r8,r5,LSL #1
000054  1e80              SUBS     r0,r0,#2
000056  4680              MOV      r8,r0
;;;172    
;;;173    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;174    
;;;175      /* Copy (srcALen) samples in scratch buffer */
;;;176      arm_copy_q15(pIn1, pScr, srcALen);
000058  4601              MOV      r1,r0
00005a  4632              MOV      r2,r6
00005c  4638              MOV      r0,r7
00005e  f7fffffe          BL       arm_copy_q15
;;;177    
;;;178      /* Update pointers */
;;;179      pScr += srcALen;
000062  eb080146          ADD      r1,r8,r6,LSL #1
;;;180    
;;;181    #else
;;;182    
;;;183      /* Apply loop unrolling and do 4 Copies simultaneously. */
;;;184      j = srcALen >> 2u;
;;;185    
;;;186      /* First part of the processing with loop unrolling copies 4 data points at a time.       
;;;187       ** a second loop below copies for the remaining 1 to 3 samples. */
;;;188      while(j > 0u)
;;;189      {
;;;190        /* copy second buffer in reversal manner */
;;;191        *pScr++ = *pIn1++;
;;;192        *pScr++ = *pIn1++;
;;;193        *pScr++ = *pIn1++;
;;;194        *pScr++ = *pIn1++;
;;;195    
;;;196        /* Decrement the loop counter */
;;;197        j--;
;;;198      }
;;;199    
;;;200      /* If the count is not a multiple of 4, copy remaining samples here.       
;;;201       ** No loop unrolling is used. */
;;;202      j = srcALen % 0x4u;
;;;203    
;;;204      while(j > 0u)
;;;205      {
;;;206        /* copy second buffer in reversal manner for remaining samples */
;;;207        *pScr++ = *pIn1++;
;;;208    
;;;209        /* Decrement the loop counter */
;;;210        j--;
;;;211      }
;;;212    
;;;213    #endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE	*/
;;;214    
;;;215    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;216    
;;;217      /* Fill (srcBLen - 1u) zeros at end of scratch buffer */
;;;218      arm_fill_q15(0, pScr, (srcBLen - 1u));
000066  1e6a              SUBS     r2,r5,#1
000068  2000              MOVS     r0,#0
00006a  f7fffffe          BL       arm_fill_q15
;;;219    
;;;220      /* Update pointer */
;;;221      pScr += (srcBLen - 1u);
;;;222    
;;;223    #else
;;;224    
;;;225    /* Apply loop unrolling and do 4 Copies simultaneously. */
;;;226      j = (srcBLen - 1u) >> 2u;
;;;227    
;;;228      /* First part of the processing with loop unrolling copies 4 data points at a time.       
;;;229       ** a second loop below copies for the remaining 1 to 3 samples. */
;;;230      while(j > 0u)
;;;231      {
;;;232        /* copy second buffer in reversal manner */
;;;233        *pScr++ = 0;
;;;234        *pScr++ = 0;
;;;235        *pScr++ = 0;
;;;236        *pScr++ = 0;
;;;237    
;;;238        /* Decrement the loop counter */
;;;239        j--;
;;;240      }
;;;241    
;;;242      /* If the count is not a multiple of 4, copy remaining samples here.       
;;;243       ** No loop unrolling is used. */
;;;244      j = (srcBLen - 1u) % 0x4u;
;;;245    
;;;246      while(j > 0u)
;;;247      {
;;;248        /* copy second buffer in reversal manner for remaining samples */
;;;249        *pScr++ = 0;
;;;250    
;;;251        /* Decrement the loop counter */
;;;252        j--;
;;;253      }
;;;254    
;;;255    #endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE	*/
;;;256    
;;;257      /* Temporary pointer for scratch2 */
;;;258      py = pIn2;
;;;259    
;;;260    
;;;261      /* Actual correlation process starts here */
;;;262      blkCnt = (srcALen + srcBLen - 1u) >> 2;
00006e  1970              ADDS     r0,r6,r5
000070  1e40              SUBS     r0,r0,#1
000072  e9cd4002          STRD     r4,r0,[sp,#8]
000076  ea4f0e90          LSR      lr,r0,#2
;;;263    
;;;264      while(blkCnt > 0)
00007a  e068              B        |L1.334|
                  |L1.124|
;;;265      {
;;;266        /* Initialze temporary scratch pointer as scratch1 */
;;;267        pScr = pScratch;
;;;268    
;;;269        /* Clear Accumlators */
;;;270        acc0 = 0;
;;;271        acc1 = 0;
;;;272        acc2 = 0;
;;;273        acc3 = 0;
;;;274    
;;;275        /* Read four samples from scratch1 buffer */
;;;276        x1 = *__SIMD32(pScr)++;
00007c  980f              LDR      r0,[sp,#0x3c]
00007e  2300              MOVS     r3,#0                 ;270
000080  469c              MOV      r12,r3                ;271
000082  f8502b04          LDR      r2,[r0],#4
000086  4699              MOV      r9,r3                 ;272
000088  469a              MOV      r10,r3                ;273
;;;277    
;;;278        /* Read next four samples from scratch1 buffer */
;;;279        x2 = *__SIMD32(pScr)++;
00008a  f8501b04          LDR      r1,[r0],#4
;;;280    
;;;281        tapCnt = (srcBLen) >> 2u;
00008e  08ae              LSRS     r6,r5,#2
;;;282    
;;;283        while(tapCnt > 0u)
000090  e022              B        |L1.216|
;;;284        {
;;;285    
;;;286    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;287    
;;;288          /* Read four samples from smaller buffer */
;;;289          y1 = _SIMD32_OFFSET(pIn2);
000092  bf00              NOP      
                  |L1.148|
000094  f8547b04          LDR      r7,[r4],#4
;;;290          y2 = _SIMD32_OFFSET(pIn2 + 2u);
000098  f8546b04          LDR      r6,[r4],#4
;;;291    
;;;292          acc0 = __SMLAD(x1, y1, acc0);
00009c  fb223807          SMLAD    r8,r2,r7,r3
;;;293    
;;;294          acc2 = __SMLAD(x2, y1, acc2);
0000a0  fb219907          SMLAD    r9,r1,r7,r9
;;;295    
;;;296    #ifndef ARM_MATH_BIG_ENDIAN
;;;297          x3 = __PKHBT(x2, x1, 0);
0000a4  eac10202          PKHBT    r2,r1,r2
;;;298    #else
;;;299          x3 = __PKHBT(x1, x2, 0);
;;;300    #endif
;;;301    
;;;302          acc1 = __SMLADX(x3, y1, acc1);
0000a8  fb22cc17          SMLADX   r12,r2,r7,r12
;;;303    
;;;304          x1 = _SIMD32_OFFSET(pScr);
0000ac  f8cdc010          STR      r12,[sp,#0x10]
0000b0  f8502b04          LDR      r2,[r0],#4
;;;305    
;;;306          acc0 = __SMLAD(x2, y2, acc0);
0000b4  fb218306          SMLAD    r3,r1,r6,r8
;;;307    
;;;308          acc2 = __SMLAD(x1, y2, acc2);
0000b8  fb229906          SMLAD    r9,r2,r6,r9
;;;309    
;;;310    #ifndef ARM_MATH_BIG_ENDIAN
;;;311          x3 = __PKHBT(x1, x2, 0);
0000bc  eac20101          PKHBT    r1,r2,r1
;;;312    #else
;;;313          x3 = __PKHBT(x2, x1, 0);
;;;314    #endif
;;;315    
;;;316          acc3 = __SMLADX(x3, y1, acc3);
0000c0  fb21a717          SMLADX   r7,r1,r7,r10
;;;317    
;;;318          acc1 = __SMLADX(x3, y2, acc1);
0000c4  fb21cc16          SMLADX   r12,r1,r6,r12
;;;319    
;;;320          x2 = _SIMD32_OFFSET(pScr + 2u);
0000c8  f8501b04          LDR      r1,[r0],#4
;;;321    
;;;322    #ifndef ARM_MATH_BIG_ENDIAN
;;;323          x3 = __PKHBT(x2, x1, 0);
0000cc  eac10802          PKHBT    r8,r1,r2
;;;324    #else
;;;325          x3 = __PKHBT(x1, x2, 0);
;;;326    #endif
;;;327    
;;;328          acc3 = __SMLADX(x3, y2, acc3);
0000d0  fb287a16          SMLADX   r10,r8,r6,r7
;;;329    #else	 
;;;330    
;;;331          /* Read four samples from smaller buffer */
;;;332    	  a = *pIn2;
;;;333    	  b = *(pIn2 + 1);
;;;334    
;;;335    #ifndef ARM_MATH_BIG_ENDIAN
;;;336          y1 = __PKHBT(a, b, 16);
;;;337    #else
;;;338          y1 = __PKHBT(b, a, 16);
;;;339    #endif
;;;340    	  
;;;341    	  a = *(pIn2 + 2);
;;;342    	  b = *(pIn2 + 3);
;;;343    #ifndef ARM_MATH_BIG_ENDIAN
;;;344          y2 = __PKHBT(a, b, 16);
;;;345    #else
;;;346          y2 = __PKHBT(b, a, 16);
;;;347    #endif				
;;;348    
;;;349          acc0 = __SMLAD(x1, y1, acc0);
;;;350    
;;;351          acc2 = __SMLAD(x2, y1, acc2);
;;;352    
;;;353    #ifndef ARM_MATH_BIG_ENDIAN
;;;354          x3 = __PKHBT(x2, x1, 0);
;;;355    #else
;;;356          x3 = __PKHBT(x1, x2, 0);
;;;357    #endif
;;;358    
;;;359          acc1 = __SMLADX(x3, y1, acc1);
;;;360    
;;;361    	  a = *pScr;
;;;362    	  b = *(pScr + 1);
;;;363    
;;;364    #ifndef ARM_MATH_BIG_ENDIAN
;;;365          x1 = __PKHBT(a, b, 16);
;;;366    #else
;;;367          x1 = __PKHBT(b, a, 16);
;;;368    #endif
;;;369    
;;;370          acc0 = __SMLAD(x2, y2, acc0);
;;;371    
;;;372          acc2 = __SMLAD(x1, y2, acc2);
;;;373    
;;;374    #ifndef ARM_MATH_BIG_ENDIAN
;;;375          x3 = __PKHBT(x1, x2, 0);
;;;376    #else
;;;377          x3 = __PKHBT(x2, x1, 0);
;;;378    #endif
;;;379    
;;;380          acc3 = __SMLADX(x3, y1, acc3);
;;;381    
;;;382          acc1 = __SMLADX(x3, y2, acc1);
;;;383    
;;;384    	  a = *(pScr + 2);
;;;385    	  b = *(pScr + 3);
;;;386    
;;;387    #ifndef ARM_MATH_BIG_ENDIAN
;;;388          x2 = __PKHBT(a, b, 16);
;;;389    #else
;;;390          x2 = __PKHBT(b, a, 16);
;;;391    #endif
;;;392    
;;;393    #ifndef ARM_MATH_BIG_ENDIAN
;;;394          x3 = __PKHBT(x2, x1, 0);
;;;395    #else
;;;396          x3 = __PKHBT(x1, x2, 0);
;;;397    #endif
;;;398    
;;;399          acc3 = __SMLADX(x3, y2, acc3);
;;;400    
;;;401    #endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE	*/
;;;402    
;;;403          pIn2 += 4u;
;;;404    
;;;405          pScr += 4u;
;;;406    
;;;407    
;;;408          /* Decrement the loop counter */
;;;409          tapCnt--;
0000d4  f1ab0601          SUB      r6,r11,#1
                  |L1.216|
0000d8  ea5f0b06          MOVS     r11,r6                ;281
0000dc  d1da              BNE      |L1.148|
;;;410        }
;;;411    
;;;412    
;;;413    
;;;414        /* Update scratch pointer for remaining samples of smaller length sequence */
;;;415        pScr -= 4u;
;;;416    
;;;417    
;;;418        /* apply same above for remaining samples of smaller length sequence */
;;;419        tapCnt = (srcBLen) & 3u;
0000de  f0050103          AND      r1,r5,#3
0000e2  3808              SUBS     r0,r0,#8
;;;420    
;;;421        while(tapCnt > 0u)
0000e4  e010              B        |L1.264|
;;;422        {
;;;423    
;;;424          /* accumlate the results */
;;;425          acc0 += (*pScr++ * *pIn2);
0000e6  bf00              NOP      
                  |L1.232|
0000e8  f8306b02          LDRH     r6,[r0],#2
0000ec  f8342b02          LDRH     r2,[r4],#2
0000f0  fb163302          SMLABB   r3,r6,r2,r3
;;;426          acc1 += (*pScr++ * *pIn2);
0000f4  8806              LDRH     r6,[r0,#0]
0000f6  fb16cc02          SMLABB   r12,r6,r2,r12
;;;427          acc2 += (*pScr++ * *pIn2);
0000fa  8847              LDRH     r7,[r0,#2]
0000fc  fb179902          SMLABB   r9,r7,r2,r9
;;;428          acc3 += (*pScr++ * *pIn2++);
000100  8887              LDRH     r7,[r0,#4]
000102  fb17aa02          SMLABB   r10,r7,r2,r10
000106  1e49              SUBS     r1,r1,#1
                  |L1.264|
000108  2900              CMP      r1,#0                 ;421
00010a  d1ed              BNE      |L1.232|
;;;429    
;;;430          pScr -= 3u;
;;;431    
;;;432          /* Decrement the loop counter */
;;;433          tapCnt--;
;;;434        }
;;;435    
;;;436        blkCnt--;
;;;437    
;;;438    
;;;439        /* Store the results in the accumulators in the destination buffer. */
;;;440        *pOut = (__SSAT(acc0 >> 15u, 16));
00010c  9800              LDR      r0,[sp,#0]
00010e  f32331cf          SSAT     r1,#16,r3,ASR #15
000112  f1ae0e01          SUB      lr,lr,#1              ;436
000116  8001              STRH     r1,[r0,#0]
000118  e9dd0100          LDRD     r0,r1,[sp,#0]
;;;441        pOut += inc;
00011c  eb000041          ADD      r0,r0,r1,LSL #1
;;;442        *pOut = (__SSAT(acc1 >> 15u, 16));
000120  f32c31cf          SSAT     r1,#16,r12,ASR #15
000124  8001              STRH     r1,[r0,#0]
;;;443        pOut += inc;
000126  9901              LDR      r1,[sp,#4]
000128  eb000041          ADD      r0,r0,r1,LSL #1
;;;444        *pOut = (__SSAT(acc2 >> 15u, 16));
00012c  f32931cf          SSAT     r1,#16,r9,ASR #15
000130  8001              STRH     r1,[r0,#0]
;;;445        pOut += inc;
000132  9901              LDR      r1,[sp,#4]
000134  eb000041          ADD      r0,r0,r1,LSL #1
;;;446        *pOut = (__SSAT(acc3 >> 15u, 16));
000138  f32a31cf          SSAT     r1,#16,r10,ASR #15
00013c  8001              STRH     r1,[r0,#0]
;;;447        pOut += inc;
00013e  9901              LDR      r1,[sp,#4]
;;;448    
;;;449    
;;;450        /* Initialization of inputB pointer */
;;;451        pIn2 = py;
;;;452    
;;;453        pScratch += 4u;
000140  9c02              LDR      r4,[sp,#8]
000142  eb000041          ADD      r0,r0,r1,LSL #1       ;447
000146  9000              STR      r0,[sp,#0]            ;451
000148  980f              LDR      r0,[sp,#0x3c]
00014a  3008              ADDS     r0,r0,#8
00014c  900f              STR      r0,[sp,#0x3c]
                  |L1.334|
00014e  f1be0f00          CMP      lr,#0                 ;264
000152  d193              BNE      |L1.124|
;;;454    
;;;455      }
;;;456    
;;;457    
;;;458      blkCnt = (srcALen + srcBLen - 1u) & 0x3;
000154  9803              LDR      r0,[sp,#0xc]
000156  f0000203          AND      r2,r0,#3
;;;459    
;;;460      /* Calculate correlation for remaining samples of Bigger length sequence */
;;;461      while(blkCnt > 0)
00015a  e02c              B        |L1.438|
                  |L1.348|
;;;462      {
;;;463        /* Initialze temporary scratch pointer as scratch1 */
;;;464        pScr = pScratch;
;;;465    
;;;466        /* Clear Accumlators */
;;;467        acc0 = 0;
00015c  2100              MOVS     r1,#0
;;;468    
;;;469        tapCnt = (srcBLen) >> 1u;
00015e  086b              LSRS     r3,r5,#1
;;;470    
;;;471        while(tapCnt > 0u)
000160  980f              LDR      r0,[sp,#0x3c]
000162  e00c              B        |L1.382|
                  |L1.356|
;;;472        {
;;;473    
;;;474          acc0 += (*pScr++ * *pIn2++);
000164  f8306b02          LDRH     r6,[r0],#2
000168  f8347b02          LDRH     r7,[r4],#2
00016c  fb161107          SMLABB   r1,r6,r7,r1
;;;475          acc0 += (*pScr++ * *pIn2++);
000170  f8306b02          LDRH     r6,[r0],#2
000174  f8347b02          LDRH     r7,[r4],#2
000178  fb161107          SMLABB   r1,r6,r7,r1
00017c  1e5b              SUBS     r3,r3,#1
                  |L1.382|
00017e  2b00              CMP      r3,#0                 ;471
000180  d1f0              BNE      |L1.356|
;;;476    
;;;477          /* Decrement the loop counter */
;;;478          tapCnt--;
;;;479        }
;;;480    
;;;481        tapCnt = (srcBLen) & 1u;
000182  f0050301          AND      r3,r5,#1
;;;482    
;;;483        /* apply same above for remaining samples of smaller length sequence */
;;;484        while(tapCnt > 0u)
000186  e006              B        |L1.406|
                  |L1.392|
;;;485        {
;;;486    
;;;487          /* accumlate the results */
;;;488          acc0 += (*pScr++ * *pIn2++);
000188  f8306b02          LDRH     r6,[r0],#2
00018c  f8347b02          LDRH     r7,[r4],#2
000190  fb161107          SMLABB   r1,r6,r7,r1
000194  1e5b              SUBS     r3,r3,#1
                  |L1.406|
000196  2b00              CMP      r3,#0                 ;484
000198  d1f6              BNE      |L1.392|
;;;489    
;;;490          /* Decrement the loop counter */
;;;491          tapCnt--;
;;;492        }
;;;493    
;;;494        blkCnt--;
;;;495    
;;;496        /* Store the result in the accumulator in the destination buffer. */
;;;497    
;;;498        *pOut = (q15_t) (__SSAT((acc0 >> 15), 16));
00019a  9800              LDR      r0,[sp,#0]
00019c  f32131cf          SSAT     r1,#16,r1,ASR #15
0001a0  8001              STRH     r1,[r0,#0]
0001a2  e9dd0100          LDRD     r0,r1,[sp,#0]
;;;499    
;;;500        pOut += inc;
0001a6  eb000041          ADD      r0,r0,r1,LSL #1
;;;501    
;;;502        /* Initialization of inputB pointer */
;;;503        pIn2 = py;
0001aa  9000              STR      r0,[sp,#0]
;;;504    
;;;505        pScratch += 1u;
0001ac  980f              LDR      r0,[sp,#0x3c]
0001ae  9c02              LDR      r4,[sp,#8]
0001b0  1c80              ADDS     r0,r0,#2
0001b2  1e52              SUBS     r2,r2,#1
0001b4  900f              STR      r0,[sp,#0x3c]
                  |L1.438|
0001b6  2a00              CMP      r2,#0                 ;461
0001b8  d1d0              BNE      |L1.348|
;;;506    
;;;507      }
;;;508    }
0001ba  b005              ADD      sp,sp,#0x14
0001bc  e8bd8ff0          POP      {r4-r11,pc}
;;;509    
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\FilteringFunctions\\arm_correlate_fast_opt_q15.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___28_arm_correlate_fast_opt_q15_c_938dbf25____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___28_arm_correlate_fast_opt_q15_c_938dbf25____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___28_arm_correlate_fast_opt_q15_c_938dbf25____REVSH|
#line 144
|__asm___28_arm_correlate_fast_opt_q15_c_938dbf25____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___28_arm_correlate_fast_opt_q15_c_938dbf25____RRX|
#line 300
|__asm___28_arm_correlate_fast_opt_q15_c_938dbf25____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
