; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_mat_cmplx_mult_q15.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_mat_cmplx_mult_q15.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_mat_cmplx_mult_q15.crf src\MatrixFunctions\arm_mat_cmplx_mult_q15.c]
                          THUMB

                          AREA ||i.arm_mat_cmplx_mult_q15||, CODE, READONLY, ALIGN=2

                  arm_mat_cmplx_mult_q15 PROC
;;;87     
;;;88     arm_status arm_mat_cmplx_mult_q15(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;89       const arm_matrix_instance_q15 * pSrcA,
;;;90       const arm_matrix_instance_q15 * pSrcB,
;;;91       arm_matrix_instance_q15 * pDst,
;;;92       q15_t * pScratch)
;;;93     {
000004  b085              SUB      sp,sp,#0x14
000006  4690              MOV      r8,r2
;;;94       /* accumulator */
;;;95       q15_t *pSrcBT = pScratch;                      /* input data matrix pointer for transpose */
;;;96       q15_t *pInA = pSrcA->pData;                    /* input data matrix pointer A of Q15 type */
;;;97       q15_t *pInB = pSrcB->pData;                    /* input data matrix pointer B of Q15 type */
;;;98       q15_t *px;                                     /* Temporary output data matrix pointer */
;;;99       uint16_t numRowsA = pSrcA->numRows;            /* number of rows of input matrix A    */
000008  9a05              LDR      r2,[sp,#0x14]
00000a  6848              LDR      r0,[r1,#4]
;;;100      uint16_t numColsB = pSrcB->numCols;            /* number of columns of input matrix B */
;;;101      uint16_t numColsA = pSrcA->numCols;            /* number of columns of input matrix A */
;;;102      uint16_t numRowsB = pSrcB->numRows;            /* number of rows of input matrix A    */
;;;103      uint16_t col, i = 0u, row = numRowsB, colCnt;  /* loop counters */
00000c  2500              MOVS     r5,#0
00000e  8816              LDRH     r6,[r2,#0]            ;99
000010  884a              LDRH     r2,[r1,#2]            ;100
000012  9201              STR      r2,[sp,#4]            ;101
000014  9a05              LDR      r2,[sp,#0x14]         ;101
000016  469e              MOV      lr,r3                 ;95
000018  8852              LDRH     r2,[r2,#2]            ;101
00001a  9200              STR      r2,[sp,#0]            ;102
00001c  8809              LDRH     r1,[r1,#0]            ;102
;;;104      arm_status status;                             /* status of matrix multiplication */
;;;105      q63_t sumReal, sumImag;
;;;106    
;;;107    #ifdef UNALIGNED_SUPPORT_DISABLE
;;;108      q15_t in;                                      /* Temporary variable to hold the input value */
;;;109      q15_t a, b, c, d;
;;;110    #else
;;;111      q31_t in;                                      /* Temporary variable to hold the input value */
;;;112      q31_t prod1, prod2;
;;;113      q31_t pSourceA, pSourceB;
;;;114    #endif
;;;115    
;;;116    #ifdef ARM_MATH_MATRIX_CHECK
;;;117      /* Check for matrix mismatch condition */
;;;118      if((pSrcA->numCols != pSrcB->numRows) ||
;;;119         (pSrcA->numRows != pDst->numRows) || (pSrcB->numCols != pDst->numCols))
;;;120      {
;;;121        /* Set status as ARM_MATH_SIZE_MISMATCH */
;;;122        status = ARM_MATH_SIZE_MISMATCH;
;;;123      }
;;;124      else
;;;125    #endif
;;;126      {
;;;127        /* Matrix transpose */
;;;128        do
;;;129        {
;;;130          /* Apply loop unrolling and exchange the columns with row elements */
;;;131          col = numColsB >> 2;
00001e  9a01              LDR      r2,[sp,#4]
000020  460c              MOV      r4,r1                 ;103
000022  0897              LSRS     r7,r2,#2
                  |L1.36|
000024  463b              MOV      r3,r7
;;;132    
;;;133          /* The pointer px is set to starting address of the column being processed */
;;;134          px = pSrcBT + i;
000026  eb0e0245          ADD      r2,lr,r5,LSL #1
;;;135    
;;;136          /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.      
;;;137           ** a second loop below computes the remaining 1 to 3 samples. */
;;;138          while(col > 0u)
00002a  e019              B        |L1.96|
                  |L1.44|
;;;139          {
;;;140    #ifdef UNALIGNED_SUPPORT_DISABLE
;;;141            /* Read two elements from the row */
;;;142            in = *pInB++;
;;;143            *px = in;
;;;144            in = *pInB++;
;;;145            px[1] = in;
;;;146    
;;;147            /* Update the pointer px to point to the next row of the transposed matrix */
;;;148            px += numRowsB * 2;
;;;149    
;;;150            /* Read two elements from the row */
;;;151            in = *pInB++;
;;;152            *px = in;
;;;153            in = *pInB++;
;;;154            px[1] = in;
;;;155    
;;;156            /* Update the pointer px to point to the next row of the transposed matrix */
;;;157            px += numRowsB * 2;
;;;158    
;;;159            /* Read two elements from the row */
;;;160            in = *pInB++;
;;;161            *px = in;
;;;162            in = *pInB++;
;;;163            px[1] = in;
;;;164    
;;;165            /* Update the pointer px to point to the next row of the transposed matrix */
;;;166            px += numRowsB * 2;
;;;167    
;;;168            /* Read two elements from the row */
;;;169            in = *pInB++;
;;;170            *px = in;
;;;171            in = *pInB++;
;;;172            px[1] = in;
;;;173    
;;;174            /* Update the pointer px to point to the next row of the transposed matrix */
;;;175            px += numRowsB * 2;
;;;176    
;;;177            /* Decrement the column loop counter */
;;;178            col--;
;;;179          }
;;;180    
;;;181          /* If the columns of pSrcB is not a multiple of 4, compute any remaining output samples here.      
;;;182           ** No loop unrolling is used. */
;;;183          col = numColsB % 0x4u;
;;;184    
;;;185          while(col > 0u)
;;;186          {
;;;187            /* Read two elements from the row */
;;;188            in = *pInB++;
;;;189            *px = in;
;;;190            in = *pInB++;
;;;191            px[1] = in;
;;;192    #else
;;;193    
;;;194            /* Read two elements from the row */
;;;195            in = *__SIMD32(pInB)++;
00002c  f850cb04          LDR      r12,[r0],#4
;;;196    
;;;197            *__SIMD32(px) = in;
000030  f8c2c000          STR      r12,[r2,#0]
;;;198    
;;;199            /* Update the pointer px to point to the next row of the transposed matrix */
;;;200            px += numRowsB * 2;
000034  eb020281          ADD      r2,r2,r1,LSL #2
;;;201    
;;;202    
;;;203            /* Read two elements from the row */
;;;204            in = *__SIMD32(pInB)++;
000038  f850cb04          LDR      r12,[r0],#4
;;;205    
;;;206            *__SIMD32(px) = in;
00003c  f8c2c000          STR      r12,[r2,#0]
;;;207    
;;;208            /* Update the pointer px to point to the next row of the transposed matrix */
;;;209            px += numRowsB * 2;
000040  eb020281          ADD      r2,r2,r1,LSL #2
;;;210    
;;;211            /* Read two elements from the row */
;;;212            in = *__SIMD32(pInB)++;
000044  f850cb04          LDR      r12,[r0],#4
;;;213    
;;;214            *__SIMD32(px) = in;
000048  f8c2c000          STR      r12,[r2,#0]
;;;215    
;;;216            /* Update the pointer px to point to the next row of the transposed matrix */
;;;217            px += numRowsB * 2;
00004c  eb020281          ADD      r2,r2,r1,LSL #2
;;;218    
;;;219            /* Read two elements from the row */
;;;220            in = *__SIMD32(pInB)++;
000050  f850cb04          LDR      r12,[r0],#4
;;;221    
;;;222            *__SIMD32(px) = in;
000054  f8c2c000          STR      r12,[r2,#0]
;;;223    
;;;224            /* Update the pointer px to point to the next row of the transposed matrix */
;;;225            px += numRowsB * 2;
000058  1e5b              SUBS     r3,r3,#1
00005a  eb020281          ADD      r2,r2,r1,LSL #2
;;;226    
;;;227            /* Decrement the column loop counter */
;;;228            col--;
00005e  b29b              UXTH     r3,r3
                  |L1.96|
000060  2b00              CMP      r3,#0                 ;138
000062  d1e3              BNE      |L1.44|
;;;229          }
;;;230    
;;;231          /* If the columns of pSrcB is not a multiple of 4, compute any remaining output samples here.      
;;;232           ** No loop unrolling is used. */
;;;233          col = numColsB % 0x4u;
000064  9b01              LDR      r3,[sp,#4]
000066  f0030303          AND      r3,r3,#3
;;;234    
;;;235          while(col > 0u)
00006a  e007              B        |L1.124|
                  |L1.108|
;;;236          {
;;;237            /* Read two elements from the row */
;;;238            in = *__SIMD32(pInB)++;
00006c  f850cb04          LDR      r12,[r0],#4
;;;239    
;;;240            *__SIMD32(px) = in;
000070  f8c2c000          STR      r12,[r2,#0]
;;;241    #endif
;;;242    
;;;243            /* Update the pointer px to point to the next row of the transposed matrix */
;;;244            px += numRowsB * 2;
000074  1e5b              SUBS     r3,r3,#1
000076  eb020281          ADD      r2,r2,r1,LSL #2
;;;245    
;;;246            /* Decrement the column loop counter */
;;;247            col--;
00007a  b29b              UXTH     r3,r3
                  |L1.124|
00007c  2b00              CMP      r3,#0                 ;235
00007e  d1f5              BNE      |L1.108|
000080  1cad              ADDS     r5,r5,#2              ;235
;;;248          }
;;;249    
;;;250          i = i + 2u;
000082  1e64              SUBS     r4,r4,#1
;;;251    
;;;252          /* Decrement the row loop counter */
;;;253          row--;
000084  0424              LSLS     r4,r4,#16
000086  b2ad              UXTH     r5,r5                 ;250
000088  0c24              LSRS     r4,r4,#16
;;;254    
;;;255        } while(row > 0u);
00008a  d1cb              BNE      |L1.36|
;;;256    
;;;257        /* Reset the variables for the usage in the following multiplication process */
;;;258        row = numRowsA;
;;;259        i = 0u;
;;;260        px = pDst->pData;
;;;261    
;;;262        /* The following loop performs the dot-product of each row in pSrcA with each column in pSrcB */
;;;263        /* row loop */
;;;264        do
;;;265        {
;;;266          /* For every row wise process, the column loop counter is to be initiated */
;;;267          col = numColsB;
;;;268    
;;;269          /* For every row wise process, the pIn2 pointer is set      
;;;270           ** to the starting address of the transposed pSrcB data */
;;;271          pInB = pSrcBT;
;;;272    
;;;273          /* column loop */
;;;274          do
;;;275          {
;;;276            /* Set the variable sum, that acts as accumulator, to zero */
;;;277            sumReal = 0;
;;;278            sumImag = 0;
;;;279    
;;;280            /* Apply loop unrolling and compute 2 MACs simultaneously. */
;;;281            colCnt = numColsA >> 1;
00008c  9800              LDR      r0,[sp,#0]
00008e  9602              STR      r6,[sp,#8]            ;260
000090  f8d8b004          LDR      r11,[r8,#4]           ;101
000094  0840              LSRS     r0,r0,#1
000096  4699              MOV      r9,r3                 ;259
000098  9003              STR      r0,[sp,#0xc]
                  |L1.154|
00009a  9f01              LDR      r7,[sp,#4]            ;271
00009c  4672              MOV      r2,lr                 ;271
                  |L1.158|
;;;282    
;;;283            /* Initiate the pointer pIn1 to point to the starting address of the column being processed */
;;;284            pInA = pSrcA->pData + i * 2;
00009e  9d05              LDR      r5,[sp,#0x14]
0000a0  2300              MOVS     r3,#0                 ;271
0000a2  4618              MOV      r0,r3                 ;271
0000a4  686d              LDR      r5,[r5,#4]
0000a6  461c              MOV      r4,r3                 ;271
0000a8  4619              MOV      r1,r3                 ;271
0000aa  9e03              LDR      r6,[sp,#0xc]
0000ac  eb050589          ADD      r5,r5,r9,LSL #2
;;;285    
;;;286    
;;;287            /* matrix multiplication */
;;;288            while(colCnt > 0u)
0000b0  e025              B        |L1.254|
;;;289            {
;;;290              /* c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n) */
;;;291    
;;;292    #ifdef UNALIGNED_SUPPORT_DISABLE
;;;293    
;;;294              /* read real and imag values from pSrcA buffer */
;;;295              a = *pInA;
;;;296              b = *(pInA + 1u);
;;;297              /* read real and imag values from pSrcB buffer */
;;;298              c = *pInB;
;;;299              d = *(pInB + 1u);
;;;300    
;;;301              /* Multiply and Accumlates */
;;;302              sumReal += (q31_t) a *c;
;;;303              sumImag += (q31_t) a *d;
;;;304              sumReal -= (q31_t) b *d;
;;;305              sumImag += (q31_t) b *c;
;;;306    
;;;307              /* read next real and imag values from pSrcA buffer */
;;;308              a = *(pInA + 2u);
;;;309              b = *(pInA + 3u);
;;;310              /* read next real and imag values from pSrcB buffer */
;;;311              c = *(pInB + 2u);
;;;312              d = *(pInB + 3u);
;;;313    
;;;314              /* update pointer */
;;;315              pInA += 4u;
;;;316    
;;;317              /* Multiply and Accumlates */
;;;318              sumReal += (q31_t) a *c;
;;;319              sumImag += (q31_t) a *d;
;;;320              sumReal -= (q31_t) b *d;
;;;321              sumImag += (q31_t) b *c;
;;;322              /* update pointer */
;;;323              pInB += 4u;
;;;324    #else
;;;325              /* read real and imag values from pSrcA and pSrcB buffer */
;;;326              pSourceA = *__SIMD32(pInA)++;
0000b2  bf00              NOP      
                  |L1.180|
0000b4  f8d5a000          LDR      r10,[r5,#0]
;;;327              pSourceB = *__SIMD32(pInB)++;
0000b8  f8528b04          LDR      r8,[r2],#4
;;;328    
;;;329              /* Multiply and Accumlates */
;;;330    #ifdef ARM_MATH_BIG_ENDIAN
;;;331              prod1 = -__SMUSD(pSourceA, pSourceB);
;;;332    #else
;;;333              prod1 = __SMUSD(pSourceA, pSourceB);
0000bc  fb4afc08          SMUSD    r12,r10,r8
;;;334    #endif
;;;335              prod2 = __SMUADX(pSourceA, pSourceB);
0000c0  fb2afa18          SMUADX   r10,r10,r8
0000c4  eb13030c          ADDS     r3,r3,r12
0000c8  eb4078ec          ADC      r8,r0,r12,ASR #31
0000cc  f8cdc010          STR      r12,[sp,#0x10]
0000d0  eb14040a          ADDS     r4,r4,r10
;;;336              sumReal += (q63_t) prod1;
;;;337              sumImag += (q63_t) prod2;
;;;338    
;;;339              /* read real and imag values from pSrcA and pSrcB buffer */
;;;340              pSourceA = *__SIMD32(pInA)++;
0000d4  6868              LDR      r0,[r5,#4]
;;;341              pSourceB = *__SIMD32(pInB)++;
0000d6  f852cb04          LDR      r12,[r2],#4
0000da  eb417aea          ADC      r10,r1,r10,ASR #31    ;335
;;;342    
;;;343              /* Multiply and Accumlates */
;;;344    #ifdef ARM_MATH_BIG_ENDIAN
;;;345              prod1 = -__SMUSD(pSourceA, pSourceB);
;;;346    #else
;;;347              prod1 = __SMUSD(pSourceA, pSourceB);
0000de  fb40f10c          SMUSD    r1,r0,r12
;;;348    #endif
;;;349              prod2 = __SMUADX(pSourceA, pSourceB);
0000e2  fb20fc1c          SMUADX   r12,r0,r12
0000e6  185b              ADDS     r3,r3,r1
0000e8  eb4870e1          ADC      r0,r8,r1,ASR #31
0000ec  eb14040c          ADDS     r4,r4,r12
0000f0  f1a60601          SUB      r6,r6,#1
0000f4  f1050508          ADD      r5,r5,#8
0000f8  eb4a71ec          ADC      r1,r10,r12,ASR #31
;;;350              sumReal += (q63_t) prod1;
;;;351              sumImag += (q63_t) prod2;
;;;352    
;;;353    #endif /*      #ifdef UNALIGNED_SUPPORT_DISABLE */
;;;354    
;;;355              /* Decrement the loop counter */
;;;356              colCnt--;
0000fc  b2b6              UXTH     r6,r6
                  |L1.254|
0000fe  2e00              CMP      r6,#0                 ;288
000100  d1d8              BNE      |L1.180|
;;;357            }
;;;358    
;;;359            /* process odd column samples */
;;;360            if((numColsA & 0x1u) > 0u)
000102  9e00              LDR      r6,[sp,#0]
000104  07f6              LSLS     r6,r6,#31
000106  d00c              BEQ      |L1.290|
;;;361            {
;;;362              /* c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n) */
;;;363    
;;;364    #ifdef UNALIGNED_SUPPORT_DISABLE
;;;365    
;;;366              /* read real and imag values from pSrcA and pSrcB buffer */
;;;367              a = *pInA++;
;;;368              b = *pInA++;
;;;369              c = *pInB++;
;;;370              d = *pInB++;
;;;371    
;;;372              /* Multiply and Accumlates */
;;;373              sumReal += (q31_t) a *c;
;;;374              sumImag += (q31_t) a *d;
;;;375              sumReal -= (q31_t) b *d;
;;;376              sumImag += (q31_t) b *c;
;;;377    
;;;378    #else
;;;379              /* read real and imag values from pSrcA and pSrcB buffer */
;;;380              pSourceA = *__SIMD32(pInA)++;
000108  682d              LDR      r5,[r5,#0]
;;;381              pSourceB = *__SIMD32(pInB)++;
00010a  f852cb04          LDR      r12,[r2],#4
;;;382    
;;;383              /* Multiply and Accumlates */
;;;384    #ifdef ARM_MATH_BIG_ENDIAN
;;;385              prod1 = -__SMUSD(pSourceA, pSourceB);
;;;386    #else
;;;387              prod1 = __SMUSD(pSourceA, pSourceB);
00010e  fb45f60c          SMUSD    r6,r5,r12
;;;388    #endif
;;;389              prod2 = __SMUADX(pSourceA, pSourceB);
000112  fb25f51c          SMUADX   r5,r5,r12
000116  199b              ADDS     r3,r3,r6
000118  eb4070e6          ADC      r0,r0,r6,ASR #31
00011c  1964              ADDS     r4,r4,r5
00011e  eb4171e5          ADC      r1,r1,r5,ASR #31
                  |L1.290|
;;;390              sumReal += (q63_t) prod1;
;;;391              sumImag += (q63_t) prod2;
;;;392    
;;;393    #endif /*      #ifdef UNALIGNED_SUPPORT_DISABLE */
;;;394    
;;;395            }
;;;396    
;;;397            /* Saturate and store the result in the destination buffer */
;;;398    
;;;399            *px++ = (q15_t) (__SSAT(sumReal >> 15, 16));
000122  ea4f4540          LSL      r5,r0,#17
000126  ea4530d3          ORR      r0,r5,r3,LSR #15
00012a  f300030f          SSAT     r3,#16,r0
00012e  f8ab3000          STRH     r3,[r11,#0]
;;;400            *px++ = (q15_t) (__SSAT(sumImag >> 15, 16));
000132  ea4f4341          LSL      r3,r1,#17
000136  f10b0002          ADD      r0,r11,#2             ;399
00013a  ea4331d4          ORR      r1,r3,r4,LSR #15
00013e  f301010f          SSAT     r1,#16,r1
000142  f1a70701          SUB      r7,r7,#1
000146  f8201b02          STRH     r1,[r0],#2
;;;401    
;;;402            /* Decrement the column loop counter */
;;;403            col--;
00014a  043f              LSLS     r7,r7,#16
00014c  4683              MOV      r11,r0                ;400
00014e  0c3f              LSRS     r7,r7,#16
;;;404    
;;;405          } while(col > 0u);
000150  d1a5              BNE      |L1.158|
;;;406    
;;;407          i = i + numColsA;
000152  9900              LDR      r1,[sp,#0]
000154  eb090001          ADD      r0,r9,r1
000158  fa1ff980          UXTH     r9,r0
;;;408    
;;;409          /* Decrement the row loop counter */
;;;410          row--;
00015c  9802              LDR      r0,[sp,#8]
00015e  1e40              SUBS     r0,r0,#1
000160  0400              LSLS     r0,r0,#16
000162  0c00              LSRS     r0,r0,#16
;;;411    
;;;412        } while(row > 0u);
000164  9002              STR      r0,[sp,#8]
000166  d198              BNE      |L1.154|
;;;413    
;;;414        /* set status as ARM_MATH_SUCCESS */
;;;415        status = ARM_MATH_SUCCESS;
;;;416      }
;;;417    
;;;418      /* Return to application */
;;;419      return (status);
;;;420    }
000168  b009              ADD      sp,sp,#0x24
00016a  e8bd8ff0          POP      {r4-r11,pc}
;;;421    
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\MatrixFunctions\\arm_mat_cmplx_mult_q15.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___24_arm_mat_cmplx_mult_q15_c_dbc728df____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___24_arm_mat_cmplx_mult_q15_c_dbc728df____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___24_arm_mat_cmplx_mult_q15_c_dbc728df____REVSH|
#line 144
|__asm___24_arm_mat_cmplx_mult_q15_c_dbc728df____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___24_arm_mat_cmplx_mult_q15_c_dbc728df____RRX|
#line 300
|__asm___24_arm_mat_cmplx_mult_q15_c_dbc728df____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
