; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_mat_scale_q31.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_mat_scale_q31.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_mat_scale_q31.crf src\MatrixFunctions\arm_mat_scale_q31.c]
                          THUMB

                          AREA ||i.arm_mat_scale_q31||, CODE, READONLY, ALIGN=1

                  arm_mat_scale_q31 PROC
;;;66     
;;;67     arm_status arm_mat_scale_q31(
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;68       const arm_matrix_instance_q31 * pSrc,
;;;69       q31_t scaleFract,
;;;70       int32_t shift,
;;;71       arm_matrix_instance_q31 * pDst)
;;;72     {
;;;73       q31_t *pIn = pSrc->pData;                      /* input data matrix pointer */
;;;74       q31_t *pOut = pDst->pData;                     /* output data matrix pointer */
000004  6844              LDR      r4,[r0,#4]
;;;75       uint32_t numSamples;                           /* total number of elements in the matrix */
;;;76       int32_t totShift = shift + 1;                  /* shift to apply after scaling */
;;;77       uint32_t blkCnt;                               /* loop counters  */
;;;78       arm_status status;                             /* status of matrix scaling      */
;;;79       q31_t in1, in2, out1;                          /* temporary variabels */
;;;80     
;;;81     #ifndef ARM_MATH_CM0_FAMILY
;;;82     
;;;83       q31_t in3, in4, out2, out3, out4;              /* temporary variables */
;;;84     
;;;85     #endif //      #ifndef ARM_MAT_CM0
;;;86     
;;;87     #ifdef ARM_MATH_MATRIX_CHECK
;;;88       /* Check for matrix mismatch  */
;;;89       if((pSrc->numRows != pDst->numRows) || (pSrc->numCols != pDst->numCols))
;;;90       {
;;;91         /* Set status as ARM_MATH_SIZE_MISMATCH */
;;;92         status = ARM_MATH_SIZE_MISMATCH;
;;;93       }
;;;94       else
;;;95     #endif //    #ifdef ARM_MATH_MATRIX_CHECK
;;;96       {
;;;97         /* Total number of samples in the input matrix */
;;;98         numSamples = (uint32_t) pSrc->numRows * pSrc->numCols;
000006  8805              LDRH     r5,[r0,#0]
000008  8840              LDRH     r0,[r0,#2]
00000a  685b              LDR      r3,[r3,#4]            ;74
00000c  fb05fb00          MUL      r11,r5,r0
;;;99     
;;;100    #ifndef ARM_MATH_CM0_FAMILY
;;;101    
;;;102        /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;103    
;;;104        /* Loop Unrolling */
;;;105        blkCnt = numSamples >> 2u;
000010  ea4f0c9b          LSR      r12,r11,#2
;;;106    
;;;107        /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.    
;;;108         ** a second loop below computes the remaining 1 to 3 samples. */
;;;109        while(blkCnt > 0u)
;;;110        {
;;;111          /* C(m,n) = A(m,n) * k */
;;;112          /* Read values from input */
;;;113          in1 = *pIn;
;;;114          in2 = *(pIn + 1);
;;;115          in3 = *(pIn + 2);
;;;116          in4 = *(pIn + 3);
;;;117    
;;;118          /* multiply input with scaler value */
;;;119          in1 = ((q63_t) in1 * scaleFract) >> 32;
;;;120          in2 = ((q63_t) in2 * scaleFract) >> 32;
;;;121          in3 = ((q63_t) in3 * scaleFract) >> 32;
;;;122          in4 = ((q63_t) in4 * scaleFract) >> 32;
;;;123    
;;;124          /* apply shifting */
;;;125          out1 = in1 << totShift;
;;;126          out2 = in2 << totShift;
;;;127    
;;;128          /* saturate the results. */
;;;129          if(in1 != (out1 >> totShift))
;;;130            out1 = 0x7FFFFFFF ^ (in1 >> 31);
000014  f06f4e00          MVN      lr,#0x80000000
000018  1c52              ADDS     r2,r2,#1
00001a  e033              B        |L1.132|
                  |L1.28|
00001c  e9d46000          LDRD     r6,r0,[r4,#0]         ;72
000020  fb56f601          SMMUL    r6,r6,r1              ;119
000024  fb50f701          SMMUL    r7,r0,r1              ;120
000028  e9d45802          LDRD     r5,r8,[r4,#8]         ;120
00002c  fb55f901          SMMUL    r9,r5,r1              ;121
000030  fb58fa01          SMMUL    r10,r8,r1             ;122
000034  fa06f502          LSL      r5,r6,r2              ;125
000038  fa07f002          LSL      r0,r7,r2              ;126
00003c  fa45f802          ASR      r8,r5,r2              ;129
000040  45b0              CMP      r8,r6                 ;129
000042  d001              BEQ      |L1.72|
000044  ea8e75e6          EOR      r5,lr,r6,ASR #31
                  |L1.72|
;;;131    
;;;132          if(in2 != (out2 >> totShift))
000048  fa40f602          ASR      r6,r0,r2
00004c  42be              CMP      r6,r7
00004e  d001              BEQ      |L1.84|
;;;133            out2 = 0x7FFFFFFF ^ (in2 >> 31);
000050  ea8e70e7          EOR      r0,lr,r7,ASR #31
                  |L1.84|
;;;134    
;;;135          out3 = in3 << totShift;
;;;136          out4 = in4 << totShift;
000054  e9c35000          STRD     r5,r0,[r3,#0]
000058  fa09f702          LSL      r7,r9,r2              ;135
00005c  fa0af602          LSL      r6,r10,r2
;;;137    
;;;138          *pOut = out1;
;;;139          *(pOut + 1) = out2;
;;;140    
;;;141          if(in3 != (out3 >> totShift))
000060  fa47f002          ASR      r0,r7,r2
000064  4548              CMP      r0,r9
000066  d001              BEQ      |L1.108|
;;;142            out3 = 0x7FFFFFFF ^ (in3 >> 31);
000068  ea8e77e9          EOR      r7,lr,r9,ASR #31
                  |L1.108|
;;;143    
;;;144          if(in4 != (out4 >> totShift))
00006c  fa46f002          ASR      r0,r6,r2
000070  4550              CMP      r0,r10
000072  d001              BEQ      |L1.120|
;;;145            out4 = 0x7FFFFFFF ^ (in4 >> 31);
000074  ea8e76ea          EOR      r6,lr,r10,ASR #31
                  |L1.120|
000078  e9c37602          STRD     r7,r6,[r3,#8]
00007c  3310              ADDS     r3,r3,#0x10
00007e  3410              ADDS     r4,r4,#0x10
000080  f1ac0c01          SUB      r12,r12,#1
                  |L1.132|
000084  f1bc0f00          CMP      r12,#0                ;109
000088  d1c8              BNE      |L1.28|
;;;146    
;;;147    
;;;148          *(pOut + 2) = out3;
;;;149          *(pOut + 3) = out4;
;;;150    
;;;151          /* update pointers to process next sampels */
;;;152          pIn += 4u;
;;;153          pOut += 4u;
;;;154    
;;;155    
;;;156          /* Decrement the numSamples loop counter */
;;;157          blkCnt--;
;;;158        }
;;;159    
;;;160        /* If the numSamples is not a multiple of 4, compute any remaining output samples here.    
;;;161         ** No loop unrolling is used. */
;;;162        blkCnt = numSamples % 0x4u;
00008a  f00b0703          AND      r7,r11,#3
00008e  46f4              MOV      r12,lr                ;130
;;;163    
;;;164    #else
;;;165    
;;;166        /* Run the below code for Cortex-M0 */
;;;167    
;;;168        /* Initialize blkCnt with number of samples */
;;;169        blkCnt = numSamples;
;;;170    
;;;171    #endif /* #ifndef ARM_MATH_CM0_FAMILY */
;;;172    
;;;173        while(blkCnt > 0u)
000090  e00c              B        |L1.172|
                  |L1.146|
;;;174        {
;;;175          /* C(m,n) = A(m,n) * k */
;;;176          /* Scale, saturate and then store the results in the destination buffer. */
;;;177          in1 = *pIn++;
000092  cc01              LDM      r4!,{r0}
;;;178    
;;;179          in2 = ((q63_t) in1 * scaleFract) >> 32;
000094  fb50f501          SMMUL    r5,r0,r1
;;;180    
;;;181          out1 = in2 << totShift;
000098  fa05f602          LSL      r6,r5,r2
;;;182    
;;;183          if(in2 != (out1 >> totShift))
00009c  fa46f002          ASR      r0,r6,r2
0000a0  42a8              CMP      r0,r5
0000a2  d001              BEQ      |L1.168|
;;;184            out1 = 0x7FFFFFFF ^ (in2 >> 31);
0000a4  ea8c76e5          EOR      r6,r12,r5,ASR #31
                  |L1.168|
;;;185    
;;;186          *pOut++ = out1;
0000a8  c340              STM      r3!,{r6}
0000aa  1e7f              SUBS     r7,r7,#1
                  |L1.172|
0000ac  2f00              CMP      r7,#0                 ;173
0000ae  d1f0              BNE      |L1.146|
;;;187    
;;;188          /* Decrement the numSamples loop counter */
;;;189          blkCnt--;
;;;190        }
;;;191    
;;;192        /* Set status as ARM_MATH_SUCCESS */
;;;193        status = ARM_MATH_SUCCESS;
0000b0  2000              MOVS     r0,#0
;;;194      }
;;;195    
;;;196      /* Return to application */
;;;197      return (status);
;;;198    }
0000b2  e8bd8ff0          POP      {r4-r11,pc}
;;;199    
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\MatrixFunctions\\arm_mat_scale_q31.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_mat_scale_q31_c_a18e8561____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___19_arm_mat_scale_q31_c_a18e8561____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_mat_scale_q31_c_a18e8561____REVSH|
#line 144
|__asm___19_arm_mat_scale_q31_c_a18e8561____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_mat_scale_q31_c_a18e8561____RRX|
#line 300
|__asm___19_arm_mat_scale_q31_c_a18e8561____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
