; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_biquad_cascade_df1_32x64_q31.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_biquad_cascade_df1_32x64_q31.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_biquad_cascade_df1_32x64_q31.crf src\FilteringFunctions\arm_biquad_cascade_df1_32x64_q31.c]
                          THUMB

                          AREA ||i.arm_biquad_cas_df1_32x64_q31||, CODE, READONLY, ALIGN=2

                  arm_biquad_cas_df1_32x64_q31 PROC
;;;186    
;;;187    void arm_biquad_cas_df1_32x64_q31(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;188      const arm_biquad_cas_df1_32x64_ins_q31 * S,
;;;189      q31_t * pSrc,
;;;190      q31_t * pDst,
;;;191      uint32_t blockSize)
;;;192    {
;;;193      q31_t *pIn = pSrc;                             /*  input pointer initialization  */
000004  4688              MOV      r8,r1
;;;194      q31_t *pOut = pDst;                            /*  output pointer initialization */
;;;195      q63_t *pState = S->pState;                     /*  state pointer initialization  */
;;;196      q31_t *pCoeffs = S->pCoeffs;                   /*  coeff pointer initialization  */
000006  e9d09101          LDRD     r9,r1,[r0,#4]
00000a  b099              SUB      sp,sp,#0x64           ;192
;;;197      q63_t acc;                                     /*  accumulator                   */
;;;198      q31_t Xn1, Xn2;                                /*  Input Filter state variables        */
;;;199      q63_t Yn1, Yn2;                                /*  Output Filter state variables        */
;;;200      q31_t b0, b1, b2, a1, a2;                      /*  Filter coefficients           */
;;;201      q31_t Xn;                                      /*  temporary input               */
;;;202      int32_t shift = (int32_t) S->postShift + 1;    /*  Shift to be applied to the output */
00000c  9114              STR      r1,[sp,#0x50]
00000e  7b01              LDRB     r1,[r0,#0xc]
000010  9d1b              LDR      r5,[sp,#0x6c]         ;195
000012  1c4a              ADDS     r2,r1,#1
;;;203      uint32_t sample, stage = S->numStages;         /*  loop counters                     */
000014  9217              STR      r2,[sp,#0x5c]
000016  7800              LDRB     r0,[r0,#0]
000018  1c49              ADDS     r1,r1,#1
;;;204      q31_t acc_l, acc_h;                            /*  temporary output               */
;;;205      uint32_t uShift = ((uint32_t) S->postShift + 1u);
;;;206      uint32_t lShift = 32u - uShift;                /*  Shift to be applied to the output */
00001a  9015              STR      r0,[sp,#0x54]
00001c  9113              STR      r1,[sp,#0x4c]
00001e  f1c10020          RSB      r0,r1,#0x20
000022  9009              STR      r0,[sp,#0x24]         ;192
;;;207    
;;;208    
;;;209    #ifndef ARM_MATH_CM0_FAMILY
;;;210    
;;;211      /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;212    
;;;213      do
;;;214      {
;;;215        /* Reading the coefficients */
;;;216        b0 = *pCoeffs++;
;;;217        b1 = *pCoeffs++;
;;;218        b2 = *pCoeffs++;
;;;219        a1 = *pCoeffs++;
;;;220        a2 = *pCoeffs++;
;;;221    
;;;222        /* Reading the state values */
;;;223        Xn1 = (q31_t) (pState[0]);
;;;224        Xn2 = (q31_t) (pState[1]);
;;;225        Yn1 = pState[2];
;;;226        Yn2 = pState[3];
;;;227    
;;;228        /* Apply loop unrolling and compute 4 output values simultaneously. */
;;;229        /* The variable acc hold output value that is being computed and    
;;;230         * stored in the destination buffer    
;;;231         * acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2]    
;;;232         */
;;;233    
;;;234        sample = blockSize >> 2u;
000024  981c              LDR      r0,[sp,#0x70]
000026  0880              LSRS     r0,r0,#2
000028  9018              STR      r0,[sp,#0x60]
                  |L1.42|
00002a  9814              LDR      r0,[sp,#0x50]         ;216
00002c  6800              LDR      r0,[r0,#0]            ;216
00002e  9007              STR      r0,[sp,#0x1c]         ;216
000030  9814              LDR      r0,[sp,#0x50]         ;217
000032  6841              LDR      r1,[r0,#4]            ;217
000034  9105              STR      r1,[sp,#0x14]         ;218
000036  6881              LDR      r1,[r0,#8]            ;218
000038  9103              STR      r1,[sp,#0xc]          ;219
00003a  68c1              LDR      r1,[r0,#0xc]          ;219
00003c  910c              STR      r1,[sp,#0x30]         ;220
00003e  6901              LDR      r1,[r0,#0x10]         ;220
000040  3014              ADDS     r0,r0,#0x14           ;220
000042  9104              STR      r1,[sp,#0x10]         ;223
000044  9014              STR      r0,[sp,#0x50]         ;223
000046  f8d94000          LDR      r4,[r9,#0]            ;224
00004a  f8d90008          LDR      r0,[r9,#8]            ;224
00004e  9006              STR      r0,[sp,#0x18]         ;225
000050  e9d9ab06          LDRD     r10,r11,[r9,#0x18]    ;226
000054  e9d96704          LDRD     r6,r7,[r9,#0x10]      ;226
000058  9818              LDR      r0,[sp,#0x60]
;;;235    
;;;236        /* First part of the processing with loop unrolling. Compute 4 outputs at a time.    
;;;237         ** a second loop below computes the remaining 1 to 3 samples. */
;;;238        while(sample > 0u)
00005a  9016              STR      r0,[sp,#0x58]
00005c  e0c9              B        |L1.498|
;;;239        {
;;;240          /* Read the input */
;;;241          Xn = *pIn++;
00005e  bf00              NOP      
                  |L1.96|
000060  f8d80000          LDR      r0,[r8,#0]
000064  f1080104          ADD      r1,r8,#4
;;;242    
;;;243          /* acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2] */
;;;244    
;;;245          /* acc =  b0 * x[n] */
;;;246          acc = (q63_t) Xn *b0;
000068  910d              STR      r1,[sp,#0x34]
00006a  9907              LDR      r1,[sp,#0x1c]
00006c  900a              STR      r0,[sp,#0x28]
00006e  fb803201          SMULL    r3,r2,r0,r1
;;;247    
;;;248          /* acc +=  b1 * x[n-1] */
;;;249          acc += (q63_t) Xn1 *b1;
000072  9805              LDR      r0,[sp,#0x14]
;;;250    
;;;251          /* acc +=  b[2] * x[n-2] */
;;;252          acc += (q63_t) Xn2 *b2;
000074  9903              LDR      r1,[sp,#0xc]
000076  fbc43200          SMLAL    r3,r2,r4,r0           ;249
00007a  9806              LDR      r0,[sp,#0x18]
00007c  fbc03201          SMLAL    r3,r2,r0,r1
;;;253    
;;;254          /* acc +=  a1 * y[n-1] */
;;;255          acc += mult32x64(Yn1, a1);
000080  9201              STR      r2,[sp,#4]
000082  4698              MOV      r8,r3                 ;252
000084  4630              MOV      r0,r6
000086  4639              MOV      r1,r7
000088  9a0c              LDR      r2,[sp,#0x30]
00008a  f7fffffe          BL       mult32x64
00008e  9a01              LDR      r2,[sp,#4]
000090  eb100808          ADDS     r8,r0,r8
000094  414a              ADCS     r2,r2,r1
;;;256    
;;;257          /* acc +=  a2 * y[n-2] */
;;;258          acc += mult32x64(Yn2, a2);
000096  9201              STR      r2,[sp,#4]
000098  4650              MOV      r0,r10
00009a  4659              MOV      r1,r11
00009c  9a04              LDR      r2,[sp,#0x10]
00009e  f7fffffe          BL       mult32x64
0000a2  9a01              LDR      r2,[sp,#4]
0000a4  eb100008          ADDS     r0,r0,r8
0000a8  eb410802          ADC      r8,r1,r2
0000ac  4682              MOV      r10,r0
;;;259    
;;;260          /* The result is converted to 1.63 , Yn2 variable is reused */
;;;261          Yn2 = acc << shift;
0000ae  4641              MOV      r1,r8
0000b0  9a17              LDR      r2,[sp,#0x5c]
0000b2  f7fffffe          BL       __aeabi_llsl
;;;262    
;;;263          /* Calc lower part of acc */
;;;264          acc_l = acc & 0xffffffff;
;;;265    
;;;266          /* Calc upper part of acc */
;;;267          acc_h = (acc >> 32) & 0xffffffff;
;;;268    
;;;269          /* Apply shift for lower part of acc and upper part of acc */
;;;270          acc_h = (uint32_t) acc_l >> lShift | acc_h << uShift;
0000b6  9111              STR      r1,[sp,#0x44]
0000b8  9909              LDR      r1,[sp,#0x24]
0000ba  4683              MOV      r11,r0                ;261
0000bc  fa2af001          LSR      r0,r10,r1
0000c0  9913              LDR      r1,[sp,#0x4c]
0000c2  fa08fc01          LSL      r12,r8,r1
0000c6  ea40000c          ORR      r0,r0,r12
;;;271    
;;;272          /* Store the output in the destination buffer in 1.31 format. */
;;;273          *pOut = acc_h;
;;;274    
;;;275          /* Read the second input into Xn2, to reuse the value */
;;;276          Xn2 = *pIn++;
0000ca  6028              STR      r0,[r5,#0]
0000cc  990d              LDR      r1,[sp,#0x34]
0000ce  c901              LDM      r1!,{r0}
0000d0  468a              MOV      r10,r1
;;;277    
;;;278          /* acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2] */
;;;279    
;;;280          /* acc +=  b1 * x[n-1] */
;;;281          acc = (q63_t) Xn *b1;
0000d2  9006              STR      r0,[sp,#0x18]
0000d4  9905              LDR      r1,[sp,#0x14]
0000d6  980a              LDR      r0,[sp,#0x28]
0000d8  fb808201          SMULL    r8,r2,r0,r1
0000dc  e9dd0106          LDRD     r0,r1,[sp,#0x18]
;;;282    
;;;283          /* acc =  b0 * x[n] */
;;;284          acc += (q63_t) Xn2 *b0;
0000e0  fbc08201          SMLAL    r8,r2,r0,r1
;;;285    
;;;286          /* acc +=  b[2] * x[n-2] */
;;;287          acc += (q63_t) Xn1 *b2;
0000e4  9803              LDR      r0,[sp,#0xc]
;;;288    
;;;289          /* acc +=  a1 * y[n-1] */
;;;290          acc += mult32x64(Yn2, a1);
0000e6  9911              LDR      r1,[sp,#0x44]
0000e8  fbc48200          SMLAL    r8,r2,r4,r0           ;287
0000ec  4614              MOV      r4,r2                 ;287
0000ee  4658              MOV      r0,r11
0000f0  9a0c              LDR      r2,[sp,#0x30]
0000f2  f7fffffe          BL       mult32x64
0000f6  4622              MOV      r2,r4
0000f8  eb100408          ADDS     r4,r0,r8
0000fc  eb410802          ADC      r8,r1,r2
;;;291    
;;;292          /* acc +=  a2 * y[n-2] */
;;;293          acc += mult32x64(Yn1, a2);
000100  4630              MOV      r0,r6
000102  4639              MOV      r1,r7
000104  9a04              LDR      r2,[sp,#0x10]
000106  f7fffffe          BL       mult32x64
00010a  1900              ADDS     r0,r0,r4
00010c  eb410108          ADC      r1,r1,r8
000110  4604              MOV      r4,r0
000112  460e              MOV      r6,r1
;;;294    
;;;295          /* The result is converted to 1.63, Yn1 variable is reused */
;;;296          Yn1 = acc << shift;
000114  9a17              LDR      r2,[sp,#0x5c]
000116  f7fffffe          BL       __aeabi_llsl
00011a  e9cd010e          STRD     r0,r1,[sp,#0x38]
;;;297    
;;;298          /* Calc lower part of acc */
;;;299          acc_l = acc & 0xffffffff;
;;;300    
;;;301          /* Calc upper part of acc */
;;;302          acc_h = (acc >> 32) & 0xffffffff;
;;;303    
;;;304          /* Apply shift for lower part of acc and upper part of acc */
;;;305          acc_h = (uint32_t) acc_l >> lShift | acc_h << uShift;
00011e  9a09              LDR      r2,[sp,#0x24]
;;;306    
;;;307          /* Read the third input into Xn1, to reuse the value */
;;;308          Xn1 = *pIn++;
000120  f10a0804          ADD      r8,r10,#4
000124  fa24f002          LSR      r0,r4,r2              ;305
000128  9a13              LDR      r2,[sp,#0x4c]         ;305
00012a  fa06f102          LSL      r1,r6,r2              ;305
00012e  4308              ORRS     r0,r0,r1              ;305
000130  f8da1000          LDR      r1,[r10,#0]
;;;309    
;;;310          /* The result is converted to 1.31 */
;;;311          /* Store the output in the destination buffer. */
;;;312          *(pOut + 1u) = acc_h;
000134  9102              STR      r1,[sp,#8]
;;;313    
;;;314          /* acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2] */
;;;315    
;;;316          /* acc =  b0 * x[n] */
;;;317          acc = (q63_t) Xn1 *b0;
000136  6068              STR      r0,[r5,#4]
000138  9902              LDR      r1,[sp,#8]
00013a  9807              LDR      r0,[sp,#0x1c]
00013c  fb814600          SMULL    r4,r6,r1,r0
000140  e9dd0105          LDRD     r0,r1,[sp,#0x14]
;;;318    
;;;319          /* acc +=  b1 * x[n-1] */
;;;320          acc += (q63_t) Xn2 *b1;
000144  fbc14600          SMLAL    r4,r6,r1,r0
;;;321    
;;;322          /* acc +=  b[2] * x[n-2] */
;;;323          acc += (q63_t) Xn *b2;
000148  9903              LDR      r1,[sp,#0xc]
00014a  980a              LDR      r0,[sp,#0x28]
;;;324    
;;;325          /* acc +=  a1 * y[n-1] */
;;;326          acc += mult32x64(Yn1, a1);
00014c  9a0c              LDR      r2,[sp,#0x30]
00014e  fbc04601          SMLAL    r4,r6,r0,r1           ;323
000152  e9dd010e          LDRD     r0,r1,[sp,#0x38]
000156  f7fffffe          BL       mult32x64
00015a  1904              ADDS     r4,r0,r4
00015c  eb410706          ADC      r7,r1,r6
;;;327    
;;;328          /* acc +=  a2 * y[n-2] */
;;;329          acc += mult32x64(Yn2, a2);
000160  4658              MOV      r0,r11
000162  9a04              LDR      r2,[sp,#0x10]
000164  9911              LDR      r1,[sp,#0x44]
000166  f7fffffe          BL       mult32x64
00016a  1900              ADDS     r0,r0,r4
00016c  4179              ADCS     r1,r1,r7
00016e  4604              MOV      r4,r0
000170  460e              MOV      r6,r1
;;;330    
;;;331          /* The result is converted to 1.63, Yn2 variable is reused  */
;;;332          Yn2 = acc << shift;
000172  9a17              LDR      r2,[sp,#0x5c]
000174  f7fffffe          BL       __aeabi_llsl
;;;333    
;;;334          /* Calc lower part of acc */
;;;335          acc_l = acc & 0xffffffff;
;;;336    
;;;337          /* Calc upper part of acc */
;;;338          acc_h = (acc >> 32) & 0xffffffff;
;;;339    
;;;340          /* Apply shift for lower part of acc and upper part of acc */
;;;341          acc_h = (uint32_t) acc_l >> lShift | acc_h << uShift;
000178  9a09              LDR      r2,[sp,#0x24]
00017a  4682              MOV      r10,r0                ;332
00017c  fa24f002          LSR      r0,r4,r2
000180  9a13              LDR      r2,[sp,#0x4c]
000182  468b              MOV      r11,r1                ;332
000184  fa06f102          LSL      r1,r6,r2
000188  4308              ORRS     r0,r0,r1
;;;342    
;;;343          /* Store the output in the destination buffer in 1.31 format. */
;;;344          *(pOut + 2u) = acc_h;
;;;345    
;;;346          /* Read the fourth input into Xn, to reuse the value */
;;;347          Xn = *pIn++;
00018a  60a8              STR      r0,[r5,#8]
00018c  f8584b04          LDR      r4,[r8],#4
;;;348    
;;;349          /* acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2] */
;;;350          /* acc =  b0 * x[n] */
;;;351          acc = (q63_t) Xn *b0;
000190  9807              LDR      r0,[sp,#0x1c]
000192  940a              STR      r4,[sp,#0x28]
000194  fb844600          SMULL    r4,r6,r4,r0
;;;352    
;;;353          /* acc +=  b1 * x[n-1] */
;;;354          acc += (q63_t) Xn1 *b1;
000198  9902              LDR      r1,[sp,#8]
00019a  9805              LDR      r0,[sp,#0x14]
;;;355    
;;;356          /* acc +=  b[2] * x[n-2] */
;;;357          acc += (q63_t) Xn2 *b2;
;;;358    
;;;359          /* acc +=  a1 * y[n-1] */
;;;360          acc += mult32x64(Yn2, a1);
00019c  9a0c              LDR      r2,[sp,#0x30]
00019e  fbc14600          SMLAL    r4,r6,r1,r0           ;354
0001a2  9903              LDR      r1,[sp,#0xc]          ;357
0001a4  9806              LDR      r0,[sp,#0x18]         ;357
0001a6  fbc04601          SMLAL    r4,r6,r0,r1           ;357
0001aa  4650              MOV      r0,r10
0001ac  4659              MOV      r1,r11
0001ae  f7fffffe          BL       mult32x64
0001b2  1904              ADDS     r4,r0,r4
0001b4  eb410706          ADC      r7,r1,r6
;;;361    
;;;362          /* acc +=  a2 * y[n-2] */
;;;363          acc += mult32x64(Yn1, a2);
0001b8  e9dd010e          LDRD     r0,r1,[sp,#0x38]
0001bc  9a04              LDR      r2,[sp,#0x10]
0001be  f7fffffe          BL       mult32x64
0001c2  1900              ADDS     r0,r0,r4
0001c4  4179              ADCS     r1,r1,r7
0001c6  4604              MOV      r4,r0
;;;364    
;;;365          /* The result is converted to 1.63, Yn1 variable is reused  */
;;;366          Yn1 = acc << shift;
0001c8  9101              STR      r1,[sp,#4]
0001ca  9a17              LDR      r2,[sp,#0x5c]
0001cc  f7fffffe          BL       __aeabi_llsl
;;;367    
;;;368          /* Calc lower part of acc */
;;;369          acc_l = acc & 0xffffffff;
;;;370    
;;;371          /* Calc upper part of acc */
;;;372          acc_h = (acc >> 32) & 0xffffffff;
;;;373    
;;;374          /* Apply shift for lower part of acc and upper part of acc */
;;;375          acc_h = (uint32_t) acc_l >> lShift | acc_h << uShift;
0001d0  9a09              LDR      r2,[sp,#0x24]
0001d2  4606              MOV      r6,r0                 ;366
0001d4  460f              MOV      r7,r1                 ;366
0001d6  fa24f002          LSR      r0,r4,r2
0001da  9a13              LDR      r2,[sp,#0x4c]
0001dc  9901              LDR      r1,[sp,#4]
0001de  4091              LSLS     r1,r1,r2
0001e0  4308              ORRS     r0,r0,r1
;;;376    
;;;377          /* Store the output in the destination buffer in 1.31 format. */
;;;378          *(pOut + 3u) = acc_h;
;;;379    
;;;380          /* Every time after the output is computed state should be updated. */
;;;381          /* The states should be updated as:  */
;;;382          /* Xn2 = Xn1    */
;;;383          /* Xn1 = Xn     */
;;;384          /* Yn2 = Yn1    */
;;;385          /* Yn1 = acc    */
;;;386          Xn2 = Xn1;
0001e2  60e8              STR      r0,[r5,#0xc]
;;;387          Xn1 = Xn;
;;;388    
;;;389          /* update output pointer */
;;;390          pOut += 4u;
;;;391    
;;;392          /* decrement the loop counter */
;;;393          sample--;
0001e4  9816              LDR      r0,[sp,#0x58]
0001e6  9902              LDR      r1,[sp,#8]            ;386
0001e8  1e40              SUBS     r0,r0,#1
0001ea  9c0a              LDR      r4,[sp,#0x28]
0001ec  9106              STR      r1,[sp,#0x18]         ;387
0001ee  3510              ADDS     r5,r5,#0x10
0001f0  9016              STR      r0,[sp,#0x58]
                  |L1.498|
0001f2  2800              CMP      r0,#0                 ;238
0001f4  f47faf34          BNE      |L1.96|
;;;394        }
;;;395    
;;;396        /* If the blockSize is not a multiple of 4, compute any remaining output samples here.    
;;;397         ** No loop unrolling is used. */
;;;398        sample = (blockSize & 0x3u);
0001f8  981c              LDR      r0,[sp,#0x70]
0001fa  f0000003          AND      r0,r0,#3
;;;399    
;;;400        while(sample > 0u)
0001fe  e039              B        |L1.628|
                  |L1.512|
;;;401        {
;;;402          /* Read the input */
;;;403          Xn = *pIn++;
000200  f8580b04          LDR      r0,[r8],#4
;;;404    
;;;405          /* acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2] */
;;;406    
;;;407          /* acc =  b0 * x[n] */
;;;408          acc = (q63_t) Xn *b0;
000204  9907              LDR      r1,[sp,#0x1c]
000206  900a              STR      r0,[sp,#0x28]
000208  fb803201          SMULL    r3,r2,r0,r1
;;;409          /* acc +=  b1 * x[n-1] */
;;;410          acc += (q63_t) Xn1 *b1;
00020c  9805              LDR      r0,[sp,#0x14]
;;;411          /* acc +=  b[2] * x[n-2] */
;;;412          acc += (q63_t) Xn2 *b2;
00020e  9903              LDR      r1,[sp,#0xc]
000210  fbc43200          SMLAL    r3,r2,r4,r0           ;410
000214  9806              LDR      r0,[sp,#0x18]
000216  fbc03201          SMLAL    r3,r2,r0,r1
00021a  e9cd3200          STRD     r3,r2,[sp,#0]
;;;413          /* acc +=  a1 * y[n-1] */
;;;414          acc += mult32x64(Yn1, a1);
00021e  4630              MOV      r0,r6
000220  4639              MOV      r1,r7
000222  9a0c              LDR      r2,[sp,#0x30]
000224  f7fffffe          BL       mult32x64
000228  e9dd3200          LDRD     r3,r2,[sp,#0]
00022c  18c3              ADDS     r3,r0,r3
00022e  eb410c02          ADC      r12,r1,r2
000232  e9cd3c00          STRD     r3,r12,[sp,#0]
;;;415          /* acc +=  a2 * y[n-2] */
;;;416          acc += mult32x64(Yn2, a2);
000236  4650              MOV      r0,r10
000238  4659              MOV      r1,r11
00023a  9a04              LDR      r2,[sp,#0x10]
00023c  f7fffffe          BL       mult32x64
000240  e9dd3c00          LDRD     r3,r12,[sp,#0]
000244  18c0              ADDS     r0,r0,r3
000246  eb41010c          ADC      r1,r1,r12
;;;417    
;;;418          /* Every time after the output is computed state should be updated. */
;;;419          /* The states should be updated as:  */
;;;420          /* Xn2 = Xn1    */
;;;421          /* Xn1 = Xn     */
;;;422          /* Yn2 = Yn1    */
;;;423          /* Yn1 = acc    */
;;;424          Xn2 = Xn1;
00024a  9406              STR      r4,[sp,#0x18]
00024c  e9cd0100          STRD     r0,r1,[sp,#0]
;;;425          Xn1 = Xn;
;;;426          Yn2 = Yn1;
000250  46b2              MOV      r10,r6
000252  46bb              MOV      r11,r7
;;;427          /* The result is converted to 1.63, Yn1 variable is reused  */
;;;428          Yn1 = acc << shift;
000254  9c0a              LDR      r4,[sp,#0x28]
000256  9a17              LDR      r2,[sp,#0x5c]
000258  f7fffffe          BL       __aeabi_llsl
00025c  4606              MOV      r6,r0
00025e  460f              MOV      r7,r1
;;;429    
;;;430          /* Calc lower part of acc */
;;;431          acc_l = acc & 0xffffffff;
;;;432    
;;;433          /* Calc upper part of acc */
;;;434          acc_h = (acc >> 32) & 0xffffffff;
;;;435    
;;;436          /* Apply shift for lower part of acc and upper part of acc */
;;;437          acc_h = (uint32_t) acc_l >> lShift | acc_h << uShift;
000260  e9dd0100          LDRD     r0,r1,[sp,#0]
000264  9a09              LDR      r2,[sp,#0x24]
000266  40d0              LSRS     r0,r0,r2
000268  9a13              LDR      r2,[sp,#0x4c]
00026a  4091              LSLS     r1,r1,r2
00026c  4308              ORRS     r0,r0,r1
;;;438    
;;;439          /* Store the output in the destination buffer in 1.31 format. */
;;;440          *pOut++ = acc_h;
00026e  c501              STM      r5!,{r0}
;;;441          /* Yn1 = acc << shift; */
;;;442    
;;;443          /* Store the output in the destination buffer in 1.31 format. */
;;;444    /*      *pOut++ = (q31_t) (acc >> (32 - shift));  */
;;;445    
;;;446          /* decrement the loop counter */
;;;447          sample--;
000270  9816              LDR      r0,[sp,#0x58]
000272  1e40              SUBS     r0,r0,#1
                  |L1.628|
000274  9016              STR      r0,[sp,#0x58]         ;398
000276  2800              CMP      r0,#0                 ;398
000278  d1c2              BNE      |L1.512|
;;;448        }
;;;449    
;;;450        /*  The first stage output is given as input to the second stage. */
;;;451        pIn = pDst;
00027a  9d1b              LDR      r5,[sp,#0x6c]
;;;452    
;;;453        /* Reset to destination buffer working pointer */
;;;454        pOut = pDst;
;;;455    
;;;456        /*  Store the updated state variables back into the pState array */
;;;457        /*  Store the updated state variables back into the pState array */
;;;458        *pState++ = (q63_t) Xn1;
00027c  17e0              ASRS     r0,r4,#31
00027e  e9c94000          STRD     r4,r0,[r9,#0]
;;;459        *pState++ = (q63_t) Xn2;
000282  9906              LDR      r1,[sp,#0x18]
000284  f1090008          ADD      r0,r9,#8              ;458
000288  17ca              ASRS     r2,r1,#31
00028a  e8e01202          STRD     r1,r2,[r0],#8
00028e  46a8              MOV      r8,r5                 ;451
000290  e8e06702          STRD     r6,r7,[r0],#8
000294  e8e0ab02          STRD     r10,r11,[r0],#8
;;;460        *pState++ = Yn1;
;;;461        *pState++ = Yn2;
000298  4681              MOV      r9,r0
;;;462    
;;;463      } while(--stage);
00029a  9815              LDR      r0,[sp,#0x54]
00029c  1e40              SUBS     r0,r0,#1
00029e  9015              STR      r0,[sp,#0x54]
0002a0  f47faec3          BNE      |L1.42|
;;;464    
;;;465    #else
;;;466    
;;;467      /* Run the below code for Cortex-M0 */
;;;468    
;;;469      do
;;;470      {
;;;471        /* Reading the coefficients */
;;;472        b0 = *pCoeffs++;
;;;473        b1 = *pCoeffs++;
;;;474        b2 = *pCoeffs++;
;;;475        a1 = *pCoeffs++;
;;;476        a2 = *pCoeffs++;
;;;477    
;;;478        /* Reading the state values */
;;;479        Xn1 = pState[0];
;;;480        Xn2 = pState[1];
;;;481        Yn1 = pState[2];
;;;482        Yn2 = pState[3];
;;;483    
;;;484        /* The variable acc hold output value that is being computed and        
;;;485         * stored in the destination buffer            
;;;486         * acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2]            
;;;487         */
;;;488    
;;;489        sample = blockSize;
;;;490    
;;;491        while(sample > 0u)
;;;492        {
;;;493          /* Read the input */
;;;494          Xn = *pIn++;
;;;495    
;;;496          /* acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2] */
;;;497          /* acc =  b0 * x[n] */
;;;498          acc = (q63_t) Xn *b0;
;;;499          /* acc +=  b1 * x[n-1] */
;;;500          acc += (q63_t) Xn1 *b1;
;;;501          /* acc +=  b[2] * x[n-2] */
;;;502          acc += (q63_t) Xn2 *b2;
;;;503          /* acc +=  a1 * y[n-1] */
;;;504          acc += mult32x64(Yn1, a1);
;;;505          /* acc +=  a2 * y[n-2] */
;;;506          acc += mult32x64(Yn2, a2);
;;;507    
;;;508          /* Every time after the output is computed state should be updated. */
;;;509          /* The states should be updated as:  */
;;;510          /* Xn2 = Xn1    */
;;;511          /* Xn1 = Xn     */
;;;512          /* Yn2 = Yn1    */
;;;513          /* Yn1 = acc    */
;;;514          Xn2 = Xn1;
;;;515          Xn1 = Xn;
;;;516          Yn2 = Yn1;
;;;517    
;;;518          /* The result is converted to 1.63, Yn1 variable is reused  */
;;;519          Yn1 = acc << shift;
;;;520    
;;;521          /* Calc lower part of acc */
;;;522          acc_l = acc & 0xffffffff;
;;;523    
;;;524          /* Calc upper part of acc */
;;;525          acc_h = (acc >> 32) & 0xffffffff;
;;;526    
;;;527          /* Apply shift for lower part of acc and upper part of acc */
;;;528          acc_h = (uint32_t) acc_l >> lShift | acc_h << uShift;
;;;529    
;;;530          /* Store the output in the destination buffer in 1.31 format. */
;;;531          *pOut++ = acc_h;
;;;532    
;;;533          /* Yn1 = acc << shift; */
;;;534    
;;;535          /* Store the output in the destination buffer in 1.31 format. */
;;;536          /* *pOut++ = (q31_t) (acc >> (32 - shift)); */
;;;537    
;;;538          /* decrement the loop counter */
;;;539          sample--;
;;;540        }
;;;541    
;;;542        /*  The first stage output is given as input to the second stage. */
;;;543        pIn = pDst;
;;;544    
;;;545        /* Reset to destination buffer working pointer */
;;;546        pOut = pDst;
;;;547    
;;;548        /*  Store the updated state variables back into the pState array */
;;;549        *pState++ = (q63_t) Xn1;
;;;550        *pState++ = (q63_t) Xn2;
;;;551        *pState++ = Yn1;
;;;552        *pState++ = Yn2;
;;;553    
;;;554      } while(--stage);
;;;555    
;;;556    #endif /*    #ifndef ARM_MATH_CM0_FAMILY     */
;;;557    }
0002a4  b01d              ADD      sp,sp,#0x74
0002a6  e8bd8ff0          POP      {r4-r11,pc}
;;;558    
                          ENDP


                          AREA ||i.mult32x64||, CODE, READONLY, ALIGN=1

                  mult32x64 PROC
;;;499    
;;;500      static __INLINE q63_t mult32x64(
000000  b5f0              PUSH     {r4-r7,lr}
;;;501      q63_t x,
;;;502      q31_t y)
;;;503      {
;;;504        return ((((q63_t) (x & 0x00000000FFFFFFFF) * y) >> 32) +
000002  fba06502          UMULL    r6,r5,r0,r2
000006  2400              MOVS     r4,#0
000008  fba16702          UMULL    r6,r7,r1,r2
00000c  fb045402          MLA      r4,r4,r2,r5
000010  17d3              ASRS     r3,r2,#31
000012  17cd              ASRS     r5,r1,#31
000014  fb004003          MLA      r0,r0,r3,r4
000018  fb057202          MLA      r2,r5,r2,r7
00001c  17c4              ASRS     r4,r0,#31
00001e  fb012103          MLA      r1,r1,r3,r2
000022  1980              ADDS     r0,r0,r6
000024  4161              ADCS     r1,r1,r4
;;;505                (((q63_t) (x >> 32) * y)));
;;;506      }
000026  bdf0              POP      {r4-r7,pc}
;;;507    
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\FilteringFunctions\\arm_biquad_cascade_df1_32x64_q31.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___34_arm_biquad_cascade_df1_32x64_q31_c_68808ed6____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___34_arm_biquad_cascade_df1_32x64_q31_c_68808ed6____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___34_arm_biquad_cascade_df1_32x64_q31_c_68808ed6____REVSH|
#line 144
|__asm___34_arm_biquad_cascade_df1_32x64_q31_c_68808ed6____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___34_arm_biquad_cascade_df1_32x64_q31_c_68808ed6____RRX|
#line 300
|__asm___34_arm_biquad_cascade_df1_32x64_q31_c_68808ed6____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
