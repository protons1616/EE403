; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_fir_q7.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_fir_q7.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_fir_q7.crf src\FilteringFunctions\arm_fir_q7.c]
                          THUMB

                          AREA ||i.arm_fir_q7||, CODE, READONLY, ALIGN=2

                  arm_fir_q7 PROC
;;;68     
;;;69     void arm_fir_q7(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;70       const arm_fir_instance_q7 * S,
;;;71       q7_t * pSrc,
;;;72       q7_t * pDst,
;;;73       uint32_t blockSize)
;;;74     {
000004  b093              SUB      sp,sp,#0x4c
;;;75     
;;;76     #ifndef ARM_MATH_CM0_FAMILY
;;;77     
;;;78       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;79     
;;;80       q7_t *pState = S->pState;                      /* State pointer */
000006  9813              LDR      r0,[sp,#0x4c]
;;;81       q7_t *pCoeffs = S->pCoeffs;                    /* Coefficient pointer */
000008  9913              LDR      r1,[sp,#0x4c]
00000a  6840              LDR      r0,[r0,#4]            ;80
00000c  6889              LDR      r1,[r1,#8]
;;;82       q7_t *pStateCurnt;                             /* Points to the current sample of the state */
;;;83       q7_t x0, x1, x2, x3;                           /* Temporary variables to hold state */
;;;84       q7_t c0;                                       /* Temporary variable to hold coefficient value */
;;;85       q7_t *px;                                      /* Temporary pointer for state */
;;;86       q7_t *pb;                                      /* Temporary pointer for coefficient buffer */
;;;87       q31_t acc0, acc1, acc2, acc3;                  /* Accumulators */
;;;88       uint32_t numTaps = S->numTaps;                 /* Number of filter coefficients in the filter */
00000e  910e              STR      r1,[sp,#0x38]
000010  9913              LDR      r1,[sp,#0x4c]
000012  8809              LDRH     r1,[r1,#0]
000014  910c              STR      r1,[sp,#0x30]
000016  1e49              SUBS     r1,r1,#1
;;;89       uint32_t i, tapCnt, blkCnt;                    /* Loop counters */
;;;90     
;;;91       /* S->pState points to state array which contains previous frame (numTaps - 1) samples */
;;;92       /* pStateCurnt points to the location where the new input data should be written */
;;;93       pStateCurnt = &(S->pState[(numTaps - 1u)]);
000018  eb000b01          ADD      r11,r0,r1
;;;94     
;;;95       /* Apply loop unrolling and compute 4 output values simultaneously.    
;;;96        * The variables acc0 ... acc3 hold output values that are being computed:    
;;;97        *    
;;;98        *    acc0 =  b[numTaps-1] * x[n-numTaps-1] + b[numTaps-2] * x[n-numTaps-2] + b[numTaps-3] * x[n-numTaps-3] +...+ b[0] * x[0]    
;;;99        *    acc1 =  b[numTaps-1] * x[n-numTaps] +   b[numTaps-2] * x[n-numTaps-1] + b[numTaps-3] * x[n-numTaps-2] +...+ b[0] * x[1]    
;;;100       *    acc2 =  b[numTaps-1] * x[n-numTaps+1] + b[numTaps-2] * x[n-numTaps] +   b[numTaps-3] * x[n-numTaps-1] +...+ b[0] * x[2]    
;;;101       *    acc3 =  b[numTaps-1] * x[n-numTaps+2] + b[numTaps-2] * x[n-numTaps+1] + b[numTaps-3] * x[n-numTaps]   +...+ b[0] * x[3]    
;;;102       */
;;;103      blkCnt = blockSize >> 2;
00001c  9112              STR      r1,[sp,#0x48]
00001e  9916              LDR      r1,[sp,#0x58]
000020  0889              LSRS     r1,r1,#2
000022  9111              STR      r1,[sp,#0x44]         ;74
000024  e0a4              B        |L1.368|
                  |L1.38|
;;;104    
;;;105      /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.    
;;;106       ** a second loop below computes the remaining 1 to 3 samples. */
;;;107      while(blkCnt > 0u)
;;;108      {
;;;109        /* Copy four new input samples into the state buffer */
;;;110        *pStateCurnt++ = *pSrc++;
000026  9914              LDR      r1,[sp,#0x50]
;;;111        *pStateCurnt++ = *pSrc++;
;;;112        *pStateCurnt++ = *pSrc++;
;;;113        *pStateCurnt++ = *pSrc++;
;;;114    
;;;115        /* Set all accumulators to zero */
;;;116        acc0 = 0;
000028  2600              MOVS     r6,#0
;;;117        acc1 = 0;
00002a  46b1              MOV      r9,r6
00002c  780a              LDRB     r2,[r1,#0]            ;110
00002e  f88b2000          STRB     r2,[r11,#0]           ;110
000032  9914              LDR      r1,[sp,#0x50]         ;111
000034  f10b0201          ADD      r2,r11,#1             ;110
;;;118        acc2 = 0;
000038  46b2              MOV      r10,r6
00003a  784b              LDRB     r3,[r1,#1]            ;111
00003c  f8023b01          STRB     r3,[r2],#1            ;111
000040  788b              LDRB     r3,[r1,#2]            ;112
000042  f8023b01          STRB     r3,[r2],#1            ;112
000046  78cb              LDRB     r3,[r1,#3]            ;113
000048  f8023b01          STRB     r3,[r2],#1            ;113
00004c  1d09              ADDS     r1,r1,#4              ;113
00004e  4693              MOV      r11,r2                ;113
;;;119        acc3 = 0;
;;;120    
;;;121        /* Initialize state pointer */
;;;122        px = pState;
;;;123    
;;;124        /* Initialize coefficient pointer */
;;;125        pb = pCoeffs;
;;;126    
;;;127        /* Read the first three samples from the state buffer:    
;;;128         *  x[n-numTaps], x[n-numTaps-1], x[n-numTaps-2] */
;;;129        x0 = *(px++);
000050  1c42              ADDS     r2,r0,#1
000052  9114              STR      r1,[sp,#0x50]         ;125
;;;130        x1 = *(px++);
000054  f9124b01          LDRSB    r4,[r2],#1
;;;131        x2 = *(px++);
;;;132    
;;;133        /* Loop unrolling.  Process 4 taps at a time. */
;;;134        tapCnt = numTaps >> 2;
000058  f8ddc030          LDR      r12,[sp,#0x30]
00005c  f9905000          LDRSB    r5,[r0,#0]            ;129
000060  f9121b01          LDRSB    r1,[r2],#1            ;131
000064  ea4f0c9c          LSR      r12,r12,#2
000068  4637              MOV      r7,r6                 ;119
00006a  9b0e              LDR      r3,[sp,#0x38]         ;130
;;;135        i = tapCnt;
;;;136    
;;;137        while(i > 0u)
00006c  f8cdc040          STR      r12,[sp,#0x40]
000070  e04a              B        |L1.264|
;;;138        {
;;;139          /* Read the b[numTaps] coefficient */
;;;140          c0 = *pb;
000072  bf00              NOP      
                  |L1.116|
000074  f913cb01          LDRSB    r12,[r3],#1
;;;141    
;;;142          /* Read x[n-numTaps-3] sample */
;;;143          x3 = *px;
000078  f9128b01          LDRSB    r8,[r2],#1
;;;144          
;;;145          /* acc0 +=  b[numTaps] * x[n-numTaps] */
;;;146          acc0 += ((q15_t) x0 * c0);
00007c  fb15660c          SMLABB   r6,r5,r12,r6
;;;147    
;;;148          /* acc1 +=  b[numTaps] * x[n-numTaps-1] */
;;;149          acc1 += ((q15_t) x1 * c0);
000080  fb14990c          SMLABB   r9,r4,r12,r9
;;;150    
;;;151          /* acc2 +=  b[numTaps] * x[n-numTaps-2] */
;;;152          acc2 += ((q15_t) x2 * c0);
000084  f8cd900c          STR      r9,[sp,#0xc]
000088  fb11a90c          SMLABB   r9,r1,r12,r10
;;;153    
;;;154          /* acc3 +=  b[numTaps] * x[n-numTaps-3] */
;;;155          acc3 += ((q15_t) x3 * c0);
00008c  fb187a0c          SMLABB   r10,r8,r12,r7
;;;156    
;;;157          /* Read the b[numTaps-1] coefficient */
;;;158          c0 = *(pb + 1u);
000090  f8cd9010          STR      r9,[sp,#0x10]
000094  f9137b01          LDRSB    r7,[r3],#1
;;;159    
;;;160          /* Read x[n-numTaps-4] sample */
;;;161          x0 = *(px + 1u);
000098  f9125b01          LDRSB    r5,[r2],#1
;;;162    
;;;163          /* Perform the multiply-accumulates */
;;;164          acc0 += ((q15_t) x1 * c0);
00009c  fb146607          SMLABB   r6,r4,r7,r6
;;;165          acc1 += ((q15_t) x2 * c0);
0000a0  f8dd900c          LDR      r9,[sp,#0xc]
0000a4  fb119c07          SMLABB   r12,r1,r7,r9
;;;166          acc2 += ((q15_t) x3 * c0);
0000a8  f8dd9010          LDR      r9,[sp,#0x10]
0000ac  f8cdc00c          STR      r12,[sp,#0xc]
0000b0  fb189c07          SMLABB   r12,r8,r7,r9
;;;167          acc3 += ((q15_t) x0 * c0);
0000b4  fb15a907          SMLABB   r9,r5,r7,r10
;;;168    
;;;169          /* Read the b[numTaps-2] coefficient */
;;;170          c0 = *(pb + 2u);
0000b8  f8cdc010          STR      r12,[sp,#0x10]
0000bc  f9137b02          LDRSB    r7,[r3],#2
;;;171    
;;;172          /* Read x[n-numTaps-5] sample */
;;;173          x1 = *(px + 2u);
0000c0  f9124b02          LDRSB    r4,[r2],#2
;;;174    
;;;175          /* Perform the multiply-accumulates */
;;;176          acc0 += ((q15_t) x2 * c0);
0000c4  fb116607          SMLABB   r6,r1,r7,r6
;;;177          acc1 += ((q15_t) x3 * c0);
0000c8  f8ddc00c          LDR      r12,[sp,#0xc]
0000cc  fb18ca07          SMLABB   r10,r8,r7,r12
;;;178          acc2 += ((q15_t) x0 * c0);
0000d0  f8ddc010          LDR      r12,[sp,#0x10]
0000d4  fb15cc07          SMLABB   r12,r5,r7,r12
;;;179          acc3 += ((q15_t) x1 * c0);
0000d8  f8cdc010          STR      r12,[sp,#0x10]
0000dc  fb149c07          SMLABB   r12,r4,r7,r9
;;;180    
;;;181          /* Read the b[numTaps-3] coefficients */
;;;182          c0 = *(pb + 3u);
0000e0  f8cdc008          STR      r12,[sp,#8]
0000e4  f9137c01          LDRSB    r7,[r3,#-1]
;;;183    
;;;184          /* Read x[n-numTaps-6] sample */
;;;185          x2 = *(px + 3u);
0000e8  f9121c01          LDRSB    r1,[r2,#-1]
;;;186          
;;;187          /* Perform the multiply-accumulates */
;;;188          acc0 += ((q15_t) x3 * c0);
0000ec  fb186607          SMLABB   r6,r8,r7,r6
;;;189          acc1 += ((q15_t) x0 * c0);
0000f0  fb15a907          SMLABB   r9,r5,r7,r10
;;;190          acc2 += ((q15_t) x1 * c0);
0000f4  f8ddc010          LDR      r12,[sp,#0x10]
0000f8  fb14ca07          SMLABB   r10,r4,r7,r12
;;;191          acc3 += ((q15_t) x2 * c0);
0000fc  f8ddc008          LDR      r12,[sp,#8]
000100  fb11c707          SMLABB   r7,r1,r7,r12
;;;192    
;;;193          /* update coefficient pointer */
;;;194          pb += 4u;
;;;195          px += 4u;
;;;196          
;;;197          /* Decrement the loop counter */
;;;198          i--;
000104  f1ae0c01          SUB      r12,lr,#1
                  |L1.264|
000108  ea5f0e0c          MOVS     lr,r12                ;135
00010c  d1b2              BNE      |L1.116|
;;;199        }
;;;200    
;;;201        /* If the filter length is not a multiple of 4, compute the remaining filter taps */
;;;202    
;;;203        i = numTaps - (tapCnt * 4u);
00010e  f8ddc040          LDR      r12,[sp,#0x40]
000112  f1cc0800          RSB      r8,r12,#0
000116  f8ddc030          LDR      r12,[sp,#0x30]
00011a  eb0c0c88          ADD      r12,r12,r8,LSL #2
;;;204        while(i > 0u)
00011e  e010              B        |L1.322|
                  |L1.288|
;;;205        {
;;;206          /* Read coefficients */
;;;207          c0 = *(pb++);
000120  f913cb01          LDRSB    r12,[r3],#1
;;;208    
;;;209          /* Fetch 1 state variable */
;;;210          x3 = *(px++);
000124  f9128b01          LDRSB    r8,[r2],#1
;;;211    
;;;212          /* Perform the multiply-accumulates */
;;;213          acc0 += ((q15_t) x0 * c0);
000128  fb05660c          MLA      r6,r5,r12,r6
;;;214          acc1 += ((q15_t) x1 * c0);
00012c  fb04990c          MLA      r9,r4,r12,r9
;;;215          acc2 += ((q15_t) x2 * c0);
000130  fb11aa0c          SMLABB   r10,r1,r12,r10
;;;216          acc3 += ((q15_t) x3 * c0);
000134  fb18770c          SMLABB   r7,r8,r12,r7
;;;217    
;;;218          /* Reuse the present sample states for next sample */
;;;219          x0 = x1;
000138  4625              MOV      r5,r4
;;;220          x1 = x2;
00013a  460c              MOV      r4,r1
;;;221          x2 = x3;
00013c  4641              MOV      r1,r8
;;;222    
;;;223          /* Decrement the loop counter */
;;;224          i--;
00013e  f1ae0c01          SUB      r12,lr,#1
                  |L1.322|
000142  ea5f0e0c          MOVS     lr,r12                ;203
000146  d1eb              BNE      |L1.288|
;;;225        }
;;;226    
;;;227        /* Advance the state pointer by 4 to process the next group of 4 samples */
;;;228        pState = pState + 4;
;;;229    
;;;230        /* The results in the 4 accumulators are in 2.62 format.  Convert to 1.31    
;;;231         ** Then store the 4 outputs in the destination buffer. */
;;;232        acc0 = __SSAT((acc0 >> 7u), 8);
;;;233        *pDst++ = acc0;
000148  9a15              LDR      r2,[sp,#0x54]
00014a  f32611c7          SSAT     r1,#8,r6,ASR #7       ;232
00014e  7011              STRB     r1,[r2,#0]
;;;234        acc1 = __SSAT((acc1 >> 7u), 8);
;;;235        *pDst++ = acc1;
000150  9915              LDR      r1,[sp,#0x54]
000152  f32912c7          SSAT     r2,#8,r9,ASR #7       ;234
000156  704a              STRB     r2,[r1,#1]
;;;236        acc2 = __SSAT((acc2 >> 7u), 8);
000158  f32a12c7          SSAT     r2,#8,r10,ASR #7
;;;237        *pDst++ = acc2;
00015c  708a              STRB     r2,[r1,#2]
;;;238        acc3 = __SSAT((acc3 >> 7u), 8);
00015e  f32712c7          SSAT     r2,#8,r7,ASR #7
;;;239        *pDst++ = acc3;
000162  70ca              STRB     r2,[r1,#3]
000164  1d09              ADDS     r1,r1,#4
;;;240    
;;;241        /* Decrement the samples loop counter */
;;;242        blkCnt--;
000166  9115              STR      r1,[sp,#0x54]
000168  9911              LDR      r1,[sp,#0x44]
00016a  1e49              SUBS     r1,r1,#1
00016c  1d00              ADDS     r0,r0,#4
00016e  9111              STR      r1,[sp,#0x44]
                  |L1.368|
000170  2900              CMP      r1,#0                 ;107
000172  f47faf58          BNE      |L1.38|
;;;243      }
;;;244    
;;;245    
;;;246      /* If the blockSize is not a multiple of 4, compute any remaining output samples here.    
;;;247       ** No loop unrolling is used. */
;;;248      blkCnt = blockSize % 4u;
000176  9916              LDR      r1,[sp,#0x58]
000178  f0010503          AND      r5,r1,#3
;;;249    
;;;250      while(blkCnt > 0u)
00017c  e01b              B        |L1.438|
                  |L1.382|
;;;251      {
;;;252        /* Copy one sample at a time into state buffer */
;;;253        *pStateCurnt++ = *pSrc++;
00017e  9914              LDR      r1,[sp,#0x50]
000180  780a              LDRB     r2,[r1,#0]
000182  f80b2b01          STRB     r2,[r11],#1
000186  9914              LDR      r1,[sp,#0x50]
;;;254    
;;;255        /* Set the accumulator to zero */
;;;256        acc0 = 0;
;;;257    
;;;258        /* Initialize state pointer */
;;;259        px = pState;
;;;260    
;;;261        /* Initialize Coefficient pointer */
;;;262        pb = (pCoeffs);
;;;263    
;;;264        i = numTaps;
000188  9b0c              LDR      r3,[sp,#0x30]
00018a  1c49              ADDS     r1,r1,#1              ;253
00018c  9114              STR      r1,[sp,#0x50]         ;259
00018e  9a0e              LDR      r2,[sp,#0x38]
000190  2400              MOVS     r4,#0                 ;256
000192  4601              MOV      r1,r0                 ;259
                  |L1.404|
;;;265    
;;;266        /* Perform the multiply-accumulates */
;;;267        do
;;;268        {
;;;269          acc0 += (q15_t) * (px++) * (*(pb++));
000194  f9127b01          LDRSB    r7,[r2],#1
000198  f9116b01          LDRSB    r6,[r1],#1
00019c  fb164407          SMLABB   r4,r6,r7,r4
0001a0  1e5b              SUBS     r3,r3,#1
;;;270          i--;
;;;271        } while(i > 0u);
0001a2  d1f7              BNE      |L1.404|
;;;272    
;;;273        /* The result is in 2.14 format.  Convert to 1.7    
;;;274         ** Then store the output in the destination buffer. */
;;;275        *pDst++ = __SSAT((acc0 >> 7u), 8);
0001a4  9915              LDR      r1,[sp,#0x54]
0001a6  f32412c7          SSAT     r2,#8,r4,ASR #7
0001aa  1c40              ADDS     r0,r0,#1
0001ac  700a              STRB     r2,[r1,#0]
0001ae  9915              LDR      r1,[sp,#0x54]
0001b0  1c49              ADDS     r1,r1,#1
0001b2  1e6d              SUBS     r5,r5,#1
0001b4  9115              STR      r1,[sp,#0x54]
                  |L1.438|
0001b6  2d00              CMP      r5,#0                 ;250
0001b8  d1e1              BNE      |L1.382|
;;;276    
;;;277        /* Advance state pointer by 1 for the next sample */
;;;278        pState = pState + 1;
;;;279    
;;;280        /* Decrement the samples loop counter */
;;;281        blkCnt--;
;;;282      }
;;;283    
;;;284      /* Processing is complete.    
;;;285       ** Now copy the last numTaps - 1 samples to the satrt of the state buffer.    
;;;286       ** This prepares the state buffer for the next function call. */
;;;287    
;;;288      /* Points to the start of the state buffer */
;;;289      pStateCurnt = S->pState;
0001ba  9913              LDR      r1,[sp,#0x4c]
;;;290    
;;;291      tapCnt = (numTaps - 1u) >> 2u;
0001bc  9a12              LDR      r2,[sp,#0x48]
0001be  6849              LDR      r1,[r1,#4]            ;289
0001c0  0892              LSRS     r2,r2,#2
;;;292    
;;;293      /* copy data */
;;;294      while(tapCnt > 0u)
0001c2  e010              B        |L1.486|
                  |L1.452|
;;;295      {
;;;296        *pStateCurnt++ = *pState++;
0001c4  f8103b01          LDRB     r3,[r0],#1
0001c8  f8013b01          STRB     r3,[r1],#1
;;;297        *pStateCurnt++ = *pState++;
0001cc  f8103b01          LDRB     r3,[r0],#1
0001d0  f8013b01          STRB     r3,[r1],#1
;;;298        *pStateCurnt++ = *pState++;
0001d4  f8103b02          LDRB     r3,[r0],#2
0001d8  f8013b02          STRB     r3,[r1],#2
;;;299        *pStateCurnt++ = *pState++;
0001dc  f8103c01          LDRB     r3,[r0,#-1]
0001e0  f8013c01          STRB     r3,[r1,#-1]
0001e4  1e52              SUBS     r2,r2,#1
                  |L1.486|
0001e6  2a00              CMP      r2,#0                 ;294
0001e8  d1ec              BNE      |L1.452|
;;;300    
;;;301        /* Decrement the loop counter */
;;;302        tapCnt--;
;;;303      }
;;;304    
;;;305      /* Calculate remaining number of copies */
;;;306      tapCnt = (numTaps - 1u) % 0x4u;
0001ea  9a12              LDR      r2,[sp,#0x48]
0001ec  f0020203          AND      r2,r2,#3
;;;307    
;;;308      /* Copy the remaining q31_t data */
;;;309      while(tapCnt > 0u)
0001f0  e005              B        |L1.510|
;;;310      {
;;;311        *pStateCurnt++ = *pState++;
0001f2  bf00              NOP      
                  |L1.500|
0001f4  f8103b01          LDRB     r3,[r0],#1
0001f8  f8013b01          STRB     r3,[r1],#1
0001fc  1e52              SUBS     r2,r2,#1
                  |L1.510|
0001fe  2a00              CMP      r2,#0                 ;309
000200  d1f8              BNE      |L1.500|
;;;312    
;;;313        /* Decrement the loop counter */
;;;314        tapCnt--;
;;;315      }
;;;316    
;;;317    #else
;;;318    
;;;319    /* Run the below code for Cortex-M0 */
;;;320    
;;;321      uint32_t numTaps = S->numTaps;                 /* Number of taps in the filter */
;;;322      uint32_t i, blkCnt;                            /* Loop counters */
;;;323      q7_t *pState = S->pState;                      /* State pointer */
;;;324      q7_t *pCoeffs = S->pCoeffs;                    /* Coefficient pointer */
;;;325      q7_t *px, *pb;                                 /* Temporary pointers to state and coeff */
;;;326      q31_t acc = 0;                                 /* Accumlator */
;;;327      q7_t *pStateCurnt;                             /* Points to the current sample of the state */
;;;328    
;;;329    
;;;330      /* S->pState points to state array which contains previous frame (numTaps - 1) samples */
;;;331      /* pStateCurnt points to the location where the new input data should be written */
;;;332      pStateCurnt = S->pState + (numTaps - 1u);
;;;333    
;;;334      /* Initialize blkCnt with blockSize */
;;;335      blkCnt = blockSize;
;;;336    
;;;337      /* Perform filtering upto BlockSize - BlockSize%4  */
;;;338      while(blkCnt > 0u)
;;;339      {
;;;340        /* Copy one sample at a time into state buffer */
;;;341        *pStateCurnt++ = *pSrc++;
;;;342    
;;;343        /* Set accumulator to zero */
;;;344        acc = 0;
;;;345    
;;;346        /* Initialize state pointer of type q7 */
;;;347        px = pState;
;;;348    
;;;349        /* Initialize coeff pointer of type q7 */
;;;350        pb = pCoeffs;
;;;351    
;;;352    
;;;353        i = numTaps;
;;;354    
;;;355        while(i > 0u)
;;;356        {
;;;357          /* acc =  b[numTaps-1] * x[n-numTaps-1] + b[numTaps-2] * x[n-numTaps-2] + b[numTaps-3] * x[n-numTaps-3] +...+ b[0] * x[0] */
;;;358          acc += (q15_t) * px++ * *pb++;
;;;359          i--;
;;;360        }
;;;361    
;;;362        /* Store the 1.7 format filter output in destination buffer */
;;;363        *pDst++ = (q7_t) __SSAT((acc >> 7), 8);
;;;364    
;;;365        /* Advance the state pointer by 1 to process the next sample */
;;;366        pState = pState + 1;
;;;367    
;;;368        /* Decrement the loop counter */
;;;369        blkCnt--;
;;;370      }
;;;371    
;;;372      /* Processing is complete.         
;;;373       ** Now copy the last numTaps - 1 samples to the satrt of the state buffer.       
;;;374       ** This prepares the state buffer for the next function call. */
;;;375    
;;;376    
;;;377      /* Points to the start of the state buffer */
;;;378      pStateCurnt = S->pState;
;;;379    
;;;380    
;;;381      /* Copy numTaps number of values */
;;;382      i = (numTaps - 1u);
;;;383    
;;;384      /* Copy q7_t data */
;;;385      while(i > 0u)
;;;386      {
;;;387        *pStateCurnt++ = *pState++;
;;;388        i--;
;;;389      }
;;;390    
;;;391    #endif /*   #ifndef ARM_MATH_CM0_FAMILY */
;;;392    
;;;393    }
000202  b017              ADD      sp,sp,#0x5c
000204  e8bd8ff0          POP      {r4-r11,pc}
;;;394    
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\FilteringFunctions\\arm_fir_q7.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_arm_fir_q7_c_ff49d506____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___12_arm_fir_q7_c_ff49d506____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_arm_fir_q7_c_ff49d506____REVSH|
#line 144
|__asm___12_arm_fir_q7_c_ff49d506____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___12_arm_fir_q7_c_ff49d506____RRX|
#line 300
|__asm___12_arm_fir_q7_c_ff49d506____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
