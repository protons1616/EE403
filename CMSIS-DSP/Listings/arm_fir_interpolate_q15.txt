; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_fir_interpolate_q15.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_fir_interpolate_q15.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_fir_interpolate_q15.crf src\FilteringFunctions\arm_fir_interpolate_q15.c]
                          THUMB

                          AREA ||i.arm_fir_interpolate_q15||, CODE, READONLY, ALIGN=2

                  arm_fir_interpolate_q15 PROC
;;;73     
;;;74     void arm_fir_interpolate_q15(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;75       const arm_fir_interpolate_instance_q15 * S,
;;;76       q15_t * pSrc,
;;;77       q15_t * pDst,
;;;78       uint32_t blockSize)
;;;79     {
000004  4682              MOV      r10,r0
000006  b095              SUB      sp,sp,#0x54
000008  e9da0401          LDRD     r0,r4,[r10,#4]
;;;80       q15_t *pState = S->pState;                     /* State pointer                                            */
;;;81       q15_t *pCoeffs = S->pCoeffs;                   /* Coefficient pointer                                      */
;;;82       q15_t *pStateCurnt;                            /* Points to the current sample of the state                */
;;;83       q15_t *ptr1, *ptr2;                            /* Temporary pointers for state and coefficient buffers     */
;;;84       q63_t sum0;                                    /* Accumulators                                             */
;;;85       q15_t x0, c0;                                  /* Temporary variables to hold state and coefficient values */
;;;86       uint32_t i, blkCnt, j, tapCnt;                 /* Loop counters                                            */
;;;87       uint16_t phaseLen = S->phaseLength;            /* Length of each polyphase filter component */
00000c  9012              STR      r0,[sp,#0x48]
00000e  f8bae002          LDRH     lr,[r10,#2]
;;;88       uint32_t blkCntN2;
;;;89       q63_t acc0, acc1;
;;;90       q15_t x1;
;;;91     
;;;92       /* S->pState buffer contains previous frame (phaseLen - 1) samples */
;;;93       /* pStateCurnt points to the location where the new input data should be written */
;;;94       pStateCurnt = S->pState + ((q31_t) phaseLen - 1);
000012  f06f0101          MVN      r1,#1
000016  eb01004e          ADD      r0,r1,lr,LSL #1
00001a  4420              ADD      r0,r0,r4
;;;95     
;;;96       /* Initialise  blkCnt */
;;;97       blkCnt = blockSize / 2;
00001c  900a              STR      r0,[sp,#0x28]
00001e  0858              LSRS     r0,r3,#1
;;;98       blkCntN2 = blockSize - (2 * blkCnt);
000020  900d              STR      r0,[sp,#0x34]
000022  4240              RSBS     r0,r0,#0
000024  eb030040          ADD      r0,r3,r0,LSL #1
;;;99     
;;;100      /* Samples loop unrolled by 2 */
;;;101      while(blkCnt > 0u)
000028  9014              STR      r0,[sp,#0x50]
00002a  980d              LDR      r0,[sp,#0x34]         ;79
00002c  e096              B        |L1.348|
                  |L1.46|
;;;102      {
;;;103        /* Copy new input sample into the state buffer */
;;;104        *pStateCurnt++ = *pSrc++;
00002e  9816              LDR      r0,[sp,#0x58]
000030  8801              LDRH     r1,[r0,#0]
000032  980a              LDR      r0,[sp,#0x28]
000034  8001              STRH     r1,[r0,#0]
;;;105        *pStateCurnt++ = *pSrc++;
000036  9816              LDR      r0,[sp,#0x58]
000038  990a              LDR      r1,[sp,#0x28]
00003a  8842              LDRH     r2,[r0,#2]
00003c  804a              STRH     r2,[r1,#2]
00003e  1d00              ADDS     r0,r0,#4
000040  1d09              ADDS     r1,r1,#4
;;;106    
;;;107        /* Address modifier index of coefficient buffer */
;;;108        j = 1u;
000042  9016              STR      r0,[sp,#0x58]
000044  2001              MOVS     r0,#1
000046  910a              STR      r1,[sp,#0x28]
;;;109    
;;;110        /* Loop over the Interpolation factor. */
;;;111        i = (S->L);
000048  9013              STR      r0,[sp,#0x4c]
00004a  f89a0000          LDRB     r0,[r10,#0]
;;;112    
;;;113        while(i > 0u)
00004e  e078              B        |L1.322|
                  |L1.80|
;;;114        {
;;;115          /* Set accumulator to zero */
;;;116          acc0 = 0;
;;;117          acc1 = 0;
;;;118    
;;;119          /* Initialize state pointer */
;;;120          ptr1 = pState;
;;;121    
;;;122          /* Initialize coefficient pointer */
;;;123          ptr2 = pCoeffs + (S->L - j);
000050  f89ac000          LDRB     r12,[r10,#0]
000054  9d13              LDR      r5,[sp,#0x4c]
000056  2000              MOVS     r0,#0                 ;113
000058  ebac0605          SUB      r6,r12,r5
00005c  9d12              LDR      r5,[sp,#0x48]
00005e  4601              MOV      r1,r0                 ;113
000060  eb050746          ADD      r7,r5,r6,LSL #1
000064  4602              MOV      r2,r0                 ;113
000066  4603              MOV      r3,r0                 ;113
;;;124    
;;;125          /* Loop over the polyPhase length. Unroll by a factor of 4.        
;;;126           ** Repeat until we've computed numTaps-(4*S->L) coefficients. */
;;;127          tapCnt = phaseLen >> 2u;
000068  ea4f0b9e          LSR      r11,lr,#2
;;;128    
;;;129          x0 = *(ptr1++);
00006c  f9b46000          LDRSH    r6,[r4,#0]
000070  1ca5              ADDS     r5,r4,#2
;;;130    
;;;131          while(tapCnt > 0u)
000072  e037              B        |L1.228|
                  |L1.116|
;;;132          {
;;;133    
;;;134            /* Read the input sample */
;;;135            x1 = *(ptr1++);
000074  f9b59000          LDRSH    r9,[r5,#0]
000078  f1050802          ADD      r8,r5,#2
;;;136    
;;;137            /* Read the coefficient */
;;;138            c0 = *(ptr2);
00007c  f8cd801c          STR      r8,[sp,#0x1c]
000080  f9b75000          LDRSH    r5,[r7,#0]
;;;139    
;;;140            /* Perform the multiply-accumulate */
;;;141            acc0 += (q63_t) x0 *c0;
000084  fbc60185          SMLALBB  r0,r1,r6,r5
;;;142            acc1 += (q63_t) x1 *c0;
000088  fbc92385          SMLALBB  r2,r3,r9,r5
;;;143    
;;;144    
;;;145            /* Read the coefficient */
;;;146            c0 = *(ptr2 + S->L);
00008c  f937501c          LDRSH    r5,[r7,r12,LSL #1]
;;;147    
;;;148            /* Read the input sample */
;;;149            x0 = *(ptr1++);
000090  f9386b02          LDRSH    r6,[r8],#2
;;;150    
;;;151            /* Perform the multiply-accumulate */
;;;152            acc0 += (q63_t) x1 *c0;
000094  fbc90185          SMLALBB  r0,r1,r9,r5
;;;153            acc1 += (q63_t) x0 *c0;
000098  fbc62385          SMLALBB  r2,r3,r6,r5
;;;154    
;;;155    
;;;156            /* Read the coefficient */
;;;157            c0 = *(ptr2 + S->L * 2);
00009c  f8cd801c          STR      r8,[sp,#0x1c]
0000a0  f937502c          LDRSH    r5,[r7,r12,LSL #2]
;;;158    
;;;159            /* Read the input sample */
;;;160            x1 = *(ptr1++);
0000a4  f9389b02          LDRSH    r9,[r8],#2
;;;161    
;;;162            /* Perform the multiply-accumulate */
;;;163            acc0 += (q63_t) x0 *c0;
0000a8  fbc60185          SMLALBB  r0,r1,r6,r5
;;;164            acc1 += (q63_t) x1 *c0;
0000ac  fbc92385          SMLALBB  r2,r3,r9,r5
;;;165    
;;;166            /* Read the coefficient */
;;;167            c0 = *(ptr2 + S->L * 3);
0000b0  9010              STR      r0,[sp,#0x40]
0000b2  eb0c004c          ADD      r0,r12,r12,LSL #1
0000b6  f8cd801c          STR      r8,[sp,#0x1c]
0000ba  f9378010          LDRSH    r8,[r7,r0,LSL #1]
;;;168    
;;;169            /* Read the input sample */
;;;170            x0 = *(ptr1++);
0000be  f8cd8038          STR      r8,[sp,#0x38]
0000c2  f8dd801c          LDR      r8,[sp,#0x1c]
;;;171    
;;;172            /* Perform the multiply-accumulate */
;;;173            acc0 += (q63_t) x1 *c0;
0000c6  9810              LDR      r0,[sp,#0x40]
0000c8  f1080502          ADD      r5,r8,#2              ;170
0000cc  f9b86000          LDRSH    r6,[r8,#0]            ;170
0000d0  f8dd8038          LDR      r8,[sp,#0x38]
0000d4  fbc90188          SMLALBB  r0,r1,r9,r8
;;;174            acc1 += (q63_t) x0 *c0;
0000d8  fbc62388          SMLALBB  r2,r3,r6,r8
;;;175    
;;;176    
;;;177            /* Upsampling is done by stuffing L-1 zeros between each sample.        
;;;178             * So instead of multiplying zeros with coefficients,        
;;;179             * Increment the coefficient pointer by interpolation factor times. */
;;;180            ptr2 += 4 * S->L;
0000dc  eb0707cc          ADD      r7,r7,r12,LSL #3
;;;181    
;;;182            /* Decrement the loop counter */
;;;183            tapCnt--;
0000e0  f1ab0b01          SUB      r11,r11,#1
                  |L1.228|
0000e4  f1bb0f00          CMP      r11,#0                ;131
0000e8  d1c4              BNE      |L1.116|
;;;184          }
;;;185    
;;;186          /* If the polyPhase length is not a multiple of 4, compute the remaining filter taps */
;;;187          tapCnt = phaseLen % 0x4u;
0000ea  f00e0803          AND      r8,lr,#3
;;;188    
;;;189          while(tapCnt > 0u)
0000ee  e00c              B        |L1.266|
                  |L1.240|
;;;190          {
;;;191    
;;;192            /* Read the input sample */
;;;193            x1 = *(ptr1++);
0000f0  f9359b02          LDRSH    r9,[r5],#2
;;;194    
;;;195            /* Read the coefficient */
;;;196            c0 = *(ptr2);
0000f4  f9b78000          LDRSH    r8,[r7,#0]
;;;197    
;;;198            /* Perform the multiply-accumulate */
;;;199            acc0 += (q63_t) x0 *c0;
0000f8  fbc60188          SMLALBB  r0,r1,r6,r8
;;;200            acc1 += (q63_t) x1 *c0;
0000fc  fbc92388          SMLALBB  r2,r3,r9,r8
;;;201    
;;;202            /* Increment the coefficient pointer by interpolation factor times. */
;;;203            ptr2 += S->L;
000100  eb07074c          ADD      r7,r7,r12,LSL #1
;;;204    
;;;205            /* update states for next sample processing */
;;;206            x0 = x1;
000104  464e              MOV      r6,r9
;;;207    
;;;208            /* Decrement the loop counter */
;;;209            tapCnt--;
000106  f1ab0801          SUB      r8,r11,#1
                  |L1.266|
00010a  ea5f0b08          MOVS     r11,r8                ;187
00010e  d1ef              BNE      |L1.240|
;;;210          }
;;;211    
;;;212          /* The result is in the accumulator, store in the destination buffer. */
;;;213          *pDst = (q15_t) (__SSAT((acc0 >> 15), 16));
000110  0bc0              LSRS     r0,r0,#15
000112  ea404041          ORR      r0,r0,r1,LSL #17
000116  f300010f          SSAT     r1,#16,r0
00011a  9817              LDR      r0,[sp,#0x5c]
00011c  8001              STRH     r1,[r0,#0]
;;;214          *(pDst + S->L) = (q15_t) (__SSAT((acc1 >> 15), 16));
00011e  0bd0              LSRS     r0,r2,#15
000120  ea404043          ORR      r0,r0,r3,LSL #17
000124  f300010f          SSAT     r1,#16,r0
000128  f89a2000          LDRB     r2,[r10,#0]
00012c  9817              LDR      r0,[sp,#0x5c]
00012e  f8201012          STRH     r1,[r0,r2,LSL #1]
;;;215    
;;;216          pDst++;
000132  9817              LDR      r0,[sp,#0x5c]
000134  1c80              ADDS     r0,r0,#2
;;;217    
;;;218          /* Increment the address modifier index of coefficient buffer */
;;;219          j++;
000136  9017              STR      r0,[sp,#0x5c]
000138  9813              LDR      r0,[sp,#0x4c]
00013a  1c40              ADDS     r0,r0,#1
;;;220    
;;;221          /* Decrement the loop counter */
;;;222          i--;
00013c  9013              STR      r0,[sp,#0x4c]
00013e  980c              LDR      r0,[sp,#0x30]
000140  1e40              SUBS     r0,r0,#1
                  |L1.322|
000142  900c              STR      r0,[sp,#0x30]         ;111
000144  2800              CMP      r0,#0                 ;111
000146  d183              BNE      |L1.80|
;;;223        }
;;;224    
;;;225        /* Advance the state pointer by 1        
;;;226         * to process the next group of interpolation factor number samples */
;;;227        pState = pState + 2;
;;;228    
;;;229        pDst += S->L;
000148  f89a1000          LDRB     r1,[r10,#0]
00014c  9817              LDR      r0,[sp,#0x5c]
00014e  eb000041          ADD      r0,r0,r1,LSL #1
;;;230    
;;;231        /* Decrement the loop counter */
;;;232        blkCnt--;
000152  9017              STR      r0,[sp,#0x5c]
000154  980d              LDR      r0,[sp,#0x34]
000156  1e40              SUBS     r0,r0,#1
000158  1d24              ADDS     r4,r4,#4
00015a  900d              STR      r0,[sp,#0x34]
                  |L1.348|
00015c  2800              CMP      r0,#0                 ;101
00015e  f47faf66          BNE      |L1.46|
;;;233      }
;;;234    
;;;235      /* If the blockSize is not a multiple of 2, compute any remaining output samples here.        
;;;236       ** No loop unrolling is used. */
;;;237      blkCnt = blkCntN2;
;;;238    
;;;239      /* Loop over the blockSize. */
;;;240      while(blkCnt > 0u)
000162  f8ddb050          LDR      r11,[sp,#0x50]
000166  e061              B        |L1.556|
                  |L1.360|
;;;241      {
;;;242        /* Copy new input sample into the state buffer */
;;;243        *pStateCurnt++ = *pSrc++;
000168  9816              LDR      r0,[sp,#0x58]
00016a  8801              LDRH     r1,[r0,#0]
00016c  980a              LDR      r0,[sp,#0x28]
00016e  8001              STRH     r1,[r0,#0]
000170  9816              LDR      r0,[sp,#0x58]
000172  1c80              ADDS     r0,r0,#2
000174  9016              STR      r0,[sp,#0x58]
000176  980a              LDR      r0,[sp,#0x28]
000178  1c80              ADDS     r0,r0,#2
;;;244    
;;;245        /* Address modifier index of coefficient buffer */
;;;246        j = 1u;
00017a  900a              STR      r0,[sp,#0x28]
00017c  2001              MOVS     r0,#1
;;;247    
;;;248        /* Loop over the Interpolation factor. */
;;;249        i = S->L;
00017e  9013              STR      r0,[sp,#0x4c]
000180  f89a0000          LDRB     r0,[r10,#0]
;;;250        while(i > 0u)
000184  e04c              B        |L1.544|
                  |L1.390|
;;;251        {
;;;252          /* Set accumulator to zero */
;;;253          sum0 = 0;
;;;254    
;;;255          /* Initialize state pointer */
;;;256          ptr1 = pState;
;;;257    
;;;258          /* Initialize coefficient pointer */
;;;259          ptr2 = pCoeffs + (S->L - j);
000186  f89a3000          LDRB     r3,[r10,#0]
00018a  9d13              LDR      r5,[sp,#0x4c]
00018c  2100              MOVS     r1,#0                 ;250
00018e  1b5e              SUBS     r6,r3,r5
000190  9d12              LDR      r5,[sp,#0x48]
000192  4608              MOV      r0,r1                 ;250
000194  eb050646          ADD      r6,r5,r6,LSL #1
000198  4622              MOV      r2,r4                 ;256
;;;260    
;;;261          /* Loop over the polyPhase length. Unroll by a factor of 4.        
;;;262           ** Repeat until we've computed numTaps-(4*S->L) coefficients. */
;;;263          tapCnt = phaseLen >> 2;
00019a  ea4f059e          LSR      r5,lr,#2
;;;264          while(tapCnt > 0u)
00019e  e020              B        |L1.482|
                  |L1.416|
;;;265          {
;;;266    
;;;267            /* Read the coefficient */
;;;268            c0 = *(ptr2);
0001a0  f9b6c000          LDRSH    r12,[r6,#0]
;;;269    
;;;270            /* Upsampling is done by stuffing L-1 zeros between each sample.        
;;;271             * So instead of multiplying zeros with coefficients,        
;;;272             * Increment the coefficient pointer by interpolation factor times. */
;;;273            ptr2 += S->L;
0001a4  eb060743          ADD      r7,r6,r3,LSL #1
;;;274    
;;;275            /* Read the input sample */
;;;276            x0 = *(ptr1++);
0001a8  f9326b02          LDRSH    r6,[r2],#2
;;;277    
;;;278            /* Perform the multiply-accumulate */
;;;279            sum0 += (q63_t) x0 *c0;
0001ac  fbc6108c          SMLALBB  r1,r0,r6,r12
;;;280    
;;;281            /* Read the coefficient */
;;;282            c0 = *(ptr2);
0001b0  f9b76000          LDRSH    r6,[r7,#0]
;;;283    
;;;284            /* Increment the coefficient pointer by interpolation factor times. */
;;;285            ptr2 += S->L;
0001b4  eb070c43          ADD      r12,r7,r3,LSL #1
;;;286    
;;;287            /* Read the input sample */
;;;288            x0 = *(ptr1++);
0001b8  f9327b02          LDRSH    r7,[r2],#2
;;;289    
;;;290            /* Perform the multiply-accumulate */
;;;291            sum0 += (q63_t) x0 *c0;
0001bc  fbc71086          SMLALBB  r1,r0,r7,r6
;;;292    
;;;293            /* Read the coefficient */
;;;294            c0 = *(ptr2);
0001c0  f9bc6000          LDRSH    r6,[r12,#0]
;;;295    
;;;296            /* Increment the coefficient pointer by interpolation factor times. */
;;;297            ptr2 += S->L;
;;;298    
;;;299            /* Read the input sample */
;;;300            x0 = *(ptr1++);
0001c4  f9327b04          LDRSH    r7,[r2],#4
0001c8  eb0c0c43          ADD      r12,r12,r3,LSL #1     ;297
;;;301    
;;;302            /* Perform the multiply-accumulate */
;;;303            sum0 += (q63_t) x0 *c0;
0001cc  fbc71086          SMLALBB  r1,r0,r7,r6
;;;304    
;;;305            /* Read the coefficient */
;;;306            c0 = *(ptr2);
0001d0  f9bc8000          LDRSH    r8,[r12,#0]
;;;307    
;;;308            /* Increment the coefficient pointer by interpolation factor times. */
;;;309            ptr2 += S->L;
;;;310    
;;;311            /* Read the input sample */
;;;312            x0 = *(ptr1++);
0001d4  f9327c02          LDRSH    r7,[r2,#-2]
0001d8  eb0c0643          ADD      r6,r12,r3,LSL #1      ;309
;;;313    
;;;314            /* Perform the multiply-accumulate */
;;;315            sum0 += (q63_t) x0 *c0;
0001dc  fbc71088          SMLALBB  r1,r0,r7,r8
0001e0  1e6d              SUBS     r5,r5,#1
                  |L1.482|
0001e2  2d00              CMP      r5,#0                 ;264
0001e4  d1dc              BNE      |L1.416|
;;;316    
;;;317            /* Decrement the loop counter */
;;;318            tapCnt--;
;;;319          }
;;;320    
;;;321          /* If the polyPhase length is not a multiple of 4, compute the remaining filter taps */
;;;322          tapCnt = phaseLen & 0x3u;
0001e6  f00e0503          AND      r5,lr,#3
;;;323    
;;;324          while(tapCnt > 0u)
0001ea  e008              B        |L1.510|
                  |L1.492|
;;;325          {
;;;326            /* Read the coefficient */
;;;327            c0 = *(ptr2);
0001ec  f9b6c000          LDRSH    r12,[r6,#0]
;;;328    
;;;329            /* Increment the coefficient pointer by interpolation factor times. */
;;;330            ptr2 += S->L;
;;;331    
;;;332            /* Read the input sample */
;;;333            x0 = *(ptr1++);
0001f0  f9327b02          LDRSH    r7,[r2],#2
0001f4  eb060643          ADD      r6,r6,r3,LSL #1       ;330
;;;334    
;;;335            /* Perform the multiply-accumulate */
;;;336            sum0 += (q63_t) x0 *c0;
0001f8  fbc7108c          SMLALBB  r1,r0,r7,r12
0001fc  1e6d              SUBS     r5,r5,#1
                  |L1.510|
0001fe  2d00              CMP      r5,#0                 ;324
000200  d1f4              BNE      |L1.492|
;;;337    
;;;338            /* Decrement the loop counter */
;;;339            tapCnt--;
;;;340          }
;;;341    
;;;342          /* The result is in the accumulator, store in the destination buffer. */
;;;343          *pDst++ = (q15_t) (__SSAT((sum0 >> 15), 16));
000202  0442              LSLS     r2,r0,#17
000204  ea4230d1          ORR      r0,r2,r1,LSR #15
000208  f300010f          SSAT     r1,#16,r0
00020c  9817              LDR      r0,[sp,#0x5c]
00020e  8001              STRH     r1,[r0,#0]
000210  9817              LDR      r0,[sp,#0x5c]
000212  1c80              ADDS     r0,r0,#2
;;;344    
;;;345          j++;
000214  9017              STR      r0,[sp,#0x5c]
000216  9813              LDR      r0,[sp,#0x4c]
000218  1c40              ADDS     r0,r0,#1
;;;346    
;;;347          /* Decrement the loop counter */
;;;348          i--;
00021a  9013              STR      r0,[sp,#0x4c]
00021c  f1a90001          SUB      r0,r9,#1
                  |L1.544|
000220  ea5f0900          MOVS     r9,r0                 ;249
000224  d1af              BNE      |L1.390|
;;;349        }
;;;350    
;;;351        /* Advance the state pointer by 1        
;;;352         * to process the next group of interpolation factor number samples */
;;;353        pState = pState + 1;
;;;354    
;;;355        /* Decrement the loop counter */
;;;356        blkCnt--;
000226  f1ab0b01          SUB      r11,r11,#1
00022a  1ca4              ADDS     r4,r4,#2
                  |L1.556|
00022c  f1bb0f00          CMP      r11,#0                ;240
000230  d19a              BNE      |L1.360|
;;;357      }
;;;358    
;;;359    
;;;360      /* Processing is complete.    
;;;361       ** Now copy the last phaseLen - 1 samples to the satrt of the state buffer.    
;;;362       ** This prepares the state buffer for the next function call. */
;;;363    
;;;364      /* Points to the start of the state buffer */
;;;365      pStateCurnt = S->pState;
;;;366    
;;;367      i = ((uint32_t) phaseLen - 1u) >> 2u;
000232  f1ae0201          SUB      r2,lr,#1
000236  0891              LSRS     r1,r2,#2
;;;368    
;;;369      /* copy data */
;;;370      while(i > 0u)
000238  f8da0008          LDR      r0,[r10,#8]
00023c  e009              B        |L1.594|
;;;371      {
;;;372    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;373    
;;;374        *__SIMD32(pStateCurnt)++ = *__SIMD32(pState)++;
00023e  bf00              NOP      
                  |L1.576|
000240  f8543b04          LDR      r3,[r4],#4
000244  f8403b04          STR      r3,[r0],#4
;;;375        *__SIMD32(pStateCurnt)++ = *__SIMD32(pState)++;
000248  f8543b04          LDR      r3,[r4],#4
00024c  f8403b04          STR      r3,[r0],#4
000250  1e49              SUBS     r1,r1,#1
                  |L1.594|
000252  2900              CMP      r1,#0                 ;370
000254  d1f4              BNE      |L1.576|
;;;376    
;;;377    #else
;;;378    
;;;379        *pStateCurnt++ = *pState++;
;;;380    	*pStateCurnt++ = *pState++;
;;;381    	*pStateCurnt++ = *pState++;
;;;382    	*pStateCurnt++ = *pState++;
;;;383    	
;;;384    #endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE	*/
;;;385    	
;;;386    	/* Decrement the loop counter */
;;;387        i--;
;;;388      }
;;;389    
;;;390      i = ((uint32_t) phaseLen - 1u) % 0x04u;
000256  f0020103          AND      r1,r2,#3
;;;391    
;;;392      while(i > 0u)
00025a  e004              B        |L1.614|
                  |L1.604|
;;;393      {
;;;394        *pStateCurnt++ = *pState++;
00025c  f8342b02          LDRH     r2,[r4],#2
000260  f8202b02          STRH     r2,[r0],#2
000264  1e49              SUBS     r1,r1,#1
                  |L1.614|
000266  2900              CMP      r1,#0                 ;392
000268  d1f8              BNE      |L1.604|
;;;395    
;;;396        /* Decrement the loop counter */
;;;397        i--;
;;;398      }
;;;399    }
00026a  b019              ADD      sp,sp,#0x64
00026c  e8bd8ff0          POP      {r4-r11,pc}
;;;400    
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\FilteringFunctions\\arm_fir_interpolate_q15.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___25_arm_fir_interpolate_q15_c_014cfa50____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___25_arm_fir_interpolate_q15_c_014cfa50____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___25_arm_fir_interpolate_q15_c_014cfa50____REVSH|
#line 144
|__asm___25_arm_fir_interpolate_q15_c_014cfa50____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___25_arm_fir_interpolate_q15_c_014cfa50____RRX|
#line 300
|__asm___25_arm_fir_interpolate_q15_c_014cfa50____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
