; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_conv_opt_q15.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_conv_opt_q15.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_conv_opt_q15.crf src\FilteringFunctions\arm_conv_opt_q15.c]
                          THUMB

                          AREA ||i.arm_conv_opt_q15||, CODE, READONLY, ALIGN=2

                  arm_conv_opt_q15 PROC
;;;84     
;;;85     void arm_conv_opt_q15(
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;86       q15_t * pSrcA,
;;;87       uint32_t srcALen,
;;;88       q15_t * pSrcB,
;;;89       uint32_t srcBLen,
;;;90       q15_t * pDst,
;;;91       q15_t * pScratch1,
;;;92       q15_t * pScratch2)
;;;93     {
000004  b08b              SUB      sp,sp,#0x2c
000006  460e              MOV      r6,r1
000008  461d              MOV      r5,r3
;;;94       q63_t acc0, acc1, acc2, acc3;                  /* Accumulator */
;;;95       q31_t x1, x2, x3;                              /* Temporary variables to hold state and coefficient values */
;;;96       q31_t y1, y2;                                  /* State variables */
;;;97       q15_t *pOut = pDst;                            /* output pointer */
00000a  9c16              LDR      r4,[sp,#0x58]
00000c  9914              LDR      r1,[sp,#0x50]
;;;98       q15_t *pScr1 = pScratch1;                      /* Temporary pointer for scratch1 */
;;;99       q15_t *pScr2 = pScratch2;                      /* Temporary pointer for scratch1 */
;;;100      q15_t *pIn1;                                   /* inputA pointer */
;;;101      q15_t *pIn2;                                   /* inputB pointer */
;;;102      q15_t *px;                                     /* Intermediate inputA pointer  */
;;;103      q15_t *py;                                     /* Intermediate inputB pointer  */
;;;104      uint32_t j, k, blkCnt;                         /* loop counter */
;;;105      uint32_t tapCnt;                               /* loop count */
;;;106    #ifdef UNALIGNED_SUPPORT_DISABLE
;;;107    
;;;108      q15_t a, b;
;;;109    
;;;110    #endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE	*/
;;;111    
;;;112      /* The algorithm implementation is based on the lengths of the inputs. */
;;;113      /* srcB is always made to slide across srcA. */
;;;114      /* So srcBLen is always considered as shorter or equal to srcALen */
;;;115      if(srcALen >= srcBLen)
00000e  9104              STR      r1,[sp,#0x10]
000010  42ae              CMP      r6,r5
000012  d302              BCC      |L1.26|
;;;116      {
;;;117        /* Initialization of inputA pointer */
;;;118        pIn1 = pSrcA;
000014  4607              MOV      r7,r0
;;;119    
;;;120        /* Initialization of inputB pointer */
;;;121        pIn2 = pSrcB;
000016  4610              MOV      r0,r2
000018  e002              B        |L1.32|
                  |L1.26|
;;;122    
;;;123      }
;;;124      else
;;;125      {
;;;126        /* Initialization of inputA pointer */
;;;127        pIn1 = pSrcB;
;;;128    
;;;129        /* Initialization of inputB pointer */
;;;130        pIn2 = pSrcA;
;;;131    
;;;132        /* srcBLen is always considered as shorter or equal to srcALen */
;;;133        j = srcBLen;
;;;134        srcBLen = srcALen;
00001a  4635              MOV      r5,r6
00001c  4617              MOV      r7,r2                 ;127
;;;135        srcALen = j;
00001e  461e              MOV      r6,r3
                  |L1.32|
;;;136      }
;;;137    
;;;138      /* pointer to take end of scratch2 buffer */
;;;139      pScr2 = pScratch2 + srcBLen - 1;
;;;140    
;;;141      /* points to smaller length sequence */
;;;142      px = pIn2;
;;;143    
;;;144      /* Apply loop unrolling and do 4 Copies simultaneously. */
;;;145      k = srcBLen >> 2u;
000020  08aa              LSRS     r2,r5,#2
000022  eb040145          ADD      r1,r4,r5,LSL #1       ;139
000026  1e89              SUBS     r1,r1,#2
;;;146    
;;;147      /* First part of the processing with loop unrolling copies 4 data points at a time.       
;;;148       ** a second loop below copies for the remaining 1 to 3 samples. */
;;;149      /* Copy smaller length input sequence in reverse order into second scratch buffer */
;;;150      while(k > 0u)
000028  920a              STR      r2,[sp,#0x28]
00002a  e010              B        |L1.78|
                  |L1.44|
;;;151      {
;;;152        /* copy second buffer in reversal manner */
;;;153        *pScr2-- = *px++;
00002c  f8303b02          LDRH     r3,[r0],#2
000030  800b              STRH     r3,[r1,#0]
;;;154        *pScr2-- = *px++;
000032  f830cb02          LDRH     r12,[r0],#2
000036  f821cc02          STRH     r12,[r1,#-2]
;;;155        *pScr2-- = *px++;
00003a  f830cb02          LDRH     r12,[r0],#2
00003e  f821cc04          STRH     r12,[r1,#-4]
;;;156        *pScr2-- = *px++;
000042  f830cb02          LDRH     r12,[r0],#2
000046  f821cc06          STRH     r12,[r1,#-6]
00004a  3908              SUBS     r1,r1,#8
00004c  1e52              SUBS     r2,r2,#1
                  |L1.78|
00004e  2a00              CMP      r2,#0                 ;150
000050  d1ec              BNE      |L1.44|
;;;157    
;;;158        /* Decrement the loop counter */
;;;159        k--;
;;;160      }
;;;161    
;;;162      /* If the count is not a multiple of 4, copy remaining samples here.       
;;;163       ** No loop unrolling is used. */
;;;164      k = srcBLen % 0x4u;
000052  f0050203          AND      r2,r5,#3
;;;165    
;;;166      while(k > 0u)
000056  9209              STR      r2,[sp,#0x24]
000058  e005              B        |L1.102|
;;;167      {
;;;168        /* copy second buffer in reversal manner for remaining samples */
;;;169        *pScr2-- = *px++;
00005a  bf00              NOP      
                  |L1.92|
00005c  f8303b02          LDRH     r3,[r0],#2
000060  f8213902          STRH     r3,[r1],#-2
000064  1e52              SUBS     r2,r2,#1
                  |L1.102|
000066  2a00              CMP      r2,#0                 ;166
000068  d1f8              BNE      |L1.92|
;;;170    
;;;171        /* Decrement the loop counter */
;;;172        k--;
;;;173      }
;;;174    
;;;175      /* Initialze temporary scratch pointer */
;;;176      pScr1 = pScratch1;
;;;177    
;;;178      /* Assuming scratch1 buffer is aligned by 32-bit */
;;;179      /* Fill (srcBLen - 1u) zeros in scratch buffer */
;;;180      arm_fill_q15(0, pScr1, (srcBLen - 1u));
00006a  f8dd8054          LDR      r8,[sp,#0x54]
00006e  1e6a              SUBS     r2,r5,#1
000070  4641              MOV      r1,r8
000072  2000              MOVS     r0,#0
000074  f7fffffe          BL       arm_fill_q15
;;;181    
;;;182      /* Update temporary scratch pointer */
;;;183      pScr1 += (srcBLen - 1u);
000078  eb080045          ADD      r0,r8,r5,LSL #1
00007c  1e80              SUBS     r0,r0,#2
00007e  4680              MOV      r8,r0
;;;184    
;;;185      /* Copy bigger length sequence(srcALen) samples in scratch1 buffer */
;;;186    
;;;187    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;188    
;;;189      /* Copy (srcALen) samples in scratch buffer */
;;;190      arm_copy_q15(pIn1, pScr1, srcALen);
000080  4601              MOV      r1,r0
000082  4632              MOV      r2,r6
000084  4638              MOV      r0,r7
000086  f7fffffe          BL       arm_copy_q15
;;;191    
;;;192      /* Update pointers */
;;;193      pScr1 += srcALen;
00008a  eb080146          ADD      r1,r8,r6,LSL #1
;;;194    
;;;195    #else
;;;196    
;;;197      /* Apply loop unrolling and do 4 Copies simultaneously. */
;;;198      k = srcALen >> 2u;
;;;199    
;;;200      /* First part of the processing with loop unrolling copies 4 data points at a time.       
;;;201       ** a second loop below copies for the remaining 1 to 3 samples. */
;;;202      while(k > 0u)
;;;203      {
;;;204        /* copy second buffer in reversal manner */
;;;205        *pScr1++ = *pIn1++;
;;;206        *pScr1++ = *pIn1++;
;;;207        *pScr1++ = *pIn1++;
;;;208        *pScr1++ = *pIn1++;
;;;209    
;;;210        /* Decrement the loop counter */
;;;211        k--;
;;;212      }
;;;213    
;;;214      /* If the count is not a multiple of 4, copy remaining samples here.       
;;;215       ** No loop unrolling is used. */
;;;216      k = srcALen % 0x4u;
;;;217    
;;;218      while(k > 0u)
;;;219      {
;;;220        /* copy second buffer in reversal manner for remaining samples */
;;;221        *pScr1++ = *pIn1++;
;;;222    
;;;223        /* Decrement the loop counter */
;;;224        k--;
;;;225      }
;;;226    
;;;227    #endif
;;;228    
;;;229    
;;;230    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;231    
;;;232      /* Fill (srcBLen - 1u) zeros at end of scratch buffer */
;;;233      arm_fill_q15(0, pScr1, (srcBLen - 1u));
00008e  1e6a              SUBS     r2,r5,#1
000090  2000              MOVS     r0,#0
000092  f7fffffe          BL       arm_fill_q15
;;;234    
;;;235      /* Update pointer */
;;;236      pScr1 += (srcBLen - 1u);
;;;237    
;;;238    #else
;;;239    
;;;240      /* Apply loop unrolling and do 4 Copies simultaneously. */
;;;241      k = (srcBLen - 1u) >> 2u;
;;;242    
;;;243      /* First part of the processing with loop unrolling copies 4 data points at a time.       
;;;244       ** a second loop below copies for the remaining 1 to 3 samples. */
;;;245      while(k > 0u)
;;;246      {
;;;247        /* copy second buffer in reversal manner */
;;;248        *pScr1++ = 0;
;;;249        *pScr1++ = 0;
;;;250        *pScr1++ = 0;
;;;251        *pScr1++ = 0;
;;;252    
;;;253        /* Decrement the loop counter */
;;;254        k--;
;;;255      }
;;;256    
;;;257      /* If the count is not a multiple of 4, copy remaining samples here.       
;;;258       ** No loop unrolling is used. */
;;;259      k = (srcBLen - 1u) % 0x4u;
;;;260    
;;;261      while(k > 0u)
;;;262      {
;;;263        /* copy second buffer in reversal manner for remaining samples */
;;;264        *pScr1++ = 0;
;;;265    
;;;266        /* Decrement the loop counter */
;;;267        k--;
;;;268      }
;;;269    
;;;270    #endif
;;;271    
;;;272      /* Temporary pointer for scratch2 */
;;;273      py = pScratch2;
;;;274    
;;;275    
;;;276      /* Initialization of pIn2 pointer */
;;;277      pIn2 = py;
;;;278    
;;;279      /* First part of the processing with loop unrolling process 4 data points at a time.       
;;;280       ** a second loop below process for the remaining 1 to 3 samples. */
;;;281    
;;;282      /* Actual convolution process starts here */
;;;283      blkCnt = (srcALen + srcBLen - 1u) >> 2;
000096  1970              ADDS     r0,r6,r5
000098  1e40              SUBS     r0,r0,#1
00009a  9008              STR      r0,[sp,#0x20]
00009c  0880              LSRS     r0,r0,#2
00009e  e9cd4005          STRD     r4,r0,[sp,#0x14]
;;;284    
;;;285      while(blkCnt > 0)
0000a2  e0a3              B        |L1.492|
                  |L1.164|
;;;286      {
;;;287        /* Initialze temporary scratch pointer as scratch1 */
;;;288        pScr1 = pScratch1;
0000a4  2200              MOVS     r2,#0
;;;289    
;;;290        /* Clear Accumlators */
;;;291        acc0 = 0;
;;;292        acc1 = 0;
0000a6  9815              LDR      r0,[sp,#0x54]
0000a8  e9cd2200          STRD     r2,r2,[sp,#0]
0000ac  e9cd2202          STRD     r2,r2,[sp,#8]
;;;293        acc2 = 0;
;;;294        acc3 = 0;
;;;295    
;;;296        /* Read two samples from scratch1 buffer */
;;;297        x1 = *__SIMD32(pScr1)++;
0000b0  f8506b04          LDR      r6,[r0],#4
0000b4  4693              MOV      r11,r2                ;291
0000b6  4696              MOV      lr,r2                 ;291
0000b8  4692              MOV      r10,r2                ;292
0000ba  4691              MOV      r9,r2                 ;292
;;;298    
;;;299        /* Read next two samples from scratch1 buffer */
;;;300        x2 = *__SIMD32(pScr1)++;
0000bc  f8503b04          LDR      r3,[r0],#4
;;;301    
;;;302        tapCnt = (srcBLen) >> 2u;
;;;303    
;;;304        while(tapCnt > 0u)
0000c0  990a              LDR      r1,[sp,#0x28]
0000c2  e03c              B        |L1.318|
                  |L1.196|
;;;305        {
;;;306    
;;;307    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;308    
;;;309          /* Read four samples from smaller buffer */
;;;310          y1 = _SIMD32_OFFSET(pIn2);
0000c4  f854cb04          LDR      r12,[r4],#4
;;;311          y2 = _SIMD32_OFFSET(pIn2 + 2u);
;;;312    
;;;313          /* multiply and accumlate */
;;;314          acc0 = __SMLALD(x1, y1, acc0);
0000c8  465a              MOV      r2,r11
0000ca  f8547b04          LDR      r7,[r4],#4            ;311
0000ce  4671              MOV      r1,lr
0000d0  fbc621cc          SMLALD   r2,r1,r6,r12
0000d4  468e              MOV      lr,r1
0000d6  e9dd8100          LDRD     r8,r1,[sp,#0]
0000da  4693              MOV      r11,r2
;;;315          acc2 = __SMLALD(x2, y1, acc2);
0000dc  fbc381cc          SMLALD   r8,r1,r3,r12
;;;316    
;;;317          /* pack input data */
;;;318    #ifndef ARM_MATH_BIG_ENDIAN
;;;319          x3 = __PKHBT(x2, x1, 0);
0000e0  eac30606          PKHBT    r6,r3,r6
;;;320    #else
;;;321          x3 = __PKHBT(x1, x2, 0);
;;;322    #endif
;;;323    
;;;324          /* multiply and accumlate */
;;;325          acc1 = __SMLALDX(x3, y1, acc1);
0000e4  9101              STR      r1,[sp,#4]
0000e6  4651              MOV      r1,r10
0000e8  464a              MOV      r2,r9
0000ea  fbc612dc          SMLALDX  r1,r2,r6,r12
0000ee  4689              MOV      r9,r1
0000f0  4692              MOV      r10,r2
;;;326    
;;;327          /* Read next two samples from scratch1 buffer */
;;;328          x1 = _SIMD32_OFFSET(pScr1);
0000f2  f8506b04          LDR      r6,[r0],#4
;;;329    
;;;330          /* multiply and accumlate */
;;;331          acc0 = __SMLALD(x2, y2, acc0);
0000f6  465a              MOV      r2,r11
0000f8  4671              MOV      r1,lr
0000fa  fbc321c7          SMLALD   r2,r1,r3,r7
0000fe  468e              MOV      lr,r1
;;;332          acc2 = __SMLALD(x1, y2, acc2);
000100  9901              LDR      r1,[sp,#4]
000102  4693              MOV      r11,r2                ;331
000104  9600              STR      r6,[sp,#0]
000106  fbc681c7          SMLALD   r8,r1,r6,r7
;;;333    
;;;334          /* pack input data */
;;;335    #ifndef ARM_MATH_BIG_ENDIAN
;;;336          x3 = __PKHBT(x1, x2, 0);
00010a  eac60303          PKHBT    r3,r6,r3
00010e  e9cd8100          STRD     r8,r1,[sp,#0]
000112  e9dd1802          LDRD     r1,r8,[sp,#8]
;;;337    #else
;;;338          x3 = __PKHBT(x2, x1, 0);
;;;339    #endif
;;;340    
;;;341          acc3 = __SMLALDX(x3, y1, acc3);
000116  fbc318dc          SMLALDX  r1,r8,r3,r12
00011a  468c              MOV      r12,r1
;;;342          acc1 = __SMLALDX(x3, y2, acc1);
00011c  4649              MOV      r1,r9
00011e  4652              MOV      r2,r10
000120  fbc312d7          SMLALDX  r1,r2,r3,r7
;;;343    
;;;344          x2 = _SIMD32_OFFSET(pScr1 + 2u);
000124  f8503b04          LDR      r3,[r0],#4
000128  468a              MOV      r10,r1                ;342
00012a  4691              MOV      r9,r2                 ;342
;;;345    
;;;346    #ifndef ARM_MATH_BIG_ENDIAN
;;;347          x3 = __PKHBT(x2, x1, 0);
00012c  eac30206          PKHBT    r2,r3,r6
;;;348    #else
;;;349          x3 = __PKHBT(x1, x2, 0);
;;;350    #endif
;;;351    
;;;352          acc3 = __SMLALDX(x3, y2, acc3);
000130  4661              MOV      r1,r12
000132  fbc218d7          SMLALDX  r1,r8,r2,r7
000136  e9cd1802          STRD     r1,r8,[sp,#8]
;;;353    
;;;354    #else	 
;;;355    
;;;356          /* Read four samples from smaller buffer */
;;;357    	  a = *pIn2;
;;;358    	  b = *(pIn2 + 1);
;;;359    
;;;360    #ifndef ARM_MATH_BIG_ENDIAN
;;;361          y1 = __PKHBT(a, b, 16);
;;;362    #else
;;;363          y1 = __PKHBT(b, a, 16);
;;;364    #endif
;;;365    	  
;;;366    	  a = *(pIn2 + 2);
;;;367    	  b = *(pIn2 + 3);
;;;368    #ifndef ARM_MATH_BIG_ENDIAN
;;;369          y2 = __PKHBT(a, b, 16);
;;;370    #else
;;;371          y2 = __PKHBT(b, a, 16);
;;;372    #endif				
;;;373    
;;;374          acc0 = __SMLALD(x1, y1, acc0);
;;;375    
;;;376          acc2 = __SMLALD(x2, y1, acc2);
;;;377    
;;;378    #ifndef ARM_MATH_BIG_ENDIAN
;;;379          x3 = __PKHBT(x2, x1, 0);
;;;380    #else
;;;381          x3 = __PKHBT(x1, x2, 0);
;;;382    #endif
;;;383    
;;;384          acc1 = __SMLALDX(x3, y1, acc1);
;;;385    
;;;386    	  a = *pScr1;
;;;387    	  b = *(pScr1 + 1);
;;;388    
;;;389    #ifndef ARM_MATH_BIG_ENDIAN
;;;390          x1 = __PKHBT(a, b, 16);
;;;391    #else
;;;392          x1 = __PKHBT(b, a, 16);
;;;393    #endif
;;;394    
;;;395          acc0 = __SMLALD(x2, y2, acc0);
;;;396    
;;;397          acc2 = __SMLALD(x1, y2, acc2);
;;;398    
;;;399    #ifndef ARM_MATH_BIG_ENDIAN
;;;400          x3 = __PKHBT(x1, x2, 0);
;;;401    #else
;;;402          x3 = __PKHBT(x2, x1, 0);
;;;403    #endif
;;;404    
;;;405          acc3 = __SMLALDX(x3, y1, acc3);
;;;406    
;;;407          acc1 = __SMLALDX(x3, y2, acc1);
;;;408    
;;;409    	  a = *(pScr1 + 2);
;;;410    	  b = *(pScr1 + 3);
;;;411    
;;;412    #ifndef ARM_MATH_BIG_ENDIAN
;;;413          x2 = __PKHBT(a, b, 16);
;;;414    #else
;;;415          x2 = __PKHBT(b, a, 16);
;;;416    #endif
;;;417    
;;;418    #ifndef ARM_MATH_BIG_ENDIAN
;;;419          x3 = __PKHBT(x2, x1, 0);
;;;420    #else
;;;421          x3 = __PKHBT(x1, x2, 0);
;;;422    #endif
;;;423    
;;;424          acc3 = __SMLALDX(x3, y2, acc3);
;;;425    
;;;426    #endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE	*/
;;;427    
;;;428          pIn2 += 4u;
;;;429          pScr1 += 4u;
;;;430    
;;;431    
;;;432          /* Decrement the loop counter */
;;;433          tapCnt--;
00013a  9907              LDR      r1,[sp,#0x1c]
00013c  1e49              SUBS     r1,r1,#1
                  |L1.318|
00013e  9107              STR      r1,[sp,#0x1c]         ;302
000140  2900              CMP      r1,#0                 ;302
000142  d1bf              BNE      |L1.196|
000144  3808              SUBS     r0,r0,#8              ;302
;;;434        }
;;;435    
;;;436        /* Update scratch pointer for remaining samples of smaller length sequence */
;;;437        pScr1 -= 4u;
;;;438    
;;;439        /* apply same above for remaining samples of smaller length sequence */
;;;440        tapCnt = (srcBLen) & 3u;
;;;441    
;;;442        while(tapCnt > 0u)
000146  9e09              LDR      r6,[sp,#0x24]
000148  e022              B        |L1.400|
                  |L1.330|
;;;443        {
;;;444    
;;;445          /* accumlate the results */
;;;446          acc0 += (*pScr1++ * *pIn2);
00014a  f9307b02          LDRSH    r7,[r0],#2
00014e  f9341b02          LDRSH    r1,[r4],#2
000152  465a              MOV      r2,r11
000154  4673              MOV      r3,lr
000156  fbc72381          SMLALBB  r2,r3,r7,r1
00015a  4693              MOV      r11,r2
00015c  469e              MOV      lr,r3
;;;447          acc1 += (*pScr1++ * *pIn2);
00015e  f9b07000          LDRSH    r7,[r0,#0]
000162  4653              MOV      r3,r10
000164  464a              MOV      r2,r9
000166  fbc73281          SMLALBB  r3,r2,r7,r1
00016a  469a              MOV      r10,r3
00016c  4691              MOV      r9,r2
;;;448          acc2 += (*pScr1++ * *pIn2);
00016e  f9b07002          LDRSH    r7,[r0,#2]
000172  e9dd2300          LDRD     r2,r3,[sp,#0]
000176  fbc72381          SMLALBB  r2,r3,r7,r1
00017a  e9cd2300          STRD     r2,r3,[sp,#0]
;;;449          acc3 += (*pScr1++ * *pIn2++);
00017e  f9b07004          LDRSH    r7,[r0,#4]
000182  e9dd2302          LDRD     r2,r3,[sp,#8]
000186  fbc72381          SMLALBB  r2,r3,r7,r1
00018a  e9cd2302          STRD     r2,r3,[sp,#8]
00018e  1e76              SUBS     r6,r6,#1
                  |L1.400|
000190  2e00              CMP      r6,#0                 ;442
000192  d1da              BNE      |L1.330|
;;;450    
;;;451          pScr1 -= 3u;
;;;452    
;;;453          /* Decrement the loop counter */
;;;454          tapCnt--;
;;;455        }
;;;456    
;;;457        blkCnt--;
000194  9806              LDR      r0,[sp,#0x18]
000196  1e40              SUBS     r0,r0,#1
;;;458    
;;;459    
;;;460        /* Store the results in the accumulators in the destination buffer. */
;;;461    
;;;462    #ifndef ARM_MATH_BIG_ENDIAN
;;;463    
;;;464        *__SIMD32(pOut)++ =
000198  9006              STR      r0,[sp,#0x18]
00019a  ea4f30db          LSR      r0,r11,#15
00019e  ea40404e          ORR      r0,r0,lr,LSL #17
0001a2  f300020f          SSAT     r2,#16,r0
0001a6  ea4f30da          LSR      r0,r10,#15
0001aa  ea404049          ORR      r0,r0,r9,LSL #17
0001ae  f300000f          SSAT     r0,#16,r0
0001b2  eac24100          PKHBT    r1,r2,r0,LSL #16
0001b6  9804              LDR      r0,[sp,#0x10]
0001b8  6001              STR      r1,[r0,#0]
0001ba  e9dd1200          LDRD     r1,r2,[sp,#0]
;;;465          __PKHBT(__SSAT((acc0 >> 15), 16), __SSAT((acc1 >> 15), 16), 16);
;;;466    
;;;467        *__SIMD32(pOut)++ =
0001be  0bc9              LSRS     r1,r1,#15
0001c0  ea414142          ORR      r1,r1,r2,LSL #17
0001c4  f301030f          SSAT     r3,#16,r1
0001c8  e9dd1003          LDRD     r1,r0,[sp,#0xc]
0001cc  9a02              LDR      r2,[sp,#8]
0001ce  044c              LSLS     r4,r1,#17
0001d0  ea4431d2          ORR      r1,r4,r2,LSR #15
0001d4  f301010f          SSAT     r1,#16,r1
0001d8  eac34101          PKHBT    r1,r3,r1,LSL #16
0001dc  6041              STR      r1,[r0,#4]
0001de  3008              ADDS     r0,r0,#8
;;;468          __PKHBT(__SSAT((acc2 >> 15), 16), __SSAT((acc3 >> 15), 16), 16);
;;;469    
;;;470    #else
;;;471    
;;;472        *__SIMD32(pOut)++ =
;;;473          __PKHBT(__SSAT((acc1 >> 15), 16), __SSAT((acc0 >> 15), 16), 16);
;;;474    
;;;475        *__SIMD32(pOut)++ =
;;;476          __PKHBT(__SSAT((acc3 >> 15), 16), __SSAT((acc2 >> 15), 16), 16);
;;;477    
;;;478    
;;;479    #endif /*      #ifndef ARM_MATH_BIG_ENDIAN       */
;;;480    
;;;481        /* Initialization of inputB pointer */
;;;482        pIn2 = py;
0001e0  9004              STR      r0,[sp,#0x10]
;;;483    
;;;484        pScratch1 += 4u;
0001e2  9815              LDR      r0,[sp,#0x54]
0001e4  9c05              LDR      r4,[sp,#0x14]
0001e6  3008              ADDS     r0,r0,#8
0001e8  9015              STR      r0,[sp,#0x54]         ;285
0001ea  9806              LDR      r0,[sp,#0x18]         ;285
                  |L1.492|
0001ec  2800              CMP      r0,#0                 ;285
0001ee  f47faf59          BNE      |L1.164|
;;;485    
;;;486      }
;;;487    
;;;488    
;;;489      blkCnt = (srcALen + srcBLen - 1u) & 0x3;
0001f2  9808              LDR      r0,[sp,#0x20]
0001f4  f0000603          AND      r6,r0,#3
;;;490    
;;;491      /* Calculate convolution for remaining samples of Bigger length sequence */
;;;492      while(blkCnt > 0)
0001f8  e02e              B        |L1.600|
                  |L1.506|
;;;493      {
;;;494        /* Initialze temporary scratch pointer as scratch1 */
;;;495        pScr1 = pScratch1;
0001fa  2000              MOVS     r0,#0
0001fc  4601              MOV      r1,r0
;;;496    
;;;497        /* Clear Accumlators */
;;;498        acc0 = 0;
;;;499    
;;;500        tapCnt = (srcBLen) >> 1u;
0001fe  086b              LSRS     r3,r5,#1
;;;501    
;;;502        while(tapCnt > 0u)
000200  9a15              LDR      r2,[sp,#0x54]
000202  e00c              B        |L1.542|
                  |L1.516|
;;;503        {
;;;504    
;;;505          /* Read next two samples from scratch1 buffer */
;;;506          acc0 += (*pScr1++ * *pIn2++);
000204  f932cb02          LDRSH    r12,[r2],#2
000208  f9347b02          LDRSH    r7,[r4],#2
00020c  fbcc0187          SMLALBB  r0,r1,r12,r7
;;;507          acc0 += (*pScr1++ * *pIn2++);
000210  f932cb02          LDRSH    r12,[r2],#2
000214  f9347b02          LDRSH    r7,[r4],#2
000218  fbcc0187          SMLALBB  r0,r1,r12,r7
00021c  1e5b              SUBS     r3,r3,#1
                  |L1.542|
00021e  2b00              CMP      r3,#0                 ;502
000220  d1f0              BNE      |L1.516|
;;;508    
;;;509          /* Decrement the loop counter */
;;;510          tapCnt--;
;;;511        }
;;;512    
;;;513        tapCnt = (srcBLen) & 1u;
000222  f0050301          AND      r3,r5,#1
;;;514    
;;;515        /* apply same above for remaining samples of smaller length sequence */
;;;516        while(tapCnt > 0u)
000226  e006              B        |L1.566|
                  |L1.552|
;;;517        {
;;;518    
;;;519          /* accumlate the results */
;;;520          acc0 += (*pScr1++ * *pIn2++);
000228  f932cb02          LDRSH    r12,[r2],#2
00022c  f9347b02          LDRSH    r7,[r4],#2
000230  fbcc0187          SMLALBB  r0,r1,r12,r7
000234  1e5b              SUBS     r3,r3,#1
                  |L1.566|
000236  2b00              CMP      r3,#0                 ;516
000238  d1f6              BNE      |L1.552|
;;;521    
;;;522          /* Decrement the loop counter */
;;;523          tapCnt--;
;;;524        }
;;;525    
;;;526        blkCnt--;
;;;527    
;;;528        /* The result is in 2.30 format.  Convert to 1.15 with saturation.       
;;;529         ** Then store the output in the destination buffer. */
;;;530        *pOut++ = (q15_t) (__SSAT((acc0 >> 15), 16));
00023a  0bc0              LSRS     r0,r0,#15
00023c  ea404041          ORR      r0,r0,r1,LSL #17
000240  f300010f          SSAT     r1,#16,r0
000244  9804              LDR      r0,[sp,#0x10]
000246  8001              STRH     r1,[r0,#0]
000248  9804              LDR      r0,[sp,#0x10]
;;;531    
;;;532    
;;;533        /* Initialization of inputB pointer */
;;;534        pIn2 = py;
;;;535    
;;;536        pScratch1 += 1u;
00024a  9c05              LDR      r4,[sp,#0x14]
00024c  1c80              ADDS     r0,r0,#2              ;530
00024e  9004              STR      r0,[sp,#0x10]         ;534
000250  9815              LDR      r0,[sp,#0x54]
000252  1c80              ADDS     r0,r0,#2
000254  1e76              SUBS     r6,r6,#1
000256  9015              STR      r0,[sp,#0x54]
                  |L1.600|
000258  2e00              CMP      r6,#0                 ;492
00025a  d1ce              BNE      |L1.506|
;;;537    
;;;538      }
;;;539    
;;;540    }
00025c  b00b              ADD      sp,sp,#0x2c
00025e  e8bd8ff0          POP      {r4-r11,pc}
;;;541    
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\FilteringFunctions\\arm_conv_opt_q15.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_conv_opt_q15_c_b0d93b78____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___18_arm_conv_opt_q15_c_b0d93b78____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_conv_opt_q15_c_b0d93b78____REVSH|
#line 144
|__asm___18_arm_conv_opt_q15_c_b0d93b78____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_conv_opt_q15_c_b0d93b78____RRX|
#line 300
|__asm___18_arm_conv_opt_q15_c_b0d93b78____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
