; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_correlate_q31.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_correlate_q31.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_correlate_q31.crf src\FilteringFunctions\arm_correlate_q31.c]
                          THUMB

                          AREA ||i.arm_correlate_q31||, CODE, READONLY, ALIGN=1

                  arm_correlate_q31 PROC
;;;77     
;;;78     void arm_correlate_q31(
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;79       q31_t * pSrcA,
;;;80       uint32_t srcALen,
;;;81       q31_t * pSrcB,
;;;82       uint32_t srcBLen,
;;;83       q31_t * pDst)
;;;84     {
000004  b098              SUB      sp,sp,#0x60
;;;85     
;;;86     #ifndef ARM_MATH_CM0_FAMILY
;;;87     
;;;88       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;89     
;;;90       q31_t *pIn1;                                   /* inputA pointer               */
;;;91       q31_t *pIn2;                                   /* inputB pointer               */
;;;92       q31_t *pOut = pDst;                            /* output pointer               */
;;;93       q31_t *px;                                     /* Intermediate inputA pointer  */
;;;94       q31_t *py;                                     /* Intermediate inputB pointer  */
;;;95       q31_t *pSrc1;                                  /* Intermediate pointers        */
;;;96       q63_t sum, acc0, acc1, acc2;                   /* Accumulators                  */
;;;97       q31_t x0, x1, x2, c0;                          /* temporary variables for holding input and coefficient values */
;;;98       uint32_t j, k = 0u, count, blkCnt, outBlockSize, blockSize1, blockSize2, blockSize3;  /* loop counter                 */
;;;99       int32_t inc = 1;                               /* Destination address modifier */
000006  2401              MOVS     r4,#1
;;;100    
;;;101    
;;;102      /* The algorithm implementation is based on the lengths of the inputs. */
;;;103      /* srcB is always made to slide across srcA. */
;;;104      /* So srcBLen is always considered as shorter or equal to srcALen */
;;;105      /* But CORR(x, y) is reverse of CORR(y, x) */
;;;106      /* So, when srcBLen > srcALen, output pointer is made to point to the end of the output buffer */
;;;107      /* and the destination pointer modifier, inc is set to -1 */
;;;108      /* If srcALen > srcBLen, zero pad has to be done to srcB to make the two inputs of same length */
;;;109      /* But to improve the performance,    
;;;110       * we include zeroes in the output instead of zero padding either of the the inputs*/
;;;111      /* If srcALen > srcBLen,    
;;;112       * (srcALen - srcBLen) zeroes has to included in the starting of the output buffer */
;;;113      /* If srcALen < srcBLen,    
;;;114       * (srcALen - srcBLen) zeroes has to included in the ending of the output buffer */
;;;115      if(srcALen >= srcBLen)
;;;116      {
;;;117        /* Initialization of inputA pointer */
;;;118        pIn1 = (pSrcA);
;;;119    
;;;120        /* Initialization of inputB pointer */
;;;121        pIn2 = (pSrcB);
;;;122    
;;;123        /* Number of output samples is calculated */
;;;124        outBlockSize = (2u * srcALen) - 1u;
000008  940e              STR      r4,[sp,#0x38]
00000a  9d21              LDR      r5,[sp,#0x84]         ;99
00000c  1ea4              SUBS     r4,r4,#2
00000e  4299              CMP      r1,r3                 ;115
000010  d30a              BCC      |L1.40|
000012  920b              STR      r2,[sp,#0x2c]
000014  9011              STR      r0,[sp,#0x44]
000016  eb040041          ADD      r0,r4,r1,LSL #1
;;;125    
;;;126        /* When srcALen > srcBLen, zero padding is done to srcB    
;;;127         * to make their lengths equal.    
;;;128         * Instead, (outBlockSize - (srcALen + srcBLen - 1))    
;;;129         * number of output samples are made zero */
;;;130        j = outBlockSize - (srcALen + (srcBLen - 1u));
00001a  18ca              ADDS     r2,r1,r3
00001c  1a80              SUBS     r0,r0,r2
00001e  1c40              ADDS     r0,r0,#1
;;;131    
;;;132        /* Updating the pointer position to non zero value */
;;;133        pOut += j;
000020  eb050080          ADD      r0,r5,r0,LSL #2
000024  9000              STR      r0,[sp,#0]
000026  e00a              B        |L1.62|
                  |L1.40|
;;;134    
;;;135      }
;;;136      else
;;;137      {
;;;138        /* Initialization of inputA pointer */
;;;139        pIn1 = (pSrcB);
;;;140    
;;;141        /* Initialization of inputB pointer */
;;;142        pIn2 = (pSrcA);
;;;143    
;;;144        /* srcBLen is always considered as shorter or equal to srcALen */
;;;145        j = srcBLen;
000028  900b              STR      r0,[sp,#0x2c]
00002a  4618              MOV      r0,r3
;;;146        srcBLen = srcALen;
00002c  460b              MOV      r3,r1
;;;147        srcALen = j;
00002e  4601              MOV      r1,r0
;;;148    
;;;149        /* CORR(x, y) = Reverse order(CORR(y, x)) */
;;;150        /* Hence set the destination pointer to point to the last output sample */
;;;151        pOut = pDst + ((srcALen + srcBLen) - 2u);
000030  4418              ADD      r0,r0,r3
000032  eb050080          ADD      r0,r5,r0,LSL #2
000036  3808              SUBS     r0,r0,#8
000038  9211              STR      r2,[sp,#0x44]         ;145
;;;152    
;;;153        /* Destination address modifier is set to -1 */
;;;154        inc = -1;
00003a  940e              STR      r4,[sp,#0x38]
00003c  9000              STR      r0,[sp,#0]
                  |L1.62|
;;;155    
;;;156      }
;;;157    
;;;158      /* The function is internally    
;;;159       * divided into three parts according to the number of multiplications that has to be    
;;;160       * taken place between inputA samples and inputB samples. In the first part of the    
;;;161       * algorithm, the multiplications increase by one for every iteration.    
;;;162       * In the second part of the algorithm, srcBLen number of multiplications are done.    
;;;163       * In the third part of the algorithm, the multiplications decrease by one    
;;;164       * for every iteration.*/
;;;165      /* The algorithm is implemented in three stages.    
;;;166       * The loop counters of each stage is initiated here. */
;;;167      blockSize1 = srcBLen - 1u;
;;;168      blockSize2 = srcALen - (srcBLen - 1u);
00003e  1ac8              SUBS     r0,r1,r3
000040  9010              STR      r0,[sp,#0x40]
000042  1c40              ADDS     r0,r0,#1
;;;169      blockSize3 = blockSize1;
;;;170    
;;;171      /* --------------------------    
;;;172       * Initializations of stage1    
;;;173       * -------------------------*/
;;;174    
;;;175      /* sum = x[0] * y[srcBlen - 1]    
;;;176       * sum = x[0] * y[srcBlen - 2] + x[1] * y[srcBlen - 1]    
;;;177       * ....    
;;;178       * sum = x[0] * y[0] + x[1] * y[1] +...+ x[srcBLen - 1] * y[srcBLen - 1]    
;;;179       */
;;;180    
;;;181      /* In this stage the MAC operations are increased by 1 for every iteration.    
;;;182         The count variable holds the number of MAC operations performed */
;;;183      count = 1u;
;;;184    
;;;185      /* Working pointer of inputA */
;;;186      px = pIn1;
000044  9015              STR      r0,[sp,#0x54]
;;;187    
;;;188      /* Working pointer of inputB */
;;;189      pSrc1 = pIn2 + (srcBLen - 1u);
000046  990b              LDR      r1,[sp,#0x2c]
000048  2501              MOVS     r5,#1                 ;183
00004a  eb010183          ADD      r1,r1,r3,LSL #2
00004e  f1a30801          SUB      r8,r3,#1              ;167
000052  1f09              SUBS     r1,r1,#4
000054  f8cd804c          STR      r8,[sp,#0x4c]         ;186
000058  4689              MOV      r9,r1
;;;190      py = pSrc1;
;;;191    
;;;192      /* ------------------------    
;;;193       * Stage1 process    
;;;194       * ----------------------*/
;;;195    
;;;196      /* The first stage starts here */
;;;197      while(blockSize1 > 0u)
00005a  9811              LDR      r0,[sp,#0x44]
00005c  e045              B        |L1.234|
                  |L1.94|
00005e  2400              MOVS     r4,#0
000060  4622              MOV      r2,r4
;;;198      {
;;;199        /* Accumulator is made zero for every iteration */
;;;200        sum = 0;
;;;201    
;;;202        /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;203        k = count >> 2;
000062  08af              LSRS     r7,r5,#2
;;;204    
;;;205        /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.    
;;;206         ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;207        while(k > 0u)
000064  e021              B        |L1.170|
                  |L1.102|
;;;208        {
;;;209          /* x[0] * y[srcBLen - 4] */
;;;210          sum += (q63_t) * px++ * (*py++);
000066  6806              LDR      r6,[r0,#0]
000068  f851cb04          LDR      r12,[r1],#4
00006c  fb86c60c          SMULL    r12,r6,r6,r12
000070  eb1c0404          ADDS     r4,r12,r4
000074  4156              ADCS     r6,r6,r2
;;;211          /* x[1] * y[srcBLen - 3] */
;;;212          sum += (q63_t) * px++ * (*py++);
000076  6842              LDR      r2,[r0,#4]
000078  f851cb04          LDR      r12,[r1],#4
00007c  fb82c20c          SMULL    r12,r2,r2,r12
000080  eb1c0404          ADDS     r4,r12,r4
000084  4172              ADCS     r2,r2,r6
;;;213          /* x[2] * y[srcBLen - 2] */
;;;214          sum += (q63_t) * px++ * (*py++);
000086  6886              LDR      r6,[r0,#8]
000088  f851cb04          LDR      r12,[r1],#4
00008c  fb86c60c          SMULL    r12,r6,r6,r12
000090  eb1c0404          ADDS     r4,r12,r4
000094  4156              ADCS     r6,r6,r2
;;;215          /* x[3] * y[srcBLen - 1] */
;;;216          sum += (q63_t) * px++ * (*py++);
000096  68c2              LDR      r2,[r0,#0xc]
000098  f851cb04          LDR      r12,[r1],#4
00009c  3010              ADDS     r0,r0,#0x10
00009e  fb82c20c          SMULL    r12,r2,r2,r12
0000a2  eb1c0404          ADDS     r4,r12,r4
0000a6  4172              ADCS     r2,r2,r6
0000a8  1e7f              SUBS     r7,r7,#1
                  |L1.170|
0000aa  2f00              CMP      r7,#0                 ;207
0000ac  d1db              BNE      |L1.102|
;;;217    
;;;218          /* Decrement the loop counter */
;;;219          k--;
;;;220        }
;;;221    
;;;222        /* If the count is not a multiple of 4, compute any remaining MACs here.    
;;;223         ** No loop unrolling is used. */
;;;224        k = count % 0x4u;
0000ae  f0050603          AND      r6,r5,#3
;;;225    
;;;226        while(k > 0u)
0000b2  e008              B        |L1.198|
                  |L1.180|
;;;227        {
;;;228          /* Perform the multiply-accumulates */
;;;229          /* x[0] * y[srcBLen - 1] */
;;;230          sum += (q63_t) * px++ * (*py++);
0000b4  c880              LDM      r0!,{r7}
0000b6  f851cb04          LDR      r12,[r1],#4
0000ba  fb87c70c          SMULL    r12,r7,r7,r12
0000be  eb1c0404          ADDS     r4,r12,r4
0000c2  417a              ADCS     r2,r2,r7
0000c4  1e76              SUBS     r6,r6,#1
                  |L1.198|
0000c6  2e00              CMP      r6,#0                 ;226
0000c8  d1f4              BNE      |L1.180|
;;;231    
;;;232          /* Decrement the loop counter */
;;;233          k--;
;;;234        }
;;;235    
;;;236        /* Store the result in the accumulator in the destination buffer. */
;;;237        *pOut = (q31_t) (sum >> 31);
0000ca  9900              LDR      r1,[sp,#0]
0000cc  0fe0              LSRS     r0,r4,#31
0000ce  ea400042          ORR      r0,r0,r2,LSL #1
;;;238        /* Destination pointer is updated according to the address modifier, inc */
;;;239        pOut += inc;
0000d2  6008              STR      r0,[r1,#0]
0000d4  990e              LDR      r1,[sp,#0x38]
0000d6  9800              LDR      r0,[sp,#0]
;;;240    
;;;241        /* Update the inputA and inputB pointers for next MAC calculation */
;;;242        py = pSrc1 - count;
;;;243        px = pIn1;
;;;244    
;;;245        /* Increment the MAC count */
;;;246        count++;
;;;247    
;;;248        /* Decrement the loop counter */
;;;249        blockSize1--;
0000d8  f1a80801          SUB      r8,r8,#1
0000dc  eb000081          ADD      r0,r0,r1,LSL #2       ;239
0000e0  9000              STR      r0,[sp,#0]            ;243
0000e2  eba90185          SUB      r1,r9,r5,LSL #2       ;242
0000e6  9811              LDR      r0,[sp,#0x44]
0000e8  1c6d              ADDS     r5,r5,#1
                  |L1.234|
0000ea  f1b80f00          CMP      r8,#0                 ;197
0000ee  d1b6              BNE      |L1.94|
;;;250      }
;;;251    
;;;252      /* --------------------------    
;;;253       * Initializations of stage2    
;;;254       * ------------------------*/
;;;255    
;;;256      /* sum = x[0] * y[0] + x[1] * y[1] +...+ x[srcBLen-1] * y[srcBLen-1]    
;;;257       * sum = x[1] * y[0] + x[2] * y[1] +...+ x[srcBLen] * y[srcBLen-1]    
;;;258       * ....    
;;;259       * sum = x[srcALen-srcBLen-2] * y[0] + x[srcALen-srcBLen-1] * y[1] +...+ x[srcALen-1] * y[srcBLen-1]    
;;;260       */
;;;261    
;;;262      /* Working pointer of inputA */
;;;263      px = pIn1;
;;;264    
;;;265      /* Working pointer of inputB */
;;;266      py = pIn2;
;;;267    
;;;268      /* count is index by which the pointer pIn1 to be incremented */
;;;269      count = 0u;
0000f0  2100              MOVS     r1,#0
0000f2  9a0b              LDR      r2,[sp,#0x2c]
;;;270    
;;;271      /* -------------------    
;;;272       * Stage2 process    
;;;273       * ------------------*/
;;;274    
;;;275      /* Stage2 depends on srcBLen as in this stage srcBLen number of MACS are performed.    
;;;276       * So, to loop unroll over blockSize2,    
;;;277       * srcBLen should be greater than or equal to 4 */
;;;278      if(srcBLen >= 4u)
0000f4  9117              STR      r1,[sp,#0x5c]
0000f6  2b04              CMP      r3,#4
0000f8  d37e              BCC      |L1.504|
;;;279      {
;;;280        /* Loop unroll by 3 */
;;;281        blkCnt = blockSize2 / 3;
0000fa  9c15              LDR      r4,[sp,#0x54]
0000fc  2103              MOVS     r1,#3
0000fe  fbb4f4f1          UDIV     r4,r4,r1
;;;282    
;;;283        while(blkCnt > 0u)
000102  4621              MOV      r1,r4
000104  9407              STR      r4,[sp,#0x1c]
000106  e087              B        |L1.536|
                  |L1.264|
000108  2100              MOVS     r1,#0
;;;284        {
;;;285          /* Set all accumulators to zero */
;;;286          acc0 = 0;
;;;287          acc1 = 0;
;;;288          acc2 = 0;
;;;289    
;;;290          /* read x[0], x[1] samples */
;;;291          x0 = *(px++);
;;;292          x1 = *(px++);
;;;293    
;;;294          /* Apply loop unrolling and compute 3 MACs simultaneously. */
;;;295          k = srcBLen / 3;
00010a  2403              MOVS     r4,#3
00010c  fbb3f4f4          UDIV     r4,r3,r4
000110  468b              MOV      r11,r1                ;286
000112  4688              MOV      r8,r1                 ;286
000114  468e              MOV      lr,r1                 ;287
000116  468a              MOV      r10,r1                ;288
000118  4689              MOV      r9,r1                 ;288
00011a  9108              STR      r1,[sp,#0x20]         ;288
00011c  e8f06102          LDRD     r6,r1,[r0],#8         ;288
000120  9405              STR      r4,[sp,#0x14]
                  |L1.290|
;;;296    
;;;297          /* First part of the processing with loop unrolling.  Compute 3 MACs at a time.        
;;;298           ** a second loop below computes MACs for the remaining 1 to 2 samples. */
;;;299          do
;;;300          {
;;;301            /* Read y[0] sample */
;;;302            c0 = *(py);
000122  ca80              LDM      r2!,{r7}
;;;303    
;;;304            /* Read x[2] sample */
;;;305            x2 = *(px);
;;;306    
;;;307            /* Perform the multiply-accumulate */
;;;308            /* acc0 +=  x[0] * y[0] */
;;;309            acc0 += ((q63_t) x0 * c0);
000124  9d08              LDR      r5,[sp,#0x20]
000126  465c              MOV      r4,r11
000128  fbc64507          SMLAL    r4,r5,r6,r7
00012c  46a3              MOV      r11,r4
;;;310            /* acc1 +=  x[1] * y[0] */
;;;311            acc1 += ((q63_t) x1 * c0);
00012e  4674              MOV      r4,lr
000130  fbc18407          SMLAL    r8,r4,r1,r7
000134  f850cb04          LDR      r12,[r0],#4           ;305
;;;312            /* acc2 +=  x[2] * y[0] */
;;;313            acc2 += ((q63_t) x2 * c0);
000138  9412              STR      r4,[sp,#0x48]
00013a  4654              MOV      r4,r10
00013c  fbcc4907          SMLAL    r4,r9,r12,r7
;;;314    
;;;315            /* Read y[1] sample */
;;;316            c0 = *(py + 1u);
000140  ca80              LDM      r2!,{r7}
000142  46a6              MOV      lr,r4                 ;313
;;;317    
;;;318            /* Read x[3] sample */
;;;319            x0 = *(px + 1u);
;;;320    
;;;321            /* Perform the multiply-accumulates */
;;;322            /* acc0 +=  x[1] * y[1] */
;;;323            acc0 += ((q63_t) x1 * c0);
000144  465c              MOV      r4,r11
000146  fbc14507          SMLAL    r4,r5,r1,r7
00014a  46a2              MOV      r10,r4
;;;324            /* acc1 +=  x[2] * y[1] */
;;;325            acc1 += ((q63_t) x2 * c0);
00014c  9c12              LDR      r4,[sp,#0x48]
00014e  c840              LDM      r0!,{r6}              ;319
000150  fbcc8407          SMLAL    r8,r4,r12,r7
;;;326            /* acc2 +=  x[3] * y[1] */
;;;327            acc2 += ((q63_t) x0 * c0);
000154  9412              STR      r4,[sp,#0x48]
000156  4674              MOV      r4,lr
000158  fbc64907          SMLAL    r4,r9,r6,r7
;;;328    
;;;329            /* Read y[2] sample */
;;;330            c0 = *(py + 2u);
00015c  9414              STR      r4,[sp,#0x50]
00015e  ca80              LDM      r2!,{r7}
;;;331    
;;;332            /* Read x[4] sample */
;;;333            x1 = *(px + 2u);
;;;334    
;;;335            /* Perform the multiply-accumulates */
;;;336            /* acc0 +=  x[2] * y[2] */
;;;337            acc0 += ((q63_t) x2 * c0);
000160  4654              MOV      r4,r10
000162  fbcc4507          SMLAL    r4,r5,r12,r7
000166  c802              LDM      r0!,{r1}              ;333
000168  46a3              MOV      r11,r4
;;;338            /* acc1 +=  x[3] * y[2] */
;;;339            acc1 += ((q63_t) x0 * c0);
00016a  9508              STR      r5,[sp,#0x20]
00016c  9c12              LDR      r4,[sp,#0x48]
00016e  fbc68407          SMLAL    r8,r4,r6,r7
000172  46a6              MOV      lr,r4
;;;340            /* acc2 +=  x[4] * y[2] */
;;;341            acc2 += ((q63_t) x1 * c0);
000174  9c14              LDR      r4,[sp,#0x50]
000176  fbc14907          SMLAL    r4,r9,r1,r7
00017a  46a2              MOV      r10,r4
;;;342    
;;;343            /* update scratch pointers */
;;;344            px += 3u;
;;;345            py += 3u;
;;;346    
;;;347          } while(--k);
00017c  9c05              LDR      r4,[sp,#0x14]
00017e  1e64              SUBS     r4,r4,#1
000180  9405              STR      r4,[sp,#0x14]
000182  d1ce              BNE      |L1.290|
;;;348    
;;;349          /* If the srcBLen is not a multiple of 3, compute any remaining MACs here.        
;;;350           ** No loop unrolling is used. */
;;;351          k = srcBLen - (3 * (srcBLen / 3));
000184  2403              MOVS     r4,#3
000186  fbb3f4f4          UDIV     r4,r3,r4
00018a  eba40484          SUB      r4,r4,r4,LSL #2
00018e  441c              ADD      r4,r4,r3
;;;352    
;;;353          while(k > 0u)
000190  e016              B        |L1.448|
                  |L1.402|
;;;354          {
;;;355            /* Read y[4] sample */
;;;356            c0 = *(py++);
000192  ca10              LDM      r2!,{r4}
;;;357    
;;;358            /* Read x[7] sample */
;;;359            x2 = *(px++);
;;;360    
;;;361            /* Perform the multiply-accumulates */
;;;362            /* acc0 +=  x[4] * y[4] */
;;;363            acc0 += ((q63_t) x0 * c0);
000194  9f08              LDR      r7,[sp,#0x20]
000196  465d              MOV      r5,r11
000198  fbc65704          SMLAL    r5,r7,r6,r4
00019c  46ab              MOV      r11,r5
;;;364            /* acc1 +=  x[5] * y[4] */
;;;365            acc1 += ((q63_t) x1 * c0);
00019e  4675              MOV      r5,lr
0001a0  fbc18504          SMLAL    r8,r5,r1,r4
0001a4  f850cb04          LDR      r12,[r0],#4           ;359
0001a8  46ae              MOV      lr,r5
;;;366            /* acc2 +=  x[6] * y[4] */
;;;367            acc2 += ((q63_t) x2 * c0);
0001aa  4655              MOV      r5,r10
0001ac  464e              MOV      r6,r9
0001ae  fbcc5604          SMLAL    r5,r6,r12,r4
0001b2  46b1              MOV      r9,r6
;;;368    
;;;369            /* Reuse the present samples for the next MAC */
;;;370            x0 = x1;
;;;371            x1 = x2;
;;;372    
;;;373            /* Decrement the loop counter */
;;;374            k--;
0001b4  9c05              LDR      r4,[sp,#0x14]
0001b6  460e              MOV      r6,r1                 ;370
0001b8  46aa              MOV      r10,r5                ;367
0001ba  4661              MOV      r1,r12                ;371
0001bc  9708              STR      r7,[sp,#0x20]
0001be  1e64              SUBS     r4,r4,#1
                  |L1.448|
0001c0  9405              STR      r4,[sp,#0x14]         ;351
0001c2  2c00              CMP      r4,#0                 ;351
0001c4  d1e5              BNE      |L1.402|
;;;375          }
;;;376    
;;;377          /* Store the result in the accumulator in the destination buffer. */
;;;378          *pOut = (q31_t) (acc0 >> 31);
0001c6  9908              LDR      r1,[sp,#0x20]
0001c8  ea4f70db          LSR      r0,r11,#31
0001cc  ea400041          ORR      r0,r0,r1,LSL #1
0001d0  9900              LDR      r1,[sp,#0]
;;;379          /* Destination pointer is updated according to the address modifier, inc */
;;;380          pOut += inc;
0001d2  6008              STR      r0,[r1,#0]
0001d4  990e              LDR      r1,[sp,#0x38]
0001d6  9800              LDR      r0,[sp,#0]
0001d8  eb000081          ADD      r0,r0,r1,LSL #2
;;;381    
;;;382          *pOut = (q31_t) (acc1 >> 31);
0001dc  ea4f71d8          LSR      r1,r8,#31
0001e0  ea41014e          ORR      r1,r1,lr,LSL #1
;;;383          pOut += inc;
0001e4  6001              STR      r1,[r0,#0]
0001e6  990e              LDR      r1,[sp,#0x38]
0001e8  eb000181          ADD      r1,r0,r1,LSL #2
;;;384    
;;;385          *pOut = (q31_t) (acc2 >> 31);
0001ec  ea4f70da          LSR      r0,r10,#31
0001f0  ea400049          ORR      r0,r0,r9,LSL #1
;;;386          pOut += inc;
0001f4  6008              STR      r0,[r1,#0]
0001f6  e000              B        |L1.506|
                  |L1.504|
0001f8  e066              B        |L1.712|
                  |L1.506|
0001fa  980e              LDR      r0,[sp,#0x38]
;;;387    
;;;388          /* Increment the pointer pIn1 index, count by 3 */
;;;389          count += 3u;
;;;390    
;;;391          /* Update the inputA and inputB pointers for next MAC calculation */
;;;392          px = pIn1 + count;
;;;393          py = pIn2;
;;;394    
;;;395    
;;;396          /* Decrement the loop counter */
;;;397          blkCnt--;
0001fc  9a0b              LDR      r2,[sp,#0x2c]
0001fe  eb010080          ADD      r0,r1,r0,LSL #2       ;386
000202  9000              STR      r0,[sp,#0]            ;389
000204  9817              LDR      r0,[sp,#0x5c]         ;389
000206  1cc0              ADDS     r0,r0,#3              ;389
000208  9017              STR      r0,[sp,#0x5c]         ;392
00020a  9917              LDR      r1,[sp,#0x5c]         ;392
00020c  9811              LDR      r0,[sp,#0x44]         ;392
00020e  eb000081          ADD      r0,r0,r1,LSL #2       ;392
000212  9907              LDR      r1,[sp,#0x1c]
000214  1e49              SUBS     r1,r1,#1
000216  9107              STR      r1,[sp,#0x1c]
                  |L1.536|
000218  2900              CMP      r1,#0                 ;283
00021a  f47faf75          BNE      |L1.264|
;;;398        }
;;;399    
;;;400        /* If the blockSize2 is not a multiple of 3, compute any remaining output samples here.        
;;;401         ** No loop unrolling is used. */
;;;402        blkCnt = blockSize2 - 3 * (blockSize2 / 3);
00021e  9915              LDR      r1,[sp,#0x54]
000220  2403              MOVS     r4,#3
000222  fbb1f1f4          UDIV     r1,r1,r4
000226  eba10481          SUB      r4,r1,r1,LSL #2
00022a  9915              LDR      r1,[sp,#0x54]
00022c  1867              ADDS     r7,r4,r1
;;;403    
;;;404        while(blkCnt > 0u)
00022e  e048              B        |L1.706|
                  |L1.560|
000230  2400              MOVS     r4,#0
000232  4621              MOV      r1,r4
;;;405        {
;;;406          /* Accumulator is made zero for every iteration */
;;;407          sum = 0;
;;;408    
;;;409          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;410          k = srcBLen >> 2u;
000234  089e              LSRS     r6,r3,#2
;;;411    
;;;412          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.    
;;;413           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;414          while(k > 0u)
000236  e021              B        |L1.636|
                  |L1.568|
;;;415          {
;;;416            /* Perform the multiply-accumulates */
;;;417            sum += (q63_t) * px++ * (*py++);
000238  6805              LDR      r5,[r0,#0]
00023a  f852cb04          LDR      r12,[r2],#4
00023e  fb85c50c          SMULL    r12,r5,r5,r12
000242  eb1c0404          ADDS     r4,r12,r4
000246  414d              ADCS     r5,r5,r1
;;;418            sum += (q63_t) * px++ * (*py++);
000248  6841              LDR      r1,[r0,#4]
00024a  f852cb04          LDR      r12,[r2],#4
00024e  fb81c10c          SMULL    r12,r1,r1,r12
000252  eb1c0404          ADDS     r4,r12,r4
000256  4169              ADCS     r1,r1,r5
;;;419            sum += (q63_t) * px++ * (*py++);
000258  6885              LDR      r5,[r0,#8]
00025a  f852cb04          LDR      r12,[r2],#4
00025e  fb85c50c          SMULL    r12,r5,r5,r12
000262  eb1c0404          ADDS     r4,r12,r4
000266  414d              ADCS     r5,r5,r1
;;;420            sum += (q63_t) * px++ * (*py++);
000268  68c1              LDR      r1,[r0,#0xc]
00026a  f852cb04          LDR      r12,[r2],#4
00026e  3010              ADDS     r0,r0,#0x10
000270  fb81c10c          SMULL    r12,r1,r1,r12
000274  eb1c0404          ADDS     r4,r12,r4
000278  4169              ADCS     r1,r1,r5
00027a  1e76              SUBS     r6,r6,#1
                  |L1.636|
00027c  2e00              CMP      r6,#0                 ;414
00027e  d1db              BNE      |L1.568|
;;;421    
;;;422            /* Decrement the loop counter */
;;;423            k--;
;;;424          }
;;;425    
;;;426          /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.    
;;;427           ** No loop unrolling is used. */
;;;428          k = srcBLen % 0x4u;
000280  f0030503          AND      r5,r3,#3
;;;429    
;;;430          while(k > 0u)
000284  e008              B        |L1.664|
                  |L1.646|
;;;431          {
;;;432            /* Perform the multiply-accumulate */
;;;433            sum += (q63_t) * px++ * (*py++);
000286  c840              LDM      r0!,{r6}
000288  f852cb04          LDR      r12,[r2],#4
00028c  fb86c60c          SMULL    r12,r6,r6,r12
000290  eb1c0404          ADDS     r4,r12,r4
000294  4171              ADCS     r1,r1,r6
000296  1e6d              SUBS     r5,r5,#1
                  |L1.664|
000298  2d00              CMP      r5,#0                 ;430
00029a  d1f4              BNE      |L1.646|
;;;434    
;;;435            /* Decrement the loop counter */
;;;436            k--;
;;;437          }
;;;438    
;;;439          /* Store the result in the accumulator in the destination buffer. */
;;;440          *pOut = (q31_t) (sum >> 31);
00029c  0fe0              LSRS     r0,r4,#31
00029e  ea400041          ORR      r0,r0,r1,LSL #1
0002a2  9900              LDR      r1,[sp,#0]
;;;441          /* Destination pointer is updated according to the address modifier, inc */
;;;442          pOut += inc;
0002a4  6008              STR      r0,[r1,#0]
0002a6  990e              LDR      r1,[sp,#0x38]
0002a8  9800              LDR      r0,[sp,#0]
;;;443    
;;;444          /* Increment the MAC count */
;;;445          count++;
;;;446    
;;;447          /* Update the inputA and inputB pointers for next MAC calculation */
;;;448          px = pIn1 + count;
;;;449          py = pIn2;
0002aa  9a0b              LDR      r2,[sp,#0x2c]
0002ac  eb000081          ADD      r0,r0,r1,LSL #2       ;442
0002b0  9000              STR      r0,[sp,#0]            ;445
0002b2  9817              LDR      r0,[sp,#0x5c]         ;445
0002b4  1c40              ADDS     r0,r0,#1              ;445
0002b6  9017              STR      r0,[sp,#0x5c]         ;448
0002b8  9917              LDR      r1,[sp,#0x5c]         ;448
0002ba  9811              LDR      r0,[sp,#0x44]         ;448
0002bc  1e7f              SUBS     r7,r7,#1
0002be  eb000081          ADD      r0,r0,r1,LSL #2       ;448
                  |L1.706|
0002c2  2f00              CMP      r7,#0                 ;404
0002c4  d1b4              BNE      |L1.560|
0002c6  e024              B        |L1.786|
                  |L1.712|
;;;450    
;;;451          /* Decrement the loop counter */
;;;452          blkCnt--;
;;;453        }
;;;454      }
;;;455      else
;;;456      {
;;;457        /* If the srcBLen is not a multiple of 4,    
;;;458         * the blockSize2 loop cannot be unrolled by 4 */
;;;459        blkCnt = blockSize2;
;;;460    
;;;461        while(blkCnt > 0u)
0002c8  9e15              LDR      r6,[sp,#0x54]
0002ca  e020              B        |L1.782|
                  |L1.716|
0002cc  2400              MOVS     r4,#0
0002ce  4621              MOV      r1,r4
;;;462        {
;;;463          /* Accumulator is made zero for every iteration */
;;;464          sum = 0;
;;;465    
;;;466          /* Loop over srcBLen */
;;;467          k = srcBLen;
0002d0  461d              MOV      r5,r3
;;;468    
;;;469          while(k > 0u)
0002d2  e008              B        |L1.742|
                  |L1.724|
;;;470          {
;;;471            /* Perform the multiply-accumulate */
;;;472            sum += (q63_t) * px++ * (*py++);
0002d4  c880              LDM      r0!,{r7}
0002d6  f852cb04          LDR      r12,[r2],#4
0002da  fb87c70c          SMULL    r12,r7,r7,r12
0002de  eb1c0404          ADDS     r4,r12,r4
0002e2  4179              ADCS     r1,r1,r7
0002e4  1e6d              SUBS     r5,r5,#1
                  |L1.742|
0002e6  2d00              CMP      r5,#0                 ;469
0002e8  d1f4              BNE      |L1.724|
;;;473    
;;;474            /* Decrement the loop counter */
;;;475            k--;
;;;476          }
;;;477    
;;;478          /* Store the result in the accumulator in the destination buffer. */
;;;479          *pOut = (q31_t) (sum >> 31);
0002ea  0fe0              LSRS     r0,r4,#31
0002ec  ea400041          ORR      r0,r0,r1,LSL #1
0002f0  9900              LDR      r1,[sp,#0]
;;;480          /* Destination pointer is updated according to the address modifier, inc */
;;;481          pOut += inc;
0002f2  6008              STR      r0,[r1,#0]
0002f4  990e              LDR      r1,[sp,#0x38]
0002f6  9800              LDR      r0,[sp,#0]
;;;482    
;;;483          /* Increment the MAC count */
;;;484          count++;
;;;485    
;;;486          /* Update the inputA and inputB pointers for next MAC calculation */
;;;487          px = pIn1 + count;
;;;488          py = pIn2;
0002f8  9a0b              LDR      r2,[sp,#0x2c]
0002fa  eb000081          ADD      r0,r0,r1,LSL #2       ;481
0002fe  9000              STR      r0,[sp,#0]            ;484
000300  9817              LDR      r0,[sp,#0x5c]         ;484
000302  9911              LDR      r1,[sp,#0x44]         ;487
000304  1c40              ADDS     r0,r0,#1              ;484
000306  9017              STR      r0,[sp,#0x5c]         ;487
000308  eb010080          ADD      r0,r1,r0,LSL #2       ;487
00030c  1e76              SUBS     r6,r6,#1
                  |L1.782|
00030e  2e00              CMP      r6,#0                 ;461
000310  d1dc              BNE      |L1.716|
                  |L1.786|
000312  e9dd0110          LDRD     r0,r1,[sp,#0x40]      ;461
;;;489    
;;;490          /* Decrement the loop counter */
;;;491          blkCnt--;
;;;492        }
;;;493      }
;;;494    
;;;495      /* --------------------------    
;;;496       * Initializations of stage3    
;;;497       * -------------------------*/
;;;498    
;;;499      /* sum += x[srcALen-srcBLen+1] * y[0] + x[srcALen-srcBLen+2] * y[1] +...+ x[srcALen-1] * y[srcBLen-1]    
;;;500       * sum += x[srcALen-srcBLen+2] * y[0] + x[srcALen-srcBLen+3] * y[1] +...+ x[srcALen-1] * y[srcBLen-1]    
;;;501       * ....    
;;;502       * sum +=  x[srcALen-2] * y[0] + x[srcALen-1] * y[1]    
;;;503       * sum +=  x[srcALen-1] * y[0]    
;;;504       */
;;;505    
;;;506      /* In this stage the MAC operations are decreased by 1 for every iteration.    
;;;507         The count variable holds the number of MAC operations performed */
;;;508      count = srcBLen - 1u;
;;;509    
;;;510      /* Working pointer of inputA */
;;;511      pSrc1 = pIn1 + (srcALen - (srcBLen - 1u));
000316  eb010080          ADD      r0,r1,r0,LSL #2
00031a  1d00              ADDS     r0,r0,#4
;;;512      px = pSrc1;
00031c  4601              MOV      r1,r0
;;;513    
;;;514      /* Working pointer of inputB */
;;;515      py = pIn2;
;;;516    
;;;517      /* -------------------    
;;;518       * Stage3 process    
;;;519       * ------------------*/
;;;520    
;;;521      while(blockSize3 > 0u)
00031e  9c13              LDR      r4,[sp,#0x4c]
000320  e045              B        |L1.942|
                  |L1.802|
000322  2700              MOVS     r7,#0
000324  463c              MOV      r4,r7
;;;522      {
;;;523        /* Accumulator is made zero for every iteration */
;;;524        sum = 0;
;;;525    
;;;526        /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;527        k = count >> 2u;
000326  089e              LSRS     r6,r3,#2
;;;528    
;;;529        /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.    
;;;530         ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;531        while(k > 0u)
000328  e021              B        |L1.878|
                  |L1.810|
;;;532        {
;;;533          /* Perform the multiply-accumulates */
;;;534          /* sum += x[srcALen - srcBLen + 4] * y[3] */
;;;535          sum += (q63_t) * px++ * (*py++);
00032a  680d              LDR      r5,[r1,#0]
00032c  f852cb04          LDR      r12,[r2],#4
000330  fb85c50c          SMULL    r12,r5,r5,r12
000334  eb1c0707          ADDS     r7,r12,r7
000338  4165              ADCS     r5,r5,r4
;;;536          /* sum += x[srcALen - srcBLen + 3] * y[2] */
;;;537          sum += (q63_t) * px++ * (*py++);
00033a  684c              LDR      r4,[r1,#4]
00033c  f852cb04          LDR      r12,[r2],#4
000340  fb84c40c          SMULL    r12,r4,r4,r12
000344  eb1c0707          ADDS     r7,r12,r7
000348  416c              ADCS     r4,r4,r5
;;;538          /* sum += x[srcALen - srcBLen + 2] * y[1] */
;;;539          sum += (q63_t) * px++ * (*py++);
00034a  688d              LDR      r5,[r1,#8]
00034c  f852cb04          LDR      r12,[r2],#4
000350  fb85c50c          SMULL    r12,r5,r5,r12
000354  eb1c0707          ADDS     r7,r12,r7
000358  4165              ADCS     r5,r5,r4
;;;540          /* sum += x[srcALen - srcBLen + 1] * y[0] */
;;;541          sum += (q63_t) * px++ * (*py++);
00035a  68cc              LDR      r4,[r1,#0xc]
00035c  f852cb04          LDR      r12,[r2],#4
000360  3110              ADDS     r1,r1,#0x10
000362  fb84c40c          SMULL    r12,r4,r4,r12
000366  eb1c0707          ADDS     r7,r12,r7
00036a  416c              ADCS     r4,r4,r5
00036c  1e76              SUBS     r6,r6,#1
                  |L1.878|
00036e  2e00              CMP      r6,#0                 ;531
000370  d1db              BNE      |L1.810|
;;;542    
;;;543          /* Decrement the loop counter */
;;;544          k--;
;;;545        }
;;;546    
;;;547        /* If the count is not a multiple of 4, compute any remaining MACs here.    
;;;548         ** No loop unrolling is used. */
;;;549        k = count % 0x4u;
000372  f0030503          AND      r5,r3,#3
;;;550    
;;;551        while(k > 0u)
000376  e008              B        |L1.906|
                  |L1.888|
;;;552        {
;;;553          /* Perform the multiply-accumulates */
;;;554          sum += (q63_t) * px++ * (*py++);
000378  c940              LDM      r1!,{r6}
00037a  f852cb04          LDR      r12,[r2],#4
00037e  fb86c60c          SMULL    r12,r6,r6,r12
000382  eb1c0707          ADDS     r7,r12,r7
000386  4174              ADCS     r4,r4,r6
000388  1e6d              SUBS     r5,r5,#1
                  |L1.906|
00038a  2d00              CMP      r5,#0                 ;551
00038c  d1f4              BNE      |L1.888|
;;;555    
;;;556          /* Decrement the loop counter */
;;;557          k--;
;;;558        }
;;;559    
;;;560        /* Store the result in the accumulator in the destination buffer. */
;;;561        *pOut = (q31_t) (sum >> 31);
00038e  9a00              LDR      r2,[sp,#0]
000390  0ff9              LSRS     r1,r7,#31
000392  ea410144          ORR      r1,r1,r4,LSL #1
;;;562        /* Destination pointer is updated according to the address modifier, inc */
;;;563        pOut += inc;
000396  6011              STR      r1,[r2,#0]
000398  9a0e              LDR      r2,[sp,#0x38]
00039a  9900              LDR      r1,[sp,#0]
00039c  1d00              ADDS     r0,r0,#4
00039e  eb010182          ADD      r1,r1,r2,LSL #2
;;;564    
;;;565        /* Update the inputA and inputB pointers for next MAC calculation */
;;;566        px = ++pSrc1;
;;;567        py = pIn2;
;;;568    
;;;569        /* Decrement the MAC count */
;;;570        count--;
;;;571    
;;;572        /* Decrement the loop counter */
;;;573        blockSize3--;
0003a2  9c13              LDR      r4,[sp,#0x4c]
0003a4  9100              STR      r1,[sp,#0]            ;566
0003a6  1e64              SUBS     r4,r4,#1
0003a8  9a0b              LDR      r2,[sp,#0x2c]
0003aa  4601              MOV      r1,r0                 ;566
0003ac  9413              STR      r4,[sp,#0x4c]
                  |L1.942|
0003ae  1e5b              SUBS     r3,r3,#1
0003b0  2c00              CMP      r4,#0
0003b2  d1b6              BNE      |L1.802|
;;;574      }
;;;575    
;;;576    #else
;;;577    
;;;578      /* Run the below code for Cortex-M0 */
;;;579    
;;;580      q31_t *pIn1 = pSrcA;                           /* inputA pointer               */
;;;581      q31_t *pIn2 = pSrcB + (srcBLen - 1u);          /* inputB pointer               */
;;;582      q63_t sum;                                     /* Accumulators                  */
;;;583      uint32_t i = 0u, j;                            /* loop counters */
;;;584      uint32_t inv = 0u;                             /* Reverse order flag */
;;;585      uint32_t tot = 0u;                             /* Length */
;;;586    
;;;587      /* The algorithm implementation is based on the lengths of the inputs. */
;;;588      /* srcB is always made to slide across srcA. */
;;;589      /* So srcBLen is always considered as shorter or equal to srcALen */
;;;590      /* But CORR(x, y) is reverse of CORR(y, x) */
;;;591      /* So, when srcBLen > srcALen, output pointer is made to point to the end of the output buffer */
;;;592      /* and a varaible, inv is set to 1 */
;;;593      /* If lengths are not equal then zero pad has to be done to  make the two    
;;;594       * inputs of same length. But to improve the performance, we include zeroes    
;;;595       * in the output instead of zero padding either of the the inputs*/
;;;596      /* If srcALen > srcBLen, (srcALen - srcBLen) zeroes has to included in the    
;;;597       * starting of the output buffer */
;;;598      /* If srcALen < srcBLen, (srcALen - srcBLen) zeroes has to included in the   
;;;599       * ending of the output buffer */
;;;600      /* Once the zero padding is done the remaining of the output is calcualted   
;;;601       * using correlation but with the shorter signal time shifted. */
;;;602    
;;;603      /* Calculate the length of the remaining sequence */
;;;604      tot = ((srcALen + srcBLen) - 2u);
;;;605    
;;;606      if(srcALen > srcBLen)
;;;607      {
;;;608        /* Calculating the number of zeros to be padded to the output */
;;;609        j = srcALen - srcBLen;
;;;610    
;;;611        /* Initialise the pointer after zero padding */
;;;612        pDst += j;
;;;613      }
;;;614    
;;;615      else if(srcALen < srcBLen)
;;;616      {
;;;617        /* Initialization to inputB pointer */
;;;618        pIn1 = pSrcB;
;;;619    
;;;620        /* Initialization to the end of inputA pointer */
;;;621        pIn2 = pSrcA + (srcALen - 1u);
;;;622    
;;;623        /* Initialisation of the pointer after zero padding */
;;;624        pDst = pDst + tot;
;;;625    
;;;626        /* Swapping the lengths */
;;;627        j = srcALen;
;;;628        srcALen = srcBLen;
;;;629        srcBLen = j;
;;;630    
;;;631        /* Setting the reverse flag */
;;;632        inv = 1;
;;;633    
;;;634      }
;;;635    
;;;636      /* Loop to calculate correlation for output length number of times */
;;;637      for (i = 0u; i <= tot; i++)
;;;638      {
;;;639        /* Initialize sum with zero to carry on MAC operations */
;;;640        sum = 0;
;;;641    
;;;642        /* Loop to perform MAC operations according to correlation equation */
;;;643        for (j = 0u; j <= i; j++)
;;;644        {
;;;645          /* Check the array limitations */
;;;646          if((((i - j) < srcBLen) && (j < srcALen)))
;;;647          {
;;;648            /* z[i] += x[i-j] * y[j] */
;;;649            sum += ((q63_t) pIn1[j] * pIn2[-((int32_t) i - j)]);
;;;650          }
;;;651        }
;;;652        /* Store the output in the destination buffer */
;;;653        if(inv == 1)
;;;654          *pDst-- = (q31_t) (sum >> 31u);
;;;655        else
;;;656          *pDst++ = (q31_t) (sum >> 31u);
;;;657      }
;;;658    
;;;659    #endif /*   #ifndef ARM_MATH_CM0_FAMILY */
;;;660    
;;;661    }
0003b4  b018              ADD      sp,sp,#0x60
0003b6  e8bd8ff0          POP      {r4-r11,pc}
;;;662    
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\FilteringFunctions\\arm_correlate_q31.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_correlate_q31_c_0930b14d____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___19_arm_correlate_q31_c_0930b14d____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_correlate_q31_c_0930b14d____REVSH|
#line 144
|__asm___19_arm_correlate_q31_c_0930b14d____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_correlate_q31_c_0930b14d____RRX|
#line 300
|__asm___19_arm_correlate_q31_c_0930b14d____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
