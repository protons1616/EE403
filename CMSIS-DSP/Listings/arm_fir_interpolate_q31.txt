; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_fir_interpolate_q31.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_fir_interpolate_q31.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_fir_interpolate_q31.crf src\FilteringFunctions\arm_fir_interpolate_q31.c]
                          THUMB

                          AREA ||i.arm_fir_interpolate_q31||, CODE, READONLY, ALIGN=1

                  arm_fir_interpolate_q31 PROC
;;;73     
;;;74     void arm_fir_interpolate_q31(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;75       const arm_fir_interpolate_instance_q31 * S,
;;;76       q31_t * pSrc,
;;;77       q31_t * pDst,
;;;78       uint32_t blockSize)
;;;79     {
000004  4682              MOV      r10,r0
000006  b093              SUB      sp,sp,#0x4c
000008  e9da1001          LDRD     r1,r0,[r10,#4]
;;;80       q31_t *pState = S->pState;                     /* State pointer */
;;;81       q31_t *pCoeffs = S->pCoeffs;                   /* Coefficient pointer */
;;;82       q31_t *pStateCurnt;                            /* Points to the current sample of the state */
;;;83       q31_t *ptr1, *ptr2;                            /* Temporary pointers for state and coefficient buffers */
;;;84       q63_t sum0;                                    /* Accumulators */
;;;85       q31_t x0, c0;                                  /* Temporary variables to hold state and coefficient values */
;;;86       uint32_t i, blkCnt, j;                         /* Loop counters */
;;;87       uint16_t phaseLen = S->phaseLength, tapCnt;    /* Length of each polyphase filter component */
00000c  9111              STR      r1,[sp,#0x44]
00000e  f8ba1002          LDRH     r1,[r10,#2]
;;;88     
;;;89       uint32_t blkCntN2;
;;;90       q63_t acc0, acc1;
;;;91       q31_t x1;
;;;92     
;;;93       /* S->pState buffer contains previous frame (phaseLen - 1) samples */
;;;94       /* pStateCurnt points to the location where the new input data should be written */
;;;95       pStateCurnt = S->pState + ((q31_t) phaseLen - 1);
000012  f06f0203          MVN      r2,#3
000016  910b              STR      r1,[sp,#0x2c]
000018  eb020181          ADD      r1,r2,r1,LSL #2
00001c  4401              ADD      r1,r1,r0
;;;96     
;;;97       /* Initialise  blkCnt */
;;;98       blkCnt = blockSize / 2;
00001e  910c              STR      r1,[sp,#0x30]
000020  0859              LSRS     r1,r3,#1
;;;99       blkCntN2 = blockSize - (2 * blkCnt);
000022  910d              STR      r1,[sp,#0x34]
000024  4249              RSBS     r1,r1,#0
000026  eb030141          ADD      r1,r3,r1,LSL #1
;;;100    
;;;101      /* Samples loop unrolled by 2 */
;;;102      while(blkCnt > 0u)
00002a  9112              STR      r1,[sp,#0x48]
00002c  990d              LDR      r1,[sp,#0x34]         ;79
00002e  e08c              B        |L1.330|
                  |L1.48|
;;;103      {
;;;104        /* Copy new input sample into the state buffer */
;;;105        *pStateCurnt++ = *pSrc++;
000030  9914              LDR      r1,[sp,#0x50]
000032  680a              LDR      r2,[r1,#0]
000034  990c              LDR      r1,[sp,#0x30]
000036  600a              STR      r2,[r1,#0]
;;;106        *pStateCurnt++ = *pSrc++;
000038  9914              LDR      r1,[sp,#0x50]
00003a  9a0c              LDR      r2,[sp,#0x30]
00003c  684b              LDR      r3,[r1,#4]
00003e  3108              ADDS     r1,r1,#8
000040  6053              STR      r3,[r2,#4]
000042  3208              ADDS     r2,r2,#8
;;;107    
;;;108        /* Address modifier index of coefficient buffer */
;;;109        j = 1u;
000044  9114              STR      r1,[sp,#0x50]
000046  2101              MOVS     r1,#1
000048  920c              STR      r2,[sp,#0x30]
;;;110    
;;;111        /* Loop over the Interpolation factor. */
;;;112        i = (S->L);
00004a  910f              STR      r1,[sp,#0x3c]
00004c  f89a1000          LDRB     r1,[r10,#0]
;;;113    
;;;114        while(i > 0u)
000050  e06e              B        |L1.304|
                  |L1.82|
;;;115        {
;;;116          /* Set accumulator to zero */
;;;117          acc0 = 0;
;;;118          acc1 = 0;
;;;119    
;;;120          /* Initialize state pointer */
;;;121          ptr1 = pState;
;;;122    
;;;123          /* Initialize coefficient pointer */
;;;124          ptr2 = pCoeffs + (S->L - j);
000052  f89a6000          LDRB     r6,[r10,#0]
000056  990f              LDR      r1,[sp,#0x3c]
000058  2200              MOVS     r2,#0                 ;114
00005a  1a73              SUBS     r3,r6,r1
00005c  9911              LDR      r1,[sp,#0x44]
00005e  4693              MOV      r11,r2                ;117
000060  eb010383          ADD      r3,r1,r3,LSL #2
;;;125    
;;;126          /* Loop over the polyPhase length. Unroll by a factor of 4.        
;;;127           ** Repeat until we've computed numTaps-(4*S->L) coefficients. */
;;;128          tapCnt = phaseLen >> 2u;
000064  990b              LDR      r1,[sp,#0x2c]
000066  4691              MOV      r9,r2                 ;117
000068  ea4f0e91          LSR      lr,r1,#2
00006c  4690              MOV      r8,r2                 ;117
;;;129    
;;;130          x0 = *(ptr1++);
00006e  1d01              ADDS     r1,r0,#4
;;;131    
;;;132          while(tapCnt > 0u)
000070  6805              LDR      r5,[r0,#0]
000072  e02e              B        |L1.210|
                  |L1.116|
;;;133          {
;;;134    
;;;135            /* Read the input sample */
;;;136            x1 = *(ptr1++);
000074  f1010c04          ADD      r12,r1,#4
;;;137    
;;;138            /* Read the coefficient */
;;;139            c0 = *(ptr2);
000078  680f              LDR      r7,[r1,#0]
;;;140    
;;;141            /* Perform the multiply-accumulate */
;;;142            acc0 += (q63_t) x0 *c0;
00007a  6819              LDR      r1,[r3,#0]
00007c  465c              MOV      r4,r11
00007e  fbc52401          SMLAL    r2,r4,r5,r1
;;;143            acc1 += (q63_t) x1 *c0;
000082  fbc79801          SMLAL    r9,r8,r7,r1
;;;144    
;;;145    
;;;146            /* Read the coefficient */
;;;147            c0 = *(ptr2 + S->L);
000086  f8535026          LDR      r5,[r3,r6,LSL #2]
;;;148    
;;;149            /* Read the input sample */
;;;150            x0 = *(ptr1++);
00008a  f85c1b04          LDR      r1,[r12],#4
;;;151    
;;;152            /* Perform the multiply-accumulate */
;;;153            acc0 += (q63_t) x1 *c0;
00008e  fbc72405          SMLAL    r2,r4,r7,r5
;;;154            acc1 += (q63_t) x0 *c0;
000092  fbc19805          SMLAL    r9,r8,r1,r5
;;;155    
;;;156    
;;;157            /* Read the coefficient */
;;;158            c0 = *(ptr2 + S->L * 2);
000096  f8535036          LDR      r5,[r3,r6,LSL #3]
00009a  46e3              MOV      r11,r12               ;150
;;;159    
;;;160            /* Read the input sample */
;;;161            x1 = *(ptr1++);
00009c  f8dcc000          LDR      r12,[r12,#0]
;;;162    
;;;163            /* Perform the multiply-accumulate */
;;;164            acc0 += (q63_t) x0 *c0;
0000a0  fbc12405          SMLAL    r2,r4,r1,r5
;;;165            acc1 += (q63_t) x1 *c0;
;;;166    
;;;167            /* Read the coefficient */
;;;168            c0 = *(ptr2 + S->L * 3);
0000a4  eb060146          ADD      r1,r6,r6,LSL #1
0000a8  f8cdc008          STR      r12,[sp,#8]
0000ac  f8537021          LDR      r7,[r3,r1,LSL #2]
0000b0  fbcc9805          SMLAL    r9,r8,r12,r5          ;165
;;;169    
;;;170            /* Read the input sample */
;;;171            x0 = *(ptr1++);
0000b4  f85b5f04          LDR      r5,[r11,#4]!
;;;172    
;;;173            /* Perform the multiply-accumulate */
;;;174            acc0 += (q63_t) x1 *c0;
0000b8  fbcc2407          SMLAL    r2,r4,r12,r7
;;;175            acc1 += (q63_t) x0 *c0;
0000bc  fbc59807          SMLAL    r9,r8,r5,r7
0000c0  f10b0104          ADD      r1,r11,#4             ;171
0000c4  46a3              MOV      r11,r4                ;174
;;;176    
;;;177    
;;;178            /* Upsampling is done by stuffing L-1 zeros between each sample.        
;;;179             * So instead of multiplying zeros with coefficients,        
;;;180             * Increment the coefficient pointer by interpolation factor times. */
;;;181            ptr2 += 4 * S->L;
;;;182    
;;;183            /* Decrement the loop counter */
;;;184            tapCnt--;
0000c6  f1ae0401          SUB      r4,lr,#1
0000ca  eb031306          ADD      r3,r3,r6,LSL #4       ;181
0000ce  fa1ffe84          UXTH     lr,r4
                  |L1.210|
0000d2  f1be0f00          CMP      lr,#0                 ;132
0000d6  d1cd              BNE      |L1.116|
;;;185          }
;;;186    
;;;187          /* If the polyPhase length is not a multiple of 4, compute the remaining filter taps */
;;;188          tapCnt = phaseLen % 0x4u;
0000d8  9c0b              LDR      r4,[sp,#0x2c]
0000da  f0040403          AND      r4,r4,#3
;;;189    
;;;190          while(tapCnt > 0u)
0000de  e00e              B        |L1.254|
                  |L1.224|
;;;191          {
;;;192    
;;;193            /* Read the input sample */
;;;194            x1 = *(ptr1++);
;;;195    
;;;196            /* Read the coefficient */
;;;197            c0 = *(ptr2);
;;;198    
;;;199            /* Perform the multiply-accumulate */
;;;200            acc0 += (q63_t) x0 *c0;
0000e0  681c              LDR      r4,[r3,#0]
0000e2  f851eb04          LDR      lr,[r1],#4            ;194
0000e6  465f              MOV      r7,r11
0000e8  fbc52704          SMLAL    r2,r7,r5,r4
;;;201            acc1 += (q63_t) x1 *c0;
0000ec  fbce9804          SMLAL    r9,r8,lr,r4
;;;202    
;;;203            /* Increment the coefficient pointer by interpolation factor times. */
;;;204            ptr2 += S->L;
;;;205    
;;;206            /* update states for next sample processing */
;;;207            x0 = x1;
;;;208    
;;;209            /* Decrement the loop counter */
;;;210            tapCnt--;
0000f0  f1ac0401          SUB      r4,r12,#1
0000f4  46bb              MOV      r11,r7                ;200
0000f6  eb030386          ADD      r3,r3,r6,LSL #2       ;204
0000fa  4675              MOV      r5,lr                 ;207
0000fc  b2a4              UXTH     r4,r4
                  |L1.254|
0000fe  ea5f0c04          MOVS     r12,r4                ;188
000102  d1ed              BNE      |L1.224|
;;;211          }
;;;212    
;;;213          /* The result is in the accumulator, store in the destination buffer. */
;;;214          *pDst = (q31_t) (acc0 >> 31);
000104  0fd1              LSRS     r1,r2,#31
000106  9a15              LDR      r2,[sp,#0x54]
000108  ea41014b          ORR      r1,r1,r11,LSL #1
;;;215          *(pDst + S->L) = (q31_t) (acc1 >> 31);
00010c  6011              STR      r1,[r2,#0]
00010e  f89a3000          LDRB     r3,[r10,#0]
000112  9a15              LDR      r2,[sp,#0x54]
000114  ea4f71d9          LSR      r1,r9,#31
000118  ea410148          ORR      r1,r1,r8,LSL #1
00011c  f8421023          STR      r1,[r2,r3,LSL #2]
;;;216    
;;;217    
;;;218          pDst++;
000120  9915              LDR      r1,[sp,#0x54]
000122  1d09              ADDS     r1,r1,#4
;;;219    
;;;220          /* Increment the address modifier index of coefficient buffer */
;;;221          j++;
000124  9115              STR      r1,[sp,#0x54]
000126  990f              LDR      r1,[sp,#0x3c]
000128  1c49              ADDS     r1,r1,#1
;;;222    
;;;223          /* Decrement the loop counter */
;;;224          i--;
00012a  910f              STR      r1,[sp,#0x3c]
00012c  990e              LDR      r1,[sp,#0x38]
00012e  1e49              SUBS     r1,r1,#1
                  |L1.304|
000130  910e              STR      r1,[sp,#0x38]         ;112
000132  2900              CMP      r1,#0                 ;112
000134  d18d              BNE      |L1.82|
;;;225        }
;;;226    
;;;227        /* Advance the state pointer by 1        
;;;228         * to process the next group of interpolation factor number samples */
;;;229        pState = pState + 2;
;;;230    
;;;231        pDst += S->L;
000136  f89a2000          LDRB     r2,[r10,#0]
00013a  9915              LDR      r1,[sp,#0x54]
00013c  eb010182          ADD      r1,r1,r2,LSL #2
;;;232    
;;;233        /* Decrement the loop counter */
;;;234        blkCnt--;
000140  9115              STR      r1,[sp,#0x54]
000142  990d              LDR      r1,[sp,#0x34]
000144  1e49              SUBS     r1,r1,#1
000146  3008              ADDS     r0,r0,#8
000148  910d              STR      r1,[sp,#0x34]
                  |L1.330|
00014a  2900              CMP      r1,#0                 ;102
00014c  f47faf70          BNE      |L1.48|
;;;235      }
;;;236    
;;;237      /* If the blockSize is not a multiple of 2, compute any remaining output samples here.        
;;;238       ** No loop unrolling is used. */
;;;239      blkCnt = blkCntN2;
;;;240    
;;;241      /* Loop over the blockSize. */
;;;242      while(blkCnt > 0u)
000150  f8dd9048          LDR      r9,[sp,#0x48]
000154  e05c              B        |L1.528|
                  |L1.342|
;;;243      {
;;;244        /* Copy new input sample into the state buffer */
;;;245        *pStateCurnt++ = *pSrc++;
000156  9914              LDR      r1,[sp,#0x50]
;;;246    
;;;247        /* Address modifier index of coefficient buffer */
;;;248        j = 1u;
000158  f04f0b01          MOV      r11,#1
00015c  680a              LDR      r2,[r1,#0]            ;245
00015e  990c              LDR      r1,[sp,#0x30]         ;245
000160  600a              STR      r2,[r1,#0]            ;245
000162  9914              LDR      r1,[sp,#0x50]         ;245
000164  1d09              ADDS     r1,r1,#4              ;245
000166  9114              STR      r1,[sp,#0x50]         ;245
000168  990c              LDR      r1,[sp,#0x30]         ;245
00016a  1d09              ADDS     r1,r1,#4              ;245
;;;249    
;;;250        /* Loop over the Interpolation factor. */
;;;251        i = S->L;
00016c  910c              STR      r1,[sp,#0x30]
00016e  f89a1000          LDRB     r1,[r10,#0]
;;;252        while(i > 0u)
000172  e047              B        |L1.516|
                  |L1.372|
;;;253        {
;;;254          /* Set accumulator to zero */
;;;255          sum0 = 0;
;;;256    
;;;257          /* Initialize state pointer */
;;;258          ptr1 = pState;
;;;259    
;;;260          /* Initialize coefficient pointer */
;;;261          ptr2 = pCoeffs + (S->L - j);
000174  f89a4000          LDRB     r4,[r10,#0]
000178  9d11              LDR      r5,[sp,#0x44]
00017a  eba4060b          SUB      r6,r4,r11
00017e  eb050686          ADD      r6,r5,r6,LSL #2
000182  2100              MOVS     r1,#0                 ;252
;;;262    
;;;263          /* Loop over the polyPhase length. Unroll by a factor of 4.        
;;;264           ** Repeat until we've computed numTaps-(4*S->L) coefficients. */
;;;265          tapCnt = phaseLen >> 2;
000184  9d0b              LDR      r5,[sp,#0x2c]
000186  460a              MOV      r2,r1                 ;252
000188  4603              MOV      r3,r0                 ;258
00018a  08ad              LSRS     r5,r5,#2
;;;266          while(tapCnt > 0u)
00018c  e01d              B        |L1.458|
                  |L1.398|
;;;267          {
;;;268    
;;;269            /* Read the coefficient */
;;;270            c0 = *(ptr2);
;;;271    
;;;272            /* Upsampling is done by stuffing L-1 zeros between each sample.        
;;;273             * So instead of multiplying zeros with coefficients,        
;;;274             * Increment the coefficient pointer by interpolation factor times. */
;;;275            ptr2 += S->L;
00018e  6837              LDR      r7,[r6,#0]
;;;276    
;;;277            /* Read the input sample */
;;;278            x0 = *(ptr1++);
000190  f853cb04          LDR      r12,[r3],#4
000194  eb060684          ADD      r6,r6,r4,LSL #2       ;275
;;;279    
;;;280            /* Perform the multiply-accumulate */
;;;281            sum0 += (q63_t) x0 *c0;
000198  fbcc1207          SMLAL    r1,r2,r12,r7
;;;282    
;;;283            /* Read the coefficient */
;;;284            c0 = *(ptr2);
;;;285    
;;;286            /* Increment the coefficient pointer by interpolation factor times. */
;;;287            ptr2 += S->L;
00019c  f8d6c000          LDR      r12,[r6,#0]
;;;288    
;;;289            /* Read the input sample */
;;;290            x0 = *(ptr1++);
0001a0  cb80              LDM      r3!,{r7}
0001a2  eb060684          ADD      r6,r6,r4,LSL #2       ;287
;;;291    
;;;292            /* Perform the multiply-accumulate */
;;;293            sum0 += (q63_t) x0 *c0;
0001a6  fbc7120c          SMLAL    r1,r2,r7,r12
;;;294    
;;;295            /* Read the coefficient */
;;;296            c0 = *(ptr2);
;;;297    
;;;298            /* Increment the coefficient pointer by interpolation factor times. */
;;;299            ptr2 += S->L;
0001aa  6837              LDR      r7,[r6,#0]
;;;300    
;;;301            /* Read the input sample */
;;;302            x0 = *(ptr1++);
0001ac  f853cb04          LDR      r12,[r3],#4
0001b0  eb060684          ADD      r6,r6,r4,LSL #2       ;299
;;;303    
;;;304            /* Perform the multiply-accumulate */
;;;305            sum0 += (q63_t) x0 *c0;
0001b4  fbcc1207          SMLAL    r1,r2,r12,r7
;;;306    
;;;307            /* Read the coefficient */
;;;308            c0 = *(ptr2);
;;;309    
;;;310            /* Increment the coefficient pointer by interpolation factor times. */
;;;311            ptr2 += S->L;
0001b8  6837              LDR      r7,[r6,#0]
;;;312    
;;;313            /* Read the input sample */
;;;314            x0 = *(ptr1++);
0001ba  f853cb04          LDR      r12,[r3],#4
;;;315    
;;;316            /* Perform the multiply-accumulate */
;;;317            sum0 += (q63_t) x0 *c0;
0001be  1e6d              SUBS     r5,r5,#1
0001c0  fbcc1207          SMLAL    r1,r2,r12,r7
0001c4  eb060684          ADD      r6,r6,r4,LSL #2       ;311
;;;318    
;;;319            /* Decrement the loop counter */
;;;320            tapCnt--;
0001c8  b2ad              UXTH     r5,r5
                  |L1.458|
0001ca  2d00              CMP      r5,#0                 ;266
0001cc  d1df              BNE      |L1.398|
;;;321          }
;;;322    
;;;323          /* If the polyPhase length is not a multiple of 4, compute the remaining filter taps */
;;;324          tapCnt = phaseLen & 0x3u;
0001ce  9d0b              LDR      r5,[sp,#0x2c]
0001d0  f0050503          AND      r5,r5,#3
;;;325    
;;;326          while(tapCnt > 0u)
0001d4  e008              B        |L1.488|
                  |L1.470|
;;;327          {
;;;328            /* Read the coefficient */
;;;329            c0 = *(ptr2);
;;;330    
;;;331            /* Increment the coefficient pointer by interpolation factor times. */
;;;332            ptr2 += S->L;
0001d6  6837              LDR      r7,[r6,#0]
;;;333    
;;;334            /* Read the input sample */
;;;335            x0 = *(ptr1++);
0001d8  f853cb04          LDR      r12,[r3],#4
;;;336    
;;;337            /* Perform the multiply-accumulate */
;;;338            sum0 += (q63_t) x0 *c0;
0001dc  1e6d              SUBS     r5,r5,#1
0001de  fbcc1207          SMLAL    r1,r2,r12,r7
0001e2  eb060684          ADD      r6,r6,r4,LSL #2       ;332
;;;339    
;;;340            /* Decrement the loop counter */
;;;341            tapCnt--;
0001e6  b2ad              UXTH     r5,r5
                  |L1.488|
0001e8  2d00              CMP      r5,#0                 ;326
0001ea  d1f4              BNE      |L1.470|
;;;342          }
;;;343    
;;;344          /* The result is in the accumulator, store in the destination buffer. */
;;;345          *pDst++ = (q31_t) (sum0 >> 31);
0001ec  0fc9              LSRS     r1,r1,#31
0001ee  ea410142          ORR      r1,r1,r2,LSL #1
0001f2  9a15              LDR      r2,[sp,#0x54]
;;;346    
;;;347          /* Increment the address modifier index of coefficient buffer */
;;;348          j++;
0001f4  f10b0b01          ADD      r11,r11,#1
0001f8  6011              STR      r1,[r2,#0]            ;345
0001fa  9915              LDR      r1,[sp,#0x54]         ;345
0001fc  1d09              ADDS     r1,r1,#4              ;345
;;;349    
;;;350          /* Decrement the loop counter */
;;;351          i--;
0001fe  9115              STR      r1,[sp,#0x54]
000200  f1a80101          SUB      r1,r8,#1
                  |L1.516|
000204  ea5f0801          MOVS     r8,r1                 ;251
000208  d1b4              BNE      |L1.372|
;;;352        }
;;;353    
;;;354        /* Advance the state pointer by 1        
;;;355         * to process the next group of interpolation factor number samples */
;;;356        pState = pState + 1;
;;;357    
;;;358        /* Decrement the loop counter */
;;;359        blkCnt--;
00020a  f1a90901          SUB      r9,r9,#1
00020e  1d00              ADDS     r0,r0,#4
                  |L1.528|
000210  f1b90f00          CMP      r9,#0                 ;242
000214  d19f              BNE      |L1.342|
;;;360      }
;;;361    
;;;362      /* Processing is complete.        
;;;363       ** Now copy the last phaseLen - 1 samples to the satrt of the state buffer.        
;;;364       ** This prepares the state buffer for the next function call. */
;;;365    
;;;366      /* Points to the start of the state buffer */
;;;367      pStateCurnt = S->pState;
;;;368    
;;;369      tapCnt = (phaseLen - 1u) >> 2u;
000216  9b0b              LDR      r3,[sp,#0x2c]
000218  f8da1008          LDR      r1,[r10,#8]
00021c  1e5b              SUBS     r3,r3,#1
00021e  f3c3028f          UBFX     r2,r3,#2,#16
;;;370    
;;;371      /* copy data */
;;;372      while(tapCnt > 0u)
000222  e00d              B        |L1.576|
                  |L1.548|
;;;373      {
;;;374        *pStateCurnt++ = *pState++;
000224  c810              LDM      r0!,{r4}
;;;375        *pStateCurnt++ = *pState++;
;;;376        *pStateCurnt++ = *pState++;
;;;377        *pStateCurnt++ = *pState++;
000226  1e52              SUBS     r2,r2,#1
000228  c110              STM      r1!,{r4}              ;374
00022a  c810              LDM      r0!,{r4}              ;375
;;;378    
;;;379        /* Decrement the loop counter */
;;;380        tapCnt--;
00022c  b292              UXTH     r2,r2
00022e  c110              STM      r1!,{r4}              ;375
000230  f8504b08          LDR      r4,[r0],#8            ;376
000234  f8414b08          STR      r4,[r1],#8            ;376
000238  f8504c04          LDR      r4,[r0,#-4]           ;377
00023c  f8414c04          STR      r4,[r1,#-4]           ;377
                  |L1.576|
000240  2a00              CMP      r2,#0                 ;372
000242  d1ef              BNE      |L1.548|
;;;381      }
;;;382    
;;;383      tapCnt = (phaseLen - 1u) % 0x04u;
000244  f0030203          AND      r2,r3,#3
;;;384    
;;;385      /* copy data */
;;;386      while(tapCnt > 0u)
000248  e003              B        |L1.594|
                  |L1.586|
;;;387      {
;;;388        *pStateCurnt++ = *pState++;
00024a  c808              LDM      r0!,{r3}
00024c  1e52              SUBS     r2,r2,#1
00024e  c108              STM      r1!,{r3}
;;;389    
;;;390        /* Decrement the loop counter */
;;;391        tapCnt--;
000250  b292              UXTH     r2,r2
                  |L1.594|
000252  2a00              CMP      r2,#0                 ;386
000254  d1f9              BNE      |L1.586|
;;;392      }
;;;393    
;;;394    }
000256  b017              ADD      sp,sp,#0x5c
000258  e8bd8ff0          POP      {r4-r11,pc}
;;;395    
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\FilteringFunctions\\arm_fir_interpolate_q31.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___25_arm_fir_interpolate_q31_c_34175ccb____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___25_arm_fir_interpolate_q31_c_34175ccb____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___25_arm_fir_interpolate_q31_c_34175ccb____REVSH|
#line 144
|__asm___25_arm_fir_interpolate_q31_c_34175ccb____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___25_arm_fir_interpolate_q31_c_34175ccb____RRX|
#line 300
|__asm___25_arm_fir_interpolate_q31_c_34175ccb____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
