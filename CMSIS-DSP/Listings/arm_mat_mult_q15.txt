; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_mat_mult_q15.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_mat_mult_q15.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_mat_mult_q15.crf src\MatrixFunctions\arm_mat_mult_q15.c]
                          THUMB

                          AREA ||i.arm_mat_mult_q15||, CODE, READONLY, ALIGN=2

                  arm_mat_mult_q15 PROC
;;;78     
;;;79     arm_status arm_mat_mult_q15(
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;80       const arm_matrix_instance_q15 * pSrcA,
;;;81       const arm_matrix_instance_q15 * pSrcB,
;;;82       arm_matrix_instance_q15 * pDst,
;;;83       q15_t * pState CMSIS_UNUSED)
;;;84     {
000004  4681              MOV      r9,r0
000006  b086              SUB      sp,sp,#0x18
000008  4693              MOV      r11,r2
;;;85       q63_t sum;                                     /* accumulator */
;;;86     
;;;87     #ifndef ARM_MATH_CM0_FAMILY
;;;88     
;;;89       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;90     
;;;91       q15_t *pSrcBT = pState;                        /* input data matrix pointer for transpose */
;;;92       q15_t *pInA = pSrcA->pData;                    /* input data matrix pointer A of Q15 type */
;;;93       q15_t *pInB = pSrcB->pData;                    /* input data matrix pointer B of Q15 type */
;;;94       q15_t *px;                                     /* Temporary output data matrix pointer */
;;;95       uint16_t numRowsA = pSrcA->numRows;            /* number of rows of input matrix A    */
00000a  f8b9a000          LDRH     r10,[r9,#0]
;;;96       uint16_t numColsB = pSrcB->numCols;            /* number of columns of input matrix B */
00000e  884e              LDRH     r6,[r1,#2]
;;;97       uint16_t numColsA = pSrcA->numCols;            /* number of columns of input matrix A */
000010  f8b92002          LDRH     r2,[r9,#2]
000014  6848              LDR      r0,[r1,#4]
;;;98       uint16_t numRowsB = pSrcB->numRows;            /* number of rows of input matrix A    */
000016  9202              STR      r2,[sp,#8]
000018  8809              LDRH     r1,[r1,#0]
;;;99       uint16_t col, i = 0u, row = numRowsB, colCnt;  /* loop counters */
00001a  2500              MOVS     r5,#0
00001c  4688              MOV      r8,r1
;;;100      arm_status status;                             /* status of matrix multiplication */
;;;101    
;;;102    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;103    
;;;104      q31_t in;                                      /* Temporary variable to hold the input value */
;;;105      q31_t pSourceA1, pSourceB1, pSourceA2, pSourceB2;
;;;106    
;;;107    #else
;;;108    
;;;109      q15_t in;                                      /* Temporary variable to hold the input value */
;;;110      q15_t inA1, inB1, inA2, inB2;
;;;111    
;;;112    #endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE	*/
;;;113    
;;;114    #ifdef ARM_MATH_MATRIX_CHECK
;;;115      /* Check for matrix mismatch condition */
;;;116      if((pSrcA->numCols != pSrcB->numRows) ||
;;;117         (pSrcA->numRows != pDst->numRows) || (pSrcB->numCols != pDst->numCols))
;;;118      {
;;;119        /* Set status as ARM_MATH_SIZE_MISMATCH */
;;;120        status = ARM_MATH_SIZE_MISMATCH;
;;;121      }
;;;122      else
;;;123    #endif /*    #ifdef ARM_MATH_MATRIX_CHECK    */
;;;124      {
;;;125        /* Matrix transpose */
;;;126        do
;;;127        {
;;;128          /* Apply loop unrolling and exchange the columns with row elements */
;;;129          col = numColsB >> 2;
00001e  ea4f0c96          LSR      r12,r6,#2
                  |L1.34|
000022  4664              MOV      r4,r12
;;;130    
;;;131          /* The pointer px is set to starting address of the column being processed */
;;;132          px = pSrcBT + i;
000024  eb030245          ADD      r2,r3,r5,LSL #1
;;;133    
;;;134          /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.        
;;;135           ** a second loop below computes the remaining 1 to 3 samples. */
;;;136          while(col > 0u)
000028  e014              B        |L1.84|
;;;137          {
;;;138    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;139    
;;;140            /* Read two elements from the row */
;;;141            in = *__SIMD32(pInB)++;
00002a  bf00              NOP      
                  |L1.44|
00002c  f8507b04          LDR      r7,[r0],#4
;;;142    
;;;143            /* Unpack and store one element in the destination */
;;;144    #ifndef ARM_MATH_BIG_ENDIAN
;;;145    
;;;146            *px = (q15_t) in;
000030  8017              STRH     r7,[r2,#0]
;;;147    
;;;148    #else
;;;149    
;;;150            *px = (q15_t) ((in & (q31_t) 0xffff0000) >> 16);
;;;151    
;;;152    #endif /*    #ifndef ARM_MATH_BIG_ENDIAN    */
;;;153    
;;;154            /* Update the pointer px to point to the next row of the transposed matrix */
;;;155            px += numRowsB;
000032  eb020241          ADD      r2,r2,r1,LSL #1
;;;156    
;;;157            /* Unpack and store the second element in the destination */
;;;158    #ifndef ARM_MATH_BIG_ENDIAN
;;;159    
;;;160            *px = (q15_t) ((in & (q31_t) 0xffff0000) >> 16);
000036  143f              ASRS     r7,r7,#16
000038  8017              STRH     r7,[r2,#0]
;;;161    
;;;162    #else
;;;163    
;;;164            *px = (q15_t) in;
;;;165    
;;;166    #endif /*    #ifndef ARM_MATH_BIG_ENDIAN    */
;;;167    
;;;168            /* Update the pointer px to point to the next row of the transposed matrix */
;;;169            px += numRowsB;
00003a  eb020741          ADD      r7,r2,r1,LSL #1
;;;170    
;;;171            /* Read two elements from the row */
;;;172            in = *__SIMD32(pInB)++;
00003e  f8502b04          LDR      r2,[r0],#4
;;;173    
;;;174            /* Unpack and store one element in the destination */
;;;175    #ifndef ARM_MATH_BIG_ENDIAN
;;;176    
;;;177            *px = (q15_t) in;
000042  803a              STRH     r2,[r7,#0]
;;;178    
;;;179    #else
;;;180    
;;;181            *px = (q15_t) ((in & (q31_t) 0xffff0000) >> 16);
;;;182    
;;;183    #endif /*    #ifndef ARM_MATH_BIG_ENDIAN    */
;;;184    
;;;185            /* Update the pointer px to point to the next row of the transposed matrix */
;;;186            px += numRowsB;
;;;187    
;;;188            /* Unpack and store the second element in the destination */
;;;189    
;;;190    #ifndef ARM_MATH_BIG_ENDIAN
;;;191    
;;;192            *px = (q15_t) ((in & (q31_t) 0xffff0000) >> 16);
000044  1412              ASRS     r2,r2,#16
000046  eb070741          ADD      r7,r7,r1,LSL #1       ;186
;;;193    
;;;194    #else
;;;195    
;;;196            *px = (q15_t) in;
;;;197    
;;;198    #endif /*    #ifndef ARM_MATH_BIG_ENDIAN    */
;;;199    
;;;200            /* Update the pointer px to point to the next row of the transposed matrix */
;;;201            px += numRowsB;
00004a  1e64              SUBS     r4,r4,#1
00004c  803a              STRH     r2,[r7,#0]            ;192
00004e  eb070241          ADD      r2,r7,r1,LSL #1
;;;202    
;;;203    #else
;;;204    
;;;205            /* Read one element from the row */
;;;206            in = *pInB++;
;;;207    
;;;208            /* Store one element in the destination */
;;;209            *px = in;
;;;210     
;;;211            /* Update the pointer px to point to the next row of the transposed matrix */
;;;212            px += numRowsB;
;;;213    
;;;214            /* Read one element from the row */
;;;215            in = *pInB++;
;;;216    
;;;217            /* Store one element in the destination */
;;;218            *px = in;
;;;219     
;;;220            /* Update the pointer px to point to the next row of the transposed matrix */
;;;221            px += numRowsB;
;;;222    
;;;223            /* Read one element from the row */
;;;224            in = *pInB++;
;;;225    
;;;226            /* Store one element in the destination */
;;;227            *px = in;
;;;228     
;;;229            /* Update the pointer px to point to the next row of the transposed matrix */
;;;230            px += numRowsB;
;;;231    
;;;232            /* Read one element from the row */
;;;233            in = *pInB++;
;;;234    
;;;235            /* Store one element in the destination */
;;;236            *px = in;
;;;237     
;;;238            /* Update the pointer px to point to the next row of the transposed matrix */
;;;239            px += numRowsB;
;;;240    
;;;241    #endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE	*/
;;;242    
;;;243           /* Decrement the column loop counter */
;;;244            col--;
000052  b2a4              UXTH     r4,r4
                  |L1.84|
000054  2c00              CMP      r4,#0                 ;136
000056  d1e9              BNE      |L1.44|
;;;245          }
;;;246    
;;;247          /* If the columns of pSrcB is not a multiple of 4, compute any remaining output samples here.        
;;;248           ** No loop unrolling is used. */
;;;249          col = numColsB % 0x4u;
000058  f0060403          AND      r4,r6,#3
;;;250    
;;;251          while(col > 0u)
00005c  e007              B        |L1.110|
;;;252          {
;;;253            /* Read and store the input element in the destination */
;;;254            *px = *pInB++;
00005e  bf00              NOP      
                  |L1.96|
000060  f8307b02          LDRH     r7,[r0],#2
000064  8017              STRH     r7,[r2,#0]
;;;255    
;;;256            /* Update the pointer px to point to the next row of the transposed matrix */
;;;257            px += numRowsB;
000066  1e64              SUBS     r4,r4,#1
000068  eb020241          ADD      r2,r2,r1,LSL #1
;;;258    
;;;259            /* Decrement the column loop counter */
;;;260            col--;
00006c  b2a4              UXTH     r4,r4
                  |L1.110|
00006e  2c00              CMP      r4,#0                 ;251
000070  d1f6              BNE      |L1.96|
000072  1c6d              ADDS     r5,r5,#1              ;251
;;;261          }
;;;262    
;;;263          i++;
;;;264    
;;;265          /* Decrement the row loop counter */
;;;266          row--;
000074  f1a80201          SUB      r2,r8,#1
000078  b292              UXTH     r2,r2
00007a  b2ad              UXTH     r5,r5                 ;263
00007c  ea5f0802          MOVS     r8,r2
;;;267    
;;;268        } while(row > 0u);
000080  d1cf              BNE      |L1.34|
;;;269    
;;;270        /* Reset the variables for the usage in the following multiplication process */
;;;271        row = numRowsA;
;;;272        i = 0u;
;;;273        px = pDst->pData;
000082  f8cda00c          STR      r10,[sp,#0xc]
000086  f8db0004          LDR      r0,[r11,#4]
00008a  9004              STR      r0,[sp,#0x10]         ;97
;;;274    
;;;275        /* The following loop performs the dot-product of each row in pSrcA with each column in pSrcB */
;;;276        /* row loop */
;;;277        do
;;;278        {
;;;279          /* For every row wise process, the column loop counter is to be initiated */
;;;280          col = numColsB;
;;;281    
;;;282          /* For every row wise process, the pIn2 pointer is set        
;;;283           ** to the starting address of the transposed pSrcB data */
;;;284          pInB = pSrcBT;
;;;285    
;;;286          /* column loop */
;;;287          do
;;;288          {
;;;289            /* Set the variable sum, that acts as accumulator, to zero */
;;;290            sum = 0;
;;;291    
;;;292            /* Apply loop unrolling and compute 2 MACs simultaneously. */
;;;293            colCnt = numColsA >> 2;
00008c  9802              LDR      r0,[sp,#8]
00008e  2700              MOVS     r7,#0                 ;272
000090  0880              LSRS     r0,r0,#2
000092  9005              STR      r0,[sp,#0x14]
                  |L1.148|
000094  46b2              MOV      r10,r6                ;280
000096  461c              MOV      r4,r3                 ;284
                  |L1.152|
;;;294    
;;;295            /* Initiate the pointer pIn1 to point to the starting address of the column being processed */
;;;296            pInA = pSrcA->pData + i;
000098  f8d92004          LDR      r2,[r9,#4]
00009c  2000              MOVS     r0,#0                 ;284
00009e  4601              MOV      r1,r0                 ;284
0000a0  9d05              LDR      r5,[sp,#0x14]
0000a2  eb020247          ADD      r2,r2,r7,LSL #1
;;;297    
;;;298    
;;;299            /* matrix multiplication */
;;;300            while(colCnt > 0u)
0000a6  e013              B        |L1.208|
                  |L1.168|
;;;301            {
;;;302              /* c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n) */
;;;303    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;304    
;;;305              /* read real and imag values from pSrcA and pSrcB buffer */
;;;306              pSourceA1 = *__SIMD32(pInA)++;
0000a8  f852eb04          LDR      lr,[r2],#4
;;;307              pSourceB1 = *__SIMD32(pInB)++;
0000ac  f854bb04          LDR      r11,[r4],#4
;;;308    
;;;309              pSourceA2 = *__SIMD32(pInA)++;
0000b0  f8528b04          LDR      r8,[r2],#4
;;;310              pSourceB2 = *__SIMD32(pInB)++;
0000b4  f8cd8004          STR      r8,[sp,#4]
0000b8  f854cb04          LDR      r12,[r4],#4
;;;311    
;;;312              /* Multiply and Accumlates */
;;;313              sum = __SMLALD(pSourceA1, pSourceB1, sum);
0000bc  fbce01cb          SMLALD   r0,r1,lr,r11
0000c0  f8cdc000          STR      r12,[sp,#0]
0000c4  e9dd8c00          LDRD     r8,r12,[sp,#0]
;;;314              sum = __SMLALD(pSourceA2, pSourceB2, sum);
0000c8  fbcc01c8          SMLALD   r0,r1,r12,r8
0000cc  1e6d              SUBS     r5,r5,#1
;;;315    
;;;316    #else
;;;317              /* read real and imag values from pSrcA and pSrcB buffer */
;;;318              inA1 = *pInA++;
;;;319              inB1 = *pInB++;
;;;320              inA2 = *pInA++;
;;;321              /* Multiply and Accumlates */
;;;322              sum += inA1 * inB1;
;;;323              inB2 = *pInB++;
;;;324    
;;;325              inA1 = *pInA++;
;;;326              inB1 = *pInB++;
;;;327              /* Multiply and Accumlates */
;;;328              sum += inA2 * inB2;
;;;329              inA2 = *pInA++;
;;;330              inB2 = *pInB++;
;;;331    
;;;332              /* Multiply and Accumlates */
;;;333              sum += inA1 * inB1;
;;;334              sum += inA2 * inB2;
;;;335    
;;;336    #endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE	*/
;;;337    
;;;338              /* Decrement the loop counter */
;;;339              colCnt--;
0000ce  b2ad              UXTH     r5,r5
                  |L1.208|
0000d0  2d00              CMP      r5,#0                 ;300
0000d2  d1e9              BNE      |L1.168|
;;;340            }
;;;341    
;;;342            /* process remaining column samples */
;;;343            colCnt = numColsA & 3u;
0000d4  9d02              LDR      r5,[sp,#8]
0000d6  f0050503          AND      r5,r5,#3
;;;344    
;;;345            while(colCnt > 0u)
0000da  e007              B        |L1.236|
                  |L1.220|
;;;346            {
;;;347              /* c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n) */
;;;348              sum += *pInA++ * *pInB++;
0000dc  f9328b02          LDRSH    r8,[r2],#2
0000e0  f934cb02          LDRSH    r12,[r4],#2
0000e4  fbc8018c          SMLALBB  r0,r1,r8,r12
0000e8  1e6d              SUBS     r5,r5,#1
;;;349    
;;;350              /* Decrement the loop counter */
;;;351              colCnt--;
0000ea  b2ad              UXTH     r5,r5
                  |L1.236|
0000ec  2d00              CMP      r5,#0                 ;345
0000ee  d1f5              BNE      |L1.220|
;;;352            }
;;;353    
;;;354            /* Saturate and store the result in the destination buffer */
;;;355            *px = (q15_t) (__SSAT((sum >> 15), 16));
0000f0  0bc0              LSRS     r0,r0,#15
0000f2  ea404041          ORR      r0,r0,r1,LSL #17
0000f6  f300010f          SSAT     r1,#16,r0
0000fa  9804              LDR      r0,[sp,#0x10]
0000fc  8001              STRH     r1,[r0,#0]
;;;356            px++;
0000fe  9804              LDR      r0,[sp,#0x10]
000100  1c80              ADDS     r0,r0,#2
;;;357    
;;;358            /* Decrement the column loop counter */
;;;359            col--;
000102  9004              STR      r0,[sp,#0x10]
000104  f1aa0001          SUB      r0,r10,#1
000108  b280              UXTH     r0,r0
00010a  ea5f0a00          MOVS     r10,r0
;;;360    
;;;361          } while(col > 0u);
00010e  d1c3              BNE      |L1.152|
;;;362    
;;;363          i = i + numColsA;
000110  9802              LDR      r0,[sp,#8]
000112  4438              ADD      r0,r0,r7
000114  b287              UXTH     r7,r0
;;;364    
;;;365          /* Decrement the row loop counter */
;;;366          row--;
000116  9803              LDR      r0,[sp,#0xc]
000118  1e40              SUBS     r0,r0,#1
00011a  0400              LSLS     r0,r0,#16
00011c  0c00              LSRS     r0,r0,#16
;;;367    
;;;368        } while(row > 0u);
00011e  9003              STR      r0,[sp,#0xc]
000120  d1b8              BNE      |L1.148|
;;;369    
;;;370    #else
;;;371    
;;;372      /* Run the below code for Cortex-M0 */
;;;373    
;;;374      q15_t *pIn1 = pSrcA->pData;                    /* input data matrix pointer A */
;;;375      q15_t *pIn2 = pSrcB->pData;                    /* input data matrix pointer B */
;;;376      q15_t *pInA = pSrcA->pData;                    /* input data matrix pointer A of Q15 type */
;;;377      q15_t *pInB = pSrcB->pData;                    /* input data matrix pointer B of Q15 type */
;;;378      q15_t *pOut = pDst->pData;                     /* output data matrix pointer */
;;;379      q15_t *px;                                     /* Temporary output data matrix pointer */
;;;380      uint16_t numColsB = pSrcB->numCols;            /* number of columns of input matrix B */
;;;381      uint16_t numColsA = pSrcA->numCols;            /* number of columns of input matrix A */
;;;382      uint16_t numRowsA = pSrcA->numRows;            /* number of rows of input matrix A    */
;;;383      uint16_t col, i = 0u, row = numRowsA, colCnt;  /* loop counters */
;;;384      arm_status status;                             /* status of matrix multiplication */
;;;385    
;;;386    #ifdef ARM_MATH_MATRIX_CHECK
;;;387    
;;;388      /* Check for matrix mismatch condition */
;;;389      if((pSrcA->numCols != pSrcB->numRows) ||
;;;390         (pSrcA->numRows != pDst->numRows) || (pSrcB->numCols != pDst->numCols))
;;;391      {
;;;392        /* Set status as ARM_MATH_SIZE_MISMATCH */
;;;393        status = ARM_MATH_SIZE_MISMATCH;
;;;394      }
;;;395      else
;;;396    #endif /*    #ifdef ARM_MATH_MATRIX_CHECK    */
;;;397    
;;;398      {
;;;399        /* The following loop performs the dot-product of each row in pSrcA with each column in pSrcB */
;;;400        /* row loop */
;;;401        do
;;;402        {
;;;403          /* Output pointer is set to starting address of the row being processed */
;;;404          px = pOut + i;
;;;405    
;;;406          /* For every row wise process, the column loop counter is to be initiated */
;;;407          col = numColsB;
;;;408    
;;;409          /* For every row wise process, the pIn2 pointer is set          
;;;410           ** to the starting address of the pSrcB data */
;;;411          pIn2 = pSrcB->pData;
;;;412    
;;;413          /* column loop */
;;;414          do
;;;415          {
;;;416            /* Set the variable sum, that acts as accumulator, to zero */
;;;417            sum = 0;
;;;418    
;;;419            /* Initiate the pointer pIn1 to point to the starting address of pSrcA */
;;;420            pIn1 = pInA;
;;;421    
;;;422            /* Matrix A columns number of MAC operations are to be performed */
;;;423            colCnt = numColsA;
;;;424    
;;;425            /* matrix multiplication */
;;;426            while(colCnt > 0u)
;;;427            {
;;;428              /* c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n) */
;;;429              /* Perform the multiply-accumulates */
;;;430              sum += (q31_t) * pIn1++ * *pIn2;
;;;431              pIn2 += numColsB;
;;;432    
;;;433              /* Decrement the loop counter */
;;;434              colCnt--;
;;;435            }
;;;436    
;;;437            /* Convert the result from 34.30 to 1.15 format and store the saturated value in destination buffer */
;;;438            /* Saturate and store the result in the destination buffer */
;;;439            *px++ = (q15_t) __SSAT((sum >> 15), 16);
;;;440    
;;;441            /* Decrement the column loop counter */
;;;442            col--;
;;;443    
;;;444            /* Update the pointer pIn2 to point to the  starting address of the next column */
;;;445            pIn2 = pInB + (numColsB - col);
;;;446    
;;;447          } while(col > 0u);
;;;448    
;;;449          /* Update the pointer pSrcA to point to the  starting address of the next row */
;;;450          i = i + numColsB;
;;;451          pInA = pInA + numColsA;
;;;452    
;;;453          /* Decrement the row loop counter */
;;;454          row--;
;;;455    
;;;456        } while(row > 0u);
;;;457    
;;;458    #endif /* #ifndef ARM_MATH_CM0_FAMILY */
;;;459        /* set status as ARM_MATH_SUCCESS */
;;;460        status = ARM_MATH_SUCCESS;
;;;461      }
;;;462    
;;;463      /* Return to application */
;;;464      return (status);
;;;465    }
000122  b006              ADD      sp,sp,#0x18
000124  e8bd8ff0          POP      {r4-r11,pc}
;;;466    
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\MatrixFunctions\\arm_mat_mult_q15.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_mat_mult_q15_c_6512b3d9____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___18_arm_mat_mult_q15_c_6512b3d9____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_mat_mult_q15_c_6512b3d9____REVSH|
#line 144
|__asm___18_arm_mat_mult_q15_c_6512b3d9____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_mat_mult_q15_c_6512b3d9____RRX|
#line 300
|__asm___18_arm_mat_mult_q15_c_6512b3d9____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
