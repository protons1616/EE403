; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_conv_fast_opt_q15.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_conv_fast_opt_q15.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_conv_fast_opt_q15.crf src\FilteringFunctions\arm_conv_fast_opt_q15.c]
                          THUMB

                          AREA ||i.arm_conv_fast_opt_q15||, CODE, READONLY, ALIGN=2

                  arm_conv_fast_opt_q15 PROC
;;;82     
;;;83     void arm_conv_fast_opt_q15(
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;84       q15_t * pSrcA,
;;;85       uint32_t srcALen,
;;;86       q15_t * pSrcB,
;;;87       uint32_t srcBLen,
;;;88       q15_t * pDst,
;;;89       q15_t * pScratch1,
;;;90       q15_t * pScratch2)
;;;91     {
000004  b087              SUB      sp,sp,#0x1c
000006  460f              MOV      r7,r1
000008  461d              MOV      r5,r3
;;;92       q31_t acc0, acc1, acc2, acc3;                  /* Accumulators */
;;;93       q31_t x1, x2, x3;                              /* Temporary variables to hold state and coefficient values */
;;;94       q31_t y1, y2;                                  /* State variables */
;;;95       q15_t *pOut = pDst;                            /* output pointer */
00000a  9c12              LDR      r4,[sp,#0x48]
00000c  9910              LDR      r1,[sp,#0x40]
;;;96       q15_t *pScr1 = pScratch1;                      /* Temporary pointer for scratch1 */
;;;97       q15_t *pScr2 = pScratch2;                      /* Temporary pointer for scratch1 */
;;;98       q15_t *pIn1;                                   /* inputA pointer */
;;;99       q15_t *pIn2;                                   /* inputB pointer */
;;;100      q15_t *px;                                     /* Intermediate inputA pointer  */
;;;101      q15_t *py;                                     /* Intermediate inputB pointer  */
;;;102      uint32_t j, k, blkCnt;                         /* loop counter */
;;;103      uint32_t tapCnt;                               /* loop count */
;;;104    #ifdef UNALIGNED_SUPPORT_DISABLE
;;;105    
;;;106      q15_t a, b;
;;;107    
;;;108    #endif	/*	#ifdef UNALIGNED_SUPPORT_DISABLE	*/
;;;109    
;;;110      /* The algorithm implementation is based on the lengths of the inputs. */
;;;111      /* srcB is always made to slide across srcA. */
;;;112      /* So srcBLen is always considered as shorter or equal to srcALen */
;;;113      if(srcALen >= srcBLen)
00000e  9100              STR      r1,[sp,#0]
000010  42af              CMP      r7,r5
000012  d302              BCC      |L1.26|
;;;114      {
;;;115        /* Initialization of inputA pointer */
;;;116        pIn1 = pSrcA;
000014  4606              MOV      r6,r0
;;;117    
;;;118        /* Initialization of inputB pointer */
;;;119        pIn2 = pSrcB;
000016  4610              MOV      r0,r2
000018  e002              B        |L1.32|
                  |L1.26|
;;;120      }
;;;121      else
;;;122      {
;;;123        /* Initialization of inputA pointer */
;;;124        pIn1 = pSrcB;
;;;125    
;;;126        /* Initialization of inputB pointer */
;;;127        pIn2 = pSrcA;
;;;128    
;;;129        /* srcBLen is always considered as shorter or equal to srcALen */
;;;130        j = srcBLen;
;;;131        srcBLen = srcALen;
00001a  463d              MOV      r5,r7
00001c  4616              MOV      r6,r2                 ;124
;;;132        srcALen = j;
00001e  461f              MOV      r7,r3
                  |L1.32|
;;;133      }
;;;134    
;;;135      /* Pointer to take end of scratch2 buffer */
;;;136      pScr2 = pScratch2 + srcBLen - 1;
;;;137    
;;;138      /* points to smaller length sequence */
;;;139      px = pIn2;
;;;140    
;;;141      /* Apply loop unrolling and do 4 Copies simultaneously. */
;;;142      k = srcBLen >> 2u;
000020  08aa              LSRS     r2,r5,#2
000022  eb040145          ADD      r1,r4,r5,LSL #1       ;136
000026  1e89              SUBS     r1,r1,#2
;;;143    
;;;144      /* First part of the processing with loop unrolling copies 4 data points at a time.       
;;;145       ** a second loop below copies for the remaining 1 to 3 samples. */
;;;146    
;;;147      /* Copy smaller length input sequence in reverse order into second scratch buffer */
;;;148      while(k > 0u)
000028  9204              STR      r2,[sp,#0x10]
00002a  e010              B        |L1.78|
                  |L1.44|
;;;149      {
;;;150        /* copy second buffer in reversal manner */
;;;151        *pScr2-- = *px++;
00002c  f8303b02          LDRH     r3,[r0],#2
000030  800b              STRH     r3,[r1,#0]
;;;152        *pScr2-- = *px++;
000032  f830cb02          LDRH     r12,[r0],#2
000036  f821cc02          STRH     r12,[r1,#-2]
;;;153        *pScr2-- = *px++;
00003a  f830cb02          LDRH     r12,[r0],#2
00003e  f821cc04          STRH     r12,[r1,#-4]
;;;154        *pScr2-- = *px++;
000042  f830cb02          LDRH     r12,[r0],#2
000046  f821cc06          STRH     r12,[r1,#-6]
00004a  3908              SUBS     r1,r1,#8
00004c  1e52              SUBS     r2,r2,#1
                  |L1.78|
00004e  2a00              CMP      r2,#0                 ;148
000050  d1ec              BNE      |L1.44|
;;;155    
;;;156        /* Decrement the loop counter */
;;;157        k--;
;;;158      }
;;;159    
;;;160      /* If the count is not a multiple of 4, copy remaining samples here.       
;;;161       ** No loop unrolling is used. */
;;;162      k = srcBLen % 0x4u;
000052  f0050203          AND      r2,r5,#3
;;;163    
;;;164      while(k > 0u)
000056  9203              STR      r2,[sp,#0xc]
000058  e005              B        |L1.102|
;;;165      {
;;;166        /* copy second buffer in reversal manner for remaining samples */
;;;167        *pScr2-- = *px++;
00005a  bf00              NOP      
                  |L1.92|
00005c  f8303b02          LDRH     r3,[r0],#2
000060  f8213902          STRH     r3,[r1],#-2
000064  1e52              SUBS     r2,r2,#1
                  |L1.102|
000066  2a00              CMP      r2,#0                 ;164
000068  d1f8              BNE      |L1.92|
;;;168    
;;;169        /* Decrement the loop counter */
;;;170        k--;
;;;171      }
;;;172    
;;;173      /* Initialze temporary scratch pointer */
;;;174      pScr1 = pScratch1;
;;;175    
;;;176      /* Assuming scratch1 buffer is aligned by 32-bit */
;;;177      /* Fill (srcBLen - 1u) zeros in scratch1 buffer */
;;;178      arm_fill_q15(0, pScr1, (srcBLen - 1u));
00006a  f8dd8044          LDR      r8,[sp,#0x44]
00006e  1e6a              SUBS     r2,r5,#1
000070  4641              MOV      r1,r8
000072  2000              MOVS     r0,#0
000074  f7fffffe          BL       arm_fill_q15
;;;179    
;;;180      /* Update temporary scratch pointer */
;;;181      pScr1 += (srcBLen - 1u);
000078  eb080045          ADD      r0,r8,r5,LSL #1
00007c  1e80              SUBS     r0,r0,#2
00007e  4680              MOV      r8,r0
;;;182    
;;;183      /* Copy bigger length sequence(srcALen) samples in scratch1 buffer */
;;;184    
;;;185    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;186    
;;;187      /* Copy (srcALen) samples in scratch buffer */
;;;188      arm_copy_q15(pIn1, pScr1, srcALen);
000080  4601              MOV      r1,r0
000082  463a              MOV      r2,r7
000084  4630              MOV      r0,r6
000086  f7fffffe          BL       arm_copy_q15
;;;189    
;;;190      /* Update pointers */
;;;191      pScr1 += srcALen;
00008a  eb080147          ADD      r1,r8,r7,LSL #1
;;;192    
;;;193    #else
;;;194    
;;;195      /* Apply loop unrolling and do 4 Copies simultaneously. */
;;;196      k = srcALen >> 2u;
;;;197    
;;;198      /* First part of the processing with loop unrolling copies 4 data points at a time.       
;;;199       ** a second loop below copies for the remaining 1 to 3 samples. */
;;;200      while(k > 0u)
;;;201      {
;;;202        /* copy second buffer in reversal manner */
;;;203        *pScr1++ = *pIn1++;
;;;204        *pScr1++ = *pIn1++;
;;;205        *pScr1++ = *pIn1++;
;;;206        *pScr1++ = *pIn1++;
;;;207    
;;;208        /* Decrement the loop counter */
;;;209        k--;
;;;210      }
;;;211    
;;;212      /* If the count is not a multiple of 4, copy remaining samples here.       
;;;213       ** No loop unrolling is used. */
;;;214      k = srcALen % 0x4u;
;;;215    
;;;216      while(k > 0u)
;;;217      {
;;;218        /* copy second buffer in reversal manner for remaining samples */
;;;219        *pScr1++ = *pIn1++;
;;;220    
;;;221        /* Decrement the loop counter */
;;;222        k--;
;;;223      }
;;;224    
;;;225    #endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE	*/
;;;226    
;;;227    
;;;228    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;229    
;;;230      /* Fill (srcBLen - 1u) zeros at end of scratch buffer */
;;;231      arm_fill_q15(0, pScr1, (srcBLen - 1u));
00008e  1e6a              SUBS     r2,r5,#1
000090  2000              MOVS     r0,#0
000092  f7fffffe          BL       arm_fill_q15
;;;232    
;;;233      /* Update pointer */
;;;234      pScr1 += (srcBLen - 1u);
;;;235    
;;;236    #else
;;;237    
;;;238      /* Apply loop unrolling and do 4 Copies simultaneously. */
;;;239      k = (srcBLen - 1u) >> 2u;
;;;240    
;;;241      /* First part of the processing with loop unrolling copies 4 data points at a time.       
;;;242       ** a second loop below copies for the remaining 1 to 3 samples. */
;;;243      while(k > 0u)
;;;244      {
;;;245        /* copy second buffer in reversal manner */
;;;246        *pScr1++ = 0;
;;;247        *pScr1++ = 0;
;;;248        *pScr1++ = 0;
;;;249        *pScr1++ = 0;
;;;250    
;;;251        /* Decrement the loop counter */
;;;252        k--;
;;;253      }
;;;254    
;;;255      /* If the count is not a multiple of 4, copy remaining samples here.       
;;;256       ** No loop unrolling is used. */
;;;257      k = (srcBLen - 1u) % 0x4u;
;;;258    
;;;259      while(k > 0u)
;;;260      {
;;;261        /* copy second buffer in reversal manner for remaining samples */
;;;262        *pScr1++ = 0;
;;;263    
;;;264        /* Decrement the loop counter */
;;;265        k--;
;;;266      }
;;;267    
;;;268    #endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE	*/
;;;269    
;;;270      /* Temporary pointer for scratch2 */
;;;271      py = pScratch2;
;;;272    
;;;273    
;;;274      /* Initialization of pIn2 pointer */
;;;275      pIn2 = py;
;;;276    
;;;277      /* First part of the processing with loop unrolling process 4 data points at a time.       
;;;278       ** a second loop below process for the remaining 1 to 3 samples. */
;;;279    
;;;280      /* Actual convolution process starts here */
;;;281      blkCnt = (srcALen + srcBLen - 1u) >> 2;
000096  1978              ADDS     r0,r7,r5
000098  1e40              SUBS     r0,r0,#1
00009a  e9cd4001          STRD     r4,r0,[sp,#4]
00009e  ea4f0e90          LSR      lr,r0,#2
;;;282    
;;;283      while(blkCnt > 0)
0000a2  e05d              B        |L1.352|
                  |L1.164|
;;;284      {
;;;285        /* Initialze temporary scratch pointer as scratch1 */
;;;286        pScr1 = pScratch1;
;;;287    
;;;288        /* Clear Accumlators */
;;;289        acc0 = 0;
;;;290        acc1 = 0;
;;;291        acc2 = 0;
;;;292        acc3 = 0;
;;;293    
;;;294        /* Read two samples from scratch1 buffer */
;;;295        x1 = *__SIMD32(pScr1)++;
0000a4  9811              LDR      r0,[sp,#0x44]
0000a6  2300              MOVS     r3,#0                 ;289
0000a8  469c              MOV      r12,r3                ;290
0000aa  f8502b04          LDR      r2,[r0],#4
0000ae  4699              MOV      r9,r3                 ;291
0000b0  469a              MOV      r10,r3                ;292
;;;296    
;;;297        /* Read next two samples from scratch1 buffer */
;;;298        x2 = *__SIMD32(pScr1)++;
0000b2  f8501b04          LDR      r1,[r0],#4
;;;299    
;;;300        tapCnt = (srcBLen) >> 2u;
;;;301    
;;;302        while(tapCnt > 0u)
0000b6  9e04              LDR      r6,[sp,#0x10]
0000b8  e022              B        |L1.256|
;;;303        {
;;;304    
;;;305    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;306    
;;;307          /* Read four samples from smaller buffer */
;;;308          y1 = _SIMD32_OFFSET(pIn2);
0000ba  bf00              NOP      
                  |L1.188|
0000bc  f8547b04          LDR      r7,[r4],#4
;;;309          y2 = _SIMD32_OFFSET(pIn2 + 2u);
0000c0  f8546b04          LDR      r6,[r4],#4
;;;310    
;;;311          /* multiply and accumlate */
;;;312          acc0 = __SMLAD(x1, y1, acc0);
0000c4  fb223807          SMLAD    r8,r2,r7,r3
;;;313          acc2 = __SMLAD(x2, y1, acc2);
0000c8  fb219907          SMLAD    r9,r1,r7,r9
;;;314    
;;;315          /* pack input data */
;;;316    #ifndef ARM_MATH_BIG_ENDIAN
;;;317          x3 = __PKHBT(x2, x1, 0);
0000cc  eac10202          PKHBT    r2,r1,r2
;;;318    #else
;;;319          x3 = __PKHBT(x1, x2, 0);
;;;320    #endif
;;;321    
;;;322          /* multiply and accumlate */
;;;323          acc1 = __SMLADX(x3, y1, acc1);
0000d0  fb22cc17          SMLADX   r12,r2,r7,r12
;;;324    
;;;325          /* Read next two samples from scratch1 buffer */
;;;326          x1 = _SIMD32_OFFSET(pScr1);
0000d4  f8cdc014          STR      r12,[sp,#0x14]
0000d8  f8502b04          LDR      r2,[r0],#4
;;;327    
;;;328          /* multiply and accumlate */
;;;329          acc0 = __SMLAD(x2, y2, acc0);
0000dc  fb218306          SMLAD    r3,r1,r6,r8
;;;330          acc2 = __SMLAD(x1, y2, acc2);
0000e0  fb229906          SMLAD    r9,r2,r6,r9
;;;331    
;;;332          /* pack input data */
;;;333    #ifndef ARM_MATH_BIG_ENDIAN
;;;334          x3 = __PKHBT(x1, x2, 0);
0000e4  eac20101          PKHBT    r1,r2,r1
;;;335    #else
;;;336          x3 = __PKHBT(x2, x1, 0);
;;;337    #endif
;;;338    
;;;339          acc3 = __SMLADX(x3, y1, acc3);
0000e8  fb21a717          SMLADX   r7,r1,r7,r10
;;;340          acc1 = __SMLADX(x3, y2, acc1);
0000ec  fb21cc16          SMLADX   r12,r1,r6,r12
;;;341    
;;;342          x2 = _SIMD32_OFFSET(pScr1 + 2u);
0000f0  f8501b04          LDR      r1,[r0],#4
;;;343    
;;;344    #ifndef ARM_MATH_BIG_ENDIAN
;;;345          x3 = __PKHBT(x2, x1, 0);
0000f4  eac10802          PKHBT    r8,r1,r2
;;;346    #else
;;;347          x3 = __PKHBT(x1, x2, 0);
;;;348    #endif
;;;349    
;;;350          acc3 = __SMLADX(x3, y2, acc3);
0000f8  fb287a16          SMLADX   r10,r8,r6,r7
;;;351    
;;;352    #else	 
;;;353    
;;;354          /* Read four samples from smaller buffer */
;;;355    	  a = *pIn2;
;;;356    	  b = *(pIn2 + 1);
;;;357    
;;;358    #ifndef ARM_MATH_BIG_ENDIAN
;;;359          y1 = __PKHBT(a, b, 16);
;;;360    #else
;;;361          y1 = __PKHBT(b, a, 16);
;;;362    #endif
;;;363    	  
;;;364    	  a = *(pIn2 + 2);
;;;365    	  b = *(pIn2 + 3);
;;;366    #ifndef ARM_MATH_BIG_ENDIAN
;;;367          y2 = __PKHBT(a, b, 16);
;;;368    #else
;;;369          y2 = __PKHBT(b, a, 16);
;;;370    #endif				
;;;371    
;;;372          acc0 = __SMLAD(x1, y1, acc0);
;;;373    
;;;374          acc2 = __SMLAD(x2, y1, acc2);
;;;375    
;;;376    #ifndef ARM_MATH_BIG_ENDIAN
;;;377          x3 = __PKHBT(x2, x1, 0);
;;;378    #else
;;;379          x3 = __PKHBT(x1, x2, 0);
;;;380    #endif
;;;381    
;;;382          acc1 = __SMLADX(x3, y1, acc1);
;;;383    
;;;384    	  a = *pScr1;
;;;385    	  b = *(pScr1 + 1);
;;;386    
;;;387    #ifndef ARM_MATH_BIG_ENDIAN
;;;388          x1 = __PKHBT(a, b, 16);
;;;389    #else
;;;390          x1 = __PKHBT(b, a, 16);
;;;391    #endif
;;;392    
;;;393          acc0 = __SMLAD(x2, y2, acc0);
;;;394    
;;;395          acc2 = __SMLAD(x1, y2, acc2);
;;;396    
;;;397    #ifndef ARM_MATH_BIG_ENDIAN
;;;398          x3 = __PKHBT(x1, x2, 0);
;;;399    #else
;;;400          x3 = __PKHBT(x2, x1, 0);
;;;401    #endif
;;;402    
;;;403          acc3 = __SMLADX(x3, y1, acc3);
;;;404    
;;;405          acc1 = __SMLADX(x3, y2, acc1);
;;;406    
;;;407    	  a = *(pScr1 + 2);
;;;408    	  b = *(pScr1 + 3);
;;;409    
;;;410    #ifndef ARM_MATH_BIG_ENDIAN
;;;411          x2 = __PKHBT(a, b, 16);
;;;412    #else
;;;413          x2 = __PKHBT(b, a, 16);
;;;414    #endif
;;;415    
;;;416    #ifndef ARM_MATH_BIG_ENDIAN
;;;417          x3 = __PKHBT(x2, x1, 0);
;;;418    #else
;;;419          x3 = __PKHBT(x1, x2, 0);
;;;420    #endif
;;;421    
;;;422          acc3 = __SMLADX(x3, y2, acc3);
;;;423    
;;;424    #endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE	*/
;;;425    
;;;426          /* update scratch pointers */
;;;427          pIn2 += 4u;
;;;428          pScr1 += 4u;
;;;429    
;;;430    
;;;431          /* Decrement the loop counter */
;;;432          tapCnt--;
0000fc  f1ab0601          SUB      r6,r11,#1
                  |L1.256|
000100  ea5f0b06          MOVS     r11,r6                ;300
000104  d1da              BNE      |L1.188|
000106  3808              SUBS     r0,r0,#8              ;300
;;;433        }
;;;434    
;;;435        /* Update scratch pointer for remaining samples of smaller length sequence */
;;;436        pScr1 -= 4u;
;;;437    
;;;438        /* apply same above for remaining samples of smaller length sequence */
;;;439        tapCnt = (srcBLen) & 3u;
;;;440    
;;;441        while(tapCnt > 0u)
000108  9903              LDR      r1,[sp,#0xc]
00010a  e00f              B        |L1.300|
                  |L1.268|
;;;442        {
;;;443    
;;;444          /* accumlate the results */
;;;445          acc0 += (*pScr1++ * *pIn2);
00010c  f8306b02          LDRH     r6,[r0],#2
000110  f8342b02          LDRH     r2,[r4],#2
000114  fb163302          SMLABB   r3,r6,r2,r3
;;;446          acc1 += (*pScr1++ * *pIn2);
000118  8806              LDRH     r6,[r0,#0]
00011a  fb16cc02          SMLABB   r12,r6,r2,r12
;;;447          acc2 += (*pScr1++ * *pIn2);
00011e  8847              LDRH     r7,[r0,#2]
000120  fb179902          SMLABB   r9,r7,r2,r9
;;;448          acc3 += (*pScr1++ * *pIn2++);
000124  8887              LDRH     r7,[r0,#4]
000126  fb17aa02          SMLABB   r10,r7,r2,r10
00012a  1e49              SUBS     r1,r1,#1
                  |L1.300|
00012c  2900              CMP      r1,#0                 ;441
00012e  d1ed              BNE      |L1.268|
;;;449    
;;;450          pScr1 -= 3u;
;;;451    
;;;452          /* Decrement the loop counter */
;;;453          tapCnt--;
;;;454        }
;;;455    
;;;456        blkCnt--;
000130  f1ae0e01          SUB      lr,lr,#1
;;;457    
;;;458    
;;;459        /* Store the results in the accumulators in the destination buffer. */
;;;460    
;;;461    #ifndef ARM_MATH_BIG_ENDIAN
;;;462    
;;;463        *__SIMD32(pOut)++ =
000134  f32330cf          SSAT     r0,#16,r3,ASR #15
000138  f32c31cf          SSAT     r1,#16,r12,ASR #15
00013c  eac04101          PKHBT    r1,r0,r1,LSL #16
000140  9800              LDR      r0,[sp,#0]
;;;464          __PKHBT(__SSAT((acc0 >> 15), 16), __SSAT((acc1 >> 15), 16), 16);
;;;465    
;;;466        *__SIMD32(pOut)++ =
000142  f32932cf          SSAT     r2,#16,r9,ASR #15
000146  6001              STR      r1,[r0,#0]            ;463
000148  f32a31cf          SSAT     r1,#16,r10,ASR #15
00014c  eac24101          PKHBT    r1,r2,r1,LSL #16
000150  9800              LDR      r0,[sp,#0]
000152  6041              STR      r1,[r0,#4]
000154  3008              ADDS     r0,r0,#8
;;;467          __PKHBT(__SSAT((acc2 >> 15), 16), __SSAT((acc3 >> 15), 16), 16);
;;;468    
;;;469    
;;;470    #else
;;;471    
;;;472        *__SIMD32(pOut)++ =
;;;473          __PKHBT(__SSAT((acc1 >> 15), 16), __SSAT((acc0 >> 15), 16), 16);
;;;474    
;;;475        *__SIMD32(pOut)++ =
;;;476          __PKHBT(__SSAT((acc3 >> 15), 16), __SSAT((acc2 >> 15), 16), 16);
;;;477    
;;;478    
;;;479    
;;;480    #endif /*      #ifndef ARM_MATH_BIG_ENDIAN       */
;;;481    
;;;482        /* Initialization of inputB pointer */
;;;483        pIn2 = py;
000156  9000              STR      r0,[sp,#0]
;;;484    
;;;485        pScratch1 += 4u;
000158  9811              LDR      r0,[sp,#0x44]
00015a  9c01              LDR      r4,[sp,#4]
00015c  3008              ADDS     r0,r0,#8
00015e  9011              STR      r0,[sp,#0x44]
                  |L1.352|
000160  f1be0f00          CMP      lr,#0                 ;283
000164  d19e              BNE      |L1.164|
;;;486    
;;;487      }
;;;488    
;;;489    
;;;490      blkCnt = (srcALen + srcBLen - 1u) & 0x3;
000166  9802              LDR      r0,[sp,#8]
000168  f0000303          AND      r3,r0,#3
;;;491    
;;;492      /* Calculate convolution for remaining samples of Bigger length sequence */
;;;493      while(blkCnt > 0)
00016c  e02b              B        |L1.454|
                  |L1.366|
;;;494      {
;;;495        /* Initialze temporary scratch pointer as scratch1 */
;;;496        pScr1 = pScratch1;
;;;497    
;;;498        /* Clear Accumlators */
;;;499        acc0 = 0;
00016e  2100              MOVS     r1,#0
;;;500    
;;;501        tapCnt = (srcBLen) >> 1u;
000170  086a              LSRS     r2,r5,#1
;;;502    
;;;503        while(tapCnt > 0u)
000172  9811              LDR      r0,[sp,#0x44]
000174  e00d              B        |L1.402|
;;;504        {
;;;505    
;;;506          acc0 += (*pScr1++ * *pIn2++);
000176  bf00              NOP      
                  |L1.376|
000178  f8306b02          LDRH     r6,[r0],#2
00017c  f8347b02          LDRH     r7,[r4],#2
000180  fb161107          SMLABB   r1,r6,r7,r1
;;;507          acc0 += (*pScr1++ * *pIn2++);
000184  f8306b02          LDRH     r6,[r0],#2
000188  f8347b02          LDRH     r7,[r4],#2
00018c  fb161107          SMLABB   r1,r6,r7,r1
000190  1e52              SUBS     r2,r2,#1
                  |L1.402|
000192  2a00              CMP      r2,#0                 ;503
000194  d1f0              BNE      |L1.376|
;;;508    
;;;509          /* Decrement the loop counter */
;;;510          tapCnt--;
;;;511        }
;;;512    
;;;513        tapCnt = (srcBLen) & 1u;
000196  f0050201          AND      r2,r5,#1
;;;514    
;;;515        /* apply same above for remaining samples of smaller length sequence */
;;;516        while(tapCnt > 0u)
00019a  e006              B        |L1.426|
                  |L1.412|
;;;517        {
;;;518    
;;;519          /* accumlate the results */
;;;520          acc0 += (*pScr1++ * *pIn2++);
00019c  f8306b02          LDRH     r6,[r0],#2
0001a0  f8347b02          LDRH     r7,[r4],#2
0001a4  fb161107          SMLABB   r1,r6,r7,r1
0001a8  1e52              SUBS     r2,r2,#1
                  |L1.426|
0001aa  2a00              CMP      r2,#0                 ;516
0001ac  d1f6              BNE      |L1.412|
;;;521    
;;;522          /* Decrement the loop counter */
;;;523          tapCnt--;
;;;524        }
;;;525    
;;;526        blkCnt--;
;;;527    
;;;528        /* The result is in 2.30 format.  Convert to 1.15 with saturation.       
;;;529         ** Then store the output in the destination buffer. */
;;;530        *pOut++ = (q15_t) (__SSAT((acc0 >> 15), 16));
0001ae  9800              LDR      r0,[sp,#0]
0001b0  f32131cf          SSAT     r1,#16,r1,ASR #15
0001b4  8001              STRH     r1,[r0,#0]
0001b6  9800              LDR      r0,[sp,#0]
;;;531    
;;;532        /* Initialization of inputB pointer */
;;;533        pIn2 = py;
;;;534    
;;;535        pScratch1 += 1u;
0001b8  9c01              LDR      r4,[sp,#4]
0001ba  1c80              ADDS     r0,r0,#2              ;530
0001bc  9000              STR      r0,[sp,#0]            ;533
0001be  9811              LDR      r0,[sp,#0x44]
0001c0  1c80              ADDS     r0,r0,#2
0001c2  1e5b              SUBS     r3,r3,#1
0001c4  9011              STR      r0,[sp,#0x44]
                  |L1.454|
0001c6  2b00              CMP      r3,#0                 ;493
0001c8  d1d1              BNE      |L1.366|
;;;536    
;;;537      }
;;;538    
;;;539    }
0001ca  b007              ADD      sp,sp,#0x1c
0001cc  e8bd8ff0          POP      {r4-r11,pc}
;;;540    
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\FilteringFunctions\\arm_conv_fast_opt_q15.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___23_arm_conv_fast_opt_q15_c_c4fc4475____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___23_arm_conv_fast_opt_q15_c_c4fc4475____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___23_arm_conv_fast_opt_q15_c_c4fc4475____REVSH|
#line 144
|__asm___23_arm_conv_fast_opt_q15_c_c4fc4475____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___23_arm_conv_fast_opt_q15_c_c4fc4475____RRX|
#line 300
|__asm___23_arm_conv_fast_opt_q15_c_c4fc4475____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
