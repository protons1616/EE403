; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_min_f32.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_min_f32.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_min_f32.crf src\StatisticsFunctions\arm_min_f32.c]
                          THUMB

                          AREA ||i.arm_min_f32||, CODE, READONLY, ALIGN=1

                  arm_min_f32 PROC
;;;70     
;;;71     void arm_min_f32(
000000  b5f0              PUSH     {r4-r7,lr}
;;;72       float32_t * pSrc,
;;;73       uint32_t blockSize,
;;;74       float32_t * pResult,
;;;75       uint32_t * pIndex)
;;;76     {
;;;77     #ifndef ARM_MATH_CM0_FAMILY
;;;78     
;;;79       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;80     
;;;81       float32_t minVal1, minVal2, out;               /* Temporary variables to store the output value. */
;;;82       uint32_t blkCnt, outIndex, count;              /* loop counter */
;;;83     
;;;84       /* Initialise the count value. */
;;;85       count = 0u;
000002  2400              MOVS     r4,#0
;;;86       /* Initialise the index value to zero. */
;;;87       outIndex = 0u;
;;;88       /* Load first input value that act as reference value for comparision */
;;;89       out = *pSrc++;
;;;90     
;;;91       /* Loop unrolling */
;;;92       blkCnt = (blockSize - 1u) >> 2u;
000004  1e4f              SUBS     r7,r1,#1
000006  4625              MOV      r5,r4                 ;87
000008  ecb00a01          VLDM     r0!,{s0}              ;89
00000c  08be              LSRS     r6,r7,#2
00000e  e02a              B        |L1.102|
                  |L1.16|
;;;93     
;;;94       while(blkCnt > 0)
;;;95       {
;;;96         /* Initialize minVal to the next consecutive values one by one */
;;;97         minVal1 = *pSrc++;
000010  ed901a00          VLDR     s2,[r0,#0]
;;;98         minVal2 = *pSrc++;
000014  edd00a01          VLDR     s1,[r0,#4]
000018  3008              ADDS     r0,r0,#8
;;;99     
;;;100        /* compare for the minimum value */
;;;101        if(out > minVal1)
00001a  eeb40ac1          VCMPE.F32 s0,s2
00001e  eef1fa10          VMRS     APSR_nzcv,FPSCR
000022  dd02              BLE      |L1.42|
;;;102        {
;;;103          /* Update the minimum value and its index */
;;;104          out = minVal1;
000024  eeb00a41          VMOV.F32 s0,s2
;;;105          outIndex = count + 1u;
000028  1c65              ADDS     r5,r4,#1
                  |L1.42|
;;;106        }
;;;107    
;;;108        minVal1 = *pSrc++;
00002a  ecb01a01          VLDM     r0!,{s2}
;;;109    
;;;110        /* compare for the minimum value */
;;;111        if(out > minVal2)
00002e  eeb40ae0          VCMPE.F32 s0,s1
000032  eef1fa10          VMRS     APSR_nzcv,FPSCR
000036  dd02              BLE      |L1.62|
;;;112        {
;;;113          /* Update the minimum value and its index */
;;;114          out = minVal2;
000038  eeb00a60          VMOV.F32 s0,s1
;;;115          outIndex = count + 2u;
00003c  1ca5              ADDS     r5,r4,#2
                  |L1.62|
;;;116        }
;;;117    
;;;118        minVal2 = *pSrc++;
00003e  ecf00a01          VLDM     r0!,{s1}
;;;119    
;;;120        /* compare for the minimum value */
;;;121        if(out > minVal1)
000042  eeb40ac1          VCMPE.F32 s0,s2
000046  eef1fa10          VMRS     APSR_nzcv,FPSCR
00004a  dd02              BLE      |L1.82|
;;;122        {
;;;123          /* Update the minimum value and its index */
;;;124          out = minVal1;
00004c  eeb00a41          VMOV.F32 s0,s2
;;;125          outIndex = count + 3u;
000050  1ce5              ADDS     r5,r4,#3
                  |L1.82|
;;;126        }
;;;127    
;;;128        /* compare for the minimum value */
;;;129        if(out > minVal2)
000052  eeb40ae0          VCMPE.F32 s0,s1
000056  eef1fa10          VMRS     APSR_nzcv,FPSCR
00005a  dd02              BLE      |L1.98|
;;;130        {
;;;131          /* Update the minimum value and its index */
;;;132          out = minVal2;
00005c  eeb00a60          VMOV.F32 s0,s1
;;;133          outIndex = count + 4u;
000060  1d25              ADDS     r5,r4,#4
                  |L1.98|
000062  1d24              ADDS     r4,r4,#4
000064  1e76              SUBS     r6,r6,#1
                  |L1.102|
000066  2e00              CMP      r6,#0                 ;94
000068  d1d2              BNE      |L1.16|
;;;134        }
;;;135    
;;;136        count += 4u;
;;;137    
;;;138        blkCnt--;
;;;139      }
;;;140    
;;;141      /* if (blockSize - 1u ) is not multiple of 4 */
;;;142      blkCnt = (blockSize - 1u) % 4u;
00006a  f0070403          AND      r4,r7,#3
;;;143    
;;;144    #else
;;;145    
;;;146      /* Run the below code for Cortex-M0 */
;;;147      float32_t minVal1, out;                        /* Temporary variables to store the output value. */
;;;148      uint32_t blkCnt, outIndex;                     /* loop counter */
;;;149    
;;;150      /* Initialise the index value to zero. */
;;;151      outIndex = 0u;
;;;152      /* Load first input value that act as reference value for comparision */
;;;153      out = *pSrc++;
;;;154    
;;;155      blkCnt = (blockSize - 1u);
;;;156    
;;;157    #endif //      #ifndef ARM_MATH_CM0_FAMILY
;;;158    
;;;159      while(blkCnt > 0)
00006e  e00a              B        |L1.134|
                  |L1.112|
;;;160      {
;;;161        /* Initialize minVal to the next consecutive values one by one */
;;;162        minVal1 = *pSrc++;
000070  ecf00a01          VLDM     r0!,{s1}
;;;163    
;;;164        /* compare for the minimum value */
;;;165        if(out > minVal1)
000074  eeb40ae0          VCMPE.F32 s0,s1
000078  eef1fa10          VMRS     APSR_nzcv,FPSCR
00007c  dd02              BLE      |L1.132|
;;;166        {
;;;167          /* Update the minimum value and it's index */
;;;168          out = minVal1;
00007e  eeb00a60          VMOV.F32 s0,s1
;;;169          outIndex = blockSize - blkCnt;
000082  1b0d              SUBS     r5,r1,r4
                  |L1.132|
000084  1e64              SUBS     r4,r4,#1
                  |L1.134|
000086  2c00              CMP      r4,#0                 ;159
000088  d1f2              BNE      |L1.112|
;;;170        }
;;;171    
;;;172        blkCnt--;
;;;173    
;;;174      }
;;;175    
;;;176      /* Store the minimum value and it's index into destination pointers */
;;;177      *pResult = out;
00008a  ed820a00          VSTR     s0,[r2,#0]
;;;178      *pIndex = outIndex;
00008e  601d              STR      r5,[r3,#0]
;;;179    }
000090  bdf0              POP      {r4-r7,pc}
;;;180    
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\StatisticsFunctions\\arm_min_f32.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_arm_min_f32_c_295b0c65____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___13_arm_min_f32_c_295b0c65____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_arm_min_f32_c_295b0c65____REVSH|
#line 144
|__asm___13_arm_min_f32_c_295b0c65____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___13_arm_min_f32_c_295b0c65____RRX|
#line 300
|__asm___13_arm_min_f32_c_295b0c65____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
