; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_sqrt_q31.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_sqrt_q31.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_sqrt_q31.crf src\FastMathFunctions\arm_sqrt_q31.c]
                          THUMB

                          AREA ||i.arm_sqrt_q31||, CODE, READONLY, ALIGN=2

                  arm_sqrt_q31 PROC
;;;60     
;;;61     arm_status arm_sqrt_q31(
000000  b5f0              PUSH     {r4-r7,lr}
;;;62       q31_t in,
;;;63       q31_t * pOut)
;;;64     {
;;;65       q31_t number, temp1, bits_val1, var1, signBits1, half;
;;;66       float32_t temp_float1;
;;;67       union
;;;68       {
;;;69           q31_t fracval;
;;;70           float32_t floatval;
;;;71       } tempconv;
;;;72     
;;;73       number = in;
000002  1e03              SUBS     r3,r0,#0
;;;74     
;;;75       /* If the input is a positive number then compute the signBits. */
;;;76       if(number > 0)
;;;77       {
;;;78         signBits1 = __CLZ(number) - 1;
;;;79     
;;;80         /* Shift by the number of signBits1 */
;;;81         if((signBits1 % 2) == 0)
;;;82         {
;;;83           number = number << signBits1;
;;;84         }
;;;85         else
;;;86         {
;;;87           number = number << (signBits1 - 1);
;;;88         }
;;;89     
;;;90         /* Calculate half value of the number */
;;;91         half = number >> 1;
;;;92         /* Store the number for later use */
;;;93         temp1 = number;
;;;94     
;;;95         /*Convert to float */
;;;96         temp_float1 = number * 4.6566128731e-010f;
;;;97         /*Store as integer */
;;;98         tempconv.floatval = temp_float1;
;;;99         bits_val1 = tempconv.fracval;
;;;100        /* Subtract the shifted value from the magic number to give intial guess */
;;;101        bits_val1 = 0x5f3759df - (bits_val1 >> 1);  /* gives initial guess */
;;;102        /* Store as float */
;;;103        tempconv.fracval = bits_val1;
;;;104        temp_float1 = tempconv.floatval;
;;;105        /* Convert to integer format */
;;;106        var1 = (q31_t) (temp_float1 * 1073741824);
;;;107    
;;;108        /* 1st iteration */
;;;109        var1 = ((q31_t) ((q63_t) var1 * (0x30000000 -
;;;110                                         ((q31_t)
;;;111                                          ((((q31_t)
;;;112                                             (((q63_t) var1 * var1) >> 31)) *
;;;113                                            (q63_t) half) >> 31))) >> 31)) << 2;
;;;114        /* 2nd iteration */
;;;115        var1 = ((q31_t) ((q63_t) var1 * (0x30000000 -
;;;116                                         ((q31_t)
;;;117                                          ((((q31_t)
;;;118                                             (((q63_t) var1 * var1) >> 31)) *
;;;119                                            (q63_t) half) >> 31))) >> 31)) << 2;
;;;120        /* 3rd iteration */
;;;121        var1 = ((q31_t) ((q63_t) var1 * (0x30000000 -
;;;122                                         ((q31_t)
;;;123                                          ((((q31_t)
;;;124                                             (((q63_t) var1 * var1) >> 31)) *
;;;125                                            (q63_t) half) >> 31))) >> 31)) << 2;
;;;126    
;;;127        /* Multiply the inverse square root with the original value */
;;;128        var1 = ((q31_t) (((q63_t) temp1 * var1) >> 31)) << 1;
;;;129    
;;;130        /* Shift the output down accordingly */
;;;131        if((signBits1 % 2) == 0)
;;;132        {
;;;133          var1 = var1 >> (signBits1 / 2);
;;;134        }
;;;135        else
;;;136        {
;;;137          var1 = var1 >> ((signBits1 - 1) / 2);
;;;138        }
;;;139        *pOut = var1;
;;;140    
;;;141        return (ARM_MATH_SUCCESS);
;;;142      }
;;;143      /* If the number is a negative number then store zero as its square root value */
;;;144      else
;;;145      {
;;;146        *pOut = 0;
;;;147        return (ARM_MATH_ARGUMENT_ERROR);
;;;148      }
;;;149    }
000004  f04f30ff          MOV      r0,#0xffffffff
000008  dd68              BLE      |L1.220|
00000a  fab3f083          CLZ      r0,r3                 ;78
00000e  1e42              SUBS     r2,r0,#1              ;78
000010  07c0              LSLS     r0,r0,#31
000012  f1b04f00          CMP      r0,#0x80000000
000016  d05f              BEQ      |L1.216|
000018  1e50              SUBS     r0,r2,#1              ;87
00001a  4083              LSLS     r3,r3,r0              ;87
                  |L1.28|
00001c  ee003a10          VMOV     s0,r3                 ;96
000020  eddf0a30          VLDR     s1,|L1.228|
000024  4d30              LDR      r5,|L1.232|
000026  eeb80ac0          VCVT.F32.S32 s0,s0                 ;96
00002a  105c              ASRS     r4,r3,#1              ;91
00002c  ee200a20          VMUL.F32 s0,s0,s1              ;96
000030  eddf0a2e          VLDR     s1,|L1.236|
000034  ee100a10          VMOV     r0,s0                 ;99
000038  eba50060          SUB      r0,r5,r0,ASR #1       ;101
00003c  ee000a10          VMOV     s0,r0                 ;103
000040  ee200a20          VMUL.F32 s0,s0,s1              ;106
000044  eebd0ac0          VCVT.S32.F32 s0,s0                 ;106
000048  ee100a10          VMOV     r0,s0                 ;106
00004c  fb806500          SMULL    r6,r5,r0,r0           ;109
000050  006f              LSLS     r7,r5,#1              ;109
000052  ea4775d6          ORR      r5,r7,r6,LSR #31      ;109
000056  fb855604          SMULL    r5,r6,r5,r4           ;109
00005a  0fed              LSRS     r5,r5,#31             ;109
00005c  ea450546          ORR      r5,r5,r6,LSL #1       ;109
000060  f1c55540          RSB      r5,r5,#0x30000000     ;109
000064  fb800505          SMULL    r0,r5,r0,r5           ;109
000068  0fc0              LSRS     r0,r0,#31             ;109
00006a  ea400045          ORR      r0,r0,r5,LSL #1       ;109
00006e  0080              LSLS     r0,r0,#2              ;109
000070  fb805600          SMULL    r5,r6,r0,r0           ;115
000074  0fed              LSRS     r5,r5,#31             ;115
000076  ea450546          ORR      r5,r5,r6,LSL #1       ;115
00007a  fb855604          SMULL    r5,r6,r5,r4           ;115
00007e  0fed              LSRS     r5,r5,#31             ;115
000080  ea450546          ORR      r5,r5,r6,LSL #1       ;115
000084  f1c55540          RSB      r5,r5,#0x30000000     ;115
000088  fb800505          SMULL    r0,r5,r0,r5           ;115
00008c  0fc0              LSRS     r0,r0,#31             ;115
00008e  ea400045          ORR      r0,r0,r5,LSL #1       ;115
000092  0080              LSLS     r0,r0,#2              ;115
000094  fb806500          SMULL    r6,r5,r0,r0           ;121
000098  006f              LSLS     r7,r5,#1              ;121
00009a  ea4775d6          ORR      r5,r7,r6,LSR #31      ;121
00009e  fb854504          SMULL    r4,r5,r5,r4           ;121
0000a2  0fe4              LSRS     r4,r4,#31             ;121
0000a4  ea440445          ORR      r4,r4,r5,LSL #1       ;121
0000a8  f1c45440          RSB      r4,r4,#0x30000000     ;121
0000ac  fb804004          SMULL    r4,r0,r0,r4           ;121
0000b0  0045              LSLS     r5,r0,#1              ;121
0000b2  ea4570d4          ORR      r0,r5,r4,LSR #31      ;121
0000b6  0080              LSLS     r0,r0,#2              ;121
0000b8  fb830300          SMULL    r0,r3,r3,r0           ;128
0000bc  0fc0              LSRS     r0,r0,#31             ;128
0000be  ea400043          ORR      r0,r0,r3,LSL #1       ;128
0000c2  0040              LSLS     r0,r0,#1              ;128
0000c4  07d3              LSLS     r3,r2,#31             ;131
0000c6  d000              BEQ      |L1.202|
0000c8  1e52              SUBS     r2,r2,#1              ;131
                  |L1.202|
0000ca  eb0272d2          ADD      r2,r2,r2,LSR #31      ;133
0000ce  1052              ASRS     r2,r2,#1              ;133
0000d0  4110              ASRS     r0,r0,r2              ;133
0000d2  6008              STR      r0,[r1,#0]            ;141
0000d4  2000              MOVS     r0,#0                 ;141
0000d6  bdf0              POP      {r4-r7,pc}
                  |L1.216|
0000d8  4093              LSLS     r3,r3,r2              ;83
0000da  e79f              B        |L1.28|
                  |L1.220|
0000dc  2200              MOVS     r2,#0                 ;146
0000de  600a              STR      r2,[r1,#0]            ;146
0000e0  bdf0              POP      {r4-r7,pc}
;;;150    
                          ENDP

0000e2  0000              DCW      0x0000
                  |L1.228|
0000e4  30000000          DCFS     0x30000000 ; 4.6566128730773926e-10
                  |L1.232|
                          DCD      0x5f3759df
                  |L1.236|
0000ec  4e800000          DCFS     0x4e800000 ; 1073741824

;*** Start embedded assembler ***

#line 1 "src\\FastMathFunctions\\arm_sqrt_q31.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_arm_sqrt_q31_c_a60ed3ed____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___14_arm_sqrt_q31_c_a60ed3ed____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_arm_sqrt_q31_c_a60ed3ed____REVSH|
#line 144
|__asm___14_arm_sqrt_q31_c_a60ed3ed____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___14_arm_sqrt_q31_c_a60ed3ed____RRX|
#line 300
|__asm___14_arm_sqrt_q31_c_a60ed3ed____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
