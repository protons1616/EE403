; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_lms_q31.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_lms_q31.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_lms_q31.crf src\FilteringFunctions\arm_lms_q31.c]
                          THUMB

                          AREA ||i.arm_lms_q31||, CODE, READONLY, ALIGN=1

                  arm_lms_q31 PROC
;;;76     
;;;77     void arm_lms_q31(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;78       const arm_lms_instance_q31 * S,
;;;79       q31_t * pSrc,
;;;80       q31_t * pRef,
;;;81       q31_t * pOut,
;;;82       q31_t * pErr,
;;;83       uint32_t blockSize)
;;;84     {
000004  4681              MOV      r9,r0
;;;85       q31_t *pState = S->pState;                     /* State pointer */
;;;86       uint32_t numTaps = S->numTaps;                 /* Number of filter coefficients in the filter */
000006  f8b0a000          LDRH     r10,[r0,#0]
00000a  b087              SUB      sp,sp,#0x1c           ;84
;;;87       q31_t *pCoeffs = S->pCoeffs;                   /* Coefficient pointer */
00000c  e9d04001          LDRD     r4,r0,[r0,#4]
;;;88       q31_t *pStateCurnt;                            /* Points to the current sample of the state */
;;;89       q31_t mu = S->mu;                              /* Adaptive factor */
000010  9002              STR      r0,[sp,#8]
000012  f8d9000c          LDR      r0,[r9,#0xc]
;;;90       q31_t *px;                                     /* Temporary pointer for state */
;;;91       q31_t *pb;                                     /* Temporary pointer for coefficient buffer */
;;;92       uint32_t tapCnt, blkCnt;                       /* Loop counters */
;;;93       q63_t acc;                                     /* Accumulator */
;;;94       q31_t e = 0;                                   /* error of data sample */
;;;95       q31_t alpha;                                   /* Intermediate constant for taps update */
;;;96       q31_t coef;                                    /* Temporary variable for coef */
;;;97       q31_t acc_l, acc_h;                            /*  temporary input */
;;;98       uint32_t uShift = ((uint32_t) S->postShift + 1u);
000016  9005              STR      r0,[sp,#0x14]
000018  f8d90010          LDR      r0,[r9,#0x10]
00001c  9915              LDR      r1,[sp,#0x54]         ;85
00001e  1c40              ADDS     r0,r0,#1
;;;99       uint32_t lShift = 32u - uShift;                /*  Shift to be applied to the output */
000020  9001              STR      r0,[sp,#4]
000022  f1c00020          RSB      r0,r0,#0x20
;;;100    
;;;101      /* S->pState points to buffer which contains previous frame (numTaps - 1) samples */
;;;102      /* pStateCurnt points to the location where the new input data should be written */
;;;103      pStateCurnt = &(S->pState[(numTaps - 1u)]);
000026  f06f0203          MVN      r2,#3
00002a  9004              STR      r0,[sp,#0x10]
00002c  eb02008a          ADD      r0,r2,r10,LSL #2
000030  eb040b00          ADD      r11,r4,r0
;;;104    
;;;105      /* Initializing blkCnt with blockSize */
;;;106      blkCnt = blockSize;
;;;107    
;;;108    
;;;109    #ifndef ARM_MATH_CM0_FAMILY
;;;110    
;;;111      /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;112    
;;;113      while(blkCnt > 0u)
000034  4608              MOV      r0,r1
000036  9100              STR      r1,[sp,#0]            ;84
000038  e0a5              B        |L1.390|
                  |L1.58|
;;;114      {
;;;115        /* Copy the new input sample into the state buffer */
;;;116        *pStateCurnt++ = *pSrc++;
00003a  9808              LDR      r0,[sp,#0x20]
;;;117    
;;;118        /* Initialize state pointer */
;;;119        px = pState;
;;;120    
;;;121        /* Initialize coefficient pointer */
;;;122        pb = pCoeffs;
;;;123    
;;;124        /* Set the accumulator to zero */
;;;125        acc = 0;
;;;126    
;;;127        /* Loop unrolling.  Process 4 taps at a time. */
;;;128        tapCnt = numTaps >> 2;
00003c  ea4f069a          LSR      r6,r10,#2
000040  4622              MOV      r2,r4                 ;119
000042  6801              LDR      r1,[r0,#0]            ;116
000044  f84b1b04          STR      r1,[r11],#4           ;116
000048  9808              LDR      r0,[sp,#0x20]         ;116
00004a  46b4              MOV      r12,r6
00004c  1d00              ADDS     r0,r0,#4              ;116
00004e  9008              STR      r0,[sp,#0x20]         ;122
000050  2300              MOVS     r3,#0                 ;122
000052  4618              MOV      r0,r3                 ;122
;;;129    
;;;130        while(tapCnt > 0u)
000054  9902              LDR      r1,[sp,#8]
000056  e01a              B        |L1.142|
                  |L1.88|
;;;131        {
;;;132          /* Perform the multiply-accumulate */
;;;133          /* acc +=  b[N] * x[n-N] */
;;;134          acc += ((q63_t) (*px++)) * (*pb++);
000058  6815              LDR      r5,[r2,#0]
00005a  680f              LDR      r7,[r1,#0]
00005c  fb857507          SMULL    r7,r5,r5,r7
000060  18fb              ADDS     r3,r7,r3
000062  4145              ADCS     r5,r5,r0
;;;135    
;;;136          /* acc +=  b[N-1] * x[n-N-1] */
;;;137          acc += ((q63_t) (*px++)) * (*pb++);
000064  6850              LDR      r0,[r2,#4]
000066  684f              LDR      r7,[r1,#4]
000068  fb807007          SMULL    r7,r0,r0,r7
00006c  18fb              ADDS     r3,r7,r3
00006e  4168              ADCS     r0,r0,r5
;;;138    
;;;139          /* acc +=  b[N-2] * x[n-N-2] */
;;;140          acc += ((q63_t) (*px++)) * (*pb++);
000070  6895              LDR      r5,[r2,#8]
000072  688f              LDR      r7,[r1,#8]
000074  fb857507          SMULL    r7,r5,r5,r7
000078  18fb              ADDS     r3,r7,r3
00007a  4145              ADCS     r5,r5,r0
;;;141    
;;;142          /* acc +=  b[N-3] * x[n-N-3] */
;;;143          acc += ((q63_t) (*px++)) * (*pb++);
00007c  68d0              LDR      r0,[r2,#0xc]
00007e  68cf              LDR      r7,[r1,#0xc]
000080  3110              ADDS     r1,r1,#0x10
000082  fb807007          SMULL    r7,r0,r0,r7
000086  3210              ADDS     r2,r2,#0x10
000088  18fb              ADDS     r3,r7,r3
00008a  4168              ADCS     r0,r0,r5
00008c  1e76              SUBS     r6,r6,#1
                  |L1.142|
00008e  2e00              CMP      r6,#0                 ;130
000090  d1e2              BNE      |L1.88|
;;;144    
;;;145          /* Decrement the loop counter */
;;;146          tapCnt--;
;;;147        }
;;;148    
;;;149        /* If the filter length is not a multiple of 4, compute the remaining filter taps */
;;;150        tapCnt = numTaps % 0x4u;
000092  f00a0503          AND      r5,r10,#3
;;;151    
;;;152        while(tapCnt > 0u)
000096  9503              STR      r5,[sp,#0xc]
000098  e006              B        |L1.168|
                  |L1.154|
;;;153        {
;;;154          /* Perform the multiply-accumulate */
;;;155          acc += ((q63_t) (*px++)) * (*pb++);
00009a  ca40              LDM      r2!,{r6}
00009c  c980              LDM      r1!,{r7}
00009e  fb867607          SMULL    r7,r6,r6,r7
0000a2  18fb              ADDS     r3,r7,r3
0000a4  4170              ADCS     r0,r0,r6
0000a6  1e6d              SUBS     r5,r5,#1
                  |L1.168|
0000a8  2d00              CMP      r5,#0                 ;152
0000aa  d1f6              BNE      |L1.154|
;;;156    
;;;157          /* Decrement the loop counter */
;;;158          tapCnt--;
;;;159        }
;;;160    
;;;161        /* Converting the result to 1.31 format */
;;;162        /* Calc lower part of acc */
;;;163        acc_l = acc & 0xffffffff;
;;;164    
;;;165        /* Calc upper part of acc */
;;;166        acc_h = (acc >> 32) & 0xffffffff;
;;;167    
;;;168        acc = (uint32_t) acc_l >> lShift | acc_h << uShift;
0000ac  9904              LDR      r1,[sp,#0x10]
;;;169    
;;;170        /* Store the result from accumulator into the destination buffer. */
;;;171        *pOut++ = (q31_t) acc;
;;;172    
;;;173        /* Compute and store error */
;;;174        e = *pRef++ - (q31_t) acc;
;;;175    
;;;176        *pErr++ = (q31_t) e;
;;;177    
;;;178        /* Compute alpha i.e. intermediate constant for taps update */
;;;179        alpha = (q31_t) (((q63_t) e * mu) >> 31);
;;;180    
;;;181        /* Initialize state pointer */
;;;182        /* Advance state pointer by 1 for the next sample */
;;;183        px = pState++;
0000ae  4626              MOV      r6,r4
0000b0  40cb              LSRS     r3,r3,r1              ;168
0000b2  9901              LDR      r1,[sp,#4]            ;168
;;;184    
;;;185        /* Initialize coefficient pointer */
;;;186        pb = pCoeffs;
;;;187    
;;;188        /* Loop unrolling.  Process 4 taps at a time. */
;;;189        tapCnt = numTaps >> 2;
0000b4  46e0              MOV      r8,r12
0000b6  4088              LSLS     r0,r0,r1              ;168
0000b8  4303              ORRS     r3,r3,r0              ;168
0000ba  980a              LDR      r0,[sp,#0x28]         ;171
0000bc  6003              STR      r3,[r0,#0]            ;171
0000be  980a              LDR      r0,[sp,#0x28]         ;171
0000c0  9909              LDR      r1,[sp,#0x24]         ;174
0000c2  1d00              ADDS     r0,r0,#4              ;171
0000c4  900a              STR      r0,[sp,#0x28]         ;174
0000c6  9809              LDR      r0,[sp,#0x24]         ;174
0000c8  1d09              ADDS     r1,r1,#4              ;174
0000ca  6800              LDR      r0,[r0,#0]            ;174
0000cc  9109              STR      r1,[sp,#0x24]         ;176
0000ce  9914              LDR      r1,[sp,#0x50]         ;176
0000d0  1ac0              SUBS     r0,r0,r3              ;174
0000d2  6008              STR      r0,[r1,#0]            ;176
0000d4  9914              LDR      r1,[sp,#0x50]         ;176
;;;190    
;;;191        /* Update filter coefficients */
;;;192        while(tapCnt > 0u)
0000d6  9d02              LDR      r5,[sp,#8]
0000d8  1d09              ADDS     r1,r1,#4              ;176
0000da  9114              STR      r1,[sp,#0x50]         ;179
0000dc  9905              LDR      r1,[sp,#0x14]         ;179
0000de  fb800101          SMULL    r0,r1,r0,r1           ;179
0000e2  0fc7              LSRS     r7,r0,#31             ;179
0000e4  ea470741          ORR      r7,r7,r1,LSL #1       ;179
0000e8  1d24              ADDS     r4,r4,#4              ;183
0000ea  e033              B        |L1.340|
                  |L1.236|
;;;193        {
;;;194          /* coef is in 2.30 format */
;;;195          coef = (q31_t) (((q63_t) alpha * (*px++)) >> (32));
0000ec  6830              LDR      r0,[r6,#0]
0000ee  fb57f200          SMMUL    r2,r7,r0
;;;196          /* get coef in 1.31 format by left shifting */
;;;197          *pb = clip_q63_to_q31((q63_t) * pb + (coef << 1u));
0000f2  6828              LDR      r0,[r5,#0]
0000f4  0052              LSLS     r2,r2,#1
0000f6  17c1              ASRS     r1,r0,#31
0000f8  1880              ADDS     r0,r0,r2
0000fa  eb4171e2          ADC      r1,r1,r2,ASR #31
0000fe  f7fffffe          BL       clip_q63_to_q31
;;;198          /* update coefficient buffer to next coefficient */
;;;199          pb++;
;;;200    
;;;201          coef = (q31_t) (((q63_t) alpha * (*px++)) >> (32));
000102  6028              STR      r0,[r5,#0]
000104  6870              LDR      r0,[r6,#4]
000106  fb57f000          SMMUL    r0,r7,r0
;;;202          *pb = clip_q63_to_q31((q63_t) * pb + (coef << 1u));
00010a  0040              LSLS     r0,r0,#1
00010c  686a              LDR      r2,[r5,#4]
00010e  17c3              ASRS     r3,r0,#31
000110  1810              ADDS     r0,r2,r0
000112  eb4371e2          ADC      r1,r3,r2,ASR #31
000116  f7fffffe          BL       clip_q63_to_q31
;;;203          pb++;
;;;204    
;;;205          coef = (q31_t) (((q63_t) alpha * (*px++)) >> (32));
00011a  6068              STR      r0,[r5,#4]
00011c  68b0              LDR      r0,[r6,#8]
00011e  fb57f200          SMMUL    r2,r7,r0
;;;206          *pb = clip_q63_to_q31((q63_t) * pb + (coef << 1u));
000122  68a8              LDR      r0,[r5,#8]
000124  0052              LSLS     r2,r2,#1
000126  17c1              ASRS     r1,r0,#31
000128  1880              ADDS     r0,r0,r2
00012a  eb4171e2          ADC      r1,r1,r2,ASR #31
00012e  f7fffffe          BL       clip_q63_to_q31
;;;207          pb++;
;;;208    
;;;209          coef = (q31_t) (((q63_t) alpha * (*px++)) >> (32));
000132  60a8              STR      r0,[r5,#8]
000134  68f0              LDR      r0,[r6,#0xc]
000136  fb57f200          SMMUL    r2,r7,r0
;;;210          *pb = clip_q63_to_q31((q63_t) * pb + (coef << 1u));
00013a  68e8              LDR      r0,[r5,#0xc]
00013c  0052              LSLS     r2,r2,#1
00013e  17c1              ASRS     r1,r0,#31
000140  3610              ADDS     r6,r6,#0x10
000142  1880              ADDS     r0,r0,r2
000144  eb4171e2          ADC      r1,r1,r2,ASR #31
000148  f7fffffe          BL       clip_q63_to_q31
;;;211          pb++;
;;;212    
;;;213          /* Decrement the loop counter */
;;;214          tapCnt--;
00014c  60e8              STR      r0,[r5,#0xc]
00014e  f1a80801          SUB      r8,r8,#1
000152  3510              ADDS     r5,r5,#0x10
                  |L1.340|
000154  f1b80f00          CMP      r8,#0                 ;192
000158  d1c8              BNE      |L1.236|
;;;215        }
;;;216    
;;;217        /* If the filter length is not a multiple of 4, compute the remaining filter taps */
;;;218        tapCnt = numTaps % 0x4u;
;;;219    
;;;220        while(tapCnt > 0u)
00015a  9803              LDR      r0,[sp,#0xc]
00015c  e00d              B        |L1.378|
                  |L1.350|
;;;221        {
;;;222          /* Perform the multiply-accumulate */
;;;223          coef = (q31_t) (((q63_t) alpha * (*px++)) >> (32));
00015e  ce01              LDM      r6!,{r0}
000160  fb57f200          SMMUL    r2,r7,r0
;;;224          *pb = clip_q63_to_q31((q63_t) * pb + (coef << 1u));
000164  6828              LDR      r0,[r5,#0]
000166  0052              LSLS     r2,r2,#1
000168  17c1              ASRS     r1,r0,#31
00016a  1880              ADDS     r0,r0,r2
00016c  eb4171e2          ADC      r1,r1,r2,ASR #31
000170  f7fffffe          BL       clip_q63_to_q31
000174  c501              STM      r5!,{r0}
;;;225          pb++;
;;;226    
;;;227          /* Decrement the loop counter */
;;;228          tapCnt--;
000176  f1a80001          SUB      r0,r8,#1
                  |L1.378|
00017a  ea5f0800          MOVS     r8,r0                 ;218
00017e  d1ee              BNE      |L1.350|
;;;229        }
;;;230    
;;;231        /* Decrement the loop counter */
;;;232        blkCnt--;
000180  9800              LDR      r0,[sp,#0]
000182  1e40              SUBS     r0,r0,#1
000184  9000              STR      r0,[sp,#0]
                  |L1.390|
000186  2800              CMP      r0,#0                 ;113
000188  f47faf57          BNE      |L1.58|
;;;233      }
;;;234    
;;;235      /* Processing is complete. Now copy the last numTaps - 1 samples to the    
;;;236         satrt of the state buffer. This prepares the state buffer for the    
;;;237         next function call. */
;;;238    
;;;239      /* Points to the start of the pState buffer */
;;;240      pStateCurnt = S->pState;
;;;241    
;;;242      /* Loop unrolling for (numTaps - 1u) samples copy */
;;;243      tapCnt = (numTaps - 1u) >> 2u;
00018c  f1aa0201          SUB      r2,r10,#1
000190  0891              LSRS     r1,r2,#2
;;;244    
;;;245      /* copy data */
;;;246      while(tapCnt > 0u)
000192  f8d90004          LDR      r0,[r9,#4]
000196  e00c              B        |L1.434|
                  |L1.408|
;;;247      {
;;;248        *pStateCurnt++ = *pState++;
000198  cc08              LDM      r4!,{r3}
;;;249        *pStateCurnt++ = *pState++;
;;;250        *pStateCurnt++ = *pState++;
;;;251        *pStateCurnt++ = *pState++;
00019a  1e49              SUBS     r1,r1,#1
00019c  c008              STM      r0!,{r3}              ;248
00019e  cc08              LDM      r4!,{r3}              ;249
0001a0  c008              STM      r0!,{r3}              ;249
0001a2  f8543b08          LDR      r3,[r4],#8            ;250
0001a6  f8403b08          STR      r3,[r0],#8            ;250
0001aa  f8543c04          LDR      r3,[r4,#-4]
0001ae  f8403c04          STR      r3,[r0,#-4]
                  |L1.434|
0001b2  2900              CMP      r1,#0                 ;246
0001b4  d1f0              BNE      |L1.408|
;;;252    
;;;253        /* Decrement the loop counter */
;;;254        tapCnt--;
;;;255      }
;;;256    
;;;257      /* Calculate remaining number of copies */
;;;258      tapCnt = (numTaps - 1u) % 0x4u;
0001b6  f0020103          AND      r1,r2,#3
;;;259    
;;;260      /* Copy the remaining q31_t data */
;;;261      while(tapCnt > 0u)
0001ba  e002              B        |L1.450|
                  |L1.444|
;;;262      {
;;;263        *pStateCurnt++ = *pState++;
0001bc  cc04              LDM      r4!,{r2}
0001be  1e49              SUBS     r1,r1,#1
0001c0  c004              STM      r0!,{r2}
                  |L1.450|
0001c2  2900              CMP      r1,#0                 ;261
0001c4  d1fa              BNE      |L1.444|
;;;264    
;;;265        /* Decrement the loop counter */
;;;266        tapCnt--;
;;;267      }
;;;268    
;;;269    #else
;;;270    
;;;271      /* Run the below code for Cortex-M0 */
;;;272    
;;;273      while(blkCnt > 0u)
;;;274      {
;;;275        /* Copy the new input sample into the state buffer */
;;;276        *pStateCurnt++ = *pSrc++;
;;;277    
;;;278        /* Initialize pState pointer */
;;;279        px = pState;
;;;280    
;;;281        /* Initialize pCoeffs pointer */
;;;282        pb = pCoeffs;
;;;283    
;;;284        /* Set the accumulator to zero */
;;;285        acc = 0;
;;;286    
;;;287        /* Loop over numTaps number of values */
;;;288        tapCnt = numTaps;
;;;289    
;;;290        while(tapCnt > 0u)
;;;291        {
;;;292          /* Perform the multiply-accumulate */
;;;293          acc += ((q63_t) (*px++)) * (*pb++);
;;;294    
;;;295          /* Decrement the loop counter */
;;;296          tapCnt--;
;;;297        }
;;;298    
;;;299        /* Converting the result to 1.31 format */
;;;300        /* Store the result from accumulator into the destination buffer. */
;;;301        /* Calc lower part of acc */
;;;302        acc_l = acc & 0xffffffff;
;;;303    
;;;304        /* Calc upper part of acc */
;;;305        acc_h = (acc >> 32) & 0xffffffff;
;;;306    
;;;307        acc = (uint32_t) acc_l >> lShift | acc_h << uShift;
;;;308    
;;;309        *pOut++ = (q31_t) acc;
;;;310    
;;;311        /* Compute and store error */
;;;312        e = *pRef++ - (q31_t) acc;
;;;313    
;;;314        *pErr++ = (q31_t) e;
;;;315    
;;;316        /* Weighting factor for the LMS version */
;;;317        alpha = (q31_t) (((q63_t) e * mu) >> 31);
;;;318    
;;;319        /* Initialize pState pointer */
;;;320        /* Advance state pointer by 1 for the next sample */
;;;321        px = pState++;
;;;322    
;;;323        /* Initialize pCoeffs pointer */
;;;324        pb = pCoeffs;
;;;325    
;;;326        /* Loop over numTaps number of values */
;;;327        tapCnt = numTaps;
;;;328    
;;;329        while(tapCnt > 0u)
;;;330        {
;;;331          /* Perform the multiply-accumulate */
;;;332          coef = (q31_t) (((q63_t) alpha * (*px++)) >> (32));
;;;333          *pb = clip_q63_to_q31((q63_t) * pb + (coef << 1u));
;;;334          pb++;
;;;335    
;;;336          /* Decrement the loop counter */
;;;337          tapCnt--;
;;;338        }
;;;339    
;;;340        /* Decrement the loop counter */
;;;341        blkCnt--;
;;;342      }
;;;343    
;;;344      /* Processing is complete. Now copy the last numTaps - 1 samples to the     
;;;345         start of the state buffer. This prepares the state buffer for the   
;;;346         next function call. */
;;;347    
;;;348      /* Points to the start of the pState buffer */
;;;349      pStateCurnt = S->pState;
;;;350    
;;;351      /*  Copy (numTaps - 1u) samples  */
;;;352      tapCnt = (numTaps - 1u);
;;;353    
;;;354      /* Copy the data */
;;;355      while(tapCnt > 0u)
;;;356      {
;;;357        *pStateCurnt++ = *pState++;
;;;358    
;;;359        /* Decrement the loop counter */
;;;360        tapCnt--;
;;;361      }
;;;362    
;;;363    #endif /*   #ifndef ARM_MATH_CM0_FAMILY */
;;;364    
;;;365    }
0001c6  b00b              ADD      sp,sp,#0x2c
0001c8  e8bd8ff0          POP      {r4-r11,pc}
;;;366    
                          ENDP


                          AREA ||i.clip_q63_to_q31||, CODE, READONLY, ALIGN=1

                  clip_q63_to_q31 PROC
;;;458       */
;;;459      static __INLINE q31_t clip_q63_to_q31(
000000  17ca              ASRS     r2,r1,#31
;;;460      q63_t x)
;;;461      {
;;;462        return ((q31_t) (x >> 32) != ((q31_t) x >> 31)) ?
000002  ebb17fe0          CMP      r1,r0,ASR #31
000006  d002              BEQ      |L2.14|
;;;463          ((0x7FFFFFFF ^ ((q31_t) (x >> 63)))) : (q31_t) x;
000008  f06f4000          MVN      r0,#0x80000000
00000c  4050              EORS     r0,r0,r2
                  |L2.14|
;;;464      }
00000e  4770              BX       lr
;;;465    
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\FilteringFunctions\\arm_lms_q31.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_arm_lms_q31_c_0cadf2bb____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___13_arm_lms_q31_c_0cadf2bb____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_arm_lms_q31_c_0cadf2bb____REVSH|
#line 144
|__asm___13_arm_lms_q31_c_0cadf2bb____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___13_arm_lms_q31_c_0cadf2bb____RRX|
#line 300
|__asm___13_arm_lms_q31_c_0cadf2bb____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
