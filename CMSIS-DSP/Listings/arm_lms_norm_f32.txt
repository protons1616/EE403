; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_lms_norm_f32.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_lms_norm_f32.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_lms_norm_f32.crf src\FilteringFunctions\arm_lms_norm_f32.c]
                          THUMB

                          AREA ||i.arm_lms_norm_f32||, CODE, READONLY, ALIGN=2

                  arm_lms_norm_f32 PROC
;;;172    
;;;173    void arm_lms_norm_f32(
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;174      arm_lms_norm_instance_f32 * S,
;;;175      float32_t * pSrc,
;;;176      float32_t * pRef,
;;;177      float32_t * pOut,
;;;178      float32_t * pErr,
;;;179      uint32_t blockSize)
;;;180    {
000004  469b              MOV      r11,r3
000006  e9dde70a          LDRD     lr,r7,[sp,#0x28]
00000a  e9d03801          LDRD     r3,r8,[r0,#4]
;;;181      float32_t *pState = S->pState;                 /* State pointer */
;;;182      float32_t *pCoeffs = S->pCoeffs;               /* Coefficient pointer */
;;;183      float32_t *pStateCurnt;                        /* Points to the current sample of the state */
;;;184      float32_t *px, *pb;                            /* Temporary pointers for state and coefficient buffers */
;;;185      float32_t mu = S->mu;                          /* Adaptive factor */
00000e  edd01a03          VLDR     s3,[r0,#0xc]
;;;186      uint32_t numTaps = S->numTaps;                 /* Number of filter coefficients in the filter */
000012  8805              LDRH     r5,[r0,#0]
000014  4692              MOV      r10,r2                ;180
;;;187      uint32_t tapCnt, blkCnt;                       /* Loop counters */
;;;188      float32_t energy;                              /* Energy of the input */
;;;189      float32_t sum, e, d;                           /* accumulator, error, reference data sample */
;;;190      float32_t w, x0, in;                           /* weight factor, temporary variable to hold input sample and state */
;;;191    
;;;192      /* Initializations of error,  difference, Coefficient update */
;;;193      e = 0.0f;
000016  ed9f2a61          VLDR     s4,|L1.412|
;;;194      d = 0.0f;
;;;195      w = 0.0f;
;;;196    
;;;197      energy = S->energy;
;;;198      x0 = S->x0;
;;;199    
;;;200      /* S->pState points to buffer which contains previous frame (numTaps - 1) samples */
;;;201      /* pStateCurnt points to the location where the new input data should be written */
;;;202      pStateCurnt = &(S->pState[(numTaps - 1u)]);
00001a  f06f0203          MVN      r2,#3
00001e  eb020285          ADD      r2,r2,r5,LSL #2
000022  edd00a04          VLDR     s1,[r0,#0x10]         ;197
000026  ed900a05          VLDR     s0,[r0,#0x14]         ;198
00002a  eb030c02          ADD      r12,r3,r2
00002e  e087              B        |L1.320|
                  |L1.48|
;;;203    
;;;204      /* Loop over blockSize number of values */
;;;205      blkCnt = blockSize;
;;;206    
;;;207    
;;;208    #ifndef ARM_MATH_CM0_FAMILY
;;;209    
;;;210      /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;211    
;;;212      while(blkCnt > 0u)
;;;213      {
;;;214        /* Copy the new input sample into the state buffer */
;;;215        *pStateCurnt++ = *pSrc;
000030  ed911a00          VLDR     s2,[r1,#0]
;;;216    
;;;217        /* Initialize pState pointer */
;;;218        px = pState;
;;;219    
;;;220        /* Initialize coeff pointer */
;;;221        pb = (pCoeffs);
;;;222    
;;;223        /* Read the sample from input buffer */
;;;224        in = *pSrc++;
;;;225    
;;;226        /* Update the energy calculation */
;;;227        energy -= x0 * x0;
000034  ee400a40          VMLS.F32 s1,s0,s0
000038  ecac1a01          VSTM     r12!,{s2}             ;215
;;;228        energy += in * in;
;;;229    
;;;230        /* Set the accumulator to zero */
;;;231        sum = 0.0f;
;;;232    
;;;233        /* Loop unrolling.  Process 4 taps at a time. */
;;;234        tapCnt = numTaps >> 2;
00003c  08ae              LSRS     r6,r5,#2
00003e  ecb11a01          VLDM     r1!,{s2}              ;224
000042  461c              MOV      r4,r3                 ;218
000044  4642              MOV      r2,r8                 ;221
000046  eeb00a42          VMOV.F32 s0,s4                 ;231
00004a  46b1              MOV      r9,r6
00004c  ee410a01          VMLA.F32 s1,s2,s2              ;228
;;;235    
;;;236        while(tapCnt > 0u)
000050  e01b              B        |L1.138|
;;;237        {
;;;238          /* Perform the multiply-accumulate */
;;;239          sum += (*px++) * (*pb++);
000052  bf00              NOP      
                  |L1.84|
000054  ed941a00          VLDR     s2,[r4,#0]
000058  edd22a00          VLDR     s5,[r2,#0]
00005c  ee010a22          VMLA.F32 s0,s2,s5
;;;240          sum += (*px++) * (*pb++);
000060  ed941a01          VLDR     s2,[r4,#4]
000064  edd22a01          VLDR     s5,[r2,#4]
000068  ee010a22          VMLA.F32 s0,s2,s5
;;;241          sum += (*px++) * (*pb++);
00006c  ed941a02          VLDR     s2,[r4,#8]
000070  edd22a02          VLDR     s5,[r2,#8]
000074  ee010a22          VMLA.F32 s0,s2,s5
;;;242          sum += (*px++) * (*pb++);
000078  ed941a03          VLDR     s2,[r4,#0xc]
00007c  edd22a03          VLDR     s5,[r2,#0xc]
000080  3210              ADDS     r2,r2,#0x10
000082  3410              ADDS     r4,r4,#0x10
000084  1e76              SUBS     r6,r6,#1
000086  ee010a22          VMLA.F32 s0,s2,s5
                  |L1.138|
00008a  2e00              CMP      r6,#0                 ;236
00008c  d1e2              BNE      |L1.84|
;;;243    
;;;244          /* Decrement the loop counter */
;;;245          tapCnt--;
;;;246        }
;;;247    
;;;248        /* If the filter length is not a multiple of 4, compute the remaining filter taps */
;;;249        tapCnt = numTaps % 0x4u;
00008e  f0050603          AND      r6,r5,#3
;;;250    
;;;251        while(tapCnt > 0u)
000092  9600              STR      r6,[sp,#0]
000094  e007              B        |L1.166|
;;;252        {
;;;253          /* Perform the multiply-accumulate */
;;;254          sum += (*px++) * (*pb++);
000096  bf00              NOP      
                  |L1.152|
000098  ecb41a01          VLDM     r4!,{s2}
00009c  1e76              SUBS     r6,r6,#1
00009e  ecf22a01          VLDM     r2!,{s5}
0000a2  ee010a22          VMLA.F32 s0,s2,s5
                  |L1.166|
0000a6  2e00              CMP      r6,#0                 ;251
0000a8  d1f6              BNE      |L1.152|
;;;255    
;;;256          /* Decrement the loop counter */
;;;257          tapCnt--;
;;;258        }
;;;259    
;;;260        /* The result in the accumulator, store in the destination buffer. */
;;;261        *pOut++ = sum;
0000aa  ecab0a01          VSTM     r11!,{s0}
;;;262    
;;;263        /* Compute and store error */
;;;264        d = (float32_t) (*pRef++);
;;;265        e = d - sum;
;;;266        *pErr++ = e;
;;;267    
;;;268        /* Calculation of Weighting factor for updating filter coefficients */
;;;269        /* epsilon value 0.000000119209289f */
;;;270        w = (e * mu) / (energy + 0.000000119209289f);
;;;271    
;;;272        /* Initialize pState pointer */
;;;273        px = pState;
0000ae  461c              MOV      r4,r3
0000b0  ecba1a01          VLDM     r10!,{s2}             ;264
;;;274    
;;;275        /* Initialize coeff pointer */
;;;276        pb = (pCoeffs);
0000b4  4642              MOV      r2,r8
0000b6  464e              MOV      r6,r9
0000b8  ee310a40          VSUB.F32 s0,s2,s0              ;265
0000bc  ecae0a01          VSTM     lr!,{s0}              ;266
0000c0  ee201a21          VMUL.F32 s2,s0,s3              ;270
0000c4  ed9f0a36          VLDR     s0,|L1.416|
0000c8  ee702a80          VADD.F32 s5,s1,s0              ;270
0000cc  ee810a22          VDIV.F32 s0,s2,s5              ;270
;;;277    
;;;278        /* Loop unrolling.  Process 4 taps at a time. */
;;;279        tapCnt = numTaps >> 2;
;;;280    
;;;281        /* Update filter coefficients */
;;;282        while(tapCnt > 0u)
0000d0  e023              B        |L1.282|
;;;283        {
;;;284          /* Perform the multiply-accumulate */
;;;285          *pb += w * (*px++);
0000d2  bf00              NOP      
                  |L1.212|
0000d4  ed921a00          VLDR     s2,[r2,#0]
0000d8  edd42a00          VLDR     s5,[r4,#0]
0000dc  ee001a22          VMLA.F32 s2,s0,s5
0000e0  ed821a00          VSTR     s2,[r2,#0]
;;;286          pb++;
;;;287    
;;;288          *pb += w * (*px++);
0000e4  ed921a01          VLDR     s2,[r2,#4]
0000e8  edd42a01          VLDR     s5,[r4,#4]
0000ec  ee001a22          VMLA.F32 s2,s0,s5
0000f0  ed821a01          VSTR     s2,[r2,#4]
;;;289          pb++;
;;;290    
;;;291          *pb += w * (*px++);
0000f4  ed921a02          VLDR     s2,[r2,#8]
0000f8  edd42a02          VLDR     s5,[r4,#8]
0000fc  ee001a22          VMLA.F32 s2,s0,s5
000100  ed821a02          VSTR     s2,[r2,#8]
;;;292          pb++;
;;;293    
;;;294          *pb += w * (*px++);
000104  ed921a03          VLDR     s2,[r2,#0xc]
000108  edd42a03          VLDR     s5,[r4,#0xc]
00010c  3410              ADDS     r4,r4,#0x10
00010e  ee001a22          VMLA.F32 s2,s0,s5
000112  ed821a03          VSTR     s2,[r2,#0xc]
000116  3210              ADDS     r2,r2,#0x10
000118  1e76              SUBS     r6,r6,#1
                  |L1.282|
00011a  2e00              CMP      r6,#0                 ;282
00011c  d1da              BNE      |L1.212|
;;;295          pb++;
;;;296    
;;;297    
;;;298          /* Decrement the loop counter */
;;;299          tapCnt--;
;;;300        }
;;;301    
;;;302        /* If the filter length is not a multiple of 4, compute the remaining filter taps */
;;;303        tapCnt = numTaps % 0x4u;
;;;304    
;;;305        while(tapCnt > 0u)
00011e  9e00              LDR      r6,[sp,#0]
000120  e009              B        |L1.310|
;;;306        {
;;;307          /* Perform the multiply-accumulate */
;;;308          *pb += w * (*px++);
000122  bf00              NOP      
                  |L1.292|
000124  ecf42a01          VLDM     r4!,{s5}
000128  ed921a00          VLDR     s2,[r2,#0]
00012c  1e76              SUBS     r6,r6,#1
00012e  ee001a22          VMLA.F32 s2,s0,s5
000132  eca21a01          VSTM     r2!,{s2}
                  |L1.310|
000136  2e00              CMP      r6,#0                 ;305
000138  d1f4              BNE      |L1.292|
;;;309          pb++;
;;;310    
;;;311          /* Decrement the loop counter */
;;;312          tapCnt--;
;;;313        }
;;;314    
;;;315        x0 = *pState;
00013a  ecb30a01          VLDM     r3!,{s0}
00013e  1e7f              SUBS     r7,r7,#1
                  |L1.320|
000140  2f00              CMP      r7,#0                 ;212
000142  f47faf75          BNE      |L1.48|
;;;316    
;;;317        /* Advance state pointer by 1 for the next sample */
;;;318        pState = pState + 1;
;;;319    
;;;320        /* Decrement the loop counter */
;;;321        blkCnt--;
;;;322      }
;;;323    
;;;324      S->energy = energy;
000146  edc00a04          VSTR     s1,[r0,#0x10]
;;;325      S->x0 = x0;
00014a  ed800a05          VSTR     s0,[r0,#0x14]
;;;326    
;;;327      /* Processing is complete. Now copy the last numTaps - 1 samples to the    
;;;328         satrt of the state buffer. This prepares the state buffer for the    
;;;329         next function call. */
;;;330    
;;;331      /* Points to the start of the pState buffer */
;;;332      pStateCurnt = S->pState;
00014e  1e6d              SUBS     r5,r5,#1
000150  6840              LDR      r0,[r0,#4]
;;;333    
;;;334      /* Loop unrolling for (numTaps - 1u)/4 samples copy */
;;;335      tapCnt = (numTaps - 1u) >> 2u;
000152  08a9              LSRS     r1,r5,#2
;;;336    
;;;337      /* copy data */
;;;338      while(tapCnt > 0u)
000154  e013              B        |L1.382|
;;;339      {
;;;340        *pStateCurnt++ = *pState++;
000156  bf00              NOP      
                  |L1.344|
000158  ed930a00          VLDR     s0,[r3,#0]
;;;341        *pStateCurnt++ = *pState++;
;;;342        *pStateCurnt++ = *pState++;
;;;343        *pStateCurnt++ = *pState++;
00015c  1e49              SUBS     r1,r1,#1
00015e  ed800a00          VSTR     s0,[r0,#0]            ;340
000162  ed930a01          VLDR     s0,[r3,#4]            ;341
000166  ed800a01          VSTR     s0,[r0,#4]            ;341
00016a  ed930a02          VLDR     s0,[r3,#8]            ;342
00016e  ed800a02          VSTR     s0,[r0,#8]            ;342
000172  ed930a03          VLDR     s0,[r3,#0xc]
000176  ed800a03          VSTR     s0,[r0,#0xc]
00017a  3010              ADDS     r0,r0,#0x10
00017c  3310              ADDS     r3,r3,#0x10
                  |L1.382|
00017e  2900              CMP      r1,#0                 ;338
000180  d1ea              BNE      |L1.344|
;;;344    
;;;345        /* Decrement the loop counter */
;;;346        tapCnt--;
;;;347      }
;;;348    
;;;349      /* Calculate remaining number of copies */
;;;350      tapCnt = (numTaps - 1u) % 0x4u;
000182  f0050103          AND      r1,r5,#3
;;;351    
;;;352      /* Copy the remaining q31_t data */
;;;353      while(tapCnt > 0u)
000186  e004              B        |L1.402|
                  |L1.392|
;;;354      {
;;;355        *pStateCurnt++ = *pState++;
000188  ecb30a01          VLDM     r3!,{s0}
00018c  1e49              SUBS     r1,r1,#1
00018e  eca00a01          VSTM     r0!,{s0}
                  |L1.402|
000192  2900              CMP      r1,#0                 ;353
000194  d1f8              BNE      |L1.392|
;;;356    
;;;357        /* Decrement the loop counter */
;;;358        tapCnt--;
;;;359      }
;;;360    
;;;361    #else
;;;362    
;;;363      /* Run the below code for Cortex-M0 */
;;;364    
;;;365      while(blkCnt > 0u)
;;;366      {
;;;367        /* Copy the new input sample into the state buffer */
;;;368        *pStateCurnt++ = *pSrc;
;;;369    
;;;370        /* Initialize pState pointer */
;;;371        px = pState;
;;;372    
;;;373        /* Initialize pCoeffs pointer */
;;;374        pb = pCoeffs;
;;;375    
;;;376        /* Read the sample from input buffer */
;;;377        in = *pSrc++;
;;;378    
;;;379        /* Update the energy calculation */
;;;380        energy -= x0 * x0;
;;;381        energy += in * in;
;;;382    
;;;383        /* Set the accumulator to zero */
;;;384        sum = 0.0f;
;;;385    
;;;386        /* Loop over numTaps number of values */
;;;387        tapCnt = numTaps;
;;;388    
;;;389        while(tapCnt > 0u)
;;;390        {
;;;391          /* Perform the multiply-accumulate */
;;;392          sum += (*px++) * (*pb++);
;;;393    
;;;394          /* Decrement the loop counter */
;;;395          tapCnt--;
;;;396        }
;;;397    
;;;398        /* The result in the accumulator is stored in the destination buffer. */
;;;399        *pOut++ = sum;
;;;400    
;;;401        /* Compute and store error */
;;;402        d = (float32_t) (*pRef++);
;;;403        e = d - sum;
;;;404        *pErr++ = e;
;;;405    
;;;406        /* Calculation of Weighting factor for updating filter coefficients */
;;;407        /* epsilon value 0.000000119209289f */
;;;408        w = (e * mu) / (energy + 0.000000119209289f);
;;;409    
;;;410        /* Initialize pState pointer */
;;;411        px = pState;
;;;412    
;;;413        /* Initialize pCcoeffs pointer */
;;;414        pb = pCoeffs;
;;;415    
;;;416        /* Loop over numTaps number of values */
;;;417        tapCnt = numTaps;
;;;418    
;;;419        while(tapCnt > 0u)
;;;420        {
;;;421          /* Perform the multiply-accumulate */
;;;422          *pb += w * (*px++);
;;;423          pb++;
;;;424    
;;;425          /* Decrement the loop counter */
;;;426          tapCnt--;
;;;427        }
;;;428    
;;;429        x0 = *pState;
;;;430    
;;;431        /* Advance state pointer by 1 for the next sample */
;;;432        pState = pState + 1;
;;;433    
;;;434        /* Decrement the loop counter */
;;;435        blkCnt--;
;;;436      }
;;;437    
;;;438      S->energy = energy;
;;;439      S->x0 = x0;
;;;440    
;;;441      /* Processing is complete. Now copy the last numTaps - 1 samples to the        
;;;442         satrt of the state buffer. This prepares the state buffer for the        
;;;443         next function call. */
;;;444    
;;;445      /* Points to the start of the pState buffer */
;;;446      pStateCurnt = S->pState;
;;;447    
;;;448      /* Copy (numTaps - 1u) samples  */
;;;449      tapCnt = (numTaps - 1u);
;;;450    
;;;451      /* Copy the remaining q31_t data */
;;;452      while(tapCnt > 0u)
;;;453      {
;;;454        *pStateCurnt++ = *pState++;
;;;455    
;;;456        /* Decrement the loop counter */
;;;457        tapCnt--;
;;;458      }
;;;459    
;;;460    #endif /*   #ifndef ARM_MATH_CM0_FAMILY */
;;;461    
;;;462    }
000196  e8bd8ff8          POP      {r3-r11,pc}
;;;463    
                          ENDP

00019a  0000              DCW      0x0000
                  |L1.412|
00019c  00000000          DCFS     0x00000000 ; 0
                  |L1.416|
0001a0  34000000          DCFS     0x34000000 ; 1.1920928955078125e-07

;*** Start embedded assembler ***

#line 1 "src\\FilteringFunctions\\arm_lms_norm_f32.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_lms_norm_f32_c_ba4766a7____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___18_arm_lms_norm_f32_c_ba4766a7____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_lms_norm_f32_c_ba4766a7____REVSH|
#line 144
|__asm___18_arm_lms_norm_f32_c_ba4766a7____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_lms_norm_f32_c_ba4766a7____RRX|
#line 300
|__asm___18_arm_lms_norm_f32_c_ba4766a7____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
