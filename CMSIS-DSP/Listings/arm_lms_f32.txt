; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_lms_f32.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_lms_f32.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_lms_f32.crf src\FilteringFunctions\arm_lms_f32.c]
                          THUMB

                          AREA ||i.arm_lms_f32||, CODE, READONLY, ALIGN=2

                  arm_lms_f32 PROC
;;;180    
;;;181    void arm_lms_f32(
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;182      const arm_lms_instance_f32 * S,
;;;183      float32_t * pSrc,
;;;184      float32_t * pRef,
;;;185      float32_t * pOut,
;;;186      float32_t * pErr,
;;;187      uint32_t blockSize)
;;;188    {
000004  469b              MOV      r11,r3
000006  e9dde70a          LDRD     lr,r7,[sp,#0x28]
00000a  e9d03801          LDRD     r3,r8,[r0,#4]
;;;189      float32_t *pState = S->pState;                 /* State pointer */
;;;190      float32_t *pCoeffs = S->pCoeffs;               /* Coefficient pointer */
;;;191      float32_t *pStateCurnt;                        /* Points to the current sample of the state */
;;;192      float32_t *px, *pb;                            /* Temporary pointers for state and coefficient buffers */
;;;193      float32_t mu = S->mu;                          /* Adaptive factor */
00000e  edd00a03          VLDR     s1,[r0,#0xc]
;;;194      uint32_t numTaps = S->numTaps;                 /* Number of filter coefficients in the filter */
000012  8805              LDRH     r5,[r0,#0]
000014  4692              MOV      r10,r2                ;188
;;;195      uint32_t tapCnt, blkCnt;                       /* Loop counters */
;;;196      float32_t sum, e, d;                           /* accumulator, error, reference data sample */
;;;197      float32_t w = 0.0f;                            /* weight factor */
000016  ed9f1a56          VLDR     s2,|L1.368|
;;;198    
;;;199      e = 0.0f;
;;;200      d = 0.0f;
;;;201    
;;;202      /* S->pState points to state array which contains previous frame (numTaps - 1) samples */
;;;203      /* pStateCurnt points to the location where the new input data should be written */
;;;204      pStateCurnt = &(S->pState[(numTaps - 1u)]);
00001a  f06f0203          MVN      r2,#3
00001e  eb020285          ADD      r2,r2,r5,LSL #2
000022  eb030c02          ADD      r12,r3,r2
000026  e07a              B        |L1.286|
                  |L1.40|
;;;205    
;;;206      blkCnt = blockSize;
;;;207    
;;;208    
;;;209    #ifndef ARM_MATH_CM0_FAMILY
;;;210    
;;;211      /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;212    
;;;213      while(blkCnt > 0u)
;;;214      {
;;;215        /* Copy the new input sample into the state buffer */
;;;216        *pStateCurnt++ = *pSrc++;
000028  ecb10a01          VLDM     r1!,{s0}
;;;217    
;;;218        /* Initialize pState pointer */
;;;219        px = pState;
;;;220    
;;;221        /* Initialize coeff pointer */
;;;222        pb = (pCoeffs);
;;;223    
;;;224        /* Set the accumulator to zero */
;;;225        sum = 0.0f;
;;;226    
;;;227        /* Loop unrolling.  Process 4 taps at a time. */
;;;228        tapCnt = numTaps >> 2;
00002c  08ae              LSRS     r6,r5,#2
00002e  461c              MOV      r4,r3                 ;219
000030  4642              MOV      r2,r8                 ;222
000032  ecac0a01          VSTM     r12!,{s0}             ;216
000036  eeb00a41          VMOV.F32 s0,s2                 ;225
00003a  46b1              MOV      r9,r6
;;;229    
;;;230        while(tapCnt > 0u)
00003c  e01b              B        |L1.118|
;;;231        {
;;;232          /* Perform the multiply-accumulate */
;;;233          sum += (*px++) * (*pb++);
00003e  bf00              NOP      
                  |L1.64|
000040  edd41a00          VLDR     s3,[r4,#0]
000044  ed922a00          VLDR     s4,[r2,#0]
000048  ee010a82          VMLA.F32 s0,s3,s4
;;;234          sum += (*px++) * (*pb++);
00004c  edd41a01          VLDR     s3,[r4,#4]
000050  ed922a01          VLDR     s4,[r2,#4]
000054  ee010a82          VMLA.F32 s0,s3,s4
;;;235          sum += (*px++) * (*pb++);
000058  edd41a02          VLDR     s3,[r4,#8]
00005c  ed922a02          VLDR     s4,[r2,#8]
000060  ee010a82          VMLA.F32 s0,s3,s4
;;;236          sum += (*px++) * (*pb++);
000064  edd41a03          VLDR     s3,[r4,#0xc]
000068  ed922a03          VLDR     s4,[r2,#0xc]
00006c  3210              ADDS     r2,r2,#0x10
00006e  3410              ADDS     r4,r4,#0x10
000070  1e76              SUBS     r6,r6,#1
000072  ee010a82          VMLA.F32 s0,s3,s4
                  |L1.118|
000076  2e00              CMP      r6,#0                 ;230
000078  d1e2              BNE      |L1.64|
;;;237    
;;;238          /* Decrement the loop counter */
;;;239          tapCnt--;
;;;240        }
;;;241    
;;;242        /* If the filter length is not a multiple of 4, compute the remaining filter taps */
;;;243        tapCnt = numTaps % 0x4u;
00007a  f0050603          AND      r6,r5,#3
;;;244    
;;;245        while(tapCnt > 0u)
00007e  9600              STR      r6,[sp,#0]
000080  e007              B        |L1.146|
;;;246        {
;;;247          /* Perform the multiply-accumulate */
;;;248          sum += (*px++) * (*pb++);
000082  bf00              NOP      
                  |L1.132|
000084  ecf41a01          VLDM     r4!,{s3}
000088  1e76              SUBS     r6,r6,#1
00008a  ecb22a01          VLDM     r2!,{s4}
00008e  ee010a82          VMLA.F32 s0,s3,s4
                  |L1.146|
000092  2e00              CMP      r6,#0                 ;245
000094  d1f6              BNE      |L1.132|
;;;249    
;;;250          /* Decrement the loop counter */
;;;251          tapCnt--;
;;;252        }
;;;253    
;;;254        /* The result in the accumulator, store in the destination buffer. */
;;;255        *pOut++ = sum;
000096  ecab0a01          VSTM     r11!,{s0}
;;;256    
;;;257        /* Compute and store error */
;;;258        d = (float32_t) (*pRef++);
;;;259        e = d - sum;
;;;260        *pErr++ = e;
;;;261    
;;;262        /* Calculation of Weighting factor for the updating filter coefficients */
;;;263        w = e * mu;
;;;264    
;;;265        /* Initialize pState pointer */
;;;266        px = pState;
00009a  461c              MOV      r4,r3
00009c  ecfa1a01          VLDM     r10!,{s3}             ;258
;;;267    
;;;268        /* Initialize coeff pointer */
;;;269        pb = (pCoeffs);
0000a0  4642              MOV      r2,r8
0000a2  464e              MOV      r6,r9
0000a4  ee310ac0          VSUB.F32 s0,s3,s0              ;259
0000a8  ecae0a01          VSTM     lr!,{s0}              ;260
0000ac  ee200a20          VMUL.F32 s0,s0,s1              ;263
;;;270    
;;;271        /* Loop unrolling.  Process 4 taps at a time. */
;;;272        tapCnt = numTaps >> 2;
;;;273    
;;;274        /* Update filter coefficients */
;;;275        while(tapCnt > 0u)
0000b0  e023              B        |L1.250|
;;;276        {
;;;277          /* Perform the multiply-accumulate */
;;;278          *pb = *pb + (w * (*px++));
0000b2  bf00              NOP      
                  |L1.180|
0000b4  edd21a00          VLDR     s3,[r2,#0]
0000b8  ed942a00          VLDR     s4,[r4,#0]
0000bc  ee401a02          VMLA.F32 s3,s0,s4
0000c0  edc21a00          VSTR     s3,[r2,#0]
;;;279          pb++;
;;;280    
;;;281          *pb = *pb + (w * (*px++));
0000c4  edd21a01          VLDR     s3,[r2,#4]
0000c8  ed942a01          VLDR     s4,[r4,#4]
0000cc  ee401a02          VMLA.F32 s3,s0,s4
0000d0  edc21a01          VSTR     s3,[r2,#4]
;;;282          pb++;
;;;283    
;;;284          *pb = *pb + (w * (*px++));
0000d4  edd21a02          VLDR     s3,[r2,#8]
0000d8  ed942a02          VLDR     s4,[r4,#8]
0000dc  ee401a02          VMLA.F32 s3,s0,s4
0000e0  edc21a02          VSTR     s3,[r2,#8]
;;;285          pb++;
;;;286    
;;;287          *pb = *pb + (w * (*px++));
0000e4  edd21a03          VLDR     s3,[r2,#0xc]
0000e8  ed942a03          VLDR     s4,[r4,#0xc]
0000ec  3410              ADDS     r4,r4,#0x10
0000ee  ee401a02          VMLA.F32 s3,s0,s4
0000f2  edc21a03          VSTR     s3,[r2,#0xc]
0000f6  3210              ADDS     r2,r2,#0x10
0000f8  1e76              SUBS     r6,r6,#1
                  |L1.250|
0000fa  2e00              CMP      r6,#0                 ;275
0000fc  d1da              BNE      |L1.180|
;;;288          pb++;
;;;289    
;;;290          /* Decrement the loop counter */
;;;291          tapCnt--;
;;;292        }
;;;293    
;;;294        /* If the filter length is not a multiple of 4, compute the remaining filter taps */
;;;295        tapCnt = numTaps % 0x4u;
;;;296    
;;;297        while(tapCnt > 0u)
0000fe  9e00              LDR      r6,[sp,#0]
000100  e009              B        |L1.278|
;;;298        {
;;;299          /* Perform the multiply-accumulate */
;;;300          *pb = *pb + (w * (*px++));
000102  bf00              NOP      
                  |L1.260|
000104  ecb42a01          VLDM     r4!,{s4}
000108  edd21a00          VLDR     s3,[r2,#0]
00010c  1e76              SUBS     r6,r6,#1
00010e  ee401a02          VMLA.F32 s3,s0,s4
000112  ece21a01          VSTM     r2!,{s3}
                  |L1.278|
000116  2e00              CMP      r6,#0                 ;297
000118  d1f4              BNE      |L1.260|
00011a  1d1b              ADDS     r3,r3,#4              ;297
00011c  1e7f              SUBS     r7,r7,#1              ;297
                  |L1.286|
00011e  2f00              CMP      r7,#0                 ;213
000120  d182              BNE      |L1.40|
;;;301          pb++;
;;;302    
;;;303          /* Decrement the loop counter */
;;;304          tapCnt--;
;;;305        }
;;;306    
;;;307        /* Advance state pointer by 1 for the next sample */
;;;308        pState = pState + 1;
;;;309    
;;;310        /* Decrement the loop counter */
;;;311        blkCnt--;
;;;312      }
;;;313    
;;;314    
;;;315      /* Processing is complete. Now copy the last numTaps - 1 samples to the    
;;;316         satrt of the state buffer. This prepares the state buffer for the    
;;;317         next function call. */
;;;318    
;;;319      /* Points to the start of the pState buffer */
;;;320      pStateCurnt = S->pState;
000122  1e6d              SUBS     r5,r5,#1
000124  6840              LDR      r0,[r0,#4]
;;;321    
;;;322      /* Loop unrolling for (numTaps - 1u) samples copy */
;;;323      tapCnt = (numTaps - 1u) >> 2u;
000126  08a9              LSRS     r1,r5,#2
;;;324    
;;;325      /* copy data */
;;;326      while(tapCnt > 0u)
000128  e013              B        |L1.338|
;;;327      {
;;;328        *pStateCurnt++ = *pState++;
00012a  bf00              NOP      
                  |L1.300|
00012c  ed930a00          VLDR     s0,[r3,#0]
;;;329        *pStateCurnt++ = *pState++;
;;;330        *pStateCurnt++ = *pState++;
;;;331        *pStateCurnt++ = *pState++;
000130  1e49              SUBS     r1,r1,#1
000132  ed800a00          VSTR     s0,[r0,#0]            ;328
000136  ed930a01          VLDR     s0,[r3,#4]            ;329
00013a  ed800a01          VSTR     s0,[r0,#4]            ;329
00013e  ed930a02          VLDR     s0,[r3,#8]            ;330
000142  ed800a02          VSTR     s0,[r0,#8]            ;330
000146  ed930a03          VLDR     s0,[r3,#0xc]
00014a  ed800a03          VSTR     s0,[r0,#0xc]
00014e  3010              ADDS     r0,r0,#0x10
000150  3310              ADDS     r3,r3,#0x10
                  |L1.338|
000152  2900              CMP      r1,#0                 ;326
000154  d1ea              BNE      |L1.300|
;;;332    
;;;333        /* Decrement the loop counter */
;;;334        tapCnt--;
;;;335      }
;;;336    
;;;337      /* Calculate remaining number of copies */
;;;338      tapCnt = (numTaps - 1u) % 0x4u;
000156  f0050103          AND      r1,r5,#3
;;;339    
;;;340      /* Copy the remaining q31_t data */
;;;341      while(tapCnt > 0u)
00015a  e004              B        |L1.358|
                  |L1.348|
;;;342      {
;;;343        *pStateCurnt++ = *pState++;
00015c  ecb30a01          VLDM     r3!,{s0}
000160  1e49              SUBS     r1,r1,#1
000162  eca00a01          VSTM     r0!,{s0}
                  |L1.358|
000166  2900              CMP      r1,#0                 ;341
000168  d1f8              BNE      |L1.348|
;;;344    
;;;345        /* Decrement the loop counter */
;;;346        tapCnt--;
;;;347      }
;;;348    
;;;349    #else
;;;350    
;;;351      /* Run the below code for Cortex-M0 */
;;;352    
;;;353      while(blkCnt > 0u)
;;;354      {
;;;355        /* Copy the new input sample into the state buffer */
;;;356        *pStateCurnt++ = *pSrc++;
;;;357    
;;;358        /* Initialize pState pointer */
;;;359        px = pState;
;;;360    
;;;361        /* Initialize pCoeffs pointer */
;;;362        pb = pCoeffs;
;;;363    
;;;364        /* Set the accumulator to zero */
;;;365        sum = 0.0f;
;;;366    
;;;367        /* Loop over numTaps number of values */
;;;368        tapCnt = numTaps;
;;;369    
;;;370        while(tapCnt > 0u)
;;;371        {
;;;372          /* Perform the multiply-accumulate */
;;;373          sum += (*px++) * (*pb++);
;;;374    
;;;375          /* Decrement the loop counter */
;;;376          tapCnt--;
;;;377        }
;;;378    
;;;379        /* The result is stored in the destination buffer. */
;;;380        *pOut++ = sum;
;;;381    
;;;382        /* Compute and store error */
;;;383        d = (float32_t) (*pRef++);
;;;384        e = d - sum;
;;;385        *pErr++ = e;
;;;386    
;;;387        /* Weighting factor for the LMS version */
;;;388        w = e * mu;
;;;389    
;;;390        /* Initialize pState pointer */
;;;391        px = pState;
;;;392    
;;;393        /* Initialize pCoeffs pointer */
;;;394        pb = pCoeffs;
;;;395    
;;;396        /* Loop over numTaps number of values */
;;;397        tapCnt = numTaps;
;;;398    
;;;399        while(tapCnt > 0u)
;;;400        {
;;;401          /* Perform the multiply-accumulate */
;;;402          *pb = *pb + (w * (*px++));
;;;403          pb++;
;;;404    
;;;405          /* Decrement the loop counter */
;;;406          tapCnt--;
;;;407        }
;;;408    
;;;409        /* Advance state pointer by 1 for the next sample */
;;;410        pState = pState + 1;
;;;411    
;;;412        /* Decrement the loop counter */
;;;413        blkCnt--;
;;;414      }
;;;415    
;;;416    
;;;417      /* Processing is complete. Now copy the last numTaps - 1 samples to the        
;;;418       * start of the state buffer. This prepares the state buffer for the        
;;;419       * next function call. */
;;;420    
;;;421      /* Points to the start of the pState buffer */
;;;422      pStateCurnt = S->pState;
;;;423    
;;;424      /*  Copy (numTaps - 1u) samples  */
;;;425      tapCnt = (numTaps - 1u);
;;;426    
;;;427      /* Copy the data */
;;;428      while(tapCnt > 0u)
;;;429      {
;;;430        *pStateCurnt++ = *pState++;
;;;431    
;;;432        /* Decrement the loop counter */
;;;433        tapCnt--;
;;;434      }
;;;435    
;;;436    #endif /*   #ifndef ARM_MATH_CM0_FAMILY */
;;;437    
;;;438    }
00016a  e8bd8ff8          POP      {r3-r11,pc}
;;;439    
                          ENDP

00016e  0000              DCW      0x0000
                  |L1.368|
000170  00000000          DCFS     0x00000000 ; 0

;*** Start embedded assembler ***

#line 1 "src\\FilteringFunctions\\arm_lms_f32.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_arm_lms_f32_c_8ccd16f4____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___13_arm_lms_f32_c_8ccd16f4____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_arm_lms_f32_c_8ccd16f4____REVSH|
#line 144
|__asm___13_arm_lms_f32_c_8ccd16f4____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___13_arm_lms_f32_c_8ccd16f4____RRX|
#line 300
|__asm___13_arm_lms_f32_c_8ccd16f4____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
