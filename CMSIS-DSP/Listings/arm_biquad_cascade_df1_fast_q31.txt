; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_biquad_cascade_df1_fast_q31.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_biquad_cascade_df1_fast_q31.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_biquad_cascade_df1_fast_q31.crf src\FilteringFunctions\arm_biquad_cascade_df1_fast_q31.c]
                          THUMB

                          AREA ||i.arm_biquad_cascade_df1_fast_q31||, CODE, READONLY, ALIGN=2

                  arm_biquad_cascade_df1_fast_q31 PROC
;;;76     
;;;77     void arm_biquad_cascade_df1_fast_q31(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;78       const arm_biquad_casd_df1_inst_q31 * S,
;;;79       q31_t * pSrc,
;;;80       q31_t * pDst,
;;;81       uint32_t blockSize)
;;;82     {
000004  b088              SUB      sp,sp,#0x20
;;;83       q31_t acc = 0;                                 /*  accumulator                   */
;;;84       q31_t Xn1, Xn2, Yn1, Yn2;                      /*  Filter state variables        */
;;;85       q31_t b0, b1, b2, a1, a2;                      /*  Filter coefficients           */
;;;86       q31_t *pIn = pSrc;                             /*  input pointer initialization  */
;;;87       q31_t *pOut = pDst;                            /*  output pointer initialization */
000006  e9d02301          LDRD     r2,r3,[r0,#4]
;;;88       q31_t *pState = S->pState;                     /*  pState pointer initialization */
;;;89       q31_t *pCoeffs = S->pCoeffs;                   /*  coeff pointer initialization  */
00000a  9d0a              LDR      r5,[sp,#0x28]
;;;90       q31_t Xn;                                      /*  temporary input               */
;;;91       int32_t shift = (int32_t) S->postShift + 1;    /*  Shift to be applied to the output */
00000c  9305              STR      r3,[sp,#0x14]
00000e  7b03              LDRB     r3,[r0,#0xc]
000010  1c5b              ADDS     r3,r3,#1
;;;92       uint32_t sample, stage = S->numStages;         /*  loop counters                     */
000012  9303              STR      r3,[sp,#0xc]
000014  6800              LDR      r0,[r0,#0]
000016  9006              STR      r0,[sp,#0x18]         ;82
;;;93     
;;;94     
;;;95       do
;;;96       {
;;;97         /* Reading the coefficients */
;;;98         b0 = *pCoeffs++;
;;;99         b1 = *pCoeffs++;
;;;100        b2 = *pCoeffs++;
;;;101        a1 = *pCoeffs++;
;;;102        a2 = *pCoeffs++;
;;;103    
;;;104        /* Reading the state values */
;;;105        Xn1 = pState[0];
;;;106        Xn2 = pState[1];
;;;107        Yn1 = pState[2];
;;;108        Yn2 = pState[3];
;;;109    
;;;110        /* Apply loop unrolling and compute 4 output values simultaneously. */
;;;111        /*      The variables acc ... acc3 hold output values that are being computed:       
;;;112         *       
;;;113         *    acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2]       
;;;114         */
;;;115    
;;;116        sample = blockSize >> 2u;
000018  980b              LDR      r0,[sp,#0x2c]
00001a  0880              LSRS     r0,r0,#2
00001c  9007              STR      r0,[sp,#0x1c]
                  |L1.30|
00001e  9805              LDR      r0,[sp,#0x14]         ;98
;;;117    
;;;118        /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.       
;;;119         ** a second loop below computes the remaining 1 to 3 samples. */
;;;120        while(sample > 0u)
000020  9e07              LDR      r6,[sp,#0x1c]
000022  e9d0eb00          LDRD     lr,r11,[r0,#0]        ;102
000026  e9d09a02          LDRD     r9,r10,[r0,#8]        ;102
00002a  6907              LDR      r7,[r0,#0x10]         ;102
00002c  3014              ADDS     r0,r0,#0x14           ;102
00002e  9005              STR      r0,[sp,#0x14]         ;102
000030  e9d24000          LDRD     r4,r0,[r2,#0]         ;102
000034  9000              STR      r0,[sp,#0]            ;106
000036  e9d20302          LDRD     r0,r3,[r2,#8]         ;106
00003a  e04d              B        |L1.216|
                  |L1.60|
;;;121        {
;;;122          /* Read the input */
;;;123          Xn = *pIn;
00003c  c940              LDM      r1!,{r6}
;;;124    
;;;125          /* acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2] */
;;;126          /* acc =  b0 * x[n] */
;;;127          /*acc = (q31_t) (((q63_t) b1 * Xn1) >> 32);*/
;;;128          mult_32x32_keep32_R(acc, b1, Xn1);
00003e  fb5bfc14          SMMULR   r12,r11,r4
;;;129          /* acc +=  b1 * x[n-1] */
;;;130          /*acc = (q31_t) ((((q63_t) acc << 32) + ((q63_t) b0 * (Xn))) >> 32);*/
;;;131          multAcc_32x32_keep32_R(acc, b0, Xn);
000042  9601              STR      r6,[sp,#4]
000044  fb5ec616          SMMLAR   r6,lr,r6,r12
;;;132          /* acc +=  b[2] * x[n-2] */
;;;133          /*acc = (q31_t) ((((q63_t) acc << 32) + ((q63_t) b2 * (Xn2))) >> 32);*/
;;;134          multAcc_32x32_keep32_R(acc, b2, Xn2);
000048  f8dd8000          LDR      r8,[sp,#0]
00004c  fb596618          SMMLAR   r6,r9,r8,r6
;;;135          /* acc +=  a1 * y[n-1] */
;;;136          /*acc = (q31_t) ((((q63_t) acc << 32) + ((q63_t) a1 * (Yn1))) >> 32);*/
;;;137          multAcc_32x32_keep32_R(acc, a1, Yn1);
000050  fb5a6610          SMMLAR   r6,r10,r0,r6
;;;138          /* acc +=  a2 * y[n-2] */
;;;139          /*acc = (q31_t) ((((q63_t) acc << 32) + ((q63_t) a2 * (Yn2))) >> 32);*/
;;;140          multAcc_32x32_keep32_R(acc, a2, Yn2);
000054  fb576313          SMMLAR   r3,r7,r3,r6
;;;141    
;;;142          /* The result is converted to 1.31 , Yn2 variable is reused */
;;;143          Yn2 = acc << shift;
000058  9e03              LDR      r6,[sp,#0xc]
00005a  fa03f806          LSL      r8,r3,r6
;;;144    
;;;145          /* Read the second input */
;;;146          Xn2 = *(pIn + 1u);
00005e  c940              LDM      r1!,{r6}
;;;147    
;;;148          /* Store the output in the destination buffer. */
;;;149          *pOut = Yn2;
000060  9600              STR      r6,[sp,#0]
000062  f8458b04          STR      r8,[r5],#4
;;;150    
;;;151          /* acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2] */
;;;152          /* acc =  b0 * x[n] */
;;;153          /*acc = (q31_t) (((q63_t) b0 * (Xn2)) >> 32);*/
;;;154          mult_32x32_keep32_R(acc, b0, Xn2);
000066  9e00              LDR      r6,[sp,#0]
000068  fb5ef316          SMMULR   r3,lr,r6
;;;155          /* acc +=  b1 * x[n-1] */
;;;156          /*acc = (q31_t) ((((q63_t) acc << 32) + ((q63_t) b1 * (Xn))) >> 32);*/
;;;157          multAcc_32x32_keep32_R(acc, b1, Xn);
00006c  9e01              LDR      r6,[sp,#4]
00006e  fb5b3316          SMMLAR   r3,r11,r6,r3
;;;158          /* acc +=  b[2] * x[n-2] */
;;;159          /*acc = (q31_t) ((((q63_t) acc << 32) + ((q63_t) b2 * (Xn1))) >> 32);*/
;;;160          multAcc_32x32_keep32_R(acc, b2, Xn1);
000072  fb593414          SMMLAR   r4,r9,r4,r3
;;;161          /* acc +=  a1 * y[n-1] */
;;;162          /*acc = (q31_t) ((((q63_t) acc << 32) + ((q63_t) a1 * (Yn2))) >> 32);*/
;;;163          multAcc_32x32_keep32_R(acc, a1, Yn2);
000076  fb5a4318          SMMLAR   r3,r10,r8,r4
;;;164          /* acc +=  a2 * y[n-2] */
;;;165          /*acc = (q31_t) ((((q63_t) acc << 32) + ((q63_t) a2 * (Yn1))) >> 32);*/
;;;166          multAcc_32x32_keep32_R(acc, a2, Yn1);
00007a  fb573010          SMMLAR   r0,r7,r0,r3
;;;167    
;;;168          /* The result is converted to 1.31, Yn1 variable is reused  */
;;;169          Yn1 = acc << shift;
00007e  9b03              LDR      r3,[sp,#0xc]
;;;170    
;;;171          /* Read the third input  */
;;;172          Xn1 = *(pIn + 2u);
000080  f8516b08          LDR      r6,[r1],#8
000084  4098              LSLS     r0,r0,r3              ;169
;;;173    
;;;174          /* Store the output in the destination buffer. */
;;;175          *(pOut + 1u) = Yn1;
000086  9604              STR      r6,[sp,#0x10]
000088  c501              STM      r5!,{r0}
;;;176    
;;;177          /* acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2] */
;;;178          /* acc =  b0 * x[n] */
;;;179          /*acc = (q31_t) (((q63_t) b0 * (Xn1)) >> 32);*/
;;;180          mult_32x32_keep32_R(acc, b0, Xn1);
00008a  9e04              LDR      r6,[sp,#0x10]
00008c  fb5ef316          SMMULR   r3,lr,r6
;;;181          /* acc +=  b1 * x[n-1] */
;;;182          /*acc = (q31_t) ((((q63_t) acc << 32) + ((q63_t) b1 * (Xn2))) >> 32);*/
;;;183          multAcc_32x32_keep32_R(acc, b1, Xn2);
000090  9e00              LDR      r6,[sp,#0]
000092  fb5b3316          SMMLAR   r3,r11,r6,r3
;;;184          /* acc +=  b[2] * x[n-2] */
;;;185          /*acc = (q31_t) ((((q63_t) acc << 32) + ((q63_t) b2 * (Xn))) >> 32);*/
;;;186          multAcc_32x32_keep32_R(acc, b2, Xn);
000096  9e01              LDR      r6,[sp,#4]
000098  fb593316          SMMLAR   r3,r9,r6,r3
;;;187          /* acc +=  a1 * y[n-1] */
;;;188          /*acc = (q31_t) ((((q63_t) acc << 32) + ((q63_t) a1 * (Yn1))) >> 32);*/
;;;189          multAcc_32x32_keep32_R(acc, a1, Yn1);
00009c  fb5a3410          SMMLAR   r4,r10,r0,r3
;;;190          /* acc +=  a2 * y[n-2] */
;;;191          /*acc = (q31_t) ((((q63_t) acc << 32) + ((q63_t) a2 * (Yn2))) >> 32);*/
;;;192          multAcc_32x32_keep32_R(acc, a2, Yn2);
0000a0  fb574318          SMMLAR   r3,r7,r8,r4
;;;193    
;;;194          /* The result is converted to 1.31, Yn2 variable is reused  */
;;;195          Yn2 = acc << shift;
0000a4  9c03              LDR      r4,[sp,#0xc]
0000a6  40a3              LSLS     r3,r3,r4
;;;196    
;;;197          /* Read the forth input */
;;;198          Xn = *(pIn + 3u);
0000a8  f8514c04          LDR      r4,[r1,#-4]
;;;199    
;;;200          /* Store the output in the destination buffer. */
;;;201          *(pOut + 2u) = Yn2;
0000ac  f8453b08          STR      r3,[r5],#8
;;;202          pIn += 4u;
;;;203    
;;;204          /* acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2] */
;;;205          /* acc =  b0 * x[n] */
;;;206          /*acc = (q31_t) (((q63_t) b0 * (Xn)) >> 32);*/
;;;207          mult_32x32_keep32_R(acc, b0, Xn);
0000b0  fb5efc14          SMMULR   r12,lr,r4
;;;208          /* acc +=  b1 * x[n-1] */
;;;209          /*acc = (q31_t) ((((q63_t) acc << 32) + ((q63_t) b1 * (Xn1))) >> 32);*/
;;;210          multAcc_32x32_keep32_R(acc, b1, Xn1);
0000b4  9e04              LDR      r6,[sp,#0x10]
0000b6  fb5bcc16          SMMLAR   r12,r11,r6,r12
;;;211          /* acc +=  b[2] * x[n-2] */
;;;212          /*acc = (q31_t) ((((q63_t) acc << 32) + ((q63_t) b2 * (Xn2))) >> 32);*/
;;;213          multAcc_32x32_keep32_R(acc, b2, Xn2);
0000ba  9e00              LDR      r6,[sp,#0]
0000bc  fb59c616          SMMLAR   r6,r9,r6,r12
;;;214          /* acc +=  a1 * y[n-1] */
;;;215          /*acc = (q31_t) ((((q63_t) acc << 32) + ((q63_t) a1 * (Yn2))) >> 32);*/
;;;216          multAcc_32x32_keep32_R(acc, a1, Yn2);
0000c0  fb5a6613          SMMLAR   r6,r10,r3,r6
;;;217          /* acc +=  a2 * y[n-2] */
;;;218          /*acc = (q31_t) ((((q63_t) acc << 32) + ((q63_t) a2 * (Yn1))) >> 32);*/
;;;219          multAcc_32x32_keep32_R(acc, a2, Yn1);
0000c4  fb576010          SMMLAR   r0,r7,r0,r6
;;;220    
;;;221          /* Every time after the output is computed state should be updated. */
;;;222          /* The states should be updated as:  */
;;;223          /* Xn2 = Xn1    */
;;;224          Xn2 = Xn1;
0000c8  9e04              LDR      r6,[sp,#0x10]
;;;225    
;;;226          /* The result is converted to 1.31, Yn1 variable is reused  */
;;;227          Yn1 = acc << shift;
0000ca  9600              STR      r6,[sp,#0]
0000cc  9e03              LDR      r6,[sp,#0xc]
0000ce  40b0              LSLS     r0,r0,r6
;;;228    
;;;229          /* Xn1 = Xn     */
;;;230          Xn1 = Xn;
;;;231    
;;;232          /* Store the output in the destination buffer. */
;;;233          *(pOut + 3u) = Yn1;
0000d0  f8450c04          STR      r0,[r5,#-4]
;;;234          pOut += 4u;
;;;235    
;;;236          /* decrement the loop counter */
;;;237          sample--;
0000d4  9e02              LDR      r6,[sp,#8]
0000d6  1e76              SUBS     r6,r6,#1
                  |L1.216|
0000d8  9602              STR      r6,[sp,#8]            ;116
0000da  2e00              CMP      r6,#0                 ;116
0000dc  d1ae              BNE      |L1.60|
;;;238        }
;;;239    
;;;240        /* If the blockSize is not a multiple of 4, compute any remaining output samples here.       
;;;241         ** No loop unrolling is used. */
;;;242        sample = (blockSize & 0x3u);
0000de  9e0b              LDR      r6,[sp,#0x2c]
0000e0  f0060603          AND      r6,r6,#3
;;;243    
;;;244       while(sample > 0u)
0000e4  e019              B        |L1.282|
;;;245       {
;;;246          /* Read the input */
;;;247          Xn = *pIn++;
0000e6  bf00              NOP      
                  |L1.232|
0000e8  f851cb04          LDR      r12,[r1],#4
;;;248    
;;;249          /* acc =  b0 * x[n] + b1 * x[n-1] + b2 * x[n-2] + a1 * y[n-1] + a2 * y[n-2] */
;;;250          /* acc =  b0 * x[n] */
;;;251          /*acc = (q31_t) (((q63_t) b0 * (Xn)) >> 32);*/
;;;252          mult_32x32_keep32_R(acc, b0, Xn);
0000ec  fb5ef61c          SMMULR   r6,lr,r12
;;;253          /* acc +=  b1 * x[n-1] */
;;;254          /*acc = (q31_t) ((((q63_t) acc << 32) + ((q63_t) b1 * (Xn1))) >> 32);*/
;;;255          multAcc_32x32_keep32_R(acc, b1, Xn1);
0000f0  fb5b6614          SMMLAR   r6,r11,r4,r6
;;;256          /* acc +=  b[2] * x[n-2] */
;;;257          /*acc = (q31_t) ((((q63_t) acc << 32) + ((q63_t) b2 * (Xn2))) >> 32);*/
;;;258          multAcc_32x32_keep32_R(acc, b2, Xn2);
0000f4  f8cdc004          STR      r12,[sp,#4]
0000f8  f8ddc000          LDR      r12,[sp,#0]
0000fc  fb59661c          SMMLAR   r6,r9,r12,r6
;;;259          /* acc +=  a1 * y[n-1] */
;;;260          /*acc = (q31_t) ((((q63_t) acc << 32) + ((q63_t) a1 * (Yn1))) >> 32);*/
;;;261          multAcc_32x32_keep32_R(acc, a1, Yn1);
000100  fb5a6610          SMMLAR   r6,r10,r0,r6
;;;262          /* acc +=  a2 * y[n-2] */
;;;263          /*acc = (q31_t) ((((q63_t) acc << 32) + ((q63_t) a2 * (Yn2))) >> 32);*/
;;;264          multAcc_32x32_keep32_R(acc, a2, Yn2);
000104  fb576613          SMMLAR   r6,r7,r3,r6
;;;265    
;;;266          /* The result is converted to 1.31  */
;;;267          acc = acc << shift;
000108  9b03              LDR      r3,[sp,#0xc]
;;;268    
;;;269          /* Every time after the output is computed state should be updated. */
;;;270          /* The states should be updated as:  */
;;;271          /* Xn2 = Xn1    */
;;;272          /* Xn1 = Xn     */
;;;273          /* Yn2 = Yn1    */
;;;274          /* Yn1 = acc    */
;;;275          Xn2 = Xn1;
;;;276          Xn1 = Xn;
00010a  9400              STR      r4,[sp,#0]
00010c  409e              LSLS     r6,r6,r3              ;267
;;;277          Yn2 = Yn1;
;;;278          Yn1 = acc;
;;;279    
;;;280          /* Store the output in the destination buffer. */
;;;281          *pOut++ = acc;
00010e  9c01              LDR      r4,[sp,#4]
000110  4603              MOV      r3,r0                 ;277
000112  c540              STM      r5!,{r6}
000114  4630              MOV      r0,r6                 ;278
;;;282    
;;;283          /* decrement the loop counter */
;;;284          sample--;
000116  9e02              LDR      r6,[sp,#8]
000118  1e76              SUBS     r6,r6,#1
                  |L1.282|
00011a  9602              STR      r6,[sp,#8]            ;242
00011c  2e00              CMP      r6,#0                 ;242
00011e  d1e3              BNE      |L1.232|
;;;285       }
;;;286    
;;;287        /*  The first stage goes from the input buffer to the output buffer. */
;;;288        /*  Subsequent stages occur in-place in the output buffer */
;;;289        pIn = pDst;
;;;290    
;;;291        /* Reset to destination pointer */
;;;292        pOut = pDst;
000120  990a              LDR      r1,[sp,#0x28]
;;;293    
;;;294        /*  Store the updated state variables back into the pState array */
;;;295        *pState++ = Xn1;
000122  c210              STM      r2!,{r4}
;;;296        *pState++ = Xn2;
000124  9c00              LDR      r4,[sp,#0]
000126  460d              MOV      r5,r1                 ;292
000128  c210              STM      r2!,{r4}
00012a  e8e20302          STRD     r0,r3,[r2],#8
;;;297        *pState++ = Yn1;
;;;298        *pState++ = Yn2;
;;;299    
;;;300      } while(--stage);
00012e  9806              LDR      r0,[sp,#0x18]
000130  1e40              SUBS     r0,r0,#1
000132  9006              STR      r0,[sp,#0x18]
000134  f47faf73          BNE      |L1.30|
;;;301    }
000138  b00c              ADD      sp,sp,#0x30
00013a  e8bd8ff0          POP      {r4-r11,pc}
;;;302    
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\FilteringFunctions\\arm_biquad_cascade_df1_fast_q31.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___33_arm_biquad_cascade_df1_fast_q31_c_0fbfa3c1____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___33_arm_biquad_cascade_df1_fast_q31_c_0fbfa3c1____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___33_arm_biquad_cascade_df1_fast_q31_c_0fbfa3c1____REVSH|
#line 144
|__asm___33_arm_biquad_cascade_df1_fast_q31_c_0fbfa3c1____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___33_arm_biquad_cascade_df1_fast_q31_c_0fbfa3c1____RRX|
#line 300
|__asm___33_arm_biquad_cascade_df1_fast_q31_c_0fbfa3c1____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
