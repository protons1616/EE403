; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_rfft_fast_f32.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_rfft_fast_f32.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_rfft_fast_f32.crf src\TransformFunctions\arm_rfft_fast_f32.c]
                          THUMB

                          AREA ||i.arm_rfft_fast_f32||, CODE, READONLY, ALIGN=1

                  arm_rfft_fast_f32 PROC
;;;323    
;;;324    void arm_rfft_fast_f32(
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;325    arm_rfft_fast_instance_f32 * S,
;;;326    float32_t * p, float32_t * pOut,
;;;327    uint8_t ifftFlag)
;;;328    {
000004  4604              MOV      r4,r0
;;;329       arm_cfft_instance_f32 * Sint = &(S->Sint);
;;;330       Sint->fftLen = S->fftLenRFFT / 2;
000006  8a00              LDRH     r0,[r0,#0x10]
000008  001d              MOVS     r5,r3                 ;328
00000a  ea4f0050          LSR      r0,r0,#1
00000e  4617              MOV      r7,r2                 ;328
000010  460e              MOV      r6,r1                 ;328
000012  8020              STRH     r0,[r4,#0]
000014  d00a              BEQ      |L1.44|
;;;331    
;;;332       /* Calculation of Real FFT */
;;;333       if(ifftFlag)
;;;334       {
;;;335          /*  Real FFT compression */
;;;336          merge_rfft_f32(S, p, pOut);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       merge_rfft_f32
;;;337    
;;;338          /* Complex radix-4 IFFT process */
;;;339          arm_cfft_f32( Sint, pOut, ifftFlag, 1);
00001c  462a              MOV      r2,r5
00001e  4639              MOV      r1,r7
000020  4620              MOV      r0,r4
000022  e8bd41f0          POP      {r4-r8,lr}
000026  2301              MOVS     r3,#1
000028  f7ffbffe          B.W      arm_cfft_f32
                  |L1.44|
;;;340       }
;;;341       else
;;;342       {
;;;343          /* Calculation of RFFT of input */
;;;344          arm_cfft_f32( Sint, p, ifftFlag, 1);
00002c  2301              MOVS     r3,#1
00002e  462a              MOV      r2,r5
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       arm_cfft_f32
;;;345       
;;;346          /*  Real FFT extraction */
;;;347          stage_rfft_f32(S, p, pOut);
000036  463a              MOV      r2,r7
000038  4631              MOV      r1,r6
00003a  4620              MOV      r0,r4
00003c  e8bd41f0          POP      {r4-r8,lr}
000040  f7ffbffe          B.W      stage_rfft_f32
;;;348       }
;;;349    }
;;;350    
                          ENDP


                          AREA ||i.merge_rfft_f32||, CODE, READONLY, ALIGN=1

                  merge_rfft_f32 PROC
;;;128    /* Prepares data for inverse cfft */
;;;129    void merge_rfft_f32(
000000  b510              PUSH     {r4,lr}
;;;130    arm_rfft_fast_instance_f32 * S,
;;;131    float32_t * p, float32_t * pOut)
;;;132    {
;;;133       uint32_t  k;								/* Loop Counter                     */
;;;134       float32_t twR, twI;						/* RFFT Twiddle coefficients        */
;;;135       float32_t *pCoeff = S->pTwiddleRFFT;		/* Points to RFFT Twiddle factors   */
;;;136       float32_t *pA = p;						/* increasing pointer               */
;;;137       float32_t *pB = p;						/* decreasing pointer               */
;;;138       float32_t xAR, xAI, xBR, xBI;			/* temporary variables              */
;;;139       float32_t t1a, t1b, r, s, t, u;			/* temporary variables              */
;;;140    
;;;141       k = (S->Sint).fftLen - 1;					
;;;142    
;;;143       xAR = pA[0];
000002  ed911a00          VLDR     s2,[r1,#0]
;;;144       xAI = pA[1];
000006  edd10a01          VLDR     s1,[r1,#4]
00000a  6943              LDR      r3,[r0,#0x14]         ;141
;;;145    
;;;146       pCoeff += 2 ;
;;;147    
;;;148       *pOut++ = 0.5f * ( xAR + xAI );
00000c  eeb60a00          VMOV.F32 s0,#0.50000000
000010  ee711a20          VADD.F32 s3,s2,s1
;;;149       *pOut++ = 0.5f * ( xAR - xAI );
000014  ee710a60          VSUB.F32 s1,s2,s1
000018  8800              LDRH     r0,[r0,#0]            ;141
00001a  ee611a80          VMUL.F32 s3,s3,s0              ;148
00001e  ee600a80          VMUL.F32 s1,s1,s0
000022  1e40              SUBS     r0,r0,#1
000024  edc21a00          VSTR     s3,[r2,#0]            ;148
000028  edc20a01          VSTR     s1,[r2,#4]
;;;150    
;;;151       pB  =  p + 2*k ;
00002c  eb0104c0          ADD      r4,r1,r0,LSL #3
000030  3108              ADDS     r1,r1,#8
000032  3208              ADDS     r2,r2,#8
000034  3308              ADDS     r3,r3,#8
000036  e030              B        |L2.154|
                  |L2.56|
;;;152       pA +=  2	   ;
;;;153    
;;;154       while(k > 0u)
;;;155       {
;;;156          /* G is half of the frequency complex spectrum */
;;;157          //for k = 2:N
;;;158          //    Xk(k) = 1/2 * (G(k) + conj(G(N-k+2)) + Tw(k)*( G(k) - conj(G(N-k+2))));
;;;159          xBI =   pB[1]    ;
;;;160          xBR =   pB[0]    ;
000038  ed941a00          VLDR     s2,[r4,#0]
;;;161          xAR =  pA[0];
00003c  edd13a00          VLDR     s7,[r1,#0]
000040  ed943a01          VLDR     s6,[r4,#4]            ;159
;;;162          xAI =  pA[1];
000044  edd12a01          VLDR     s5,[r1,#4]
;;;163    
;;;164          twR = *pCoeff++;
;;;165          twI = *pCoeff++;
;;;166    
;;;167          t1a = xAR - xBR ;
000048  ee334ac1          VSUB.F32 s8,s7,s2
00004c  edd31a00          VLDR     s3,[r3,#0]            ;164
;;;168          t1b = xAI + xBI ;
000050  ee720a83          VADD.F32 s1,s5,s6
;;;169    
;;;170          r = twR * t1a;
;;;171          s = twI * t1b;
;;;172          t = twI * t1a;
;;;173          u = twR * t1b;
;;;174    
;;;175          // real(tw * (xA - xB)) = twR * (xAR - xBR) - twI * (xAI - xBI);
;;;176          // imag(tw * (xA - xB)) = twI * (xAR - xBR) + twR * (xAI - xBI);
;;;177          *pOut++ = 0.5f * (xAR + xBR - r - s ); //xAR
000054  ee331a81          VADD.F32 s2,s7,s2
000058  ee215a84          VMUL.F32 s10,s3,s8             ;170
00005c  ed932a01          VLDR     s4,[r3,#4]            ;165
;;;178          *pOut++ = 0.5f * (xAI - xBI + t - u ); //xAI
000060  1e40              SUBS     r0,r0,#1
000062  3108              ADDS     r1,r1,#8
000064  ee624a20          VMUL.F32 s9,s4,s1              ;171
000068  ee311a45          VSUB.F32 s2,s2,s10             ;177
00006c  ee222a04          VMUL.F32 s4,s4,s8              ;172
000070  ee610aa0          VMUL.F32 s1,s3,s1              ;173
000074  3308              ADDS     r3,r3,#8
000076  ee311a64          VSUB.F32 s2,s2,s9              ;177
00007a  ee211a00          VMUL.F32 s2,s2,s0              ;177
00007e  ed821a00          VSTR     s2,[r2,#0]            ;177
000082  ee321ac3          VSUB.F32 s2,s5,s6
000086  ee311a02          VADD.F32 s2,s2,s4
00008a  ee710a60          VSUB.F32 s1,s2,s1
00008e  ee600a80          VMUL.F32 s1,s1,s0
000092  edc20a01          VSTR     s1,[r2,#4]
000096  3208              ADDS     r2,r2,#8
000098  3c08              SUBS     r4,r4,#8
                  |L2.154|
00009a  2800              CMP      r0,#0                 ;154
00009c  d1cc              BNE      |L2.56|
;;;179    
;;;180          pA += 2;
;;;181          pB -= 2;
;;;182          k--;
;;;183       }
;;;184    
;;;185    }
00009e  bd10              POP      {r4,pc}
;;;186    
                          ENDP


                          AREA ||i.stage_rfft_f32||, CODE, READONLY, ALIGN=2

                  stage_rfft_f32 PROC
;;;42     
;;;43     void stage_rfft_f32(
000000  b510              PUSH     {r4,lr}
;;;44       arm_rfft_fast_instance_f32 * S,
;;;45       float32_t * p, float32_t * pOut)
;;;46     {
;;;47        uint32_t  k;								   /* Loop Counter                     */
;;;48        float32_t twR, twI;						   /* RFFT Twiddle coefficients        */
;;;49        float32_t * pCoeff = S->pTwiddleRFFT;  /* Points to RFFT Twiddle factors   */
;;;50        float32_t *pA = p;						   /* increasing pointer               */
;;;51        float32_t *pB = p;						   /* decreasing pointer               */
;;;52        float32_t xAR, xAI, xBR, xBI;				/* temporary variables              */
;;;53        float32_t t1a, t1b;				         /* temporary variables              */
;;;54        float32_t p0, p1, p2, p3;				   /* temporary variables              */
;;;55     
;;;56     
;;;57        k = (S->Sint).fftLen - 1;					
;;;58     
;;;59        /* Pack first and last sample of the frequency domain together */
;;;60     
;;;61        xBR = pB[0];
000002  edd10a00          VLDR     s1,[r1,#0]
;;;62        xBI = pB[1];
000006  ed910a01          VLDR     s0,[r1,#4]
00000a  6943              LDR      r3,[r0,#0x14]         ;57
;;;63        xAR = pA[0];
;;;64        xAI = pA[1];
;;;65     
;;;66        twR = *pCoeff++ ;
;;;67        twI = *pCoeff++ ;
;;;68        
;;;69        // U1 = XA(1) + XB(1); % It is real
;;;70        t1a = xBR + xAR  ;
00000c  ee700aa0          VADD.F32 s1,s1,s1
;;;71        
;;;72        // U2 = XB(1) - XA(1); % It is imaginary
;;;73        t1b = xBI + xAI  ;
000010  ee301a00          VADD.F32 s2,s0,s0
;;;74     
;;;75        // real(tw * (xB - xA)) = twR * (xBR - xAR) - twI * (xBI - xAI);
;;;76        // imag(tw * (xB - xA)) = twI * (xBR - xAR) + twR * (xBI - xAI);
;;;77        *pOut++ = 0.5f * ( t1a + t1b );
000014  eeb60a00          VMOV.F32 s0,#0.50000000
000018  8800              LDRH     r0,[r0,#0]            ;57
00001a  ee701a81          VADD.F32 s3,s1,s2
;;;78        *pOut++ = 0.5f * ( t1a - t1b );
00001e  ee700ac1          VSUB.F32 s1,s1,s2
000022  1e40              SUBS     r0,r0,#1
;;;79     
;;;80        // XA(1) = 1/2*( U1 - imag(U2) +  i*( U1 +imag(U2) ));
;;;81        pB  = p + 2*k;
000024  eb0104c0          ADD      r4,r1,r0,LSL #3
000028  ee611a80          VMUL.F32 s3,s3,s0              ;77
00002c  ee600a80          VMUL.F32 s1,s1,s0              ;78
000030  3108              ADDS     r1,r1,#8
000032  edc21a00          VSTR     s3,[r2,#0]            ;77
000036  edc20a01          VSTR     s1,[r2,#4]            ;78
00003a  3208              ADDS     r2,r2,#8
00003c  f1130308          ADDS.W   r3,r3,#8
                  |L3.64|
000040  ec943a02          VLDM     r4,{s6-s7}
;;;82        pA += 2;
;;;83     
;;;84        do
;;;85        {
;;;86           /*
;;;87              function X = my_split_rfft(X, ifftFlag)
;;;88              % X is a series of real numbers
;;;89              L  = length(X);
;;;90              XC = X(1:2:end) +i*X(2:2:end);
;;;91              XA = fft(XC);
;;;92              XB = conj(XA([1 end:-1:2]));
;;;93              TW = i*exp(-2*pi*i*[0:L/2-1]/L).';
;;;94              for l = 2:L/2
;;;95                 XA(l) = 1/2 * (XA(l) + XB(l) + TW(l) * (XB(l) - XA(l)));
;;;96              end
;;;97              XA(1) = 1/2* (XA(1) + XB(1) + TW(1) * (XB(1) - XA(1))) + i*( 1/2*( XA(1) + XB(1) + i*( XA(1) - XB(1))));
;;;98              X = XA;
;;;99           */
;;;100    
;;;101          xBI = pB[1];
;;;102          xBR = pB[0];
;;;103          xAR = pA[0];
;;;104          xAI = pA[1];
;;;105    
;;;106          twR = *pCoeff++;
;;;107          twI = *pCoeff++;
;;;108    
;;;109          t1a = xBR - xAR ;
;;;110          t1b = xBI + xAI ;
;;;111    
;;;112          // real(tw * (xB - xA)) = twR * (xBR - xAR) - twI * (xBI - xAI);
;;;113          // imag(tw * (xB - xA)) = twI * (xBR - xAR) + twR * (xBI - xAI);
;;;114          p0 = twR * t1a;
;;;115          p1 = twI * t1a;
;;;116          p2 = twR * t1b;
;;;117          p3 = twI * t1b;
;;;118    
;;;119          *pOut++ = 0.5f * (xAR + xBR + p0 + p3 ); //xAR
;;;120          *pOut++ = 0.5f * (xAI - xBI + p1 - p2 ); //xAI
000044  1e40              SUBS     r0,r0,#1
000046  edd12a00          VLDR     s5,[r1,#0]            ;103
00004a  edd10a01          VLDR     s1,[r1,#4]            ;104
00004e  ed931a00          VLDR     s2,[r3,#0]            ;106
000052  ee731a62          VSUB.F32 s3,s6,s5              ;109
000056  ed932a01          VLDR     s4,[r3,#4]            ;107
00005a  ee334aa0          VADD.F32 s8,s7,s1              ;110
00005e  ee722a83          VADD.F32 s5,s5,s6              ;119
000062  ee614a21          VMUL.F32 s9,s2,s3              ;114
000066  ee621a21          VMUL.F32 s3,s4,s3              ;115
00006a  ee700ae3          VSUB.F32 s1,s1,s7
00006e  ee222a04          VMUL.F32 s4,s4,s8              ;117
000072  ee722aa4          VADD.F32 s5,s5,s9              ;119
000076  ee211a04          VMUL.F32 s2,s2,s8              ;116
00007a  ee700aa1          VADD.F32 s1,s1,s3
00007e  f1010108          ADD      r1,r1,#8
000082  ee322a82          VADD.F32 s4,s5,s4              ;119
000086  f1030308          ADD      r3,r3,#8
00008a  ee700ac1          VSUB.F32 s1,s1,s2
00008e  f1a40408          SUB      r4,r4,#8
000092  ee222a00          VMUL.F32 s4,s4,s0              ;119
000096  ee600a80          VMUL.F32 s1,s1,s0
00009a  ed822a00          VSTR     s4,[r2,#0]            ;119
00009e  edc20a01          VSTR     s1,[r2,#4]
0000a2  f1020208          ADD      r2,r2,#8
;;;121    
;;;122          pA += 2;
;;;123          pB -= 2;
;;;124          k--;
;;;125       } while(k > 0u);
0000a6  d1cb              BNE      |L3.64|
;;;126    }
0000a8  bd10              POP      {r4,pc}
;;;127    
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\TransformFunctions\\arm_rfft_fast_f32.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_rfft_fast_f32_c_5aa1c2a8____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___19_arm_rfft_fast_f32_c_5aa1c2a8____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_rfft_fast_f32_c_5aa1c2a8____REVSH|
#line 144
|__asm___19_arm_rfft_fast_f32_c_5aa1c2a8____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_rfft_fast_f32_c_5aa1c2a8____RRX|
#line 300
|__asm___19_arm_rfft_fast_f32_c_5aa1c2a8____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
