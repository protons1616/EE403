; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_fir_q31.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_fir_q31.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_fir_q31.crf src\FilteringFunctions\arm_fir_q31.c]
                          THUMB

                          AREA ||i.arm_fir_q31||, CODE, READONLY, ALIGN=2

                  arm_fir_q31 PROC
;;;71     
;;;72     void arm_fir_q31(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;73       const arm_fir_instance_q31 * S,
;;;74       q31_t * pSrc,
;;;75       q31_t * pDst,
;;;76       uint32_t blockSize)
;;;77     {
000004  b094              SUB      sp,sp,#0x50
;;;78       q31_t *pState = S->pState;                     /* State pointer */
;;;79       q31_t *pCoeffs = S->pCoeffs;                   /* Coefficient pointer */
;;;80       q31_t *pStateCurnt;                            /* Points to the current sample of the state */
;;;81     
;;;82     
;;;83     #ifndef ARM_MATH_CM0_FAMILY
;;;84     
;;;85       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;86     
;;;87       q31_t x0, x1, x2;                              /* Temporary variables to hold state */
;;;88       q31_t c0;                                      /* Temporary variable to hold coefficient value */
;;;89       q31_t *px;                                     /* Temporary pointer for state */
;;;90       q31_t *pb;                                     /* Temporary pointer for coefficient buffer */
;;;91       q63_t acc0, acc1, acc2;                        /* Accumulators */
;;;92       uint32_t numTaps = S->numTaps;                 /* Number of filter coefficients in the filter */
;;;93       uint32_t i, tapCnt, blkCnt, tapCntN3;          /* Loop counters */
;;;94     
;;;95       /* S->pState points to state array which contains previous frame (numTaps - 1) samples */
;;;96       /* pStateCurnt points to the location where the new input data should be written */
;;;97       pStateCurnt = &(S->pState[(numTaps - 1u)]);
000006  f06f0203          MVN      r2,#3
00000a  9814              LDR      r0,[sp,#0x50]         ;78
00000c  9914              LDR      r1,[sp,#0x50]         ;79
00000e  6840              LDR      r0,[r0,#4]            ;78
000010  6889              LDR      r1,[r1,#8]            ;79
000012  9110              STR      r1,[sp,#0x40]         ;92
000014  9914              LDR      r1,[sp,#0x50]         ;92
000016  8809              LDRH     r1,[r1,#0]            ;92
000018  9107              STR      r1,[sp,#0x1c]
00001a  eb020181          ADD      r1,r2,r1,LSL #2
00001e  4401              ADD      r1,r1,r0
;;;98     
;;;99       /* Apply loop unrolling and compute 4 output values simultaneously.    
;;;100       * The variables acc0 ... acc3 hold output values that are being computed:    
;;;101       *    
;;;102       *    acc0 =  b[numTaps-1] * x[n-numTaps-1] + b[numTaps-2] * x[n-numTaps-2] + b[numTaps-3] * x[n-numTaps-3] +...+ b[0] * x[0]    
;;;103       *    acc1 =  b[numTaps-1] * x[n-numTaps] +   b[numTaps-2] * x[n-numTaps-1] + b[numTaps-3] * x[n-numTaps-2] +...+ b[0] * x[1]    
;;;104       *    acc2 =  b[numTaps-1] * x[n-numTaps+1] + b[numTaps-2] * x[n-numTaps] +   b[numTaps-3] * x[n-numTaps-1] +...+ b[0] * x[2]    
;;;105       *    acc3 =  b[numTaps-1] * x[n-numTaps+2] + b[numTaps-2] * x[n-numTaps+1] + b[numTaps-3] * x[n-numTaps]   +...+ b[0] * x[3]    
;;;106       */
;;;107      blkCnt = blockSize / 3;
000020  2203              MOVS     r2,#3
000022  9109              STR      r1,[sp,#0x24]
000024  fbb3f1f2          UDIV     r1,r3,r2
;;;108      blockSize = blockSize - (3 * blkCnt);
000028  910e              STR      r1,[sp,#0x38]
00002a  eba10181          SUB      r1,r1,r1,LSL #2
00002e  4419              ADD      r1,r1,r3
;;;109    
;;;110      tapCnt = numTaps / 3;
000030  9117              STR      r1,[sp,#0x5c]
000032  9907              LDR      r1,[sp,#0x1c]
000034  fbb1f1f2          UDIV     r1,r1,r2
;;;111      tapCntN3 = numTaps - (3 * tapCnt);
000038  eba10281          SUB      r2,r1,r1,LSL #2
00003c  9112              STR      r1,[sp,#0x48]
00003e  9907              LDR      r1,[sp,#0x1c]
000040  4411              ADD      r1,r1,r2
;;;112    
;;;113      /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.    
;;;114       ** a second loop below computes the remaining 1 to 3 samples. */
;;;115      while(blkCnt > 0u)
000042  9113              STR      r1,[sp,#0x4c]
000044  990e              LDR      r1,[sp,#0x38]         ;77
000046  e087              B        |L1.344|
                  |L1.72|
;;;116      {
;;;117        /* Copy three new input samples into the state buffer */
;;;118        *pStateCurnt++ = *pSrc++;
000048  9915              LDR      r1,[sp,#0x54]
;;;119        *pStateCurnt++ = *pSrc++;
;;;120        *pStateCurnt++ = *pSrc++;
00004a  f04f0800          MOV      r8,#0
;;;121    
;;;122        /* Set all accumulators to zero */
;;;123        acc0 = 0;
00004e  46c2              MOV      r10,r8
000050  680a              LDR      r2,[r1,#0]            ;118
000052  9909              LDR      r1,[sp,#0x24]         ;118
;;;124        acc1 = 0;
000054  46c6              MOV      lr,r8
000056  4644              MOV      r4,r8
000058  600a              STR      r2,[r1,#0]            ;118
00005a  9915              LDR      r1,[sp,#0x54]         ;119
00005c  9a09              LDR      r2,[sp,#0x24]         ;119
;;;125        acc2 = 0;
00005e  46c3              MOV      r11,r8
000060  684b              LDR      r3,[r1,#4]            ;119
000062  6053              STR      r3,[r2,#4]            ;120
000064  688b              LDR      r3,[r1,#8]            ;120
000066  6093              STR      r3,[r2,#8]            ;120
000068  310c              ADDS     r1,r1,#0xc            ;120
;;;126    
;;;127        /* Initialize state pointer */
;;;128        px = pState;
;;;129    
;;;130        /* Initialize coefficient pointer */
;;;131        pb = pCoeffs;
00006a  9115              STR      r1,[sp,#0x54]
00006c  320c              ADDS     r2,r2,#0xc            ;120
00006e  9209              STR      r2,[sp,#0x24]
;;;132    
;;;133        /* Read the first two samples from the state buffer:    
;;;134         *  x[n-numTaps], x[n-numTaps-1] */
;;;135        x0 = *(px++);
000070  1d01              ADDS     r1,r0,#4
000072  4643              MOV      r3,r8                 ;123
;;;136        x1 = *(px++);
000074  c904              LDM      r1!,{r2}
000076  9d10              LDR      r5,[sp,#0x40]         ;135
;;;137    
;;;138        /* Loop unrolling.  Process 3 taps at a time. */
;;;139        i = tapCnt;
000078  6807              LDR      r7,[r0,#0]
;;;140    
;;;141        while(i > 0u)
00007a  9e12              LDR      r6,[sp,#0x48]
00007c  e036              B        |L1.236|
;;;142        {
;;;143          /* Read the b[numTaps] coefficient */
;;;144          c0 = *pb;
00007e  bf00              NOP      
                  |L1.128|
000080  f855cb04          LDR      r12,[r5],#4
;;;145    
;;;146          /* Read x[n-numTaps-2] sample */
;;;147          x2 = *(px++);
000084  1d0e              ADDS     r6,r1,#4
000086  f8d19000          LDR      r9,[r1,#0]
;;;148    
;;;149          /* Perform the multiply-accumulates */
;;;150          acc0 += ((q63_t) x0 * c0);
00008a  960c              STR      r6,[sp,#0x30]
00008c  4656              MOV      r6,r10
00008e  fbc7860c          SMLAL    r8,r6,r7,r12
;;;151          acc1 += ((q63_t) x1 * c0);
000092  9601              STR      r6,[sp,#4]
000094  4676              MOV      r6,lr
000096  fbc2630c          SMLAL    r6,r3,r2,r12
00009a  46b6              MOV      lr,r6
;;;152          acc2 += ((q63_t) x2 * c0);
00009c  465e              MOV      r6,r11
00009e  fbc9460c          SMLAL    r4,r6,r9,r12
0000a2  46b4              MOV      r12,r6
;;;153    
;;;154          /* Read the coefficient and state */
;;;155          c0 = *(pb + 1u);
;;;156          x0 = *(px++);
0000a4  9e0c              LDR      r6,[sp,#0x30]
0000a6  cd02              LDM      r5!,{r1}              ;155
0000a8  ce80              LDM      r6!,{r7}
0000aa  46b2              MOV      r10,r6
;;;157    
;;;158          /* Perform the multiply-accumulates */
;;;159          acc0 += ((q63_t) x1 * c0);
0000ac  9e01              LDR      r6,[sp,#4]
0000ae  fbc28601          SMLAL    r8,r6,r2,r1
;;;160          acc1 += ((q63_t) x2 * c0);
0000b2  9601              STR      r6,[sp,#4]
0000b4  4676              MOV      r6,lr
0000b6  fbc96301          SMLAL    r6,r3,r9,r1
0000ba  46b6              MOV      lr,r6
;;;161          acc2 += ((q63_t) x0 * c0);
0000bc  4666              MOV      r6,r12
0000be  fbc74601          SMLAL    r4,r6,r7,r1
0000c2  46b3              MOV      r11,r6
;;;162    
;;;163          /* Read the coefficient and state */
;;;164          c0 = *(pb + 2u);
0000c4  f855cb04          LDR      r12,[r5],#4
;;;165          x1 = *(px++);
;;;166    
;;;167          /* update coefficient pointer */
;;;168          pb += 3u;
;;;169    
;;;170          /* Perform the multiply-accumulates */
;;;171          acc0 += ((q63_t) x2 * c0);
0000c8  9e01              LDR      r6,[sp,#4]
0000ca  f10a0104          ADD      r1,r10,#4             ;165
0000ce  fbc9860c          SMLAL    r8,r6,r9,r12
0000d2  f8da2000          LDR      r2,[r10,#0]
0000d6  46b2              MOV      r10,r6
;;;172          acc1 += ((q63_t) x0 * c0);
0000d8  4676              MOV      r6,lr
0000da  fbc7630c          SMLAL    r6,r3,r7,r12
0000de  46b6              MOV      lr,r6
;;;173          acc2 += ((q63_t) x1 * c0);
0000e0  465e              MOV      r6,r11
0000e2  fbc2460c          SMLAL    r4,r6,r2,r12
0000e6  46b3              MOV      r11,r6
;;;174    
;;;175          /* Decrement the loop counter */
;;;176          i--;
0000e8  9e11              LDR      r6,[sp,#0x44]
0000ea  1e76              SUBS     r6,r6,#1
                  |L1.236|
0000ec  9611              STR      r6,[sp,#0x44]         ;139
0000ee  2e00              CMP      r6,#0                 ;139
0000f0  d1c6              BNE      |L1.128|
;;;177        }
;;;178    
;;;179        /* If the filter length is not a multiple of 3, compute the remaining filter taps */
;;;180    
;;;181        i = tapCntN3;
;;;182    
;;;183        while(i > 0u)
0000f2  9e13              LDR      r6,[sp,#0x4c]
0000f4  e017              B        |L1.294|
                  |L1.246|
;;;184        {
;;;185          /* Read coefficients */
;;;186          c0 = *(pb++);
0000f6  cd40              LDM      r5!,{r6}
;;;187    
;;;188          /* Fetch 1 state variable */
;;;189          x2 = *(px++);
0000f8  f851cb04          LDR      r12,[r1],#4
;;;190    
;;;191          /* Perform the multiply-accumulates */
;;;192          acc0 += ((q63_t) x0 * c0);
0000fc  f8cdc02c          STR      r12,[sp,#0x2c]
000100  46bc              MOV      r12,r7
000102  4657              MOV      r7,r10
000104  fbcc8706          SMLAL    r8,r7,r12,r6
000108  46ba              MOV      r10,r7
;;;193          acc1 += ((q63_t) x1 * c0);
00010a  4677              MOV      r7,lr
00010c  fbc27306          SMLAL    r7,r3,r2,r6
000110  46be              MOV      lr,r7
;;;194          acc2 += ((q63_t) x2 * c0);
000112  f8ddc02c          LDR      r12,[sp,#0x2c]
000116  465f              MOV      r7,r11
000118  fbcc4706          SMLAL    r4,r7,r12,r6
00011c  46bb              MOV      r11,r7
;;;195    
;;;196          /* Reuse the present sample states for next sample */
;;;197          x0 = x1;
00011e  4617              MOV      r7,r2
;;;198          x1 = x2;
000120  4662              MOV      r2,r12
;;;199    
;;;200          /* Decrement the loop counter */
;;;201          i--;
000122  f1a90601          SUB      r6,r9,#1
                  |L1.294|
000126  ea5f0906          MOVS     r9,r6                 ;181
00012a  d1e4              BNE      |L1.246|
;;;202        }
;;;203    
;;;204        /* Advance the state pointer by 3 to process the next group of 3 samples */
;;;205        pState = pState + 3;
;;;206    
;;;207        /* The results in the 3 accumulators are in 2.30 format.  Convert to 1.31    
;;;208         ** Then store the 3 outputs in the destination buffer. */
;;;209        *pDst++ = (q31_t) (acc0 >> 31u);
00012c  9a16              LDR      r2,[sp,#0x58]
00012e  ea4f71d8          LSR      r1,r8,#31
000132  ea41014a          ORR      r1,r1,r10,LSL #1
000136  6011              STR      r1,[r2,#0]
;;;210        *pDst++ = (q31_t) (acc1 >> 31u);
000138  9916              LDR      r1,[sp,#0x58]
00013a  ea4f72de          LSR      r2,lr,#31
00013e  ea420243          ORR      r2,r2,r3,LSL #1
;;;211        *pDst++ = (q31_t) (acc2 >> 31u);
000142  604a              STR      r2,[r1,#4]
000144  0fe2              LSRS     r2,r4,#31
000146  ea42024b          ORR      r2,r2,r11,LSL #1
00014a  608a              STR      r2,[r1,#8]
00014c  310c              ADDS     r1,r1,#0xc
;;;212    
;;;213        /* Decrement the samples loop counter */
;;;214        blkCnt--;
00014e  9116              STR      r1,[sp,#0x58]
000150  990e              LDR      r1,[sp,#0x38]
000152  1e49              SUBS     r1,r1,#1
000154  300c              ADDS     r0,r0,#0xc
000156  910e              STR      r1,[sp,#0x38]
                  |L1.344|
000158  2900              CMP      r1,#0                 ;115
00015a  f47faf75          BNE      |L1.72|
;;;215      }
;;;216    
;;;217      /* If the blockSize is not a multiple of 3, compute any remaining output samples here.    
;;;218       ** No loop unrolling is used. */
;;;219    
;;;220      while(blockSize > 0u)
;;;221      {
;;;222        /* Copy one sample at a time into state buffer */
;;;223        *pStateCurnt++ = *pSrc++;
;;;224    
;;;225        /* Set the accumulator to zero */
;;;226        acc0 = 0;
;;;227    
;;;228        /* Initialize state pointer */
;;;229        px = pState;
;;;230    
;;;231        /* Initialize Coefficient pointer */
;;;232        pb = (pCoeffs);
;;;233    
;;;234        i = numTaps;
;;;235    
;;;236        /* Perform the multiply-accumulates */
;;;237        do
;;;238        {
;;;239          acc0 += (q63_t) * (px++) * (*(pb++));
;;;240          i--;
;;;241        } while(i > 0u);
;;;242    
;;;243        /* The result is in 2.62 format.  Convert to 1.31    
;;;244         ** Then store the output in the destination buffer. */
;;;245        *pDst++ = (q31_t) (acc0 >> 31u);
;;;246    
;;;247        /* Advance state pointer by 1 for the next sample */
;;;248        pState = pState + 1;
;;;249    
;;;250        /* Decrement the samples loop counter */
;;;251        blockSize--;
00015e  9917              LDR      r1,[sp,#0x5c]
000160  e022              B        |L1.424|
                  |L1.354|
000162  9915              LDR      r1,[sp,#0x54]         ;223
000164  4603              MOV      r3,r0                 ;229
000166  680a              LDR      r2,[r1,#0]            ;223
000168  9909              LDR      r1,[sp,#0x24]         ;223
00016a  600a              STR      r2,[r1,#0]            ;223
00016c  9915              LDR      r1,[sp,#0x54]         ;223
00016e  9d07              LDR      r5,[sp,#0x1c]         ;234
000170  1d09              ADDS     r1,r1,#4              ;223
000172  9115              STR      r1,[sp,#0x54]         ;223
000174  9909              LDR      r1,[sp,#0x24]         ;223
000176  9c10              LDR      r4,[sp,#0x40]         ;234
000178  1d09              ADDS     r1,r1,#4              ;223
00017a  2200              MOVS     r2,#0                 ;223
00017c  9109              STR      r1,[sp,#0x24]         ;223
00017e  4611              MOV      r1,r2                 ;223
                  |L1.384|
000180  cb40              LDM      r3!,{r6}              ;239
000182  cc80              LDM      r4!,{r7}              ;239
000184  fb867607          SMULL    r7,r6,r6,r7           ;239
000188  18ba              ADDS     r2,r7,r2              ;239
00018a  4171              ADCS     r1,r1,r6              ;239
00018c  1e6d              SUBS     r5,r5,#1              ;239
00018e  d1f7              BNE      |L1.384|
000190  004b              LSLS     r3,r1,#1              ;245
000192  ea4371d2          ORR      r1,r3,r2,LSR #31      ;245
000196  9a16              LDR      r2,[sp,#0x58]         ;245
000198  6011              STR      r1,[r2,#0]            ;245
00019a  9916              LDR      r1,[sp,#0x58]         ;245
00019c  1d09              ADDS     r1,r1,#4              ;245
00019e  9116              STR      r1,[sp,#0x58]
0001a0  9917              LDR      r1,[sp,#0x5c]
0001a2  1e49              SUBS     r1,r1,#1
0001a4  1d00              ADDS     r0,r0,#4
0001a6  9117              STR      r1,[sp,#0x5c]
                  |L1.424|
0001a8  2900              CMP      r1,#0                 ;220
0001aa  d1da              BNE      |L1.354|
;;;252      }
;;;253    
;;;254      /* Processing is complete.    
;;;255       ** Now copy the last numTaps - 1 samples to the satrt of the state buffer.    
;;;256       ** This prepares the state buffer for the next function call. */
;;;257    
;;;258      /* Points to the start of the state buffer */
;;;259      pStateCurnt = S->pState;
0001ac  9914              LDR      r1,[sp,#0x50]
;;;260    
;;;261      tapCnt = (numTaps - 1u) >> 2u;
0001ae  9b07              LDR      r3,[sp,#0x1c]
0001b0  1e5b              SUBS     r3,r3,#1
0001b2  6849              LDR      r1,[r1,#4]            ;259
0001b4  089a              LSRS     r2,r3,#2
;;;262    
;;;263      /* copy data */
;;;264      while(tapCnt > 0u)
0001b6  e00c              B        |L1.466|
                  |L1.440|
;;;265      {
;;;266        *pStateCurnt++ = *pState++;
0001b8  c810              LDM      r0!,{r4}
;;;267        *pStateCurnt++ = *pState++;
;;;268        *pStateCurnt++ = *pState++;
;;;269        *pStateCurnt++ = *pState++;
0001ba  1e52              SUBS     r2,r2,#1
0001bc  c110              STM      r1!,{r4}              ;266
0001be  c810              LDM      r0!,{r4}              ;267
0001c0  c110              STM      r1!,{r4}              ;267
0001c2  f8504b08          LDR      r4,[r0],#8            ;268
0001c6  f8414b08          STR      r4,[r1],#8            ;268
0001ca  f8504c04          LDR      r4,[r0,#-4]
0001ce  f8414c04          STR      r4,[r1,#-4]
                  |L1.466|
0001d2  2a00              CMP      r2,#0                 ;264
0001d4  d1f0              BNE      |L1.440|
;;;270    
;;;271        /* Decrement the loop counter */
;;;272        tapCnt--;
;;;273      }
;;;274    
;;;275      /* Calculate remaining number of copies */
;;;276      tapCnt = (numTaps - 1u) % 0x4u;
0001d6  f0030203          AND      r2,r3,#3
;;;277    
;;;278      /* Copy the remaining q31_t data */
;;;279      while(tapCnt > 0u)
0001da  e002              B        |L1.482|
                  |L1.476|
;;;280      {
;;;281        *pStateCurnt++ = *pState++;
0001dc  c808              LDM      r0!,{r3}
0001de  1e52              SUBS     r2,r2,#1
0001e0  c108              STM      r1!,{r3}
                  |L1.482|
0001e2  2a00              CMP      r2,#0                 ;279
0001e4  d1fa              BNE      |L1.476|
;;;282    
;;;283        /* Decrement the loop counter */
;;;284        tapCnt--;
;;;285      }
;;;286    
;;;287    #else
;;;288    
;;;289    /* Run the below code for Cortex-M0 */
;;;290    
;;;291      q31_t *px;                                     /* Temporary pointer for state */
;;;292      q31_t *pb;                                     /* Temporary pointer for coefficient buffer */
;;;293      q63_t acc;                                     /* Accumulator */
;;;294      uint32_t numTaps = S->numTaps;                 /* Length of the filter */
;;;295      uint32_t i, tapCnt, blkCnt;                    /* Loop counters */
;;;296    
;;;297      /* S->pState buffer contains previous frame (numTaps - 1) samples */
;;;298      /* pStateCurnt points to the location where the new input data should be written */
;;;299      pStateCurnt = &(S->pState[(numTaps - 1u)]);
;;;300    
;;;301      /* Initialize blkCnt with blockSize */
;;;302      blkCnt = blockSize;
;;;303    
;;;304      while(blkCnt > 0u)
;;;305      {
;;;306        /* Copy one sample at a time into state buffer */
;;;307        *pStateCurnt++ = *pSrc++;
;;;308    
;;;309        /* Set the accumulator to zero */
;;;310        acc = 0;
;;;311    
;;;312        /* Initialize state pointer */
;;;313        px = pState;
;;;314    
;;;315        /* Initialize Coefficient pointer */
;;;316        pb = pCoeffs;
;;;317    
;;;318        i = numTaps;
;;;319    
;;;320        /* Perform the multiply-accumulates */
;;;321        do
;;;322        {
;;;323          /* acc =  b[numTaps-1] * x[n-numTaps-1] + b[numTaps-2] * x[n-numTaps-2] + b[numTaps-3] * x[n-numTaps-3] +...+ b[0] * x[0] */
;;;324          acc += (q63_t) * px++ * *pb++;
;;;325          i--;
;;;326        } while(i > 0u);
;;;327    
;;;328        /* The result is in 2.62 format.  Convert to 1.31         
;;;329         ** Then store the output in the destination buffer. */
;;;330        *pDst++ = (q31_t) (acc >> 31u);
;;;331    
;;;332        /* Advance state pointer by 1 for the next sample */
;;;333        pState = pState + 1;
;;;334    
;;;335        /* Decrement the samples loop counter */
;;;336        blkCnt--;
;;;337      }
;;;338    
;;;339      /* Processing is complete.         
;;;340       ** Now copy the last numTaps - 1 samples to the starting of the state buffer.       
;;;341       ** This prepares the state buffer for the next function call. */
;;;342    
;;;343      /* Points to the start of the state buffer */
;;;344      pStateCurnt = S->pState;
;;;345    
;;;346      /* Copy numTaps number of values */
;;;347      tapCnt = numTaps - 1u;
;;;348    
;;;349      /* Copy the data */
;;;350      while(tapCnt > 0u)
;;;351      {
;;;352        *pStateCurnt++ = *pState++;
;;;353    
;;;354        /* Decrement the loop counter */
;;;355        tapCnt--;
;;;356      }
;;;357    
;;;358    
;;;359    #endif /*  #ifndef ARM_MATH_CM0_FAMILY */
;;;360    
;;;361    }
0001e6  b018              ADD      sp,sp,#0x60
0001e8  e8bd8ff0          POP      {r4-r11,pc}
;;;362    
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\FilteringFunctions\\arm_fir_q31.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_arm_fir_q31_c_0e2cc653____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___13_arm_fir_q31_c_0e2cc653____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_arm_fir_q31_c_0e2cc653____REVSH|
#line 144
|__asm___13_arm_fir_q31_c_0e2cc653____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___13_arm_fir_q31_c_0e2cc653____RRX|
#line 300
|__asm___13_arm_fir_q31_c_0e2cc653____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
