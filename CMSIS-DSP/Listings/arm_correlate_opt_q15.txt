; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_correlate_opt_q15.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_correlate_opt_q15.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_correlate_opt_q15.crf src\FilteringFunctions\arm_correlate_opt_q15.c]
                          THUMB

                          AREA ||i.arm_correlate_opt_q15||, CODE, READONLY, ALIGN=1

                  arm_correlate_opt_q15 PROC
;;;82     
;;;83     void arm_correlate_opt_q15(
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;84       q15_t * pSrcA,
;;;85       uint32_t srcALen,
;;;86       q15_t * pSrcB,
;;;87       uint32_t srcBLen,
;;;88       q15_t * pDst,
;;;89       q15_t * pScratch)
;;;90     {
000004  b099              SUB      sp,sp,#0x64
000006  460e              MOV      r6,r1
;;;91       q15_t *pIn1;                                   /* inputA pointer               */
;;;92       q15_t *pIn2;                                   /* inputB pointer               */
;;;93       q63_t acc0, acc1, acc2, acc3;                  /* Accumulators                  */
;;;94       q15_t *py;                                     /* Intermediate inputB pointer  */
;;;95       q31_t x1, x2, x3;                              /* temporary variables for holding input1 and input2 values */
;;;96       uint32_t j, blkCnt, outBlockSize;              /* loop counter                 */
;;;97       int32_t inc = 1;                               /* output pointer increment     */
000008  2101              MOVS     r1,#1
00000a  461d              MOV      r5,r3                 ;90
;;;98       uint32_t tapCnt;
;;;99       q31_t y1, y2;
;;;100      q15_t *pScr;                                   /* Intermediate pointers        */
;;;101      q15_t *pOut = pDst;                            /* output pointer               */
;;;102    #ifdef UNALIGNED_SUPPORT_DISABLE
;;;103    
;;;104      q15_t a, b;
;;;105    
;;;106    #endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE	*/
;;;107    
;;;108      /* The algorithm implementation is based on the lengths of the inputs. */
;;;109      /* srcB is always made to slide across srcA. */
;;;110      /* So srcBLen is always considered as shorter or equal to srcALen */
;;;111      /* But CORR(x, y) is reverse of CORR(y, x) */
;;;112      /* So, when srcBLen > srcALen, output pointer is made to point to the end of the output buffer */
;;;113      /* and the destination pointer modifier, inc is set to -1 */
;;;114      /* If srcALen > srcBLen, zero pad has to be done to srcB to make the two inputs of same length */
;;;115      /* But to improve the performance,        
;;;116       * we include zeroes in the output instead of zero padding either of the the inputs*/
;;;117      /* If srcALen > srcBLen,        
;;;118       * (srcALen - srcBLen) zeroes has to included in the starting of the output buffer */
;;;119      /* If srcALen < srcBLen,        
;;;120       * (srcALen - srcBLen) zeroes has to included in the ending of the output buffer */
;;;121      if(srcALen >= srcBLen)
;;;122      {
;;;123        /* Initialization of inputA pointer */
;;;124        pIn1 = (pSrcA);
;;;125    
;;;126        /* Initialization of inputB pointer */
;;;127        pIn2 = (pSrcB);
;;;128    
;;;129        /* Number of output samples is calculated */
;;;130        outBlockSize = (2u * srcALen) - 1u;
00000c  9111              STR      r1,[sp,#0x44]
00000e  9b22              LDR      r3,[sp,#0x88]         ;97
000010  1e89              SUBS     r1,r1,#2
000012  42ae              CMP      r6,r5                 ;121
000014  d30a              BCC      |L1.44|
000016  4607              MOV      r7,r0                 ;124
000018  eb010046          ADD      r0,r1,r6,LSL #1
;;;131    
;;;132        /* When srcALen > srcBLen, zero padding is done to srcB        
;;;133         * to make their lengths equal.        
;;;134         * Instead, (outBlockSize - (srcALen + srcBLen - 1))        
;;;135         * number of output samples are made zero */
;;;136        j = outBlockSize - (srcALen + (srcBLen - 1u));
00001c  1971              ADDS     r1,r6,r5
00001e  1a40              SUBS     r0,r0,r1
000020  1c40              ADDS     r0,r0,#1
;;;137    
;;;138        /* Updating the pointer position to non zero value */
;;;139        pOut += j;
000022  eb030040          ADD      r0,r3,r0,LSL #1
000026  4614              MOV      r4,r2                 ;127
000028  900b              STR      r0,[sp,#0x2c]
00002a  e00a              B        |L1.66|
                  |L1.44|
;;;140    
;;;141      }
;;;142      else
;;;143      {
;;;144        /* Initialization of inputA pointer */
;;;145        pIn1 = (pSrcB);
;;;146    
;;;147        /* Initialization of inputB pointer */
;;;148        pIn2 = (pSrcA);
00002c  4604              MOV      r4,r0
;;;149    
;;;150        /* srcBLen is always considered as shorter or equal to srcALen */
;;;151        j = srcBLen;
00002e  4628              MOV      r0,r5
;;;152        srcBLen = srcALen;
000030  4635              MOV      r5,r6
;;;153        srcALen = j;
000032  4606              MOV      r6,r0
;;;154    
;;;155        /* CORR(x, y) = Reverse order(CORR(y, x)) */
;;;156        /* Hence set the destination pointer to point to the last output sample */
;;;157        pOut = pDst + ((srcALen + srcBLen) - 2u);
000034  4428              ADD      r0,r0,r5
000036  eb030040          ADD      r0,r3,r0,LSL #1
00003a  1f00              SUBS     r0,r0,#4
00003c  4617              MOV      r7,r2                 ;145
;;;158    
;;;159        /* Destination address modifier is set to -1 */
;;;160        inc = -1;
00003e  9111              STR      r1,[sp,#0x44]
000040  900b              STR      r0,[sp,#0x2c]
                  |L1.66|
;;;161    
;;;162      }
;;;163    
;;;164      pScr = pScratch;
;;;165    
;;;166      /* Fill (srcBLen - 1u) zeros in scratch buffer */
;;;167      arm_fill_q15(0, pScr, (srcBLen - 1u));
000042  f8dd808c          LDR      r8,[sp,#0x8c]
000046  1e6a              SUBS     r2,r5,#1
000048  4641              MOV      r1,r8
00004a  2000              MOVS     r0,#0
00004c  f7fffffe          BL       arm_fill_q15
;;;168    
;;;169      /* Update temporary scratch pointer */
;;;170      pScr += (srcBLen - 1u);
000050  eb080045          ADD      r0,r8,r5,LSL #1
000054  1e80              SUBS     r0,r0,#2
000056  4680              MOV      r8,r0
;;;171    
;;;172    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;173    
;;;174      /* Copy (srcALen) samples in scratch buffer */
;;;175      arm_copy_q15(pIn1, pScr, srcALen);
000058  4601              MOV      r1,r0
00005a  4632              MOV      r2,r6
00005c  4638              MOV      r0,r7
00005e  f7fffffe          BL       arm_copy_q15
;;;176    
;;;177      /* Update pointers */
;;;178      //pIn1 += srcALen;    
;;;179      pScr += srcALen;
000062  eb080146          ADD      r1,r8,r6,LSL #1
;;;180    
;;;181    #else
;;;182    
;;;183      /* Apply loop unrolling and do 4 Copies simultaneously. */
;;;184      j = srcALen >> 2u;
;;;185    
;;;186      /* First part of the processing with loop unrolling copies 4 data points at a time.       
;;;187       ** a second loop below copies for the remaining 1 to 3 samples. */
;;;188      while(j > 0u)
;;;189      {
;;;190        /* copy second buffer in reversal manner */
;;;191        *pScr++ = *pIn1++;
;;;192        *pScr++ = *pIn1++;
;;;193        *pScr++ = *pIn1++;
;;;194        *pScr++ = *pIn1++;
;;;195    
;;;196        /* Decrement the loop counter */
;;;197        j--;
;;;198      }
;;;199    
;;;200      /* If the count is not a multiple of 4, copy remaining samples here.       
;;;201       ** No loop unrolling is used. */
;;;202      j = srcALen % 0x4u;
;;;203    
;;;204      while(j > 0u)
;;;205      {
;;;206        /* copy second buffer in reversal manner for remaining samples */
;;;207        *pScr++ = *pIn1++;
;;;208    
;;;209        /* Decrement the loop counter */
;;;210        j--;
;;;211      }
;;;212    
;;;213    #endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE	*/
;;;214    
;;;215    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;216    
;;;217      /* Fill (srcBLen - 1u) zeros at end of scratch buffer */
;;;218      arm_fill_q15(0, pScr, (srcBLen - 1u));
000066  1e6a              SUBS     r2,r5,#1
000068  2000              MOVS     r0,#0
00006a  f7fffffe          BL       arm_fill_q15
;;;219    
;;;220      /* Update pointer */
;;;221      pScr += (srcBLen - 1u);
;;;222    
;;;223    #else
;;;224    
;;;225    /* Apply loop unrolling and do 4 Copies simultaneously. */
;;;226      j = (srcBLen - 1u) >> 2u;
;;;227    
;;;228      /* First part of the processing with loop unrolling copies 4 data points at a time.       
;;;229       ** a second loop below copies for the remaining 1 to 3 samples. */
;;;230      while(j > 0u)
;;;231      {
;;;232        /* copy second buffer in reversal manner */
;;;233        *pScr++ = 0;
;;;234        *pScr++ = 0;
;;;235        *pScr++ = 0;
;;;236        *pScr++ = 0;
;;;237    
;;;238        /* Decrement the loop counter */
;;;239        j--;
;;;240      }
;;;241    
;;;242      /* If the count is not a multiple of 4, copy remaining samples here.       
;;;243       ** No loop unrolling is used. */
;;;244      j = (srcBLen - 1u) % 0x4u;
;;;245    
;;;246      while(j > 0u)
;;;247      {
;;;248        /* copy second buffer in reversal manner for remaining samples */
;;;249        *pScr++ = 0;
;;;250    
;;;251        /* Decrement the loop counter */
;;;252        j--;
;;;253      }
;;;254    
;;;255    #endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE	*/
;;;256    
;;;257      /* Temporary pointer for scratch2 */
;;;258      py = pIn2;
;;;259    
;;;260    
;;;261      /* Actual correlation process starts here */
;;;262      blkCnt = (srcALen + srcBLen - 1u) >> 2;
00006e  1970              ADDS     r0,r6,r5
000070  1e40              SUBS     r0,r0,#1
000072  e9cd4017          STRD     r4,r0,[sp,#0x5c]
000076  0880              LSRS     r0,r0,#2
;;;263    
;;;264      while(blkCnt > 0)
000078  900f              STR      r0,[sp,#0x3c]
00007a  e0ad              B        |L1.472|
                  |L1.124|
;;;265      {
;;;266        /* Initialze temporary scratch pointer as scratch1 */
;;;267        pScr = pScratch;
00007c  2200              MOVS     r2,#0
;;;268    
;;;269        /* Clear Accumlators */
;;;270        acc0 = 0;
;;;271        acc1 = 0;
00007e  9823              LDR      r0,[sp,#0x8c]
000080  e9cd2214          STRD     r2,r2,[sp,#0x50]
000084  e9cd220d          STRD     r2,r2,[sp,#0x34]
;;;272        acc2 = 0;
;;;273        acc3 = 0;
;;;274    
;;;275        /* Read four samples from scratch1 buffer */
;;;276        x1 = *__SIMD32(pScr)++;
000088  f8506b04          LDR      r6,[r0],#4
00008c  4693              MOV      r11,r2                ;270
00008e  4696              MOV      lr,r2                 ;270
000090  4692              MOV      r10,r2                ;271
000092  4691              MOV      r9,r2                 ;271
;;;277    
;;;278        /* Read next four samples from scratch1 buffer */
;;;279        x2 = *__SIMD32(pScr)++;
000094  f8503b04          LDR      r3,[r0],#4
;;;280    
;;;281        tapCnt = (srcBLen) >> 2u;
000098  08a9              LSRS     r1,r5,#2
;;;282    
;;;283        while(tapCnt > 0u)
00009a  e03c              B        |L1.278|
                  |L1.156|
;;;284        {
;;;285    
;;;286    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;287    
;;;288          /* Read four samples from smaller buffer */
;;;289          y1 = _SIMD32_OFFSET(pIn2);
00009c  f854cb04          LDR      r12,[r4],#4
;;;290          y2 = _SIMD32_OFFSET(pIn2 + 2u);
;;;291    
;;;292          acc0 = __SMLALD(x1, y1, acc0);
0000a0  465a              MOV      r2,r11
0000a2  f8547b04          LDR      r7,[r4],#4            ;290
0000a6  4671              MOV      r1,lr
0000a8  fbc621cc          SMLALD   r2,r1,r6,r12
0000ac  468e              MOV      lr,r1
0000ae  e9dd8114          LDRD     r8,r1,[sp,#0x50]
0000b2  4693              MOV      r11,r2
;;;293    
;;;294          acc2 = __SMLALD(x2, y1, acc2);
0000b4  fbc381cc          SMLALD   r8,r1,r3,r12
;;;295    
;;;296    #ifndef ARM_MATH_BIG_ENDIAN
;;;297          x3 = __PKHBT(x2, x1, 0);
0000b8  eac30606          PKHBT    r6,r3,r6
;;;298    #else
;;;299          x3 = __PKHBT(x1, x2, 0);
;;;300    #endif
;;;301    
;;;302          acc1 = __SMLALDX(x3, y1, acc1);
0000bc  9115              STR      r1,[sp,#0x54]
0000be  4651              MOV      r1,r10
0000c0  464a              MOV      r2,r9
0000c2  fbc612dc          SMLALDX  r1,r2,r6,r12
0000c6  4689              MOV      r9,r1
0000c8  4692              MOV      r10,r2
;;;303    
;;;304          x1 = _SIMD32_OFFSET(pScr);
0000ca  f8506b04          LDR      r6,[r0],#4
;;;305    
;;;306          acc0 = __SMLALD(x2, y2, acc0);
0000ce  465a              MOV      r2,r11
0000d0  4671              MOV      r1,lr
0000d2  fbc321c7          SMLALD   r2,r1,r3,r7
0000d6  468e              MOV      lr,r1
;;;307    
;;;308          acc2 = __SMLALD(x1, y2, acc2);
0000d8  9915              LDR      r1,[sp,#0x54]
0000da  4693              MOV      r11,r2                ;306
0000dc  9602              STR      r6,[sp,#8]
0000de  fbc681c7          SMLALD   r8,r1,r6,r7
;;;309    
;;;310    #ifndef ARM_MATH_BIG_ENDIAN
;;;311          x3 = __PKHBT(x1, x2, 0);
0000e2  eac60303          PKHBT    r3,r6,r3
0000e6  e9cd8114          STRD     r8,r1,[sp,#0x50]
0000ea  e9dd810d          LDRD     r8,r1,[sp,#0x34]
;;;312    #else
;;;313          x3 = __PKHBT(x2, x1, 0);
;;;314    #endif
;;;315    
;;;316          acc3 = __SMLALDX(x3, y1, acc3);
0000ee  fbc318dc          SMLALDX  r1,r8,r3,r12
0000f2  468c              MOV      r12,r1
;;;317    
;;;318          acc1 = __SMLALDX(x3, y2, acc1);
0000f4  4649              MOV      r1,r9
0000f6  4652              MOV      r2,r10
0000f8  fbc312d7          SMLALDX  r1,r2,r3,r7
;;;319    
;;;320          x2 = _SIMD32_OFFSET(pScr + 2u);
0000fc  f8503b04          LDR      r3,[r0],#4
000100  468a              MOV      r10,r1                ;318
000102  4691              MOV      r9,r2                 ;318
;;;321    
;;;322    #ifndef ARM_MATH_BIG_ENDIAN
;;;323          x3 = __PKHBT(x2, x1, 0);
000104  eac30206          PKHBT    r2,r3,r6
;;;324    #else
;;;325          x3 = __PKHBT(x1, x2, 0);
;;;326    #endif
;;;327    
;;;328          acc3 = __SMLALDX(x3, y2, acc3);
000108  4661              MOV      r1,r12
00010a  fbc218d7          SMLALDX  r1,r8,r2,r7
00010e  e9cd810d          STRD     r8,r1,[sp,#0x34]
;;;329    
;;;330    #else	 
;;;331    
;;;332          /* Read four samples from smaller buffer */
;;;333    	  a = *pIn2;
;;;334    	  b = *(pIn2 + 1);
;;;335    
;;;336    #ifndef ARM_MATH_BIG_ENDIAN
;;;337          y1 = __PKHBT(a, b, 16);
;;;338    #else
;;;339          y1 = __PKHBT(b, a, 16);
;;;340    #endif
;;;341    	  
;;;342    	  a = *(pIn2 + 2);
;;;343    	  b = *(pIn2 + 3);
;;;344    #ifndef ARM_MATH_BIG_ENDIAN
;;;345          y2 = __PKHBT(a, b, 16);
;;;346    #else
;;;347          y2 = __PKHBT(b, a, 16);
;;;348    #endif				
;;;349    
;;;350          acc0 = __SMLALD(x1, y1, acc0);
;;;351    
;;;352          acc2 = __SMLALD(x2, y1, acc2);
;;;353    
;;;354    #ifndef ARM_MATH_BIG_ENDIAN
;;;355          x3 = __PKHBT(x2, x1, 0);
;;;356    #else
;;;357          x3 = __PKHBT(x1, x2, 0);
;;;358    #endif
;;;359    
;;;360          acc1 = __SMLALDX(x3, y1, acc1);
;;;361    
;;;362    	  a = *pScr;
;;;363    	  b = *(pScr + 1);
;;;364    
;;;365    #ifndef ARM_MATH_BIG_ENDIAN
;;;366          x1 = __PKHBT(a, b, 16);
;;;367    #else
;;;368          x1 = __PKHBT(b, a, 16);
;;;369    #endif
;;;370    
;;;371          acc0 = __SMLALD(x2, y2, acc0);
;;;372    
;;;373          acc2 = __SMLALD(x1, y2, acc2);
;;;374    
;;;375    #ifndef ARM_MATH_BIG_ENDIAN
;;;376          x3 = __PKHBT(x1, x2, 0);
;;;377    #else
;;;378          x3 = __PKHBT(x2, x1, 0);
;;;379    #endif
;;;380    
;;;381          acc3 = __SMLALDX(x3, y1, acc3);
;;;382    
;;;383          acc1 = __SMLALDX(x3, y2, acc1);
;;;384    
;;;385    	  a = *(pScr + 2);
;;;386    	  b = *(pScr + 3);
;;;387    
;;;388    #ifndef ARM_MATH_BIG_ENDIAN
;;;389          x2 = __PKHBT(a, b, 16);
;;;390    #else
;;;391          x2 = __PKHBT(b, a, 16);
;;;392    #endif
;;;393    
;;;394    #ifndef ARM_MATH_BIG_ENDIAN
;;;395          x3 = __PKHBT(x2, x1, 0);
;;;396    #else
;;;397          x3 = __PKHBT(x1, x2, 0);
;;;398    #endif
;;;399    
;;;400          acc3 = __SMLALDX(x3, y2, acc3);
;;;401    
;;;402    #endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE	*/
;;;403    
;;;404          pIn2 += 4u;
;;;405    
;;;406          pScr += 4u;
;;;407    
;;;408    
;;;409          /* Decrement the loop counter */
;;;410          tapCnt--;
000112  9907              LDR      r1,[sp,#0x1c]
000114  1e49              SUBS     r1,r1,#1
                  |L1.278|
000116  9107              STR      r1,[sp,#0x1c]         ;281
000118  2900              CMP      r1,#0                 ;281
00011a  d1bf              BNE      |L1.156|
;;;411        }
;;;412    
;;;413    
;;;414    
;;;415        /* Update scratch pointer for remaining samples of smaller length sequence */
;;;416        pScr -= 4u;
;;;417    
;;;418    
;;;419        /* apply same above for remaining samples of smaller length sequence */
;;;420        tapCnt = (srcBLen) & 3u;
00011c  f0050603          AND      r6,r5,#3
000120  3808              SUBS     r0,r0,#8
;;;421    
;;;422        while(tapCnt > 0u)
000122  e022              B        |L1.362|
                  |L1.292|
;;;423        {
;;;424    
;;;425          /* accumlate the results */
;;;426          acc0 += (*pScr++ * *pIn2);
000124  f9307b02          LDRSH    r7,[r0],#2
000128  f9341b02          LDRSH    r1,[r4],#2
00012c  465a              MOV      r2,r11
00012e  4673              MOV      r3,lr
000130  fbc72381          SMLALBB  r2,r3,r7,r1
000134  4693              MOV      r11,r2
000136  469e              MOV      lr,r3
;;;427          acc1 += (*pScr++ * *pIn2);
000138  f9b07000          LDRSH    r7,[r0,#0]
00013c  4652              MOV      r2,r10
00013e  464b              MOV      r3,r9
000140  fbc72381          SMLALBB  r2,r3,r7,r1
000144  4692              MOV      r10,r2
000146  4699              MOV      r9,r3
;;;428          acc2 += (*pScr++ * *pIn2);
000148  e9dd3214          LDRD     r3,r2,[sp,#0x50]
00014c  f9b07002          LDRSH    r7,[r0,#2]
000150  fbc73281          SMLALBB  r3,r2,r7,r1
000154  e9cd3214          STRD     r3,r2,[sp,#0x50]
;;;429          acc3 += (*pScr++ * *pIn2++);
000158  e9dd320d          LDRD     r3,r2,[sp,#0x34]
00015c  f9b07004          LDRSH    r7,[r0,#4]
000160  fbc72381          SMLALBB  r2,r3,r7,r1
000164  e9cd320d          STRD     r3,r2,[sp,#0x34]
000168  1e76              SUBS     r6,r6,#1
                  |L1.362|
00016a  2e00              CMP      r6,#0                 ;422
00016c  d1da              BNE      |L1.292|
;;;430    
;;;431          pScr -= 3u;
;;;432    
;;;433          /* Decrement the loop counter */
;;;434          tapCnt--;
;;;435        }
;;;436    
;;;437        blkCnt--;
00016e  980f              LDR      r0,[sp,#0x3c]
000170  1e40              SUBS     r0,r0,#1
;;;438    
;;;439    
;;;440        /* Store the results in the accumulators in the destination buffer. */
;;;441        *pOut = (__SSAT(acc0 >> 15u, 16));
000172  900f              STR      r0,[sp,#0x3c]
000174  ea4f30db          LSR      r0,r11,#15
000178  ea40404e          ORR      r0,r0,lr,LSL #17
00017c  f300010f          SSAT     r1,#16,r0
000180  980b              LDR      r0,[sp,#0x2c]
000182  8001              STRH     r1,[r0,#0]
;;;442        pOut += inc;
000184  9911              LDR      r1,[sp,#0x44]
000186  980b              LDR      r0,[sp,#0x2c]
000188  eb000041          ADD      r0,r0,r1,LSL #1
;;;443        *pOut = (__SSAT(acc1 >> 15u, 16));
00018c  ea4f31da          LSR      r1,r10,#15
000190  ea414149          ORR      r1,r1,r9,LSL #17
000194  f301010f          SSAT     r1,#16,r1
000198  8001              STRH     r1,[r0,#0]
;;;444        pOut += inc;
00019a  9911              LDR      r1,[sp,#0x44]
00019c  eb000041          ADD      r0,r0,r1,LSL #1
0001a0  e9dd1214          LDRD     r1,r2,[sp,#0x50]
;;;445        *pOut = (__SSAT(acc2 >> 15u, 16));
0001a4  0bc9              LSRS     r1,r1,#15
0001a6  ea414142          ORR      r1,r1,r2,LSL #17
0001aa  f301010f          SSAT     r1,#16,r1
0001ae  8001              STRH     r1,[r0,#0]
;;;446        pOut += inc;
0001b0  9911              LDR      r1,[sp,#0x44]
0001b2  eb000041          ADD      r0,r0,r1,LSL #1
0001b6  e9dd120d          LDRD     r1,r2,[sp,#0x34]
;;;447        *pOut = (__SSAT(acc3 >> 15u, 16));
0001ba  044b              LSLS     r3,r1,#17
0001bc  ea4331d2          ORR      r1,r3,r2,LSR #15
0001c0  f301010f          SSAT     r1,#16,r1
0001c4  8001              STRH     r1,[r0,#0]
;;;448        pOut += inc;
0001c6  9911              LDR      r1,[sp,#0x44]
;;;449    
;;;450        /* Initialization of inputB pointer */
;;;451        pIn2 = py;
;;;452    
;;;453        pScratch += 4u;
0001c8  9c17              LDR      r4,[sp,#0x5c]
0001ca  eb000041          ADD      r0,r0,r1,LSL #1       ;448
0001ce  900b              STR      r0,[sp,#0x2c]         ;451
0001d0  9823              LDR      r0,[sp,#0x8c]
0001d2  3008              ADDS     r0,r0,#8
0001d4  9023              STR      r0,[sp,#0x8c]         ;264
0001d6  980f              LDR      r0,[sp,#0x3c]         ;264
                  |L1.472|
0001d8  2800              CMP      r0,#0                 ;264
0001da  f47faf4f          BNE      |L1.124|
;;;454    
;;;455      }
;;;456    
;;;457    
;;;458      blkCnt = (srcALen + srcBLen - 1u) & 0x3;
0001de  9818              LDR      r0,[sp,#0x60]
0001e0  f0000603          AND      r6,r0,#3
;;;459    
;;;460      /* Calculate correlation for remaining samples of Bigger length sequence */
;;;461      while(blkCnt > 0)
0001e4  e030              B        |L1.584|
                  |L1.486|
;;;462      {
;;;463        /* Initialze temporary scratch pointer as scratch1 */
;;;464        pScr = pScratch;
0001e6  2000              MOVS     r0,#0
0001e8  4601              MOV      r1,r0
;;;465    
;;;466        /* Clear Accumlators */
;;;467        acc0 = 0;
;;;468    
;;;469        tapCnt = (srcBLen) >> 1u;
0001ea  086b              LSRS     r3,r5,#1
;;;470    
;;;471        while(tapCnt > 0u)
0001ec  9a23              LDR      r2,[sp,#0x8c]
0001ee  e00c              B        |L1.522|
                  |L1.496|
;;;472        {
;;;473    
;;;474          acc0 += (*pScr++ * *pIn2++);
0001f0  f932cb02          LDRSH    r12,[r2],#2
0001f4  f9347b02          LDRSH    r7,[r4],#2
0001f8  fbcc0187          SMLALBB  r0,r1,r12,r7
;;;475          acc0 += (*pScr++ * *pIn2++);
0001fc  f932cb02          LDRSH    r12,[r2],#2
000200  f9347b02          LDRSH    r7,[r4],#2
000204  fbcc0187          SMLALBB  r0,r1,r12,r7
000208  1e5b              SUBS     r3,r3,#1
                  |L1.522|
00020a  2b00              CMP      r3,#0                 ;471
00020c  d1f0              BNE      |L1.496|
;;;476    
;;;477          /* Decrement the loop counter */
;;;478          tapCnt--;
;;;479        }
;;;480    
;;;481        tapCnt = (srcBLen) & 1u;
00020e  f0050301          AND      r3,r5,#1
;;;482    
;;;483        /* apply same above for remaining samples of smaller length sequence */
;;;484        while(tapCnt > 0u)
000212  e006              B        |L1.546|
                  |L1.532|
;;;485        {
;;;486    
;;;487          /* accumlate the results */
;;;488          acc0 += (*pScr++ * *pIn2++);
000214  f932cb02          LDRSH    r12,[r2],#2
000218  f9347b02          LDRSH    r7,[r4],#2
00021c  fbcc0187          SMLALBB  r0,r1,r12,r7
000220  1e5b              SUBS     r3,r3,#1
                  |L1.546|
000222  2b00              CMP      r3,#0                 ;484
000224  d1f6              BNE      |L1.532|
;;;489    
;;;490          /* Decrement the loop counter */
;;;491          tapCnt--;
;;;492        }
;;;493    
;;;494        blkCnt--;
;;;495    
;;;496        /* Store the result in the accumulator in the destination buffer. */
;;;497        *pOut = (q15_t) (__SSAT((acc0 >> 15), 16));
000226  0bc0              LSRS     r0,r0,#15
000228  ea404041          ORR      r0,r0,r1,LSL #17
00022c  f300010f          SSAT     r1,#16,r0
000230  980b              LDR      r0,[sp,#0x2c]
000232  8001              STRH     r1,[r0,#0]
;;;498    
;;;499        pOut += inc;
000234  9911              LDR      r1,[sp,#0x44]
000236  980b              LDR      r0,[sp,#0x2c]
;;;500    
;;;501        /* Initialization of inputB pointer */
;;;502        pIn2 = py;
;;;503    
;;;504        pScratch += 1u;
000238  9c17              LDR      r4,[sp,#0x5c]
00023a  eb000041          ADD      r0,r0,r1,LSL #1       ;499
00023e  900b              STR      r0,[sp,#0x2c]         ;502
000240  9823              LDR      r0,[sp,#0x8c]
000242  1c80              ADDS     r0,r0,#2
000244  1e76              SUBS     r6,r6,#1
000246  9023              STR      r0,[sp,#0x8c]
                  |L1.584|
000248  2e00              CMP      r6,#0                 ;461
00024a  d1cc              BNE      |L1.486|
;;;505    
;;;506      }
;;;507    
;;;508    
;;;509    }
00024c  b019              ADD      sp,sp,#0x64
00024e  e8bd8ff0          POP      {r4-r11,pc}
;;;510    
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\FilteringFunctions\\arm_correlate_opt_q15.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___23_arm_correlate_opt_q15_c_52b1d3e6____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___23_arm_correlate_opt_q15_c_52b1d3e6____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___23_arm_correlate_opt_q15_c_52b1d3e6____REVSH|
#line 144
|__asm___23_arm_correlate_opt_q15_c_52b1d3e6____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___23_arm_correlate_opt_q15_c_52b1d3e6____RRX|
#line 300
|__asm___23_arm_correlate_opt_q15_c_52b1d3e6____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
