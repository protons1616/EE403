; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_fir_decimate_q15.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_fir_decimate_q15.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_fir_decimate_q15.crf src\FilteringFunctions\arm_fir_decimate_q15.c]
                          THUMB

                          AREA ||i.arm_fir_decimate_q15||, CODE, READONLY, ALIGN=2

                  arm_fir_decimate_q15 PROC
;;;76     
;;;77     void arm_fir_decimate_q15(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;78       const arm_fir_decimate_instance_q15 * S,
;;;79       q15_t * pSrc,
;;;80       q15_t * pDst,
;;;81       uint32_t blockSize)
;;;82     {
000004  4682              MOV      r10,r0
000006  b095              SUB      sp,sp,#0x54
000008  e9da2001          LDRD     r2,r0,[r10,#4]
;;;83       q15_t *pState = S->pState;                     /* State pointer */
;;;84       q15_t *pCoeffs = S->pCoeffs;                   /* Coefficient pointer */
;;;85       q15_t *pStateCurnt;                            /* Points to the current sample of the state */
;;;86       q15_t *px;                                     /* Temporary pointer for state buffer */
;;;87       q15_t *pb;                                     /* Temporary pointer coefficient buffer */
;;;88       q31_t x0, x1, c0, c1;                          /* Temporary variables to hold state and coefficient values */
;;;89       q63_t sum0;                                    /* Accumulators */
;;;90       q63_t acc0, acc1;
;;;91       q15_t *px0, *px1;
;;;92       uint32_t blkCntN3;
;;;93       uint32_t numTaps = S->numTaps;                 /* Number of taps */
00000c  9211              STR      r2,[sp,#0x44]
00000e  f8ba4002          LDRH     r4,[r10,#2]
;;;94       uint32_t i, blkCnt, tapCnt, outBlockSize = blockSize / S->M;  /* Loop counters */
000012  9408              STR      r4,[sp,#0x20]
000014  f89a2000          LDRB     r2,[r10,#0]
000018  fbb3f2f2          UDIV     r2,r3,r2
;;;95     
;;;96     
;;;97       /* S->pState buffer contains previous frame (numTaps - 1) samples */
;;;98       /* pStateCurnt points to the location where the new input data should be written */
;;;99       pStateCurnt = S->pState + (numTaps - 1u);
00001c  f06f0301          MVN      r3,#1
000020  eb030344          ADD      r3,r3,r4,LSL #1
000024  18c5              ADDS     r5,r0,r3
;;;100    
;;;101    
;;;102      /* Total number of output samples to be computed */
;;;103      blkCnt = outBlockSize / 2;
000026  0853              LSRS     r3,r2,#1
;;;104      blkCntN3 = outBlockSize - (2 * blkCnt);
000028  9313              STR      r3,[sp,#0x4c]
00002a  425b              RSBS     r3,r3,#0
00002c  eb020243          ADD      r2,r2,r3,LSL #1
;;;105    
;;;106    
;;;107      while(blkCnt > 0u)
000030  9212              STR      r2,[sp,#0x48]
000032  9a13              LDR      r2,[sp,#0x4c]         ;82
000034  e080              B        |L1.312|
;;;108      {
;;;109        /* Copy decimation factor number of new input samples into the state buffer */
;;;110        i = 2 * S->M;
000036  bf00              NOP      
                  |L1.56|
000038  f89a2000          LDRB     r2,[r10,#0]
00003c  ea5f0242          LSLS.W   r2,r2,#1
                  |L1.64|
;;;111    
;;;112        do
;;;113        {
;;;114          *pStateCurnt++ = *pSrc++;
000040  f8313b02          LDRH     r3,[r1],#2
000044  f8253b02          STRH     r3,[r5],#2
000048  1e52              SUBS     r2,r2,#1
;;;115    
;;;116        } while(--i);
00004a  d1f9              BNE      |L1.64|
00004c  2300              MOVS     r3,#0
;;;117    
;;;118        /* Set accumulator to zero */
;;;119        acc0 = 0;
00004e  469b              MOV      r11,r3
000050  469e              MOV      lr,r3
;;;120        acc1 = 0;
000052  930a              STR      r3,[sp,#0x28]
;;;121    
;;;122        /* Initialize state pointer */
;;;123        px0 = pState;
;;;124    
;;;125        px1 = pState + S->M;
000054  9306              STR      r3,[sp,#0x18]
000056  f89a3000          LDRB     r3,[r10,#0]
;;;126    
;;;127    
;;;128        /* Initialize coeff pointer */
;;;129        pb = pCoeffs;
;;;130    
;;;131        /* Loop unrolling.  Process 4 taps at a time. */
;;;132        tapCnt = numTaps >> 2;
00005a  9e08              LDR      r6,[sp,#0x20]
00005c  eb000443          ADD      r4,r0,r3,LSL #1       ;125
000060  9301              STR      r3,[sp,#4]            ;129
000062  4602              MOV      r2,r0                 ;123
000064  08b6              LSRS     r6,r6,#2
;;;133    
;;;134        /* Loop over the number of taps.  Unroll by a factor of 4.       
;;;135         ** Repeat until we've computed numTaps-4 coefficients. */
;;;136        while(tapCnt > 0u)
000066  9b11              LDR      r3,[sp,#0x44]
000068  e02e              B        |L1.200|
;;;137        {
;;;138          /* Read the Read b[numTaps-1] and b[numTaps-2]  coefficients */
;;;139          c0 = *__SIMD32(pb)++;
00006a  bf00              NOP      
                  |L1.108|
00006c  f853cb04          LDR      r12,[r3],#4
;;;140    
;;;141          /* Read x[n-numTaps-1] and x[n-numTaps-2]sample */
;;;142          x0 = *__SIMD32(px0)++;
000070  f8528b04          LDR      r8,[r2],#4
;;;143    
;;;144          x1 = *__SIMD32(px1)++;
000074  920f              STR      r2,[sp,#0x3c]
000076  f8542b04          LDR      r2,[r4],#4
;;;145    
;;;146          /* Perform the multiply-accumulate */
;;;147          acc0 = __SMLALD(x0, c0, acc0);
00007a  465f              MOV      r7,r11
00007c  4676              MOV      r6,lr
00007e  fbc876cc          SMLALD   r7,r6,r8,r12
000082  46b6              MOV      lr,r6
;;;148    
;;;149          acc1 = __SMLALD(x1, c0, acc1);
000084  f8dd8028          LDR      r8,[sp,#0x28]
000088  9e06              LDR      r6,[sp,#0x18]
00008a  46bb              MOV      r11,r7                ;147
00008c  fbc286cc          SMLALD   r8,r6,r2,r12
;;;150    
;;;151          /* Read the b[numTaps-3] and b[numTaps-4] coefficient */
;;;152          c0 = *__SIMD32(pb)++;
000090  f8cd8028          STR      r8,[sp,#0x28]
000094  9606              STR      r6,[sp,#0x18]
;;;153    
;;;154          /* Read x[n-numTaps-2] and x[n-numTaps-3] sample */
;;;155          x0 = *__SIMD32(px0)++;
000096  9a0f              LDR      r2,[sp,#0x3c]
000098  f853cb04          LDR      r12,[r3],#4           ;152
;;;156    
;;;157          x1 = *__SIMD32(px1)++;
00009c  f8547b04          LDR      r7,[r4],#4
0000a0  f8528b04          LDR      r8,[r2],#4            ;155
;;;158    
;;;159          /* Perform the multiply-accumulate */
;;;160          acc0 = __SMLALD(x0, c0, acc0);
0000a4  9714              STR      r7,[sp,#0x50]
0000a6  465f              MOV      r7,r11
0000a8  4676              MOV      r6,lr
0000aa  fbc876cc          SMLALD   r7,r6,r8,r12
0000ae  46bb              MOV      r11,r7
0000b0  46b6              MOV      lr,r6
;;;161    
;;;162          acc1 = __SMLALD(x1, c0, acc1);
0000b2  f8dd8028          LDR      r8,[sp,#0x28]
0000b6  9f14              LDR      r7,[sp,#0x50]
0000b8  9e06              LDR      r6,[sp,#0x18]
0000ba  fbc786cc          SMLALD   r8,r6,r7,r12
;;;163    
;;;164          /* Decrement the loop counter */
;;;165          tapCnt--;
0000be  9606              STR      r6,[sp,#0x18]
0000c0  f8cd8028          STR      r8,[sp,#0x28]
0000c4  f1a90601          SUB      r6,r9,#1
                  |L1.200|
0000c8  ea5f0906          MOVS     r9,r6                 ;132
0000cc  d1ce              BNE      |L1.108|
;;;166        }
;;;167    
;;;168        /* If the filter length is not a multiple of 4, compute the remaining filter taps */
;;;169        tapCnt = numTaps % 0x4u;
0000ce  9e08              LDR      r6,[sp,#0x20]
0000d0  f0060603          AND      r6,r6,#3
;;;170    
;;;171        while(tapCnt > 0u)
0000d4  e014              B        |L1.256|
;;;172        {
;;;173          /* Read coefficients */
;;;174          c0 = *pb++;
0000d6  bf00              NOP      
                  |L1.216|
0000d8  f933cb02          LDRSH    r12,[r3],#2
;;;175    
;;;176          /* Fetch 1 state variable */
;;;177          x0 = *px0++;
0000dc  f9328b02          LDRSH    r8,[r2],#2
;;;178    
;;;179          x1 = *px1++;
0000e0  f9349b02          LDRSH    r9,[r4],#2
;;;180    
;;;181          /* Perform the multiply-accumulate */
;;;182          acc0 = __SMLALD(x0, c0, acc0);
0000e4  465e              MOV      r6,r11
0000e6  4677              MOV      r7,lr
0000e8  fbc867cc          SMLALD   r6,r7,r8,r12
0000ec  46b3              MOV      r11,r6
0000ee  46be              MOV      lr,r7
;;;183          acc1 = __SMLALD(x1, c0, acc1);
0000f0  9f06              LDR      r7,[sp,#0x18]
0000f2  9e0a              LDR      r6,[sp,#0x28]
0000f4  fbc967cc          SMLALD   r6,r7,r9,r12
;;;184    
;;;185          /* Decrement the loop counter */
;;;186          tapCnt--;
0000f8  960a              STR      r6,[sp,#0x28]
0000fa  9e0d              LDR      r6,[sp,#0x34]
0000fc  9706              STR      r7,[sp,#0x18]
0000fe  1e76              SUBS     r6,r6,#1
                  |L1.256|
000100  960d              STR      r6,[sp,#0x34]         ;169
000102  2e00              CMP      r6,#0                 ;169
000104  d1e8              BNE      |L1.216|
;;;187        }
;;;188    
;;;189        /* Advance the state pointer by the decimation factor       
;;;190         * to process the next group of decimation factor number samples */
;;;191        pState = pState + S->M * 2;
000106  9a01              LDR      r2,[sp,#4]
000108  eb000082          ADD      r0,r0,r2,LSL #2
;;;192    
;;;193        /* Store filter output, smlad returns the values in 2.14 format */
;;;194        /* so downsacle by 15 to get output in 1.15 */
;;;195        *pDst++ = (q15_t) (__SSAT((acc0 >> 15), 16));
00010c  ea4f32db          LSR      r2,r11,#15
000110  ea42424e          ORR      r2,r2,lr,LSL #17
000114  f302030f          SSAT     r3,#16,r2
000118  9a17              LDR      r2,[sp,#0x5c]
00011a  8013              STRH     r3,[r2,#0]
;;;196        *pDst++ = (q15_t) (__SSAT((acc1 >> 15), 16));
00011c  9b06              LDR      r3,[sp,#0x18]
00011e  9c0a              LDR      r4,[sp,#0x28]
000120  045e              LSLS     r6,r3,#17
000122  9a17              LDR      r2,[sp,#0x5c]
000124  ea4633d4          ORR      r3,r6,r4,LSR #15
000128  f303030f          SSAT     r3,#16,r3
00012c  8053              STRH     r3,[r2,#2]
00012e  1d12              ADDS     r2,r2,#4
;;;197    
;;;198        /* Decrement the loop counter */
;;;199        blkCnt--;
000130  9217              STR      r2,[sp,#0x5c]
000132  9a13              LDR      r2,[sp,#0x4c]
000134  1e52              SUBS     r2,r2,#1
000136  9213              STR      r2,[sp,#0x4c]
                  |L1.312|
000138  2a00              CMP      r2,#0                 ;107
00013a  f47faf7d          BNE      |L1.56|
;;;200      }
;;;201    
;;;202    
;;;203    
;;;204      while(blkCntN3 > 0u)
;;;205      {
;;;206        /* Copy decimation factor number of new input samples into the state buffer */
;;;207        i = S->M;
;;;208    
;;;209        do
;;;210        {
;;;211          *pStateCurnt++ = *pSrc++;
;;;212    
;;;213        } while(--i);
;;;214    
;;;215        /*Set sum to zero */
;;;216        sum0 = 0;
;;;217    
;;;218        /* Initialize state pointer */
;;;219        px = pState;
;;;220    
;;;221        /* Initialize coeff pointer */
;;;222        pb = pCoeffs;
;;;223    
;;;224        /* Loop unrolling.  Process 4 taps at a time. */
;;;225        tapCnt = numTaps >> 2;
;;;226    
;;;227        /* Loop over the number of taps.  Unroll by a factor of 4.       
;;;228         ** Repeat until we've computed numTaps-4 coefficients. */
;;;229        while(tapCnt > 0u)
;;;230        {
;;;231          /* Read the Read b[numTaps-1] and b[numTaps-2]  coefficients */
;;;232          c0 = *__SIMD32(pb)++;
;;;233    
;;;234          /* Read x[n-numTaps-1] and x[n-numTaps-2]sample */
;;;235          x0 = *__SIMD32(px)++;
;;;236    
;;;237          /* Read the b[numTaps-3] and b[numTaps-4] coefficient */
;;;238          c1 = *__SIMD32(pb)++;
;;;239    
;;;240          /* Perform the multiply-accumulate */
;;;241          sum0 = __SMLALD(x0, c0, sum0);
;;;242    
;;;243          /* Read x[n-numTaps-2] and x[n-numTaps-3] sample */
;;;244          x0 = *__SIMD32(px)++;
;;;245    
;;;246          /* Perform the multiply-accumulate */
;;;247          sum0 = __SMLALD(x0, c1, sum0);
;;;248    
;;;249          /* Decrement the loop counter */
;;;250          tapCnt--;
;;;251        }
;;;252    
;;;253        /* If the filter length is not a multiple of 4, compute the remaining filter taps */
;;;254        tapCnt = numTaps % 0x4u;
;;;255    
;;;256        while(tapCnt > 0u)
;;;257        {
;;;258          /* Read coefficients */
;;;259          c0 = *pb++;
;;;260    
;;;261          /* Fetch 1 state variable */
;;;262          x0 = *px++;
;;;263    
;;;264          /* Perform the multiply-accumulate */
;;;265          sum0 = __SMLALD(x0, c0, sum0);
;;;266    
;;;267          /* Decrement the loop counter */
;;;268          tapCnt--;
;;;269        }
;;;270    
;;;271        /* Advance the state pointer by the decimation factor       
;;;272         * to process the next group of decimation factor number samples */
;;;273        pState = pState + S->M;
;;;274    
;;;275        /* Store filter output, smlad returns the values in 2.14 format */
;;;276        /* so downsacle by 15 to get output in 1.15 */
;;;277        *pDst++ = (q15_t) (__SSAT((sum0 >> 15), 16));
;;;278    
;;;279        /* Decrement the loop counter */
;;;280        blkCntN3--;
00013e  9a12              LDR      r2,[sp,#0x48]
000140  e03e              B        |L1.448|
000142  bf00              NOP                            ;207
                  |L1.324|
000144  f89a2000          LDRB     r2,[r10,#0]           ;207
                  |L1.328|
000148  f8313b02          LDRH     r3,[r1],#2            ;211
00014c  f8253b02          STRH     r3,[r5],#2            ;211
000150  1e52              SUBS     r2,r2,#1              ;211
000152  d1f9              BNE      |L1.328|
000154  2300              MOVS     r3,#0                 ;213
000156  9e08              LDR      r6,[sp,#0x20]         ;225
000158  461a              MOV      r2,r3                 ;213
00015a  4681              MOV      r9,r0                 ;219
00015c  08b6              LSRS     r6,r6,#2              ;225
00015e  9c11              LDR      r4,[sp,#0x44]         ;229
000160  e00d              B        |L1.382|
000162  bf00              NOP                            ;232
                  |L1.356|
000164  f8548b04          LDR      r8,[r4],#4            ;232
000168  f859cb04          LDR      r12,[r9],#4           ;235
00016c  f8547b04          LDR      r7,[r4],#4            ;238
000170  fbcc32c8          SMLALD   r3,r2,r12,r8          ;241
000174  f859cb04          LDR      r12,[r9],#4           ;244
000178  fbcc32c7          SMLALD   r3,r2,r12,r7          ;247
00017c  1e76              SUBS     r6,r6,#1              ;247
                  |L1.382|
00017e  2e00              CMP      r6,#0                 ;229
000180  d1f0              BNE      |L1.356|
000182  9e08              LDR      r6,[sp,#0x20]         ;254
000184  f0060603          AND      r6,r6,#3              ;254
000188  e007              B        |L1.410|
00018a  bf00              NOP                            ;259
                  |L1.396|
00018c  f9347b02          LDRSH    r7,[r4],#2            ;259
000190  f939cb02          LDRSH    r12,[r9],#2           ;262
000194  fbcc32c7          SMLALD   r3,r2,r12,r7          ;265
000198  1e76              SUBS     r6,r6,#1              ;265
                  |L1.410|
00019a  2e00              CMP      r6,#0                 ;256
00019c  d1f6              BNE      |L1.396|
00019e  f89a4000          LDRB     r4,[r10,#0]           ;273
0001a2  eb000044          ADD      r0,r0,r4,LSL #1       ;273
0001a6  0454              LSLS     r4,r2,#17             ;277
0001a8  ea4432d3          ORR      r2,r4,r3,LSR #15      ;277
0001ac  f302030f          SSAT     r3,#16,r2             ;277
0001b0  9a17              LDR      r2,[sp,#0x5c]         ;277
0001b2  8013              STRH     r3,[r2,#0]            ;277
0001b4  9a17              LDR      r2,[sp,#0x5c]         ;277
0001b6  1c92              ADDS     r2,r2,#2              ;277
0001b8  9217              STR      r2,[sp,#0x5c]
0001ba  9a12              LDR      r2,[sp,#0x48]
0001bc  1e52              SUBS     r2,r2,#1
0001be  9212              STR      r2,[sp,#0x48]
                  |L1.448|
0001c0  2a00              CMP      r2,#0                 ;204
0001c2  d1bf              BNE      |L1.324|
;;;281      }
;;;282    
;;;283      /* Processing is complete.       
;;;284       ** Now copy the last numTaps - 1 samples to the satrt of the state buffer.       
;;;285       ** This prepares the state buffer for the next function call. */
;;;286    
;;;287      /* Points to the start of the state buffer */
;;;288      pStateCurnt = S->pState;
;;;289    
;;;290      i = (numTaps - 1u) >> 2u;
0001c4  9b08              LDR      r3,[sp,#0x20]
0001c6  f8da1008          LDR      r1,[r10,#8]
0001ca  1e5b              SUBS     r3,r3,#1
0001cc  089a              LSRS     r2,r3,#2
;;;291    
;;;292      /* copy data */
;;;293      while(i > 0u)
0001ce  e008              B        |L1.482|
                  |L1.464|
;;;294      {
;;;295        *__SIMD32(pStateCurnt)++ = *__SIMD32(pState)++;
0001d0  f8504b04          LDR      r4,[r0],#4
0001d4  f8414b04          STR      r4,[r1],#4
;;;296        *__SIMD32(pStateCurnt)++ = *__SIMD32(pState)++;
0001d8  f8504b04          LDR      r4,[r0],#4
0001dc  f8414b04          STR      r4,[r1],#4
0001e0  1e52              SUBS     r2,r2,#1
                  |L1.482|
0001e2  2a00              CMP      r2,#0                 ;293
0001e4  d1f4              BNE      |L1.464|
;;;297    
;;;298        /* Decrement the loop counter */
;;;299        i--;
;;;300      }
;;;301    
;;;302      i = (numTaps - 1u) % 0x04u;
0001e6  f0030203          AND      r2,r3,#3
;;;303    
;;;304      /* copy data */
;;;305      while(i > 0u)
0001ea  e004              B        |L1.502|
                  |L1.492|
;;;306      {
;;;307        *pStateCurnt++ = *pState++;
0001ec  f8303b02          LDRH     r3,[r0],#2
0001f0  f8213b02          STRH     r3,[r1],#2
0001f4  1e52              SUBS     r2,r2,#1
                  |L1.502|
0001f6  2a00              CMP      r2,#0                 ;305
0001f8  d1f8              BNE      |L1.492|
;;;308    
;;;309        /* Decrement the loop counter */
;;;310        i--;
;;;311      }
;;;312    }
0001fa  b019              ADD      sp,sp,#0x64
0001fc  e8bd8ff0          POP      {r4-r11,pc}
;;;313    
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\FilteringFunctions\\arm_fir_decimate_q15.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_arm_fir_decimate_q15_c_9b6462e7____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___22_arm_fir_decimate_q15_c_9b6462e7____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_arm_fir_decimate_q15_c_9b6462e7____REVSH|
#line 144
|__asm___22_arm_fir_decimate_q15_c_9b6462e7____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___22_arm_fir_decimate_q15_c_9b6462e7____RRX|
#line 300
|__asm___22_arm_fir_decimate_q15_c_9b6462e7____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
