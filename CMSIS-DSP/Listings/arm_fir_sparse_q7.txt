; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_fir_sparse_q7.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_fir_sparse_q7.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_fir_sparse_q7.crf src\FilteringFunctions\arm_fir_sparse_q7.c]
                          THUMB

                          AREA ||i.arm_circularRead_q7||, CODE, READONLY, ALIGN=1

                  arm_circularRead_q7 PROC
;;;6395      */
;;;6396     static __INLINE void arm_circularRead_q7(
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;6397     q7_t * circBuffer,
;;;6398     int32_t L,
;;;6399     int32_t * readOffset,
;;;6400     int32_t bufferInc,
;;;6401     q7_t * dst,
;;;6402     q7_t * dst_base,
;;;6403     int32_t dst_length,
;;;6404     int32_t dstInc,
;;;6405     uint32_t blockSize)
;;;6406     {
000004  ac07              ADD      r4,sp,#0x1c
000006  e9dd960a          LDRD     r9,r6,[sp,#0x28]
00000a  e89410a0          LDM      r4,{r5,r7,r12}
00000e  6814              LDR      r4,[r2,#0]
;;;6407       uint32_t i = 0;
;;;6408       int32_t rOffset, dst_end;
;;;6409   
;;;6410       /* Copy the value of Index pointer that points
;;;6411        * to the current location from where the input samples to be read */
;;;6412       rOffset = *readOffset;
;;;6413   
;;;6414       dst_end = (int32_t) (dst_base + dst_length);
000010  44bc              ADD      r12,r12,r7
000012  e00c              B        |L1.46|
                  |L1.20|
;;;6415   
;;;6416       /* Loop over the blockSize */
;;;6417       i = blockSize;
;;;6418   
;;;6419       while(i > 0u)
;;;6420       {
;;;6421         /* copy the sample from the circular buffer to the destination buffer */
;;;6422         *dst = circBuffer[rOffset];
000014  f8108004          LDRB     r8,[r0,r4]
000018  f8858000          STRB     r8,[r5,#0]
;;;6423   
;;;6424         /* Update the input pointer */
;;;6425         dst += dstInc;
00001c  444d              ADD      r5,r5,r9
;;;6426   
;;;6427         if(dst == (q7_t *) dst_end)
00001e  4565              CMP      r5,r12
000020  d100              BNE      |L1.36|
;;;6428         {
;;;6429           dst = dst_base;
000022  463d              MOV      r5,r7
                  |L1.36|
;;;6430         }
;;;6431   
;;;6432         /* Circularly update rOffset.  Watch out for positive and negative value */
;;;6433         rOffset += bufferInc;
000024  441c              ADD      r4,r4,r3
;;;6434   
;;;6435         if(rOffset >= L)
000026  428c              CMP      r4,r1
000028  db00              BLT      |L1.44|
;;;6436         {
;;;6437           rOffset -= L;
00002a  1a64              SUBS     r4,r4,r1
                  |L1.44|
00002c  1e76              SUBS     r6,r6,#1
                  |L1.46|
00002e  2e00              CMP      r6,#0                 ;6419
000030  d1f0              BNE      |L1.20|
;;;6438         }
;;;6439   
;;;6440         /* Decrement the loop counter */
;;;6441         i--;
;;;6442       }
;;;6443   
;;;6444       /* Update the index pointer */
;;;6445       *readOffset = rOffset;
000032  6014              STR      r4,[r2,#0]
;;;6446     }
000034  e8bd83f0          POP      {r4-r9,pc}
;;;6447   
                          ENDP


                          AREA ||i.arm_fir_sparse_q7||, CODE, READONLY, ALIGN=2

                  arm_fir_sparse_q7 PROC
;;;72     
;;;73     void arm_fir_sparse_q7(
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;74       arm_fir_sparse_instance_q7 * S,
;;;75       q7_t * pSrc,
;;;76       q7_t * pDst,
;;;77       q7_t * pScratchIn,
;;;78       q31_t * pScratchOut,
;;;79       uint32_t blockSize)
;;;80     {
000004  4680              MOV      r8,r0
000006  b08b              SUB      sp,sp,#0x2c
;;;81     
;;;82       q7_t *pState = S->pState;                      /* State pointer */
;;;83       q7_t *pCoeffs = S->pCoeffs;                    /* Coefficient pointer */
000008  e9d0a001          LDRD     r10,r0,[r0,#4]
00000c  e9dd4614          LDRD     r4,r6,[sp,#0x50]      ;80
;;;84       q7_t *px;                                      /* Scratch buffer pointer */
;;;85       q7_t *py = pState;                             /* Temporary pointers for state buffer */
;;;86       q7_t *pb = pScratchIn;                         /* Temporary pointers for scratch buffer */
;;;87       q7_t *pOut = pDst;                             /* Destination pointer */
000010  4691              MOV      r9,r2
;;;88       int32_t *pTapDelay = S->pTapDelay;             /* Pointer to the array containing offset of the non-zero tap values. */
000012  f8d82010          LDR      r2,[r8,#0x10]
;;;89       uint32_t delaySize = S->maxDelay + blockSize;  /* state length */
000016  9200              STR      r2,[sp,#0]
000018  f8b8200c          LDRH     r2,[r8,#0xc]
00001c  46d4              MOV      r12,r10               ;85
00001e  eb020b06          ADD      r11,r2,r6
;;;90       uint16_t numTaps = S->numTaps;                 /* Filter order */
000022  f8b82000          LDRH     r2,[r8,#0]
;;;91       int32_t readIndex;                             /* Read index of the state buffer */
;;;92       uint32_t tapCnt, blkCnt;                       /* loop counters */
;;;93       q7_t coeff = *pCoeffs++;                       /* Read the coefficient value */
000026  9209              STR      r2,[sp,#0x24]
000028  f9107b01          LDRSB    r7,[r0],#1
;;;94       q31_t *pScr2 = pScratchOut;                    /* Working pointer for scratch buffer of output values */
;;;95       q31_t in;
;;;96     
;;;97     
;;;98     #ifndef ARM_MATH_CM0_FAMILY
;;;99     
;;;100      /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;101    
;;;102      q7_t in1, in2, in3, in4;
;;;103    
;;;104      /* BlockSize of Input samples are copied into the state buffer */
;;;105      /* StateIndex points to the starting position to write in the state buffer */
;;;106      arm_circularWrite_q7(py, (int32_t) delaySize, &S->stateIndex, 1, pSrc, 1,
00002c  9008              STR      r0,[sp,#0x20]
00002e  2001              MOVS     r0,#1
000030  9002              STR      r0,[sp,#8]
000032  9001              STR      r0,[sp,#4]
000034  461d              MOV      r5,r3                 ;86
000036  f1080e02          ADD      lr,r8,#2
00003a  4632              MOV      r2,r6
00003c  f8b80002          LDRH     r0,[r8,#2]
000040  e00b              B        |L2.90|
                  |L2.66|
000042  780b              LDRB     r3,[r1,#0]            ;80
000044  f80c3000          STRB     r3,[r12,r0]           ;80
000048  9b01              LDR      r3,[sp,#4]            ;80
00004a  4419              ADD      r1,r1,r3              ;80
00004c  9b02              LDR      r3,[sp,#8]            ;80
00004e  4418              ADD      r0,r0,r3              ;80
000050  4558              CMP      r0,r11                ;80
000052  db01              BLT      |L2.88|
000054  eba0000b          SUB      r0,r0,r11             ;80
                  |L2.88|
000058  1e52              SUBS     r2,r2,#1              ;80
                  |L2.90|
00005a  2a00              CMP      r2,#0                 ;80
00005c  d1f1              BNE      |L2.66|
00005e  f8ae0000          STRH     r0,[lr,#0]            ;80
;;;107                           blockSize);
;;;108    
;;;109      /* Loop over the number of taps. */
;;;110      tapCnt = numTaps;
;;;111    
;;;112      /* Read Index, from where the state buffer should be read, is calculated. */
;;;113      readIndex = ((int32_t) S->stateIndex - (int32_t) blockSize) - *pTapDelay++;
000062  f8b80002          LDRH     r0,[r8,#2]
000066  1b81              SUBS     r1,r0,r6
000068  9800              LDR      r0,[sp,#0]
00006a  6800              LDR      r0,[r0,#0]
00006c  1a08              SUBS     r0,r1,r0
00006e  9005              STR      r0,[sp,#0x14]
000070  9900              LDR      r1,[sp,#0]
000072  f1010104          ADD      r1,r1,#4
;;;114    
;;;115      /* Wraparound of readIndex */
;;;116      if(readIndex < 0)
000076  910a              STR      r1,[sp,#0x28]
000078  d501              BPL      |L2.126|
;;;117      {
;;;118        readIndex += (int32_t) delaySize;
00007a  4458              ADD      r0,r0,r11
00007c  9005              STR      r0,[sp,#0x14]
                  |L2.126|
;;;119      }
;;;120    
;;;121      /* Working pointer for state buffer is updated */
;;;122      py = pState;
;;;123    
;;;124      /* blockSize samples are read from the state buffer */
;;;125      arm_circularRead_q7(py, (int32_t) delaySize, &readIndex, 1, pb, pb,
00007e  2101              MOVS     r1,#1
000080  e9cd6102          STRD     r6,r1,[sp,#8]
000084  460b              MOV      r3,r1
000086  4660              MOV      r0,r12                ;122
000088  9501              STR      r5,[sp,#4]
00008a  aa05              ADD      r2,sp,#0x14
00008c  4659              MOV      r1,r11
00008e  9604              STR      r6,[sp,#0x10]
000090  9500              STR      r5,[sp,#0]
000092  f7fffffe          BL       arm_circularRead_q7
;;;126                          (int32_t) blockSize, 1, blockSize);
;;;127    
;;;128      /* Working pointer for the scratch buffer of state values */
;;;129      px = pb;
;;;130    
;;;131      /* Working pointer for scratch buffer of output values */
;;;132      pScratchOut = pScr2;
;;;133    
;;;134      /* Loop over the blockSize. Unroll by a factor of 4.    
;;;135       * Compute 4 multiplications at a time. */
;;;136      blkCnt = blockSize >> 2;
000096  08b2              LSRS     r2,r6,#2
000098  4629              MOV      r1,r5                 ;129
00009a  4620              MOV      r0,r4                 ;132
;;;137    
;;;138      while(blkCnt > 0u)
00009c  9207              STR      r2,[sp,#0x1c]
00009e  e016              B        |L2.206|
                  |L2.160|
;;;139      {
;;;140        /* Perform multiplication and store in the scratch buffer */
;;;141        *pScratchOut++ = ((q31_t) * px++ * coeff);
0000a0  f9113b01          LDRSB    r3,[r1],#1
0000a4  fb13f307          SMULBB   r3,r3,r7
0000a8  c008              STM      r0!,{r3}
;;;142        *pScratchOut++ = ((q31_t) * px++ * coeff);
0000aa  f9113b01          LDRSB    r3,[r1],#1
0000ae  fb13f307          SMULBB   r3,r3,r7
0000b2  c008              STM      r0!,{r3}
;;;143        *pScratchOut++ = ((q31_t) * px++ * coeff);
0000b4  f9113b02          LDRSB    r3,[r1],#2
0000b8  fb13f307          SMULBB   r3,r3,r7
0000bc  f8403b08          STR      r3,[r0],#8
;;;144        *pScratchOut++ = ((q31_t) * px++ * coeff);
0000c0  f9113c01          LDRSB    r3,[r1,#-1]
0000c4  fb13f307          SMULBB   r3,r3,r7
0000c8  f8403c04          STR      r3,[r0,#-4]
0000cc  1e52              SUBS     r2,r2,#1
                  |L2.206|
0000ce  2a00              CMP      r2,#0                 ;138
0000d0  d1e6              BNE      |L2.160|
;;;145    
;;;146        /* Decrement the loop counter */
;;;147        blkCnt--;
;;;148      }
;;;149    
;;;150      /* If the blockSize is not a multiple of 4,    
;;;151       * compute the remaining samples */
;;;152      blkCnt = blockSize % 0x4u;
0000d2  f0060203          AND      r2,r6,#3
;;;153    
;;;154      while(blkCnt > 0u)
0000d6  9206              STR      r2,[sp,#0x18]
0000d8  e006              B        |L2.232|
;;;155      {
;;;156        /* Perform multiplication and store in the scratch buffer */
;;;157        *pScratchOut++ = ((q31_t) * px++ * coeff);
0000da  bf00              NOP      
                  |L2.220|
0000dc  f9113b01          LDRSB    r3,[r1],#1
0000e0  fb13f307          SMULBB   r3,r3,r7
0000e4  c008              STM      r0!,{r3}
0000e6  1e52              SUBS     r2,r2,#1
                  |L2.232|
0000e8  2a00              CMP      r2,#0                 ;154
0000ea  d1f7              BNE      |L2.220|
;;;158    
;;;159        /* Decrement the loop counter */
;;;160        blkCnt--;
;;;161      }
;;;162    
;;;163      /* Load the coefficient value and    
;;;164       * increment the coefficient buffer for the next set of state values */
;;;165      coeff = *pCoeffs++;
0000ec  9808              LDR      r0,[sp,#0x20]
0000ee  f9107b01          LDRSB    r7,[r0],#1
;;;166    
;;;167      /* Read Index, from where the state buffer should be read, is calculated. */
;;;168      readIndex = ((int32_t) S->stateIndex - (int32_t) blockSize) - *pTapDelay++;
0000f2  9008              STR      r0,[sp,#0x20]
0000f4  f8b80002          LDRH     r0,[r8,#2]
0000f8  1b81              SUBS     r1,r0,r6
0000fa  980a              LDR      r0,[sp,#0x28]
0000fc  6800              LDR      r0,[r0,#0]
0000fe  1a08              SUBS     r0,r1,r0
000100  9005              STR      r0,[sp,#0x14]
000102  990a              LDR      r1,[sp,#0x28]
000104  f1010104          ADD      r1,r1,#4
;;;169    
;;;170      /* Wraparound of readIndex */
;;;171      if(readIndex < 0)
000108  910a              STR      r1,[sp,#0x28]
00010a  d501              BPL      |L2.272|
;;;172      {
;;;173        readIndex += (int32_t) delaySize;
00010c  4458              ADD      r0,r0,r11
00010e  9005              STR      r0,[sp,#0x14]
                  |L2.272|
;;;174      }
;;;175    
;;;176      /* Loop over the number of taps. */
;;;177      tapCnt = (uint32_t) numTaps - 2u;
000110  9809              LDR      r0,[sp,#0x24]
000112  1e80              SUBS     r0,r0,#2
;;;178    
;;;179      while(tapCnt > 0u)
000114  e045              B        |L2.418|
;;;180      {
;;;181        /* Working pointer for state buffer is updated */
;;;182        py = pState;
;;;183    
;;;184        /* blockSize samples are read from the state buffer */
;;;185        arm_circularRead_q7(py, (int32_t) delaySize, &readIndex, 1, pb, pb,
000116  bf00              NOP      
                  |L2.280|
000118  f7fffffe          BL       arm_circularRead_q7
;;;186                            (int32_t) blockSize, 1, blockSize);
;;;187    
;;;188        /* Working pointer for the scratch buffer of state values */
;;;189        px = pb;
00011c  4629              MOV      r1,r5
;;;190    
;;;191        /* Working pointer for scratch buffer of output values */
;;;192        pScratchOut = pScr2;
00011e  4620              MOV      r0,r4
;;;193    
;;;194        /* Loop over the blockSize. Unroll by a factor of 4.    
;;;195         * Compute 4 MACS at a time. */
;;;196        blkCnt = blockSize >> 2;
;;;197    
;;;198        while(blkCnt > 0u)
000120  9a07              LDR      r2,[sp,#0x1c]
000122  e01d              B        |L2.352|
                  |L2.292|
;;;199        {
;;;200          /* Perform Multiply-Accumulate */
;;;201          in = *pScratchOut + ((q31_t) * px++ * coeff);
000124  6803              LDR      r3,[r0,#0]
000126  f911cb01          LDRSB    r12,[r1],#1
00012a  fb1c3307          SMLABB   r3,r12,r7,r3
;;;202          *pScratchOut++ = in;
00012e  c008              STM      r0!,{r3}
;;;203          in = *pScratchOut + ((q31_t) * px++ * coeff);
000130  f911cb01          LDRSB    r12,[r1],#1
000134  c808              LDM      r0!,{r3}
000136  fb1c3307          SMLABB   r3,r12,r7,r3
;;;204          *pScratchOut++ = in;
00013a  f8403c04          STR      r3,[r0,#-4]
;;;205          in = *pScratchOut + ((q31_t) * px++ * coeff);
00013e  f8503b08          LDR      r3,[r0],#8
000142  f911cb01          LDRSB    r12,[r1],#1
000146  fb1c3307          SMLABB   r3,r12,r7,r3
;;;206          *pScratchOut++ = in;
00014a  f8403c08          STR      r3,[r0,#-8]
;;;207          in = *pScratchOut + ((q31_t) * px++ * coeff);
00014e  f8503c04          LDR      r3,[r0,#-4]
000152  f911cb01          LDRSB    r12,[r1],#1
000156  fb1c3307          SMLABB   r3,r12,r7,r3
;;;208          *pScratchOut++ = in;
00015a  f8403c04          STR      r3,[r0,#-4]
00015e  1e52              SUBS     r2,r2,#1
                  |L2.352|
000160  2a00              CMP      r2,#0                 ;198
000162  d1df              BNE      |L2.292|
;;;209    
;;;210          /* Decrement the loop counter */
;;;211          blkCnt--;
;;;212        }
;;;213    
;;;214        /* If the blockSize is not a multiple of 4,    
;;;215         * compute the remaining samples */
;;;216        blkCnt = blockSize % 0x4u;
;;;217    
;;;218        while(blkCnt > 0u)
000164  9a06              LDR      r2,[sp,#0x18]
000166  e006              B        |L2.374|
                  |L2.360|
;;;219        {
;;;220          /* Perform Multiply-Accumulate */
;;;221          in = *pScratchOut + ((q31_t) * px++ * coeff);
000168  6803              LDR      r3,[r0,#0]
00016a  f911cb01          LDRSB    r12,[r1],#1
00016e  fb1c3307          SMLABB   r3,r12,r7,r3
;;;222          *pScratchOut++ = in;
000172  c008              STM      r0!,{r3}
000174  1e52              SUBS     r2,r2,#1
                  |L2.374|
000176  2a00              CMP      r2,#0                 ;218
000178  d1f6              BNE      |L2.360|
;;;223    
;;;224          /* Decrement the loop counter */
;;;225          blkCnt--;
;;;226        }
;;;227    
;;;228        /* Load the coefficient value and    
;;;229         * increment the coefficient buffer for the next set of state values */
;;;230        coeff = *pCoeffs++;
00017a  9808              LDR      r0,[sp,#0x20]
00017c  f9107b01          LDRSB    r7,[r0],#1
;;;231    
;;;232        /* Read Index, from where the state buffer should be read, is calculated. */
;;;233        readIndex = ((int32_t) S->stateIndex -
000180  9008              STR      r0,[sp,#0x20]
000182  f8b80002          LDRH     r0,[r8,#2]
000186  1b81              SUBS     r1,r0,r6
000188  980a              LDR      r0,[sp,#0x28]
00018a  6800              LDR      r0,[r0,#0]
00018c  1a08              SUBS     r0,r1,r0
00018e  9005              STR      r0,[sp,#0x14]
000190  990a              LDR      r1,[sp,#0x28]
000192  f1010104          ADD      r1,r1,#4
;;;234                     (int32_t) blockSize) - *pTapDelay++;
;;;235    
;;;236        /* Wraparound of readIndex */
;;;237        if(readIndex < 0)
000196  910a              STR      r1,[sp,#0x28]
000198  d501              BPL      |L2.414|
;;;238        {
;;;239          readIndex += (int32_t) delaySize;
00019a  4458              ADD      r0,r0,r11
00019c  9005              STR      r0,[sp,#0x14]
                  |L2.414|
;;;240        }
;;;241    
;;;242        /* Decrement the tap loop counter */
;;;243        tapCnt--;
00019e  9809              LDR      r0,[sp,#0x24]
0001a0  1e40              SUBS     r0,r0,#1
                  |L2.418|
;;;244      }
;;;245    	
;;;246    	/* Compute last tap without the final read of pTapDelay */	
;;;247    	
;;;248    	/* Working pointer for state buffer is updated */
;;;249    	py = pState;
;;;250    
;;;251    	/* blockSize samples are read from the state buffer */
;;;252    	arm_circularRead_q7(py, (int32_t) delaySize, &readIndex, 1, pb, pb,
0001a2  f04f0101          MOV      r1,#1
0001a6  e9cd6102          STRD     r6,r1,[sp,#8]
0001aa  9009              STR      r0,[sp,#0x24]         ;179
0001ac  2800              CMP      r0,#0                 ;179
0001ae  460b              MOV      r3,r1
0001b0  4650              MOV      r0,r10                ;249
0001b2  9501              STR      r5,[sp,#4]
0001b4  aa05              ADD      r2,sp,#0x14
0001b6  4659              MOV      r1,r11
0001b8  9604              STR      r6,[sp,#0x10]
0001ba  9500              STR      r5,[sp,#0]
0001bc  d1ac              BNE      |L2.280|
0001be  f7fffffe          BL       arm_circularRead_q7
;;;253    											(int32_t) blockSize, 1, blockSize);
;;;254    
;;;255    	/* Working pointer for the scratch buffer of state values */
;;;256    	px = pb;
;;;257    
;;;258    	/* Working pointer for scratch buffer of output values */
;;;259    	pScratchOut = pScr2;
0001c2  4620              MOV      r0,r4
;;;260    
;;;261    	/* Loop over the blockSize. Unroll by a factor of 4.    
;;;262    	 * Compute 4 MACS at a time. */
;;;263    	blkCnt = blockSize >> 2;
;;;264    
;;;265    	while(blkCnt > 0u)
0001c4  9907              LDR      r1,[sp,#0x1c]
0001c6  e01d              B        |L2.516|
                  |L2.456|
;;;266    	{
;;;267    		/* Perform Multiply-Accumulate */
;;;268    		in = *pScratchOut + ((q31_t) * px++ * coeff);
0001c8  6802              LDR      r2,[r0,#0]
0001ca  f9153b01          LDRSB    r3,[r5],#1
0001ce  fb132207          SMLABB   r2,r3,r7,r2
;;;269    		*pScratchOut++ = in;
0001d2  c004              STM      r0!,{r2}
;;;270    		in = *pScratchOut + ((q31_t) * px++ * coeff);
0001d4  f9153b01          LDRSB    r3,[r5],#1
0001d8  c804              LDM      r0!,{r2}
0001da  fb132207          SMLABB   r2,r3,r7,r2
;;;271    		*pScratchOut++ = in;
0001de  f8402c04          STR      r2,[r0,#-4]
;;;272    		in = *pScratchOut + ((q31_t) * px++ * coeff);
0001e2  f8502b08          LDR      r2,[r0],#8
0001e6  f9153b02          LDRSB    r3,[r5],#2
0001ea  fb132207          SMLABB   r2,r3,r7,r2
;;;273    		*pScratchOut++ = in;
0001ee  f8402c08          STR      r2,[r0,#-8]
;;;274    		in = *pScratchOut + ((q31_t) * px++ * coeff);
0001f2  f8502c04          LDR      r2,[r0,#-4]
0001f6  f9153c01          LDRSB    r3,[r5,#-1]
0001fa  fb132207          SMLABB   r2,r3,r7,r2
;;;275    		*pScratchOut++ = in;
0001fe  f8402c04          STR      r2,[r0,#-4]
000202  1e49              SUBS     r1,r1,#1
                  |L2.516|
000204  2900              CMP      r1,#0                 ;265
000206  d1df              BNE      |L2.456|
;;;276    
;;;277    		/* Decrement the loop counter */
;;;278    		blkCnt--;
;;;279    	}
;;;280    
;;;281    	/* If the blockSize is not a multiple of 4,    
;;;282    	 * compute the remaining samples */
;;;283    	blkCnt = blockSize % 0x4u;
;;;284    
;;;285    	while(blkCnt > 0u)
000208  9906              LDR      r1,[sp,#0x18]
00020a  e006              B        |L2.538|
                  |L2.524|
;;;286    	{
;;;287    		/* Perform Multiply-Accumulate */
;;;288    		in = *pScratchOut + ((q31_t) * px++ * coeff);
00020c  6802              LDR      r2,[r0,#0]
00020e  f9153b01          LDRSB    r3,[r5],#1
000212  fb132207          SMLABB   r2,r3,r7,r2
;;;289    		*pScratchOut++ = in;
000216  c004              STM      r0!,{r2}
000218  1e49              SUBS     r1,r1,#1
                  |L2.538|
00021a  2900              CMP      r1,#0                 ;285
00021c  d1f6              BNE      |L2.524|
;;;290    
;;;291    		/* Decrement the loop counter */
;;;292    		blkCnt--;
;;;293    	}
;;;294    
;;;295      /* All the output values are in pScratchOut buffer.    
;;;296         Convert them into 1.15 format, saturate and store in the destination buffer. */
;;;297      /* Loop over the blockSize. */
;;;298      blkCnt = blockSize >> 2;
;;;299    
;;;300      while(blkCnt > 0u)
00021e  9807              LDR      r0,[sp,#0x1c]
000220  e01b              B        |L2.602|
                  |L2.546|
;;;301      {
;;;302        in1 = (q7_t) __SSAT(*pScr2++ >> 7, 8);
000222  cc02              LDM      r4!,{r1}
;;;303        in2 = (q7_t) __SSAT(*pScr2++ >> 7, 8);
;;;304        in3 = (q7_t) __SSAT(*pScr2++ >> 7, 8);
;;;305        in4 = (q7_t) __SSAT(*pScr2++ >> 7, 8);
;;;306    
;;;307        *__SIMD32(pOut)++ = __PACKq7(in1, in2, in3, in4);
000224  f64f76ff          MOV      r6,#0xffff
000228  f32112c7          SSAT     r2,#8,r1,ASR #7       ;302
00022c  cc02              LDM      r4!,{r1}              ;303
00022e  b2d2              UXTB     r2,r2
000230  f8543b08          LDR      r3,[r4],#8            ;304
000234  f32111c7          SSAT     r1,#8,r1,ASR #7       ;303
000238  ea062101          AND      r1,r6,r1,LSL #8
00023c  430a              ORRS     r2,r2,r1
00023e  f32313c7          SSAT     r3,#8,r3,ASR #7       ;304
000242  f8545c04          LDR      r5,[r4,#-4]           ;305
000246  b2d9              UXTB     r1,r3
000248  f32515c7          SSAT     r5,#8,r5,ASR #7       ;305
00024c  ea424101          ORR      r1,r2,r1,LSL #16
000250  ea416205          ORR      r2,r1,r5,LSL #24
000254  f8492b04          STR      r2,[r9],#4
000258  1e40              SUBS     r0,r0,#1
                  |L2.602|
00025a  2800              CMP      r0,#0                 ;300
00025c  d1e1              BNE      |L2.546|
;;;308    
;;;309        /* Decrement the blockSize loop counter */
;;;310        blkCnt--;
;;;311      }
;;;312    
;;;313      /* If the blockSize is not a multiple of 4,    
;;;314         remaining samples are processed in the below loop */
;;;315      blkCnt = blockSize % 0x4u;
;;;316    
;;;317      while(blkCnt > 0u)
00025e  9806              LDR      r0,[sp,#0x18]
000260  e005              B        |L2.622|
                  |L2.610|
;;;318      {
;;;319        *pOut++ = (q7_t) __SSAT(*pScr2++ >> 7, 8);
000262  cc02              LDM      r4!,{r1}
000264  1e40              SUBS     r0,r0,#1
000266  f32112c7          SSAT     r2,#8,r1,ASR #7
00026a  f8092b01          STRB     r2,[r9],#1
                  |L2.622|
00026e  2800              CMP      r0,#0                 ;317
000270  d1f7              BNE      |L2.610|
;;;320    
;;;321        /* Decrement the blockSize loop counter */
;;;322        blkCnt--;
;;;323      }
;;;324    
;;;325    #else
;;;326    
;;;327      /* Run the below code for Cortex-M0 */
;;;328    
;;;329      /* BlockSize of Input samples are copied into the state buffer */
;;;330      /* StateIndex points to the starting position to write in the state buffer */
;;;331      arm_circularWrite_q7(py, (int32_t) delaySize, &S->stateIndex, 1, pSrc, 1,
;;;332                           blockSize);
;;;333    
;;;334      /* Loop over the number of taps. */
;;;335      tapCnt = numTaps;
;;;336    
;;;337      /* Read Index, from where the state buffer should be read, is calculated. */
;;;338      readIndex = ((int32_t) S->stateIndex - (int32_t) blockSize) - *pTapDelay++;
;;;339    
;;;340      /* Wraparound of readIndex */
;;;341      if(readIndex < 0)
;;;342      {
;;;343        readIndex += (int32_t) delaySize;
;;;344      }
;;;345    
;;;346      /* Working pointer for state buffer is updated */
;;;347      py = pState;
;;;348    
;;;349      /* blockSize samples are read from the state buffer */
;;;350      arm_circularRead_q7(py, (int32_t) delaySize, &readIndex, 1, pb, pb,
;;;351                          (int32_t) blockSize, 1, blockSize);
;;;352    
;;;353      /* Working pointer for the scratch buffer of state values */
;;;354      px = pb;
;;;355    
;;;356      /* Working pointer for scratch buffer of output values */
;;;357      pScratchOut = pScr2;
;;;358    
;;;359      /* Loop over the blockSize */
;;;360      blkCnt = blockSize;
;;;361    
;;;362      while(blkCnt > 0u)
;;;363      {
;;;364        /* Perform multiplication and store in the scratch buffer */
;;;365        *pScratchOut++ = ((q31_t) * px++ * coeff);
;;;366    
;;;367        /* Decrement the loop counter */
;;;368        blkCnt--;
;;;369      }
;;;370    
;;;371      /* Load the coefficient value and           
;;;372       * increment the coefficient buffer for the next set of state values */
;;;373      coeff = *pCoeffs++;
;;;374    
;;;375      /* Read Index, from where the state buffer should be read, is calculated. */
;;;376      readIndex = ((int32_t) S->stateIndex - (int32_t) blockSize) - *pTapDelay++;
;;;377    
;;;378      /* Wraparound of readIndex */
;;;379      if(readIndex < 0)
;;;380      {
;;;381        readIndex += (int32_t) delaySize;
;;;382      }
;;;383    
;;;384      /* Loop over the number of taps. */
;;;385      tapCnt = (uint32_t) numTaps - 2u;
;;;386    
;;;387      while(tapCnt > 0u)
;;;388      {
;;;389        /* Working pointer for state buffer is updated */
;;;390        py = pState;
;;;391    
;;;392        /* blockSize samples are read from the state buffer */
;;;393        arm_circularRead_q7(py, (int32_t) delaySize, &readIndex, 1, pb, pb,
;;;394                            (int32_t) blockSize, 1, blockSize);
;;;395    
;;;396        /* Working pointer for the scratch buffer of state values */
;;;397        px = pb;
;;;398    
;;;399        /* Working pointer for scratch buffer of output values */
;;;400        pScratchOut = pScr2;
;;;401    
;;;402        /* Loop over the blockSize */
;;;403        blkCnt = blockSize;
;;;404    
;;;405        while(blkCnt > 0u)
;;;406        {
;;;407          /* Perform Multiply-Accumulate */
;;;408          in = *pScratchOut + ((q31_t) * px++ * coeff);
;;;409          *pScratchOut++ = in;
;;;410    
;;;411          /* Decrement the loop counter */
;;;412          blkCnt--;
;;;413        }
;;;414    
;;;415        /* Load the coefficient value and           
;;;416         * increment the coefficient buffer for the next set of state values */
;;;417        coeff = *pCoeffs++;
;;;418    
;;;419        /* Read Index, from where the state buffer should be read, is calculated. */
;;;420        readIndex =
;;;421          ((int32_t) S->stateIndex - (int32_t) blockSize) - *pTapDelay++;
;;;422    
;;;423        /* Wraparound of readIndex */
;;;424        if(readIndex < 0)
;;;425        {
;;;426          readIndex += (int32_t) delaySize;
;;;427        }
;;;428    
;;;429        /* Decrement the tap loop counter */
;;;430        tapCnt--;
;;;431      }
;;;432    	
;;;433    	/* Compute last tap without the final read of pTapDelay */	
;;;434    	
;;;435    	/* Working pointer for state buffer is updated */
;;;436    	py = pState;
;;;437    
;;;438    	/* blockSize samples are read from the state buffer */
;;;439    	arm_circularRead_q7(py, (int32_t) delaySize, &readIndex, 1, pb, pb,
;;;440    											(int32_t) blockSize, 1, blockSize);
;;;441    
;;;442    	/* Working pointer for the scratch buffer of state values */
;;;443    	px = pb;
;;;444    
;;;445    	/* Working pointer for scratch buffer of output values */
;;;446    	pScratchOut = pScr2;
;;;447    
;;;448    	/* Loop over the blockSize */
;;;449    	blkCnt = blockSize;
;;;450    
;;;451    	while(blkCnt > 0u)
;;;452    	{
;;;453    		/* Perform Multiply-Accumulate */
;;;454    		in = *pScratchOut + ((q31_t) * px++ * coeff);
;;;455    		*pScratchOut++ = in;
;;;456    
;;;457    		/* Decrement the loop counter */
;;;458    		blkCnt--;
;;;459    	}
;;;460    
;;;461      /* All the output values are in pScratchOut buffer.       
;;;462         Convert them into 1.15 format, saturate and store in the destination buffer. */
;;;463      /* Loop over the blockSize. */
;;;464      blkCnt = blockSize;
;;;465    
;;;466      while(blkCnt > 0u)
;;;467      {
;;;468        *pOut++ = (q7_t) __SSAT(*pScr2++ >> 7, 8);
;;;469    
;;;470        /* Decrement the blockSize loop counter */
;;;471        blkCnt--;
;;;472      }
;;;473    
;;;474    #endif /*   #ifndef ARM_MATH_CM0_FAMILY */
;;;475    
;;;476    }
000272  b00b              ADD      sp,sp,#0x2c
000274  e8bd8ff0          POP      {r4-r11,pc}
;;;477    
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\FilteringFunctions\\arm_fir_sparse_q7.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_fir_sparse_q7_c_0adf4ae3____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___19_arm_fir_sparse_q7_c_0adf4ae3____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_fir_sparse_q7_c_0adf4ae3____REVSH|
#line 144
|__asm___19_arm_fir_sparse_q7_c_0adf4ae3____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_fir_sparse_q7_c_0adf4ae3____RRX|
#line 300
|__asm___19_arm_fir_sparse_q7_c_0adf4ae3____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
