; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_max_f32.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_max_f32.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_max_f32.crf src\StatisticsFunctions\arm_max_f32.c]
                          THUMB

                          AREA ||i.arm_max_f32||, CODE, READONLY, ALIGN=1

                  arm_max_f32 PROC
;;;69     
;;;70     void arm_max_f32(
000000  b5f0              PUSH     {r4-r7,lr}
;;;71       float32_t * pSrc,
;;;72       uint32_t blockSize,
;;;73       float32_t * pResult,
;;;74       uint32_t * pIndex)
;;;75     {
;;;76     #ifndef ARM_MATH_CM0_FAMILY
;;;77     
;;;78       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;79       float32_t maxVal1, maxVal2, out;               /* Temporary variables to store the output value. */
;;;80       uint32_t blkCnt, outIndex, count;              /* loop counter */
;;;81     
;;;82       /* Initialise the count value. */
;;;83       count = 0u;
000002  2400              MOVS     r4,#0
;;;84       /* Initialise the index value to zero. */
;;;85       outIndex = 0u;
;;;86       /* Load first input value that act as reference value for comparision */
;;;87       out = *pSrc++;
;;;88     
;;;89       /* Loop unrolling */
;;;90       blkCnt = (blockSize - 1u) >> 2u;
000004  1e4f              SUBS     r7,r1,#1
000006  4625              MOV      r5,r4                 ;85
000008  ecb00a01          VLDM     r0!,{s0}              ;87
00000c  08be              LSRS     r6,r7,#2
00000e  e02a              B        |L1.102|
                  |L1.16|
;;;91     
;;;92       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;93       while(blkCnt > 0u)
;;;94       {
;;;95         /* Initialize maxVal to the next consecutive values one by one */
;;;96         maxVal1 = *pSrc++;
000010  ed901a00          VLDR     s2,[r0,#0]
;;;97     
;;;98         maxVal2 = *pSrc++;
000014  edd00a01          VLDR     s1,[r0,#4]
000018  3008              ADDS     r0,r0,#8
;;;99     
;;;100        /* compare for the maximum value */
;;;101        if(out < maxVal1)
00001a  eeb40ac1          VCMPE.F32 s0,s2
00001e  eef1fa10          VMRS     APSR_nzcv,FPSCR
000022  d202              BCS      |L1.42|
;;;102        {
;;;103          /* Update the maximum value and its index */
;;;104          out = maxVal1;
000024  eeb00a41          VMOV.F32 s0,s2
;;;105          outIndex = count + 1u;
000028  1c65              ADDS     r5,r4,#1
                  |L1.42|
;;;106        }
;;;107    
;;;108        maxVal1 = *pSrc++;
00002a  ecb01a01          VLDM     r0!,{s2}
;;;109    
;;;110        /* compare for the maximum value */
;;;111        if(out < maxVal2)
00002e  eeb40ae0          VCMPE.F32 s0,s1
000032  eef1fa10          VMRS     APSR_nzcv,FPSCR
000036  d202              BCS      |L1.62|
;;;112        {
;;;113          /* Update the maximum value and its index */
;;;114          out = maxVal2;
000038  eeb00a60          VMOV.F32 s0,s1
;;;115          outIndex = count + 2u;
00003c  1ca5              ADDS     r5,r4,#2
                  |L1.62|
;;;116        }
;;;117    
;;;118        maxVal2 = *pSrc++;
00003e  ecf00a01          VLDM     r0!,{s1}
;;;119    
;;;120        /* compare for the maximum value */
;;;121        if(out < maxVal1)
000042  eeb40ac1          VCMPE.F32 s0,s2
000046  eef1fa10          VMRS     APSR_nzcv,FPSCR
00004a  d202              BCS      |L1.82|
;;;122        {
;;;123          /* Update the maximum value and its index */
;;;124          out = maxVal1;
00004c  eeb00a41          VMOV.F32 s0,s2
;;;125          outIndex = count + 3u;
000050  1ce5              ADDS     r5,r4,#3
                  |L1.82|
;;;126        }
;;;127    
;;;128        /* compare for the maximum value */
;;;129        if(out < maxVal2)
000052  eeb40ae0          VCMPE.F32 s0,s1
000056  eef1fa10          VMRS     APSR_nzcv,FPSCR
00005a  d202              BCS      |L1.98|
;;;130        {
;;;131          /* Update the maximum value and its index */
;;;132          out = maxVal2;
00005c  eeb00a60          VMOV.F32 s0,s1
;;;133          outIndex = count + 4u;
000060  1d25              ADDS     r5,r4,#4
                  |L1.98|
000062  1d24              ADDS     r4,r4,#4
000064  1e76              SUBS     r6,r6,#1
                  |L1.102|
000066  2e00              CMP      r6,#0                 ;93
000068  d1d2              BNE      |L1.16|
;;;134        }
;;;135    
;;;136        count += 4u;
;;;137    
;;;138        /* Decrement the loop counter */
;;;139        blkCnt--;
;;;140      }
;;;141    
;;;142      /* if (blockSize - 1u) is not multiple of 4 */
;;;143      blkCnt = (blockSize - 1u) % 4u;
00006a  f0070403          AND      r4,r7,#3
;;;144    
;;;145    #else
;;;146    
;;;147      /* Run the below code for Cortex-M0 */
;;;148      float32_t maxVal1, out;                        /* Temporary variables to store the output value. */
;;;149      uint32_t blkCnt, outIndex;                     /* loop counter */
;;;150    
;;;151      /* Initialise the index value to zero. */
;;;152      outIndex = 0u;
;;;153      /* Load first input value that act as reference value for comparision */
;;;154      out = *pSrc++;
;;;155    
;;;156      blkCnt = (blockSize - 1u);
;;;157    
;;;158    #endif /* #ifndef ARM_MATH_CM0_FAMILY */
;;;159    
;;;160      while(blkCnt > 0u)
00006e  e00a              B        |L1.134|
                  |L1.112|
;;;161      {
;;;162        /* Initialize maxVal to the next consecutive values one by one */
;;;163        maxVal1 = *pSrc++;
000070  ecf00a01          VLDM     r0!,{s1}
;;;164    
;;;165        /* compare for the maximum value */
;;;166        if(out < maxVal1)
000074  eeb40ae0          VCMPE.F32 s0,s1
000078  eef1fa10          VMRS     APSR_nzcv,FPSCR
00007c  d202              BCS      |L1.132|
;;;167        {
;;;168          /* Update the maximum value and it's index */
;;;169          out = maxVal1;
00007e  eeb00a60          VMOV.F32 s0,s1
;;;170          outIndex = blockSize - blkCnt;
000082  1b0d              SUBS     r5,r1,r4
                  |L1.132|
000084  1e64              SUBS     r4,r4,#1
                  |L1.134|
000086  2c00              CMP      r4,#0                 ;160
000088  d1f2              BNE      |L1.112|
;;;171        }
;;;172    
;;;173    
;;;174        /* Decrement the loop counter */
;;;175        blkCnt--;
;;;176    
;;;177      }
;;;178    
;;;179      /* Store the maximum value and it's index into destination pointers */
;;;180      *pResult = out;
00008a  ed820a00          VSTR     s0,[r2,#0]
;;;181      *pIndex = outIndex;
00008e  601d              STR      r5,[r3,#0]
;;;182    }
000090  bdf0              POP      {r4-r7,pc}
;;;183    
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\StatisticsFunctions\\arm_max_f32.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_arm_max_f32_c_2aa8ec2a____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___13_arm_max_f32_c_2aa8ec2a____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_arm_max_f32_c_2aa8ec2a____REVSH|
#line 144
|__asm___13_arm_max_f32_c_2aa8ec2a____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___13_arm_max_f32_c_2aa8ec2a____RRX|
#line 300
|__asm___13_arm_max_f32_c_2aa8ec2a____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
