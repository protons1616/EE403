; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_fir_q15.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_fir_q15.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_fir_q15.crf src\FilteringFunctions\arm_fir_q15.c]
                          THUMB

                          AREA ||i.arm_fir_q15||, CODE, READONLY, ALIGN=2

                  arm_fir_q15 PROC
;;;84     
;;;85     void arm_fir_q15(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;86       const arm_fir_instance_q15 * S,
;;;87       q15_t * pSrc,
;;;88       q15_t * pDst,
;;;89       uint32_t blockSize)
;;;90     {
000004  b098              SUB      sp,sp,#0x60
;;;91       q15_t *pState = S->pState;                     /* State pointer */
;;;92       q15_t *pCoeffs = S->pCoeffs;                   /* Coefficient pointer */
;;;93       q15_t *pStateCurnt;                            /* Points to the current sample of the state */
;;;94       q15_t *px1;                                    /* Temporary q15 pointer for state buffer */
;;;95       q15_t *pb;                                     /* Temporary pointer for coefficient buffer */
;;;96       q31_t x0, x1, x2, x3, c0;                      /* Temporary variables to hold SIMD state and coefficient values */
;;;97       q63_t acc0, acc1, acc2, acc3;                  /* Accumulators */
;;;98       uint32_t numTaps = S->numTaps;                 /* Number of taps in the filter */
;;;99       uint32_t tapCnt, blkCnt;                       /* Loop counters */
;;;100    
;;;101    
;;;102      /* S->pState points to state array which contains previous frame (numTaps - 1) samples */
;;;103      /* pStateCurnt points to the location where the new input data should be written */
;;;104      pStateCurnt = &(S->pState[(numTaps - 1u)]);
000006  f06f0301          MVN      r3,#1
00000a  9818              LDR      r0,[sp,#0x60]         ;91
00000c  9a18              LDR      r2,[sp,#0x60]         ;92
00000e  6840              LDR      r0,[r0,#4]            ;91
000010  6892              LDR      r2,[r2,#8]            ;92
000012  9215              STR      r2,[sp,#0x54]         ;98
000014  9a18              LDR      r2,[sp,#0x60]         ;98
000016  f8b29000          LDRH     r9,[r2,#0]            ;98
00001a  eb030249          ADD      r2,r3,r9,LSL #1
00001e  1884              ADDS     r4,r0,r2
;;;105    
;;;106      /* Apply loop unrolling and compute 4 output values simultaneously.       
;;;107       * The variables acc0 ... acc3 hold output values that are being computed:       
;;;108       *       
;;;109       *    acc0 =  b[numTaps-1] * x[n-numTaps-1] + b[numTaps-2] * x[n-numTaps-2] + b[numTaps-3] * x[n-numTaps-3] +...+ b[0] * x[0]       
;;;110       *    acc1 =  b[numTaps-1] * x[n-numTaps] +   b[numTaps-2] * x[n-numTaps-1] + b[numTaps-3] * x[n-numTaps-2] +...+ b[0] * x[1]       
;;;111       *    acc2 =  b[numTaps-1] * x[n-numTaps+1] + b[numTaps-2] * x[n-numTaps] +   b[numTaps-3] * x[n-numTaps-1] +...+ b[0] * x[2]       
;;;112       *    acc3 =  b[numTaps-1] * x[n-numTaps+2] + b[numTaps-2] * x[n-numTaps+1] + b[numTaps-3] * x[n-numTaps]   +...+ b[0] * x[3]       
;;;113       */
;;;114    
;;;115      blkCnt = blockSize >> 2;
000020  9a1b              LDR      r2,[sp,#0x6c]
000022  0892              LSRS     r2,r2,#2
000024  9217              STR      r2,[sp,#0x5c]         ;90
000026  e0bb              B        |L1.416|
                  |L1.40|
;;;116    
;;;117      /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.       
;;;118       ** a second loop below computes the remaining 1 to 3 samples. */
;;;119      while(blkCnt > 0u)
;;;120      {
;;;121        /* Copy four new input samples into the state buffer.       
;;;122         ** Use 32-bit SIMD to move the 16-bit data.  Only requires two copies. */
;;;123        *__SIMD32(pStateCurnt)++ = *__SIMD32(pSrc)++;
;;;124        *__SIMD32(pStateCurnt)++ = *__SIMD32(pSrc)++;
000028  2300              MOVS     r3,#0
00002a  f8512b04          LDR      r2,[r1],#4            ;123
00002e  f8442b04          STR      r2,[r4],#4            ;123
000032  f8512b04          LDR      r2,[r1],#4
000036  f8442b04          STR      r2,[r4],#4
;;;125    
;;;126        /* Set all accumulators to zero */
;;;127        acc0 = 0;
;;;128        acc1 = 0;
00003a  9306              STR      r3,[sp,#0x18]
00003c  930a              STR      r3,[sp,#0x28]
;;;129        acc2 = 0;
;;;130        acc3 = 0;
;;;131    
;;;132        /* Initialize state pointer of type q15 */
;;;133        px1 = pState;
;;;134    
;;;135        /* Initialize coeff pointer of type q31 */
;;;136        pb = pCoeffs;
00003e  9310              STR      r3,[sp,#0x40]
000040  930f              STR      r3,[sp,#0x3c]         ;129
000042  930e              STR      r3,[sp,#0x38]         ;129
;;;137    
;;;138        /* Read the first two samples from the state buffer:  x[n-N], x[n-N-1] */
;;;139        x0 = _SIMD32_OFFSET(px1);
000044  6802              LDR      r2,[r0,#0]
;;;140    
;;;141        /* Read the third and forth samples from the state buffer: x[n-N-1], x[n-N-2] */
;;;142        x1 = _SIMD32_OFFSET(px1 + 1u);
000046  9208              STR      r2,[sp,#0x20]
000048  f8d02002          LDR      r2,[r0,#2]
00004c  469b              MOV      r11,r3                ;127
00004e  469e              MOV      lr,r3                 ;130
000050  469a              MOV      r10,r3                ;130
000052  9f15              LDR      r7,[sp,#0x54]         ;139
;;;143    
;;;144        px1 += 2u;
000054  1d05              ADDS     r5,r0,#4
;;;145    
;;;146        /* Loop over the number of taps.  Unroll by a factor of 4.       
;;;147         ** Repeat until we've computed numTaps-4 coefficients. */
;;;148        tapCnt = numTaps >> 2;
000056  ea4f0c99          LSR      r12,r9,#2
;;;149    
;;;150        while(tapCnt > 0u)
00005a  9211              STR      r2,[sp,#0x44]
00005c  e052              B        |L1.260|
;;;151        {
;;;152          /* Read the first two coefficients using SIMD:  b[N] and b[N-1] coefficients */
;;;153          c0 = *__SIMD32(pb)++;
00005e  bf00              NOP      
                  |L1.96|
000060  f8576b04          LDR      r6,[r7],#4
;;;154    
;;;155          /* acc0 +=  b[N] * x[n-N] + b[N-1] * x[n-N-1] */
;;;156          acc0 = __SMLALD(x0, c0, acc0);
000064  9714              STR      r7,[sp,#0x50]
000066  9f08              LDR      r7,[sp,#0x20]
000068  9a06              LDR      r2,[sp,#0x18]
00006a  465b              MOV      r3,r11
00006c  fbc723c6          SMLALD   r2,r3,r7,r6
000070  e9cd2306          STRD     r2,r3,[sp,#0x18]
;;;157    
;;;158          /* acc1 +=  b[N] * x[n-N-1] + b[N-1] * x[n-N-2] */
;;;159          acc1 = __SMLALD(x1, c0, acc1);
000074  9f11              LDR      r7,[sp,#0x44]
000076  9b0f              LDR      r3,[sp,#0x3c]
000078  9a0a              LDR      r2,[sp,#0x28]
00007a  fbc723c6          SMLALD   r2,r3,r7,r6
;;;160    
;;;161          /* Read state x[n-N-2], x[n-N-3] */
;;;162          x2 = _SIMD32_OFFSET(px1);
00007e  930f              STR      r3,[sp,#0x3c]
000080  920a              STR      r2,[sp,#0x28]
000082  f855bb02          LDR      r11,[r5],#2
;;;163    
;;;164          /* Read state x[n-N-3], x[n-N-4] */
;;;165          x3 = _SIMD32_OFFSET(px1 + 1u);
;;;166    
;;;167          /* acc2 +=  b[N] * x[n-N-2] + b[N-1] * x[n-N-3] */
;;;168          acc2 = __SMLALD(x2, c0, acc2);
000086  9b10              LDR      r3,[sp,#0x40]
000088  f8558b02          LDR      r8,[r5],#2            ;165
00008c  9a0e              LDR      r2,[sp,#0x38]
00008e  f8cd8020          STR      r8,[sp,#0x20]
000092  fbcb23c6          SMLALD   r2,r3,r11,r6
;;;169    
;;;170          /* acc3 +=  b[N] * x[n-N-3] + b[N-1] * x[n-N-4] */
;;;171          acc3 = __SMLALD(x3, c0, acc3);
000096  9310              STR      r3,[sp,#0x40]
000098  920e              STR      r2,[sp,#0x38]
00009a  4672              MOV      r2,lr
00009c  4653              MOV      r3,r10
00009e  fbc823c6          SMLALD   r2,r3,r8,r6
;;;172    
;;;173          /* Read coefficients b[N-2], b[N-3] */
;;;174          c0 = *__SIMD32(pb)++;
0000a2  9f14              LDR      r7,[sp,#0x50]
0000a4  4692              MOV      r10,r2                ;171
0000a6  469e              MOV      lr,r3                 ;171
0000a8  f8576b04          LDR      r6,[r7],#4
0000ac  e9dd2306          LDRD     r2,r3,[sp,#0x18]
;;;175    
;;;176          /* acc0 +=  b[N-2] * x[n-N-2] + b[N-3] * x[n-N-3] */
;;;177          acc0 = __SMLALD(x2, c0, acc0);
0000b0  fbcb23c6          SMLALD   r2,r3,r11,r6
0000b4  469b              MOV      r11,r3
;;;178    
;;;179          /* acc1 +=  b[N-2] * x[n-N-3] + b[N-3] * x[n-N-4] */
;;;180          acc1 = __SMLALD(x3, c0, acc1);
0000b6  9206              STR      r2,[sp,#0x18]
0000b8  f8dd8020          LDR      r8,[sp,#0x20]
0000bc  9b0f              LDR      r3,[sp,#0x3c]
0000be  9a0a              LDR      r2,[sp,#0x28]
0000c0  fbc823c6          SMLALD   r2,r3,r8,r6
;;;181    
;;;182          /* Read state x[n-N-4], x[n-N-5] */
;;;183          x0 = _SIMD32_OFFSET(px1 + 2u);
0000c4  930f              STR      r3,[sp,#0x3c]
0000c6  920a              STR      r2,[sp,#0x28]
0000c8  f8558b04          LDR      r8,[r5],#4
0000cc  f8cd8024          STR      r8,[sp,#0x24]
;;;184    
;;;185          /* Read state x[n-N-5], x[n-N-6] */
;;;186          x1 = _SIMD32_OFFSET(px1 + 3u);
0000d0  f8cd8020          STR      r8,[sp,#0x20]
0000d4  f8558c02          LDR      r8,[r5,#-2]
0000d8  f8cd8008          STR      r8,[sp,#8]
;;;187    
;;;188          /* acc2 +=  b[N-2] * x[n-N-4] + b[N-3] * x[n-N-5] */
;;;189          acc2 = __SMLALD(x0, c0, acc2);
0000dc  f8cd8044          STR      r8,[sp,#0x44]
0000e0  f8dd8024          LDR      r8,[sp,#0x24]
0000e4  9b10              LDR      r3,[sp,#0x40]
0000e6  9a0e              LDR      r2,[sp,#0x38]
0000e8  fbc823c6          SMLALD   r2,r3,r8,r6
;;;190    
;;;191          /* acc3 +=  b[N-2] * x[n-N-5] + b[N-3] * x[n-N-6] */
;;;192          acc3 = __SMLALD(x1, c0, acc3);
0000ec  9310              STR      r3,[sp,#0x40]
0000ee  920e              STR      r2,[sp,#0x38]
0000f0  f8dd8008          LDR      r8,[sp,#8]
0000f4  4652              MOV      r2,r10
0000f6  4673              MOV      r3,lr
0000f8  fbc823c6          SMLALD   r2,r3,r8,r6
0000fc  4696              MOV      lr,r2
0000fe  469a              MOV      r10,r3
000100  f1ac0c01          SUB      r12,r12,#1
                  |L1.260|
000104  f1bc0f00          CMP      r12,#0                ;150
000108  d1aa              BNE      |L1.96|
;;;193    
;;;194          px1 += 4u;
;;;195    
;;;196          tapCnt--;
;;;197    
;;;198        }
;;;199    
;;;200    
;;;201        /* If the filter length is not a multiple of 4, compute the remaining filter taps.       
;;;202         ** This is always be 2 taps since the filter length is even. */
;;;203        if((numTaps & 0x3u) != 0u)
00010a  ea5f7289          LSLS     r2,r9,#30
00010e  d01f              BEQ      |L1.336|
;;;204        {
;;;205          /* Read 2 coefficients */
;;;206          c0 = *__SIMD32(pb)++;
000110  683a              LDR      r2,[r7,#0]
;;;207    
;;;208          /* Fetch 4 state variables */
;;;209          x2 = _SIMD32_OFFSET(px1);
000112  682e              LDR      r6,[r5,#0]
;;;210    
;;;211          x3 = _SIMD32_OFFSET(px1 + 1u);
000114  f8d57002          LDR      r7,[r5,#2]
;;;212    
;;;213          /* Perform the multiply-accumulates */
;;;214          acc0 = __SMLALD(x0, c0, acc0);
000118  f8ddc020          LDR      r12,[sp,#0x20]
00011c  9b06              LDR      r3,[sp,#0x18]
00011e  465d              MOV      r5,r11
000120  fbcc35c2          SMLALD   r3,r5,r12,r2
000124  46ab              MOV      r11,r5
;;;215    
;;;216          px1 += 2u;
;;;217    
;;;218          acc1 = __SMLALD(x1, c0, acc1);
000126  9306              STR      r3,[sp,#0x18]
000128  f8ddc044          LDR      r12,[sp,#0x44]
00012c  9d0f              LDR      r5,[sp,#0x3c]
00012e  9b0a              LDR      r3,[sp,#0x28]
000130  fbcc35c2          SMLALD   r3,r5,r12,r2
;;;219          acc2 = __SMLALD(x2, c0, acc2);
000134  950f              STR      r5,[sp,#0x3c]
000136  930a              STR      r3,[sp,#0x28]
000138  9d10              LDR      r5,[sp,#0x40]
00013a  9b0e              LDR      r3,[sp,#0x38]
00013c  fbc635c2          SMLALD   r3,r5,r6,r2
;;;220          acc3 = __SMLALD(x3, c0, acc3);
000140  9510              STR      r5,[sp,#0x40]
000142  930e              STR      r3,[sp,#0x38]
000144  4673              MOV      r3,lr
000146  4655              MOV      r5,r10
000148  fbc735c2          SMLALD   r3,r5,r7,r2
00014c  469e              MOV      lr,r3
00014e  46aa              MOV      r10,r5
                  |L1.336|
;;;221        }
;;;222    
;;;223        /* The results in the 4 accumulators are in 2.30 format.  Convert to 1.15 with saturation.       
;;;224         ** Then store the 4 outputs in the destination buffer. */
;;;225    
;;;226    #ifndef ARM_MATH_BIG_ENDIAN
;;;227    
;;;228        *__SIMD32(pDst)++ =
000150  9b06              LDR      r3,[sp,#0x18]
000152  0bda              LSRS     r2,r3,#15
000154  ea42424b          ORR      r2,r2,r11,LSL #17
000158  f302050f          SSAT     r5,#16,r2
00015c  9a0a              LDR      r2,[sp,#0x28]
00015e  9b0f              LDR      r3,[sp,#0x3c]
000160  0bd2              LSRS     r2,r2,#15
000162  ea424243          ORR      r2,r2,r3,LSL #17
000166  f302020f          SSAT     r2,#16,r2
00016a  eac54302          PKHBT    r3,r5,r2,LSL #16
00016e  9a1a              LDR      r2,[sp,#0x68]
000170  6013              STR      r3,[r2,#0]
;;;229          __PKHBT(__SSAT((acc0 >> 15), 16), __SSAT((acc1 >> 15), 16), 16);
;;;230        *__SIMD32(pDst)++ =
000172  9b0e              LDR      r3,[sp,#0x38]
000174  9d10              LDR      r5,[sp,#0x40]
000176  0bdb              LSRS     r3,r3,#15
000178  ea434345          ORR      r3,r3,r5,LSL #17
00017c  f303060f          SSAT     r6,#16,r3
000180  ea4f33de          LSR      r3,lr,#15
000184  ea43434a          ORR      r3,r3,r10,LSL #17
000188  f303030f          SSAT     r3,#16,r3
00018c  eac64303          PKHBT    r3,r6,r3,LSL #16
000190  9a1a              LDR      r2,[sp,#0x68]
000192  6053              STR      r3,[r2,#4]
000194  3208              ADDS     r2,r2,#8
;;;231          __PKHBT(__SSAT((acc2 >> 15), 16), __SSAT((acc3 >> 15), 16), 16);
;;;232    
;;;233    #else
;;;234    
;;;235        *__SIMD32(pDst)++ =
;;;236          __PKHBT(__SSAT((acc1 >> 15), 16), __SSAT((acc0 >> 15), 16), 16);
;;;237        *__SIMD32(pDst)++ =
;;;238          __PKHBT(__SSAT((acc3 >> 15), 16), __SSAT((acc2 >> 15), 16), 16);
;;;239    
;;;240    #endif /*      #ifndef ARM_MATH_BIG_ENDIAN       */
;;;241    
;;;242    
;;;243    
;;;244        /* Advance the state pointer by 4 to process the next group of 4 samples */
;;;245        pState = pState + 4;
;;;246    
;;;247        /* Decrement the loop counter */
;;;248        blkCnt--;
000196  921a              STR      r2,[sp,#0x68]
000198  9a17              LDR      r2,[sp,#0x5c]
00019a  1e52              SUBS     r2,r2,#1
00019c  3008              ADDS     r0,r0,#8
00019e  9217              STR      r2,[sp,#0x5c]
                  |L1.416|
0001a0  2a00              CMP      r2,#0                 ;119
0001a2  f47faf41          BNE      |L1.40|
;;;249      }
;;;250    
;;;251      /* If the blockSize is not a multiple of 4, compute any remaining output samples here.       
;;;252       ** No loop unrolling is used. */
;;;253      blkCnt = blockSize % 0x4u;
0001a6  9a1b              LDR      r2,[sp,#0x6c]
0001a8  f0020a03          AND      r10,r2,#3
;;;254      while(blkCnt > 0u)
0001ac  e01f              B        |L1.494|
;;;255      {
;;;256        /* Copy two samples into state buffer */
;;;257        *pStateCurnt++ = *pSrc++;
0001ae  bf00              NOP      
                  |L1.432|
0001b0  f8312b02          LDRH     r2,[r1],#2
0001b4  f8242b02          STRH     r2,[r4],#2
0001b8  2200              MOVS     r2,#0
;;;258    
;;;259        /* Set the accumulator to zero */
;;;260        acc0 = 0;
;;;261    
;;;262        /* Initialize state pointer of type q15 */
;;;263        px1 = pState;
;;;264    
;;;265        /* Initialize coeff pointer of type q31 */
;;;266        pb = pCoeffs;
;;;267    
;;;268        tapCnt = numTaps >> 1;
0001ba  9e15              LDR      r6,[sp,#0x54]
0001bc  4613              MOV      r3,r2                 ;257
0001be  4605              MOV      r5,r0                 ;263
0001c0  ea4f0759          LSR      r7,r9,#1
                  |L1.452|
;;;269    
;;;270        do
;;;271        {
;;;272    
;;;273          c0 = *__SIMD32(pb)++;
0001c4  f856cb04          LDR      r12,[r6],#4
;;;274          x0 = *__SIMD32(px1)++;
0001c8  f8558b04          LDR      r8,[r5],#4
;;;275    
;;;276          acc0 = __SMLALD(x0, c0, acc0);
0001cc  fbc823cc          SMLALD   r2,r3,r8,r12
0001d0  1e7f              SUBS     r7,r7,#1
;;;277          tapCnt--;
;;;278        }
;;;279        while(tapCnt > 0u);
0001d2  d1f7              BNE      |L1.452|
;;;280    
;;;281        /* The result is in 2.30 format.  Convert to 1.15 with saturation.       
;;;282         ** Then store the output in the destination buffer. */
;;;283        *pDst++ = (q15_t) (__SSAT((acc0 >> 15), 16));
0001d4  0bd2              LSRS     r2,r2,#15
0001d6  ea424243          ORR      r2,r2,r3,LSL #17
0001da  f302030f          SSAT     r3,#16,r2
0001de  9a1a              LDR      r2,[sp,#0x68]
;;;284    
;;;285        /* Advance state pointer by 1 for the next sample */
;;;286        pState = pState + 1;
;;;287    
;;;288        /* Decrement the loop counter */
;;;289        blkCnt--;
0001e0  f1aa0a01          SUB      r10,r10,#1
0001e4  8013              STRH     r3,[r2,#0]            ;283
0001e6  9a1a              LDR      r2,[sp,#0x68]         ;283
0001e8  1c92              ADDS     r2,r2,#2              ;283
0001ea  1c80              ADDS     r0,r0,#2
0001ec  921a              STR      r2,[sp,#0x68]
                  |L1.494|
0001ee  f1ba0f00          CMP      r10,#0                ;254
0001f2  d1dd              BNE      |L1.432|
;;;290      }
;;;291    
;;;292      /* Processing is complete.       
;;;293       ** Now copy the last numTaps - 1 samples to the satrt of the state buffer.       
;;;294       ** This prepares the state buffer for the next function call. */
;;;295    
;;;296      /* Points to the start of the state buffer */
;;;297      pStateCurnt = S->pState;
0001f4  9918              LDR      r1,[sp,#0x60]
;;;298    
;;;299      /* Calculation of count for copying integer writes */
;;;300      tapCnt = (numTaps - 1u) >> 2;
0001f6  f1a90301          SUB      r3,r9,#1
0001fa  089a              LSRS     r2,r3,#2
0001fc  6849              LDR      r1,[r1,#4]            ;297
;;;301    
;;;302      while(tapCnt > 0u)
0001fe  e008              B        |L1.530|
                  |L1.512|
;;;303      {
;;;304    
;;;305        /* Copy state values to start of state buffer */
;;;306        *__SIMD32(pStateCurnt)++ = *__SIMD32(pState)++;
000200  f8504b04          LDR      r4,[r0],#4
000204  f8414b04          STR      r4,[r1],#4
;;;307        *__SIMD32(pStateCurnt)++ = *__SIMD32(pState)++;
000208  f8504b04          LDR      r4,[r0],#4
00020c  f8414b04          STR      r4,[r1],#4
000210  1e52              SUBS     r2,r2,#1
                  |L1.530|
000212  2a00              CMP      r2,#0                 ;302
000214  d1f4              BNE      |L1.512|
;;;308    
;;;309        tapCnt--;
;;;310    
;;;311      }
;;;312    
;;;313      /* Calculation of count for remaining q15_t data */
;;;314      tapCnt = (numTaps - 1u) % 0x4u;
000216  f0030203          AND      r2,r3,#3
;;;315    
;;;316      /* copy remaining data */
;;;317      while(tapCnt > 0u)
00021a  e004              B        |L1.550|
                  |L1.540|
;;;318      {
;;;319        *pStateCurnt++ = *pState++;
00021c  f8303b02          LDRH     r3,[r0],#2
000220  f8213b02          STRH     r3,[r1],#2
000224  1e52              SUBS     r2,r2,#1
                  |L1.550|
000226  2a00              CMP      r2,#0                 ;317
000228  d1f8              BNE      |L1.540|
;;;320    
;;;321        /* Decrement the loop counter */
;;;322        tapCnt--;
;;;323      }
;;;324    }
00022a  b01c              ADD      sp,sp,#0x70
00022c  e8bd8ff0          POP      {r4-r11,pc}
;;;325    
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\FilteringFunctions\\arm_fir_q15.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_arm_fir_q15_c_3b7760c8____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___13_arm_fir_q15_c_3b7760c8____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_arm_fir_q15_c_3b7760c8____REVSH|
#line 144
|__asm___13_arm_fir_q15_c_3b7760c8____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___13_arm_fir_q15_c_3b7760c8____RRX|
#line 300
|__asm___13_arm_fir_q15_c_3b7760c8____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
