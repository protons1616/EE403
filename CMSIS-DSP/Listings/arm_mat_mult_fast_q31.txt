; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_mat_mult_fast_q31.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_mat_mult_fast_q31.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_mat_mult_fast_q31.crf src\MatrixFunctions\arm_mat_mult_fast_q31.c]
                          THUMB

                          AREA ||i.arm_mat_mult_fast_q31||, CODE, READONLY, ALIGN=2

                  arm_mat_mult_fast_q31 PROC
;;;82     
;;;83     arm_status arm_mat_mult_fast_q31(
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;84       const arm_matrix_instance_q31 * pSrcA,
;;;85       const arm_matrix_instance_q31 * pSrcB,
;;;86       arm_matrix_instance_q31 * pDst)
;;;87     {
000004  b094              SUB      sp,sp,#0x50
;;;88       q31_t *pIn1 = pSrcA->pData;                    /* input data matrix pointer A */
;;;89       q31_t *pIn2 = pSrcB->pData;                    /* input data matrix pointer B */
;;;90       q31_t *pInA = pSrcA->pData;                    /* input data matrix pointer A */
;;;91     //  q31_t *pSrcB = pSrcB->pData;                    /* input data matrix pointer B */    
;;;92       q31_t *pOut = pDst->pData;                     /* output data matrix pointer */
000006  6844              LDR      r4,[r0,#4]
000008  6851              LDR      r1,[r2,#4]
;;;93       q31_t *px;                                     /* Temporary output data matrix pointer */
;;;94       q31_t sum;                                     /* Accumulator */
;;;95       uint16_t numRowsA = pSrcA->numRows;            /* number of rows of input matrix A    */
00000a  910d              STR      r1,[sp,#0x34]
;;;96       uint16_t numColsB = pSrcB->numCols;            /* number of columns of input matrix B */
00000c  9915              LDR      r1,[sp,#0x54]
;;;97       uint16_t numColsA = pSrcA->numCols;            /* number of columns of input matrix A */
00000e  f8b0e002          LDRH     lr,[r0,#2]
000012  8802              LDRH     r2,[r0,#0]            ;95
000014  8849              LDRH     r1,[r1,#2]            ;96
;;;98       uint16_t col, i = 0u, j, row = numRowsA, colCnt;      /* loop counters */
;;;99       arm_status status;                             /* status of matrix multiplication */
;;;100      q31_t inA1, inA2, inA3, inA4, inB1, inB2, inB3, inB4;
;;;101    
;;;102    #ifdef ARM_MATH_MATRIX_CHECK
;;;103    
;;;104    
;;;105      /* Check for matrix mismatch condition */
;;;106      if((pSrcA->numCols != pSrcB->numRows) ||
;;;107         (pSrcA->numRows != pDst->numRows) || (pSrcB->numCols != pDst->numCols))
;;;108      {
;;;109        /* Set status as ARM_MATH_SIZE_MISMATCH */
;;;110        status = ARM_MATH_SIZE_MISMATCH;
;;;111      }
;;;112      else
;;;113    #endif /*      #ifdef ARM_MATH_MATRIX_CHECK    */
;;;114    
;;;115      {
;;;116        /* The following loop performs the dot-product of each row in pSrcA with each column in pSrcB */
;;;117        /* row loop */
;;;118        do
;;;119        {
;;;120          /* Output pointer is set to starting address of the row being processed */
;;;121          px = pOut + i;
;;;122    
;;;123          /* For every row wise process, the column loop counter is to be initiated */
;;;124          col = numColsB;
;;;125    
;;;126          /* For every row wise process, the pIn2 pointer is set    
;;;127           ** to the starting address of the pSrcB data */
;;;128          pIn2 = pSrcB->pData;
;;;129    
;;;130          j = 0u;
;;;131    
;;;132          /* column loop */
;;;133          do
;;;134          {
;;;135            /* Set the variable sum, that acts as accumulator, to zero */
;;;136            sum = 0;
;;;137    
;;;138            /* Initiate the pointer pIn1 to point to the starting address of pInA */
;;;139            pIn1 = pInA;
;;;140    
;;;141            /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;142            colCnt = numColsA >> 2;
000016  ea4f009e          LSR      r0,lr,#2
00001a  e9cd2012          STRD     r2,r0,[sp,#0x48]
00001e  f04f0b00          MOV      r11,#0                ;98
                  |L1.34|
000022  980d              LDR      r0,[sp,#0x34]         ;121
000024  460d              MOV      r5,r1                 ;124
000026  eb000a8b          ADD      r10,r0,r11,LSL #2     ;121
00002a  9815              LDR      r0,[sp,#0x54]         ;128
00002c  2600              MOVS     r6,#0                 ;130
00002e  6847              LDR      r7,[r0,#4]            ;130
                  |L1.48|
000030  2000              MOVS     r0,#0                 ;136
000032  4623              MOV      r3,r4                 ;139
;;;143    
;;;144    
;;;145            /* matrix multiplication */
;;;146            while(colCnt > 0u)
000034  9a13              LDR      r2,[sp,#0x4c]
000036  e02d              B        |L1.148|
                  |L1.56|
;;;147            {
;;;148              /* c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n) */
;;;149              /* Perform the multiply-accumulates */
;;;150              inB1 = *pIn2;
000038  f8d78000          LDR      r8,[r7,#0]
;;;151              pIn2 += numColsB;
00003c  f8cd800c          STR      r8,[sp,#0xc]
000040  e8f3c802          LDRD     r12,r8,[r3],#8
000044  eb070781          ADD      r7,r7,r1,LSL #2
;;;152    
;;;153              inA1 = pIn1[0];
;;;154              inA2 = pIn1[1];
;;;155    
;;;156              inB2 = *pIn2;
000048  f8cd8028          STR      r8,[sp,#0x28]
;;;157              pIn2 += numColsB;
00004c  f8d79000          LDR      r9,[r7,#0]
000050  eb070781          ADD      r7,r7,r1,LSL #2
;;;158    
;;;159              inB3 = *pIn2;
000054  f8d78000          LDR      r8,[r7,#0]
;;;160              pIn2 += numColsB;
;;;161    
;;;162              sum = (q31_t) ((((q63_t) sum << 32) + ((q63_t) inA1 * inB1)) >> 32);
000058  f8cd8024          STR      r8,[sp,#0x24]
00005c  f8dd800c          LDR      r8,[sp,#0xc]
000060  eb070781          ADD      r7,r7,r1,LSL #2       ;160
000064  fb5c0008          SMMLA    r0,r12,r8,r0
;;;163              sum = (q31_t) ((((q63_t) sum << 32) + ((q63_t) inA2 * inB2)) >> 32);
000068  f8dd8028          LDR      r8,[sp,#0x28]
00006c  fb580009          SMMLA    r0,r8,r9,r0
000070  9000              STR      r0,[sp,#0]
000072  e8f39002          LDRD     r9,r0,[r3],#8
;;;164    
;;;165              inA3 = pIn1[2];
;;;166              inA4 = pIn1[3];
;;;167    
;;;168              inB4 = *pIn2;
000076  9002              STR      r0,[sp,#8]
;;;169              pIn2 += numColsB;
000078  f8d7c000          LDR      r12,[r7,#0]
;;;170    
;;;171              sum = (q31_t) ((((q63_t) sum << 32) + ((q63_t) inA3 * inB3)) >> 32);
00007c  f8dd8024          LDR      r8,[sp,#0x24]
000080  9800              LDR      r0,[sp,#0]
000082  eb070781          ADD      r7,r7,r1,LSL #2       ;169
000086  fb590808          SMMLA    r8,r9,r8,r0
;;;172              sum = (q31_t) ((((q63_t) sum << 32) + ((q63_t) inA4 * inB4)) >> 32);
00008a  9802              LDR      r0,[sp,#8]
00008c  fb50800c          SMMLA    r0,r0,r12,r8
000090  1e52              SUBS     r2,r2,#1
;;;173    
;;;174              pIn1 += 4u;
;;;175    
;;;176              /* Decrement the loop counter */
;;;177              colCnt--;
000092  b292              UXTH     r2,r2
                  |L1.148|
000094  2a00              CMP      r2,#0                 ;146
000096  d1cf              BNE      |L1.56|
;;;178            }
;;;179    
;;;180            /* If the columns of pSrcA is not a multiple of 4, compute any remaining output samples here.    
;;;181             ** No loop unrolling is used. */
;;;182            colCnt = numColsA % 0x4u;
000098  f00e0203          AND      r2,lr,#3
;;;183    
;;;184            while(colCnt > 0u)
00009c  e00a              B        |L1.180|
;;;185            {
;;;186              /* c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n) */
;;;187              /* Perform the multiply-accumulates */
;;;188              sum = (q31_t) ((((q63_t) sum << 32) +
00009e  bf00              NOP      
                  |L1.160|
0000a0  f853cb04          LDR      r12,[r3],#4
0000a4  f8d78000          LDR      r8,[r7,#0]
0000a8  fb5c0008          SMMLA    r0,r12,r8,r0
;;;189                              ((q63_t) * pIn1++ * (*pIn2))) >> 32);
;;;190              pIn2 += numColsB;
0000ac  1e52              SUBS     r2,r2,#1
0000ae  eb070781          ADD      r7,r7,r1,LSL #2
;;;191    
;;;192              /* Decrement the loop counter */
;;;193              colCnt--;
0000b2  b292              UXTH     r2,r2
                  |L1.180|
0000b4  2a00              CMP      r2,#0                 ;184
0000b6  d1f3              BNE      |L1.160|
;;;194            }
;;;195    
;;;196            /* Convert the result from 2.30 to 1.31 format and store in destination buffer */
;;;197            *px++ = sum << 1;
0000b8  0042              LSLS     r2,r0,#1
0000ba  f84a2b04          STR      r2,[r10],#4
0000be  1c76              ADDS     r6,r6,#1
;;;198    
;;;199            /* Update the pointer pIn2 to point to the  starting address of the next column */
;;;200            j++;
;;;201            pIn2 = pSrcB->pData + j;
0000c0  9815              LDR      r0,[sp,#0x54]
0000c2  1e6d              SUBS     r5,r5,#1
0000c4  b2b6              UXTH     r6,r6                 ;200
0000c6  6840              LDR      r0,[r0,#4]
;;;202    
;;;203            /* Decrement the column loop counter */
;;;204            col--;
0000c8  042d              LSLS     r5,r5,#16
0000ca  eb000786          ADD      r7,r0,r6,LSL #2       ;201
0000ce  0c2d              LSRS     r5,r5,#16
;;;205    
;;;206          } while(col > 0u);
0000d0  d1ae              BNE      |L1.48|
;;;207    
;;;208          /* Update the pointer pInA to point to the  starting address of the next row */
;;;209          i = i + numColsB;
0000d2  eb0b0001          ADD      r0,r11,r1
0000d6  fa1ffb80          UXTH     r11,r0
;;;210          pInA = pInA + numColsA;
;;;211    
;;;212          /* Decrement the row loop counter */
;;;213          row--;
0000da  9812              LDR      r0,[sp,#0x48]
0000dc  eb04048e          ADD      r4,r4,lr,LSL #2       ;210
0000e0  1e40              SUBS     r0,r0,#1
0000e2  0400              LSLS     r0,r0,#16
0000e4  0c00              LSRS     r0,r0,#16
;;;214    
;;;215        } while(row > 0u);
0000e6  9012              STR      r0,[sp,#0x48]
0000e8  d19b              BNE      |L1.34|
;;;216    
;;;217        /* set status as ARM_MATH_SUCCESS */
;;;218        status = ARM_MATH_SUCCESS;
;;;219      }
;;;220      /* Return to application */
;;;221      return (status);
;;;222    }
0000ea  b017              ADD      sp,sp,#0x5c
0000ec  e8bd8ff0          POP      {r4-r11,pc}
;;;223    
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\MatrixFunctions\\arm_mat_mult_fast_q31.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___23_arm_mat_mult_fast_q31_c_a938e5df____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___23_arm_mat_mult_fast_q31_c_a938e5df____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___23_arm_mat_mult_fast_q31_c_a938e5df____REVSH|
#line 144
|__asm___23_arm_mat_mult_fast_q31_c_a938e5df____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___23_arm_mat_mult_fast_q31_c_a938e5df____RRX|
#line 300
|__asm___23_arm_mat_mult_fast_q31_c_a938e5df____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
