; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_mat_inverse_f32.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_mat_inverse_f32.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_mat_inverse_f32.crf src\MatrixFunctions\arm_mat_inverse_f32.c]
                          THUMB

                          AREA ||i.arm_mat_inverse_f32||, CODE, READONLY, ALIGN=2

                  arm_mat_inverse_f32 PROC
;;;84     
;;;85     arm_status arm_mat_inverse_f32(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;86       const arm_matrix_instance_f32 * pSrc,
;;;87       arm_matrix_instance_f32 * pDst)
;;;88     {
;;;89       float32_t *pIn = pSrc->pData;                  /* input data matrix pointer */
;;;90       float32_t *pOut = pDst->pData;                 /* output data matrix pointer */
;;;91       float32_t *pInT1, *pInT2;                      /* Temporary input data matrix pointer */
;;;92       float32_t *pOutT1, *pOutT2;                    /* Temporary output data matrix pointer */
;;;93       float32_t *pPivotRowIn, *pPRT_in, *pPivotRowDst, *pPRT_pDst;  /* Temporary input and output data matrix pointer */
;;;94       uint32_t numRows = pSrc->numRows;              /* Number of rows in the matrix  */
;;;95       uint32_t numCols = pSrc->numCols;              /* Number of Cols in the matrix  */
000004  f8d1a004          LDR      r10,[r1,#4]
000008  f8d0e004          LDR      lr,[r0,#4]            ;90
00000c  8802              LDRH     r2,[r0,#0]            ;94
00000e  8841              LDRH     r1,[r0,#2]
;;;96     
;;;97     #ifndef ARM_MATH_CM0_FAMILY
;;;98       float32_t maxC;                                /* maximum value in the column */
;;;99     
;;;100      /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;101    
;;;102      float32_t Xchg, in = 0.0f, in1;                /* Temporary input values  */
000010  eddf0a93          VLDR     s1,|L1.608|
;;;103      uint32_t i, rowCnt, flag = 0u, j, loopCnt, k, l;      /* loop counters */
000014  2300              MOVS     r3,#0
;;;104      arm_status status;                             /* status of matrix inverse */
;;;105    
;;;106    #ifdef ARM_MATH_MATRIX_CHECK
;;;107    
;;;108    
;;;109      /* Check for matrix mismatch condition */
;;;110      if((pSrc->numRows != pSrc->numCols) || (pDst->numRows != pDst->numCols)
;;;111         || (pSrc->numRows != pDst->numRows))
;;;112      {
;;;113        /* Set status as ARM_MATH_SIZE_MISMATCH */
;;;114        status = ARM_MATH_SIZE_MISMATCH;
;;;115      }
;;;116      else
;;;117    #endif /*    #ifdef ARM_MATH_MATRIX_CHECK    */
;;;118    
;;;119      {
;;;120    
;;;121        /*--------------------------------------------------------------------------------------------------------------    
;;;122    	 * Matrix Inverse can be solved using elementary row operations.    
;;;123    	 *    
;;;124    	 *	Gauss-Jordan Method:    
;;;125    	 *    
;;;126    	 *	   1. First combine the identity matrix and the input matrix separated by a bar to form an    
;;;127    	 *        augmented matrix as follows:    
;;;128    	 *				        _ 	      	       _         _	       _    
;;;129    	 *					   |  a11  a12 | 1   0  |       |  X11 X12  |    
;;;130    	 *					   |           |        |   =   |           |    
;;;131    	 *					   |_ a21  a22 | 0   1 _|       |_ X21 X21 _|    
;;;132    	 *    
;;;133    	 *		2. In our implementation, pDst Matrix is used as identity matrix.    
;;;134    	 *    
;;;135    	 *		3. Begin with the first row. Let i = 1.    
;;;136    	 *    
;;;137    	 *	    4. Check to see if the pivot for column i is the greatest of the column.    
;;;138    	 *		   The pivot is the element of the main diagonal that is on the current row.    
;;;139    	 *		   For instance, if working with row i, then the pivot element is aii.    
;;;140    	 *		   If the pivot is not the most significant of the columns, exchange that row with a row
;;;141    	 *		   below it that does contain the most significant value in column i. If the most
;;;142    	 *         significant value of the column is zero, then an inverse to that matrix does not exist.
;;;143    	 *		   The most significant value of the column is the absolute maximum.
;;;144    	 *    
;;;145    	 *	    5. Divide every element of row i by the pivot.    
;;;146    	 *    
;;;147    	 *	    6. For every row below and  row i, replace that row with the sum of that row and    
;;;148    	 *		   a multiple of row i so that each new element in column i below row i is zero.    
;;;149    	 *    
;;;150    	 *	    7. Move to the next row and column and repeat steps 2 through 5 until you have zeros    
;;;151    	 *		   for every element below and above the main diagonal.    
;;;152    	 *    
;;;153    	 *		8. Now an identical matrix is formed to the left of the bar(input matrix, pSrc).    
;;;154    	 *		   Therefore, the matrix to the right of the bar is our solution(pDst matrix, pDst).    
;;;155    	 *----------------------------------------------------------------------------------------------------------------*/
;;;156    
;;;157        /* Working pointer for destination matrix */
;;;158        pOutT1 = pOut;
000016  9303              STR      r3,[sp,#0xc]
000018  4653              MOV      r3,r10
;;;159    
;;;160        /* Loop over the number of rows */
;;;161        rowCnt = numRows;
00001a  4614              MOV      r4,r2
;;;162    
;;;163        /* Making the destination matrix as identity matrix */
;;;164        while(rowCnt > 0u)
;;;165        {
;;;166          /* Writing all zeroes in lower triangle of the destination matrix */
;;;167          j = numRows - rowCnt;
;;;168          while(j > 0u)
;;;169          {
;;;170            *pOutT1++ = 0.0f;
;;;171            j--;
;;;172          }
;;;173    
;;;174          /* Writing all ones in the diagonal of the destination matrix */
;;;175          *pOutT1++ = 1.0f;
00001c  eeb70a00          VMOV.F32 s0,#1.00000000
000020  eeb01a60          VMOV.F32 s2,s1                 ;102
000024  e012              B        |L1.76|
                  |L1.38|
000026  1b15              SUBS     r5,r2,r4              ;167
000028  e003              B        |L1.50|
00002a  bf00              NOP                            ;170
                  |L1.44|
00002c  eca31a01          VSTM     r3!,{s2}              ;170
000030  1e6d              SUBS     r5,r5,#1              ;170
                  |L1.50|
000032  2d00              CMP      r5,#0                 ;168
000034  d1fa              BNE      |L1.44|
000036  eca30a01          VSTM     r3!,{s0}
;;;176    
;;;177          /* Writing all zeroes in upper triangle of the destination matrix */
;;;178          j = rowCnt - 1u;
00003a  1e65              SUBS     r5,r4,#1
;;;179          while(j > 0u)
00003c  e003              B        |L1.70|
;;;180          {
;;;181            *pOutT1++ = 0.0f;
00003e  bf00              NOP      
                  |L1.64|
000040  eca31a01          VSTM     r3!,{s2}
000044  1e6d              SUBS     r5,r5,#1
                  |L1.70|
000046  2d00              CMP      r5,#0                 ;179
000048  d1fa              BNE      |L1.64|
00004a  1e64              SUBS     r4,r4,#1              ;179
                  |L1.76|
00004c  2c00              CMP      r4,#0                 ;164
00004e  d1ea              BNE      |L1.38|
;;;182            j--;
;;;183          }
;;;184    
;;;185          /* Decrement the loop counter */
;;;186          rowCnt--;
;;;187        }
;;;188    
;;;189        /* Loop over the number of columns of the input matrix.    
;;;190           All the elements in each column are processed by the row operations */
;;;191        loopCnt = numCols;
000050  468b              MOV      r11,r1
;;;192    
;;;193        /* Index modifier to navigate through the columns */
;;;194        l = 0u;
000052  2300              MOVS     r3,#0
;;;195    
;;;196        while(loopCnt > 0u)
000054  e0e1              B        |L1.538|
;;;197        {
;;;198          /* Check if the pivot element is zero..    
;;;199           * If it is zero then interchange the row with non zero row below.    
;;;200           * If there is no non zero element to replace in the rows below,    
;;;201           * then the matrix is Singular. */
;;;202    
;;;203          /* Working pointer for the input matrix that points    
;;;204           * to the pivot element of the particular row  */
;;;205          pInT1 = pIn + (l * numCols);
000056  bf00              NOP      
                  |L1.88|
000058  fb03f501          MUL      r5,r3,r1
00005c  eb0e0485          ADD      r4,lr,r5,LSL #2
;;;206    
;;;207          /* Working pointer for the destination matrix that points    
;;;208           * to the pivot element of the particular row  */
;;;209          pOutT1 = pOut + (l * numCols);
000060  eb0a0585          ADD      r5,r10,r5,LSL #2
;;;210    
;;;211          /* Temporary variable to hold the pivot value */
;;;212          in = *pInT1;
000064  9500              STR      r5,[sp,#0]
000066  46a1              MOV      r9,r4                 ;205
000068  edd41a00          VLDR     s3,[r4,#0]
;;;213    
;;;214          /* Grab the most significant value from column l */
;;;215          maxC = 0;
00006c  eeb00a41          VMOV.F32 s0,s2
;;;216          for (i = l; i < numRows; i++)
000070  461e              MOV      r6,r3
000072  e012              B        |L1.154|
                  |L1.116|
;;;217          {
;;;218            maxC = *pInT1 > 0 ? (*pInT1 > maxC ? *pInT1 : maxC) : (-*pInT1 > maxC ? -*pInT1 : maxC);
000074  edd40a00          VLDR     s1,[r4,#0]
000078  eef50ac0          VCMPE.F32 s1,#0.0
00007c  eef1fa10          VMRS     APSR_nzcv,FPSCR
000080  dc01              BGT      |L1.134|
000082  eef10a60          VNEG.F32 s1,s1
                  |L1.134|
000086  eef40ac0          VCMPE.F32 s1,s0
00008a  eef1fa10          VMRS     APSR_nzcv,FPSCR
00008e  dd01              BLE      |L1.148|
000090  eeb00a60          VMOV.F32 s0,s1
                  |L1.148|
;;;219            pInT1 += numCols;
000094  eb040481          ADD      r4,r4,r1,LSL #2
000098  1c76              ADDS     r6,r6,#1
                  |L1.154|
00009a  4296              CMP      r6,r2                 ;216
00009c  d3ea              BCC      |L1.116|
;;;220          }
;;;221    
;;;222          /* Update the status if the matrix is singular */
;;;223          if(maxC == 0.0f)
00009e  eeb50ac0          VCMPE.F32 s0,#0.0
0000a2  eef1fa10          VMRS     APSR_nzcv,FPSCR
0000a6  d05a              BEQ      |L1.350|
;;;224          {
;;;225            return ARM_MATH_SINGULAR;
;;;226          }
;;;227    
;;;228          /* Restore pInT1  */
;;;229          pInT1 = pIn;
;;;230    
;;;231          /* Destination pointer modifier */
;;;232          k = 1u;
;;;233          
;;;234          /* Check if the pivot element is the most significant of the column */
;;;235          if( (in > 0.0f ? in : -in) != maxC)
0000a8  eef51ac0          VCMPE.F32 s3,#0.0
0000ac  4676              MOV      r6,lr                 ;229
0000ae  eef1fa10          VMRS     APSR_nzcv,FPSCR
0000b2  f04f0801          MOV      r8,#1                 ;232
0000b6  dd02              BLE      |L1.190|
0000b8  eef00a61          VMOV.F32 s1,s3
0000bc  e001              B        |L1.194|
                  |L1.190|
0000be  eef10a61          VNEG.F32 s1,s3
                  |L1.194|
0000c2  eef40a40          VCMP.F32 s1,s0
0000c6  eef1fa10          VMRS     APSR_nzcv,FPSCR
0000ca  d040              BEQ      |L1.334|
;;;236          {
;;;237            /* Loop over the number rows present below */
;;;238            i = numRows - (l + 1u);
;;;239    
;;;240            while(i > 0u)
;;;241            {
;;;242              /* Update the input and destination pointers */
;;;243              pInT2 = pInT1 + (numCols * l);
0000cc  fb01f403          MUL      r4,r1,r3
0000d0  eba20c03          SUB      r12,r2,r3             ;238
0000d4  eb060484          ADD      r4,r6,r4,LSL #2
0000d8  e036              B        |L1.328|
;;;244              pOutT2 = pOutT1 + (numCols * k);
0000da  bf00              NOP      
                  |L1.220|
;;;245    
;;;246              /* Look for the most significant element to    
;;;247               * replace in the rows below */
;;;248              if((*pInT2 > 0.0f ? *pInT2: -*pInT2) == maxC)
0000dc  edd40a00          VLDR     s1,[r4,#0]
0000e0  fb01f708          MUL      r7,r1,r8              ;244
0000e4  eb050787          ADD      r7,r5,r7,LSL #2       ;244
0000e8  eef50ac0          VCMPE.F32 s1,#0.0
0000ec  eef1fa10          VMRS     APSR_nzcv,FPSCR
0000f0  dc01              BGT      |L1.246|
0000f2  eef10a60          VNEG.F32 s1,s1
                  |L1.246|
0000f6  eef40a40          VCMP.F32 s1,s0
0000fa  eef1fa10          VMRS     APSR_nzcv,FPSCR
0000fe  d121              BNE      |L1.324|
;;;249              {
;;;250                /* Loop over number of columns    
;;;251                 * to the right of the pilot element */
;;;252                j = numCols - l;
000100  eba10c03          SUB      r12,r1,r3
;;;253    
;;;254                while(j > 0u)
000104  e00a              B        |L1.284|
;;;255                {
;;;256                  /* Exchange the row elements of the input matrix */
;;;257                  Xchg = *pInT2;
000106  bf00              NOP      
                  |L1.264|
000108  ed940a00          VLDR     s0,[r4,#0]
;;;258                  *pInT2++ = *pInT1;
00010c  edd60a00          VLDR     s1,[r6,#0]
;;;259                  *pInT1++ = Xchg;
000110  f1ac0c01          SUB      r12,r12,#1
000114  ece40a01          VSTM     r4!,{s1}              ;258
000118  eca60a01          VSTM     r6!,{s0}
                  |L1.284|
00011c  f1bc0f00          CMP      r12,#0                ;254
000120  d1f2              BNE      |L1.264|
;;;260    
;;;261                  /* Decrement the loop counter */
;;;262                  j--;
;;;263                }
;;;264    
;;;265                /* Loop over number of columns of the destination matrix */
;;;266                j = numCols;
000122  460c              MOV      r4,r1
;;;267    
;;;268                while(j > 0u)
000124  e009              B        |L1.314|
;;;269                {
;;;270                  /* Exchange the row elements of the destination matrix */
;;;271                  Xchg = *pOutT2;
000126  bf00              NOP      
                  |L1.296|
000128  ed970a00          VLDR     s0,[r7,#0]
;;;272                  *pOutT2++ = *pOutT1;
00012c  edd50a00          VLDR     s1,[r5,#0]
;;;273                  *pOutT1++ = Xchg;
000130  1e64              SUBS     r4,r4,#1
000132  ece70a01          VSTM     r7!,{s1}              ;272
000136  eca50a01          VSTM     r5!,{s0}
                  |L1.314|
00013a  2c00              CMP      r4,#0                 ;268
00013c  d1f4              BNE      |L1.296|
;;;274    
;;;275                  /* Decrement the loop counter */
;;;276                  j--;
;;;277                }
;;;278    
;;;279                /* Flag to indicate whether exchange is done or not */
;;;280                flag = 1u;
00013e  2401              MOVS     r4,#1
;;;281    
;;;282                /* Break after exchange is done */
;;;283                break;
000140  9403              STR      r4,[sp,#0xc]
000142  e011              B        |L1.360|
                  |L1.324|
000144  f1080801          ADD      r8,r8,#1
                  |L1.328|
000148  f1bc0c01          SUBS     r12,r12,#1
00014c  d1c6              BNE      |L1.220|
                  |L1.334|
;;;284              }
;;;285    
;;;286              /* Update the destination pointer modifier */
;;;287              k++;
;;;288    
;;;289              /* Decrement the loop counter */
;;;290              i--;
;;;291            }
;;;292          }
;;;293    
;;;294          /* Update the status if the matrix is singular */
;;;295          if((flag != 1u) && (in == 0.0f))
00014e  9c03              LDR      r4,[sp,#0xc]
000150  2c01              CMP      r4,#1
000152  d009              BEQ      |L1.360|
000154  eef51ac0          VCMPE.F32 s3,#0.0
000158  eef1fa10          VMRS     APSR_nzcv,FPSCR
00015c  d104              BNE      |L1.360|
                  |L1.350|
;;;296          {
;;;297            return ARM_MATH_SINGULAR;
00015e  f06f0004          MVN      r0,#4
                  |L1.354|
;;;298          }
;;;299    
;;;300          /* Points to the pivot row of input and destination matrices */
;;;301          pPivotRowIn = pIn + (l * numCols);
;;;302          pPivotRowDst = pOut + (l * numCols);
;;;303    
;;;304          /* Temporary pointers to the pivot row pointers */
;;;305          pInT1 = pPivotRowIn;
;;;306          pInT2 = pPivotRowDst;
;;;307    
;;;308          /* Pivot element of the row */
;;;309          in = *pPivotRowIn;
;;;310    
;;;311          /* Loop over number of columns    
;;;312           * to the right of the pilot element */
;;;313          j = (numCols - l);
;;;314    
;;;315          while(j > 0u)
;;;316          {
;;;317            /* Divide each element of the row of the input matrix    
;;;318             * by the pivot element */
;;;319            in1 = *pInT1;
;;;320            *pInT1++ = in1 / in;
;;;321    
;;;322            /* Decrement the loop counter */
;;;323            j--;
;;;324          }
;;;325    
;;;326          /* Loop over number of columns of the destination matrix */
;;;327          j = numCols;
;;;328    
;;;329          while(j > 0u)
;;;330          {
;;;331            /* Divide each element of the row of the destination matrix    
;;;332             * by the pivot element */
;;;333            in1 = *pInT2;
;;;334            *pInT2++ = in1 / in;
;;;335    
;;;336            /* Decrement the loop counter */
;;;337            j--;
;;;338          }
;;;339    
;;;340          /* Replace the rows with the sum of that row and a multiple of row i    
;;;341           * so that each new element in column i above row i is zero.*/
;;;342    
;;;343          /* Temporary pointers for input and destination matrices */
;;;344          pInT1 = pIn;
;;;345          pInT2 = pOut;
;;;346    
;;;347          /* index used to check for pivot element */
;;;348          i = 0u;
;;;349    
;;;350          /* Loop over number of rows */
;;;351          /*  to be replaced by the sum of that row and a multiple of row i */
;;;352          k = numRows;
;;;353    
;;;354          while(k > 0u)
;;;355          {
;;;356            /* Check for the pivot element */
;;;357            if(i == l)
;;;358            {
;;;359              /* If the processing element is the pivot element,    
;;;360                 only the columns to the right are to be processed */
;;;361              pInT1 += numCols - l;
;;;362    
;;;363              pInT2 += numCols;
;;;364            }
;;;365            else
;;;366            {
;;;367              /* Element of the reference row */
;;;368              in = *pInT1;
;;;369    
;;;370              /* Working pointers for input and destination pivot rows */
;;;371              pPRT_in = pPivotRowIn;
;;;372              pPRT_pDst = pPivotRowDst;
;;;373    
;;;374              /* Loop over the number of columns to the right of the pivot element,    
;;;375                 to replace the elements in the input matrix */
;;;376              j = (numCols - l);
;;;377    
;;;378              while(j > 0u)
;;;379              {
;;;380                /* Replace the element by the sum of that row    
;;;381                   and a multiple of the reference row  */
;;;382                in1 = *pInT1;
;;;383                *pInT1++ = in1 - (in * *pPRT_in++);
;;;384    
;;;385                /* Decrement the loop counter */
;;;386                j--;
;;;387              }
;;;388    
;;;389              /* Loop over the number of columns to    
;;;390                 replace the elements in the destination matrix */
;;;391              j = numCols;
;;;392    
;;;393              while(j > 0u)
;;;394              {
;;;395                /* Replace the element by the sum of that row    
;;;396                   and a multiple of the reference row  */
;;;397                in1 = *pInT2;
;;;398                *pInT2++ = in1 - (in * *pPRT_pDst++);
;;;399    
;;;400                /* Decrement the loop counter */
;;;401                j--;
;;;402              }
;;;403    
;;;404            }
;;;405    
;;;406            /* Increment the temporary input pointer */
;;;407            pInT1 = pInT1 + l;
;;;408    
;;;409            /* Decrement the loop counter */
;;;410            k--;
;;;411    
;;;412            /* Increment the pivot index */
;;;413            i++;
;;;414          }
;;;415    
;;;416          /* Increment the input pointer */
;;;417          pIn++;
;;;418    
;;;419          /* Decrement the loop counter */
;;;420          loopCnt--;
;;;421    
;;;422          /* Increment the index modifier */
;;;423          l++;
;;;424        }
;;;425    
;;;426    
;;;427    #else
;;;428    
;;;429      /* Run the below code for Cortex-M0 */
;;;430    
;;;431      float32_t Xchg, in = 0.0f;                     /* Temporary input values  */
;;;432      uint32_t i, rowCnt, flag = 0u, j, loopCnt, k, l;      /* loop counters */
;;;433      arm_status status;                             /* status of matrix inverse */
;;;434    
;;;435    #ifdef ARM_MATH_MATRIX_CHECK
;;;436    
;;;437      /* Check for matrix mismatch condition */
;;;438      if((pSrc->numRows != pSrc->numCols) || (pDst->numRows != pDst->numCols)
;;;439         || (pSrc->numRows != pDst->numRows))
;;;440      {
;;;441        /* Set status as ARM_MATH_SIZE_MISMATCH */
;;;442        status = ARM_MATH_SIZE_MISMATCH;
;;;443      }
;;;444      else
;;;445    #endif /*      #ifdef ARM_MATH_MATRIX_CHECK    */
;;;446      {
;;;447    
;;;448        /*--------------------------------------------------------------------------------------------------------------       
;;;449    	 * Matrix Inverse can be solved using elementary row operations.        
;;;450    	 *        
;;;451    	 *	Gauss-Jordan Method:       
;;;452    	 *	 	       
;;;453    	 *	   1. First combine the identity matrix and the input matrix separated by a bar to form an        
;;;454    	 *        augmented matrix as follows:        
;;;455    	 *				        _  _	      _	    _	   _   _         _	       _       
;;;456    	 *					   |  |  a11  a12  | | | 1   0  |   |       |  X11 X12  |         
;;;457    	 *					   |  |            | | |        |   |   =   |           |        
;;;458    	 *					   |_ |_ a21  a22 _| | |_0   1 _|  _|       |_ X21 X21 _|       
;;;459    	 *					          
;;;460    	 *		2. In our implementation, pDst Matrix is used as identity matrix.    
;;;461    	 *       
;;;462    	 *		3. Begin with the first row. Let i = 1.       
;;;463    	 *       
;;;464    	 *	    4. Check to see if the pivot for row i is zero.       
;;;465    	 *		   The pivot is the element of the main diagonal that is on the current row.       
;;;466    	 *		   For instance, if working with row i, then the pivot element is aii.       
;;;467    	 *		   If the pivot is zero, exchange that row with a row below it that does not        
;;;468    	 *		   contain a zero in column i. If this is not possible, then an inverse        
;;;469    	 *		   to that matrix does not exist.       
;;;470    	 *	       
;;;471    	 *	    5. Divide every element of row i by the pivot.       
;;;472    	 *	       
;;;473    	 *	    6. For every row below and  row i, replace that row with the sum of that row and        
;;;474    	 *		   a multiple of row i so that each new element in column i below row i is zero.       
;;;475    	 *	       
;;;476    	 *	    7. Move to the next row and column and repeat steps 2 through 5 until you have zeros       
;;;477    	 *		   for every element below and above the main diagonal.        
;;;478    	 *		   		          
;;;479    	 *		8. Now an identical matrix is formed to the left of the bar(input matrix, src).       
;;;480    	 *		   Therefore, the matrix to the right of the bar is our solution(dst matrix, dst).         
;;;481    	 *----------------------------------------------------------------------------------------------------------------*/
;;;482    
;;;483        /* Working pointer for destination matrix */
;;;484        pOutT1 = pOut;
;;;485    
;;;486        /* Loop over the number of rows */
;;;487        rowCnt = numRows;
;;;488    
;;;489        /* Making the destination matrix as identity matrix */
;;;490        while(rowCnt > 0u)
;;;491        {
;;;492          /* Writing all zeroes in lower triangle of the destination matrix */
;;;493          j = numRows - rowCnt;
;;;494          while(j > 0u)
;;;495          {
;;;496            *pOutT1++ = 0.0f;
;;;497            j--;
;;;498          }
;;;499    
;;;500          /* Writing all ones in the diagonal of the destination matrix */
;;;501          *pOutT1++ = 1.0f;
;;;502    
;;;503          /* Writing all zeroes in upper triangle of the destination matrix */
;;;504          j = rowCnt - 1u;
;;;505          while(j > 0u)
;;;506          {
;;;507            *pOutT1++ = 0.0f;
;;;508            j--;
;;;509          }
;;;510    
;;;511          /* Decrement the loop counter */
;;;512          rowCnt--;
;;;513        }
;;;514    
;;;515        /* Loop over the number of columns of the input matrix.     
;;;516           All the elements in each column are processed by the row operations */
;;;517        loopCnt = numCols;
;;;518    
;;;519        /* Index modifier to navigate through the columns */
;;;520        l = 0u;
;;;521        //for(loopCnt = 0u; loopCnt < numCols; loopCnt++)   
;;;522        while(loopCnt > 0u)
;;;523        {
;;;524          /* Check if the pivot element is zero..    
;;;525           * If it is zero then interchange the row with non zero row below.   
;;;526           * If there is no non zero element to replace in the rows below,   
;;;527           * then the matrix is Singular. */
;;;528    
;;;529          /* Working pointer for the input matrix that points     
;;;530           * to the pivot element of the particular row  */
;;;531          pInT1 = pIn + (l * numCols);
;;;532    
;;;533          /* Working pointer for the destination matrix that points     
;;;534           * to the pivot element of the particular row  */
;;;535          pOutT1 = pOut + (l * numCols);
;;;536    
;;;537          /* Temporary variable to hold the pivot value */
;;;538          in = *pInT1;
;;;539    
;;;540          /* Destination pointer modifier */
;;;541          k = 1u;
;;;542    
;;;543          /* Check if the pivot element is zero */
;;;544          if(*pInT1 == 0.0f)
;;;545          {
;;;546            /* Loop over the number rows present below */
;;;547            for (i = (l + 1u); i < numRows; i++)
;;;548            {
;;;549              /* Update the input and destination pointers */
;;;550              pInT2 = pInT1 + (numCols * l);
;;;551              pOutT2 = pOutT1 + (numCols * k);
;;;552    
;;;553              /* Check if there is a non zero pivot element to     
;;;554               * replace in the rows below */
;;;555              if(*pInT2 != 0.0f)
;;;556              {
;;;557                /* Loop over number of columns     
;;;558                 * to the right of the pilot element */
;;;559                for (j = 0u; j < (numCols - l); j++)
;;;560                {
;;;561                  /* Exchange the row elements of the input matrix */
;;;562                  Xchg = *pInT2;
;;;563                  *pInT2++ = *pInT1;
;;;564                  *pInT1++ = Xchg;
;;;565                }
;;;566    
;;;567                for (j = 0u; j < numCols; j++)
;;;568                {
;;;569                  Xchg = *pOutT2;
;;;570                  *pOutT2++ = *pOutT1;
;;;571                  *pOutT1++ = Xchg;
;;;572                }
;;;573    
;;;574                /* Flag to indicate whether exchange is done or not */
;;;575                flag = 1u;
;;;576    
;;;577                /* Break after exchange is done */
;;;578                break;
;;;579              }
;;;580    
;;;581              /* Update the destination pointer modifier */
;;;582              k++;
;;;583            }
;;;584          }
;;;585    
;;;586          /* Update the status if the matrix is singular */
;;;587          if((flag != 1u) && (in == 0.0f))
;;;588          {
;;;589            return ARM_MATH_SINGULAR;
;;;590          }
;;;591    
;;;592          /* Points to the pivot row of input and destination matrices */
;;;593          pPivotRowIn = pIn + (l * numCols);
;;;594          pPivotRowDst = pOut + (l * numCols);
;;;595    
;;;596          /* Temporary pointers to the pivot row pointers */
;;;597          pInT1 = pPivotRowIn;
;;;598          pOutT1 = pPivotRowDst;
;;;599    
;;;600          /* Pivot element of the row */
;;;601          in = *(pIn + (l * numCols));
;;;602    
;;;603          /* Loop over number of columns     
;;;604           * to the right of the pilot element */
;;;605          for (j = 0u; j < (numCols - l); j++)
;;;606          {
;;;607            /* Divide each element of the row of the input matrix     
;;;608             * by the pivot element */
;;;609            *pInT1 = *pInT1 / in;
;;;610            pInT1++;
;;;611          }
;;;612          for (j = 0u; j < numCols; j++)
;;;613          {
;;;614            /* Divide each element of the row of the destination matrix     
;;;615             * by the pivot element */
;;;616            *pOutT1 = *pOutT1 / in;
;;;617            pOutT1++;
;;;618          }
;;;619    
;;;620          /* Replace the rows with the sum of that row and a multiple of row i     
;;;621           * so that each new element in column i above row i is zero.*/
;;;622    
;;;623          /* Temporary pointers for input and destination matrices */
;;;624          pInT1 = pIn;
;;;625          pOutT1 = pOut;
;;;626    
;;;627          for (i = 0u; i < numRows; i++)
;;;628          {
;;;629            /* Check for the pivot element */
;;;630            if(i == l)
;;;631            {
;;;632              /* If the processing element is the pivot element,     
;;;633                 only the columns to the right are to be processed */
;;;634              pInT1 += numCols - l;
;;;635              pOutT1 += numCols;
;;;636            }
;;;637            else
;;;638            {
;;;639              /* Element of the reference row */
;;;640              in = *pInT1;
;;;641    
;;;642              /* Working pointers for input and destination pivot rows */
;;;643              pPRT_in = pPivotRowIn;
;;;644              pPRT_pDst = pPivotRowDst;
;;;645    
;;;646              /* Loop over the number of columns to the right of the pivot element,     
;;;647                 to replace the elements in the input matrix */
;;;648              for (j = 0u; j < (numCols - l); j++)
;;;649              {
;;;650                /* Replace the element by the sum of that row     
;;;651                   and a multiple of the reference row  */
;;;652                *pInT1 = *pInT1 - (in * *pPRT_in++);
;;;653                pInT1++;
;;;654              }
;;;655              /* Loop over the number of columns to     
;;;656                 replace the elements in the destination matrix */
;;;657              for (j = 0u; j < numCols; j++)
;;;658              {
;;;659                /* Replace the element by the sum of that row     
;;;660                   and a multiple of the reference row  */
;;;661                *pOutT1 = *pOutT1 - (in * *pPRT_pDst++);
;;;662                pOutT1++;
;;;663              }
;;;664    
;;;665            }
;;;666            /* Increment the temporary input pointer */
;;;667            pInT1 = pInT1 + l;
;;;668          }
;;;669          /* Increment the input pointer */
;;;670          pIn++;
;;;671    
;;;672          /* Decrement the loop counter */
;;;673          loopCnt--;
;;;674          /* Increment the index modifier */
;;;675          l++;
;;;676        }
;;;677    
;;;678    
;;;679    #endif /* #ifndef ARM_MATH_CM0_FAMILY */
;;;680    
;;;681        /* Set status as ARM_MATH_SUCCESS */
;;;682        status = ARM_MATH_SUCCESS;
;;;683    
;;;684        if((flag != 1u) && (in == 0.0f))
;;;685        {
;;;686          pIn = pSrc->pData;
;;;687          for (i = 0; i < numRows * numCols; i++)
;;;688          {
;;;689            if (pIn[i] != 0.0f)
;;;690                break;
;;;691          }
;;;692          
;;;693          if (i == numRows * numCols)
;;;694            status = ARM_MATH_SINGULAR;
;;;695        }
;;;696      }
;;;697      /* Return to application */
;;;698      return (status);
;;;699    }
000162  b004              ADD      sp,sp,#0x10
000164  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.360|
000168  f8cd9004          STR      r9,[sp,#4]            ;301
00016c  edd90a00          VLDR     s1,[r9,#0]            ;309
000170  1ace              SUBS     r6,r1,r3              ;313
000172  464c              MOV      r4,r9
000174  9d00              LDR      r5,[sp,#0]            ;309
000176  9602              STR      r6,[sp,#8]            ;315
000178  e007              B        |L1.394|
00017a  bf00              NOP                            ;319
                  |L1.380|
00017c  ed940a00          VLDR     s0,[r4,#0]            ;319
000180  1e76              SUBS     r6,r6,#1              ;320
000182  eec01a20          VDIV.F32 s3,s0,s1              ;320
000186  ece41a01          VSTM     r4!,{s3}              ;320
                  |L1.394|
00018a  2e00              CMP      r6,#0                 ;315
00018c  d1f6              BNE      |L1.380|
00018e  460c              MOV      r4,r1                 ;327
000190  e007              B        |L1.418|
000192  bf00              NOP                            ;333
                  |L1.404|
000194  ed950a00          VLDR     s0,[r5,#0]            ;333
000198  1e64              SUBS     r4,r4,#1              ;334
00019a  eec01a20          VDIV.F32 s3,s0,s1              ;334
00019e  ece51a01          VSTM     r5!,{s3}              ;334
                  |L1.418|
0001a2  2c00              CMP      r4,#0                 ;329
0001a4  d1f6              BNE      |L1.404|
0001a6  4674              MOV      r4,lr                 ;344
0001a8  4655              MOV      r5,r10                ;345
0001aa  f04f0900          MOV      r9,#0                 ;348
0001ae  4616              MOV      r6,r2                 ;352
0001b0  e02c              B        |L1.524|
                  |L1.434|
0001b2  4599              CMP      r9,r3                 ;357
0001b4  d105              BNE      |L1.450|
0001b6  9f02              LDR      r7,[sp,#8]            ;361
0001b8  eb050581          ADD      r5,r5,r1,LSL #2       ;363
0001bc  eb040487          ADD      r4,r4,r7,LSL #2       ;361
0001c0  e01f              B        |L1.514|
                  |L1.450|
0001c2  e9dd8701          LDRD     r8,r7,[sp,#4]         ;372
0001c6  edd40a00          VLDR     s1,[r4,#0]            ;368
0001ca  f8ddc000          LDR      r12,[sp,#0]           ;378
0001ce  e008              B        |L1.482|
                  |L1.464|
0001d0  ecf81a01          VLDM     r8!,{s3}              ;383
0001d4  ed940a00          VLDR     s0,[r4,#0]            ;382
0001d8  1e7f              SUBS     r7,r7,#1              ;383
0001da  ee000ae1          VMLS.F32 s0,s1,s3              ;383
0001de  eca40a01          VSTM     r4!,{s0}              ;383
                  |L1.482|
0001e2  2f00              CMP      r7,#0                 ;378
0001e4  d1f4              BNE      |L1.464|
0001e6  460f              MOV      r7,r1                 ;391
0001e8  e009              B        |L1.510|
0001ea  bf00              NOP                            ;397
                  |L1.492|
0001ec  ecfc1a01          VLDM     r12!,{s3}             ;398
0001f0  ed950a00          VLDR     s0,[r5,#0]            ;397
0001f4  1e7f              SUBS     r7,r7,#1              ;398
0001f6  ee000ae1          VMLS.F32 s0,s1,s3              ;398
0001fa  eca50a01          VSTM     r5!,{s0}              ;398
                  |L1.510|
0001fe  2f00              CMP      r7,#0                 ;393
000200  d1f4              BNE      |L1.492|
                  |L1.514|
000202  eb040483          ADD      r4,r4,r3,LSL #2       ;407
000206  f1090901          ADD      r9,r9,#1              ;413
00020a  1e76              SUBS     r6,r6,#1              ;413
                  |L1.524|
00020c  2e00              CMP      r6,#0                 ;354
00020e  d1d0              BNE      |L1.434|
000210  f10e0e04          ADD      lr,lr,#4              ;417
000214  f1ab0b01          SUB      r11,r11,#1            ;420
000218  1c5b              ADDS     r3,r3,#1              ;420
                  |L1.538|
00021a  f1bb0f00          CMP      r11,#0                ;196
00021e  f47faf1b          BNE      |L1.88|
000222  9c03              LDR      r4,[sp,#0xc]          ;684
000224  2300              MOVS     r3,#0                 ;682
000226  2c01              CMP      r4,#1                 ;684
000228  d018              BEQ      |L1.604|
00022a  eef50ac0          VCMPE.F32 s1,#0.0               ;684
00022e  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;684
000232  d113              BNE      |L1.604|
000234  6844              LDR      r4,[r0,#4]            ;687
000236  2000              MOVS     r0,#0                 ;687
000238  434a              MULS     r2,r1,r2              ;687
00023a  e009              B        |L1.592|
                  |L1.572|
00023c  eb040180          ADD      r1,r4,r0,LSL #2       ;689
000240  ed910a00          VLDR     s0,[r1,#0]            ;689
000244  eeb50ac0          VCMPE.F32 s0,#0.0               ;689
000248  eef1fa10          VMRS     APSR_nzcv,FPSCR       ;689
00024c  d102              BNE      |L1.596|
00024e  1c40              ADDS     r0,r0,#1              ;689
                  |L1.592|
000250  4282              CMP      r2,r0                 ;687
000252  d8f3              BHI      |L1.572|
                  |L1.596|
000254  4282              CMP      r2,r0                 ;693
000256  d101              BNE      |L1.604|
000258  f06f0304          MVN      r3,#4                 ;694
                  |L1.604|
00025c  4618              MOV      r0,r3                 ;698
00025e  e780              B        |L1.354|
;;;700    
                          ENDP

                  |L1.608|
000260  00000000          DCFS     0x00000000 ; 0

;*** Start embedded assembler ***

#line 1 "src\\MatrixFunctions\\arm_mat_inverse_f32.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___21_arm_mat_inverse_f32_c_ad6caf25____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___21_arm_mat_inverse_f32_c_ad6caf25____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___21_arm_mat_inverse_f32_c_ad6caf25____REVSH|
#line 144
|__asm___21_arm_mat_inverse_f32_c_ad6caf25____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___21_arm_mat_inverse_f32_c_ad6caf25____RRX|
#line 300
|__asm___21_arm_mat_inverse_f32_c_ad6caf25____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
