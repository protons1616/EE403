; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_mat_mult_f32.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_mat_mult_f32.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_mat_mult_f32.crf src\MatrixFunctions\arm_mat_mult_f32.c]
                          THUMB

                          AREA ||i.arm_mat_mult_f32||, CODE, READONLY, ALIGN=2

                  arm_mat_mult_f32 PROC
;;;77     
;;;78     arm_status arm_mat_mult_f32(
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;79       const arm_matrix_instance_f32 * pSrcA,
;;;80       const arm_matrix_instance_f32 * pSrcB,
;;;81       arm_matrix_instance_f32 * pDst)
;;;82     {
000004  468a              MOV      r10,r1
;;;83       float32_t *pIn1 = pSrcA->pData;                /* input data matrix pointer A */
;;;84       float32_t *pIn2 = pSrcB->pData;                /* input data matrix pointer B */
;;;85       float32_t *pInA = pSrcA->pData;                /* input data matrix pointer A  */
;;;86       float32_t *pOut = pDst->pData;                 /* output data matrix pointer */
;;;87       float32_t *px;                                 /* Temporary output data matrix pointer */
;;;88       float32_t sum;                                 /* Accumulator */
;;;89       uint16_t numRowsA = pSrcA->numRows;            /* number of rows of input matrix A */
;;;90       uint16_t numColsB = pSrcB->numCols;            /* number of columns of input matrix B */
000006  f8d2b004          LDR      r11,[r2,#4]
;;;91       uint16_t numColsA = pSrcA->numCols;            /* number of columns of input matrix A */
00000a  f8b08002          LDRH     r8,[r0,#2]
00000e  6843              LDR      r3,[r0,#4]            ;86
000010  f8b0e000          LDRH     lr,[r0,#0]            ;89
000014  f8ba2002          LDRH     r2,[r10,#2]           ;90
;;;92     
;;;93     #ifndef ARM_MATH_CM0_FAMILY
;;;94     
;;;95       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;96     
;;;97       float32_t in1, in2, in3, in4;
;;;98       uint16_t col, i = 0u, j, row = numRowsA, colCnt;      /* loop counters */
;;;99       arm_status status;                             /* status of matrix multiplication */
;;;100    
;;;101    #ifdef ARM_MATH_MATRIX_CHECK
;;;102    
;;;103    
;;;104      /* Check for matrix mismatch condition */
;;;105      if((pSrcA->numCols != pSrcB->numRows) ||
;;;106         (pSrcA->numRows != pDst->numRows) || (pSrcB->numCols != pDst->numCols))
;;;107      {
;;;108    
;;;109        /* Set status as ARM_MATH_SIZE_MISMATCH */
;;;110        status = ARM_MATH_SIZE_MISMATCH;
;;;111      }
;;;112      else
;;;113    #endif /*      #ifdef ARM_MATH_MATRIX_CHECK    */
;;;114    
;;;115      {
;;;116        /* The following loop performs the dot-product of each row in pSrcA with each column in pSrcB */
;;;117        /* row loop */
;;;118        do
;;;119        {
;;;120          /* Output pointer is set to starting address of the row being processed */
;;;121          px = pOut + i;
;;;122    
;;;123          /* For every row wise process, the column loop counter is to be initiated */
;;;124          col = numColsB;
;;;125    
;;;126          /* For every row wise process, the pIn2 pointer is set    
;;;127           ** to the starting address of the pSrcB data */
;;;128          pIn2 = pSrcB->pData;
;;;129    
;;;130          j = 0u;
;;;131    
;;;132          /* column loop */
;;;133          do
;;;134          {
;;;135            /* Set the variable sum, that acts as accumulator, to zero */
;;;136            sum = 0.0f;
000018  eddf0a2f          VLDR     s1,|L1.216|
00001c  f04f0c00          MOV      r12,#0                ;98
;;;137    
;;;138            /* Initiate the pointer pIn1 to point to the starting address of the column being processed */
;;;139            pIn1 = pInA;
;;;140    
;;;141            /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;142            colCnt = numColsA >> 2u;
000020  ea4f0998          LSR      r9,r8,#2
                  |L1.36|
000024  f8da0004          LDR      r0,[r10,#4]           ;130
000028  eb0b078c          ADD      r7,r11,r12,LSL #2     ;121
00002c  4615              MOV      r5,r2                 ;124
00002e  2600              MOVS     r6,#0                 ;130
                  |L1.48|
000030  eeb00a60          VMOV.F32 s0,s1                 ;136
000034  4619              MOV      r1,r3                 ;139
000036  464c              MOV      r4,r9                 ;139
;;;143    
;;;144            /* matrix multiplication        */
;;;145            while(colCnt > 0u)
000038  e023              B        |L1.130|
;;;146            {
;;;147              /* c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n) */
;;;148              in3 = *pIn2;
00003a  bf00              NOP      
                  |L1.60|
00003c  edd01a00          VLDR     s3,[r0,#0]
;;;149              pIn2 += numColsB;
;;;150              in1 = pIn1[0];
000040  ed912a00          VLDR     s4,[r1,#0]
000044  eb000082          ADD      r0,r0,r2,LSL #2       ;149
;;;151              in2 = pIn1[1];
000048  ed911a01          VLDR     s2,[r1,#4]
;;;152              sum += in1 * in3;
00004c  ee020a21          VMLA.F32 s0,s4,s3
;;;153              in4 = *pIn2;
000050  edd01a00          VLDR     s3,[r0,#0]
;;;154              pIn2 += numColsB;
000054  eb000082          ADD      r0,r0,r2,LSL #2
;;;155              sum += in2 * in4;
;;;156    
;;;157              in3 = *pIn2;
;;;158              pIn2 += numColsB;
;;;159              in1 = pIn1[2];
;;;160              in2 = pIn1[3];
000058  ed912a03          VLDR     s4,[r1,#0xc]
;;;161              sum += in1 * in3;
;;;162              in4 = *pIn2;
;;;163              pIn2 += numColsB;
;;;164              sum += in2 * in4;
00005c  1e64              SUBS     r4,r4,#1
;;;165              pIn1 += 4u;
;;;166    
;;;167              /* Decrement the loop count */
;;;168              colCnt--;
00005e  b2a4              UXTH     r4,r4
000060  ee010a21          VMLA.F32 s0,s2,s3              ;155
000064  ed901a00          VLDR     s2,[r0,#0]            ;157
000068  edd11a02          VLDR     s3,[r1,#8]            ;159
00006c  eb000082          ADD      r0,r0,r2,LSL #2       ;158
000070  3110              ADDS     r1,r1,#0x10
000072  ee010a81          VMLA.F32 s0,s3,s2              ;161
000076  ed901a00          VLDR     s2,[r0,#0]            ;162
00007a  eb000082          ADD      r0,r0,r2,LSL #2       ;163
00007e  ee020a01          VMLA.F32 s0,s4,s2              ;164
                  |L1.130|
000082  2c00              CMP      r4,#0                 ;145
000084  d1da              BNE      |L1.60|
;;;169            }
;;;170    
;;;171            /* If the columns of pSrcA is not a multiple of 4, compute any remaining MACs here.    
;;;172             ** No loop unrolling is used. */
;;;173            colCnt = numColsA % 0x4u;
000086  f0080403          AND      r4,r8,#3
;;;174    
;;;175            while(colCnt > 0u)
00008a  e009              B        |L1.160|
                  |L1.140|
;;;176            {
;;;177              /* c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n) */
;;;178              sum += *pIn1++ * (*pIn2);
00008c  ecf11a01          VLDM     r1!,{s3}
000090  ed901a00          VLDR     s2,[r0,#0]
;;;179              pIn2 += numColsB;
000094  1e64              SUBS     r4,r4,#1
000096  eb000082          ADD      r0,r0,r2,LSL #2
;;;180    
;;;181              /* Decrement the loop counter */
;;;182              colCnt--;
00009a  b2a4              UXTH     r4,r4
00009c  ee010a81          VMLA.F32 s0,s3,s2              ;178
                  |L1.160|
0000a0  2c00              CMP      r4,#0                 ;175
0000a2  d1f3              BNE      |L1.140|
;;;183            }
;;;184    
;;;185            /* Store the result in the destination buffer */
;;;186            *px++ = sum;
0000a4  1c76              ADDS     r6,r6,#1
0000a6  eca70a01          VSTM     r7!,{s0}
;;;187    
;;;188            /* Update the pointer pIn2 to point to the  starting address of the next column */
;;;189            j++;
;;;190            pIn2 = pSrcB->pData + j;
0000aa  f8da0004          LDR      r0,[r10,#4]
0000ae  1e6d              SUBS     r5,r5,#1
0000b0  b2b6              UXTH     r6,r6                 ;189
;;;191    
;;;192            /* Decrement the column loop counter */
;;;193            col--;
0000b2  042d              LSLS     r5,r5,#16
0000b4  eb000086          ADD      r0,r0,r6,LSL #2       ;190
0000b8  0c2d              LSRS     r5,r5,#16
;;;194    
;;;195          } while(col > 0u);
0000ba  d1b9              BNE      |L1.48|
;;;196    
;;;197    #else
;;;198    
;;;199      /* Run the below code for Cortex-M0 */
;;;200    
;;;201      float32_t *pInB = pSrcB->pData;                /* input data matrix pointer B */
;;;202      uint16_t col, i = 0u, row = numRowsA, colCnt;  /* loop counters */
;;;203      arm_status status;                             /* status of matrix multiplication */
;;;204    
;;;205    #ifdef ARM_MATH_MATRIX_CHECK
;;;206    
;;;207      /* Check for matrix mismatch condition */
;;;208      if((pSrcA->numCols != pSrcB->numRows) ||
;;;209         (pSrcA->numRows != pDst->numRows) || (pSrcB->numCols != pDst->numCols))
;;;210      {
;;;211    
;;;212        /* Set status as ARM_MATH_SIZE_MISMATCH */
;;;213        status = ARM_MATH_SIZE_MISMATCH;
;;;214      }
;;;215      else
;;;216    #endif /*      #ifdef ARM_MATH_MATRIX_CHECK    */
;;;217    
;;;218      {
;;;219        /* The following loop performs the dot-product of each row in pInA with each column in pInB */
;;;220        /* row loop */
;;;221        do
;;;222        {
;;;223          /* Output pointer is set to starting address of the row being processed */
;;;224          px = pOut + i;
;;;225    
;;;226          /* For every row wise process, the column loop counter is to be initiated */
;;;227          col = numColsB;
;;;228    
;;;229          /* For every row wise process, the pIn2 pointer is set     
;;;230           ** to the starting address of the pSrcB data */
;;;231          pIn2 = pSrcB->pData;
;;;232    
;;;233          /* column loop */
;;;234          do
;;;235          {
;;;236            /* Set the variable sum, that acts as accumulator, to zero */
;;;237            sum = 0.0f;
;;;238    
;;;239            /* Initialize the pointer pIn1 to point to the starting address of the row being processed */
;;;240            pIn1 = pInA;
;;;241    
;;;242            /* Matrix A columns number of MAC operations are to be performed */
;;;243            colCnt = numColsA;
;;;244    
;;;245            while(colCnt > 0u)
;;;246            {
;;;247              /* c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n) */
;;;248              sum += *pIn1++ * (*pIn2);
;;;249              pIn2 += numColsB;
;;;250    
;;;251              /* Decrement the loop counter */
;;;252              colCnt--;
;;;253            }
;;;254    
;;;255            /* Store the result in the destination buffer */
;;;256            *px++ = sum;
;;;257    
;;;258            /* Decrement the column loop counter */
;;;259            col--;
;;;260    
;;;261            /* Update the pointer pIn2 to point to the  starting address of the next column */
;;;262            pIn2 = pInB + (numColsB - col);
;;;263    
;;;264          } while(col > 0u);
;;;265    
;;;266    #endif /* #ifndef ARM_MATH_CM0_FAMILY */
;;;267    
;;;268          /* Update the pointer pInA to point to the  starting address of the next row */
;;;269          i = i + numColsB;
0000bc  eb0c0002          ADD      r0,r12,r2
0000c0  fa1ffc80          UXTH     r12,r0
;;;270          pInA = pInA + numColsA;
;;;271    
;;;272          /* Decrement the row loop counter */
;;;273          row--;
0000c4  f1ae0001          SUB      r0,lr,#1
0000c8  0400              LSLS     r0,r0,#16
0000ca  0c00              LSRS     r0,r0,#16
0000cc  eb030388          ADD      r3,r3,r8,LSL #2       ;270
0000d0  4686              MOV      lr,r0
;;;274    
;;;275        } while(row > 0u);
0000d2  d1a7              BNE      |L1.36|
;;;276        /* Set status as ARM_MATH_SUCCESS */
;;;277        status = ARM_MATH_SUCCESS;
;;;278      }
;;;279    
;;;280      /* Return to application */
;;;281      return (status);
;;;282    }
0000d4  e8bd8ff0          POP      {r4-r11,pc}
;;;283    
                          ENDP

                  |L1.216|
0000d8  00000000          DCFS     0x00000000 ; 0

;*** Start embedded assembler ***

#line 1 "src\\MatrixFunctions\\arm_mat_mult_f32.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_mat_mult_f32_c_d029f10d____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___18_arm_mat_mult_f32_c_d029f10d____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_mat_mult_f32_c_d029f10d____REVSH|
#line 144
|__asm___18_arm_mat_mult_f32_c_d029f10d____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_mat_mult_f32_c_d029f10d____RRX|
#line 300
|__asm___18_arm_mat_mult_f32_c_d029f10d____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
