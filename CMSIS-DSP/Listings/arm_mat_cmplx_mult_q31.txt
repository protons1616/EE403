; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_mat_cmplx_mult_q31.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_mat_cmplx_mult_q31.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_mat_cmplx_mult_q31.crf src\MatrixFunctions\arm_mat_cmplx_mult_q31.c]
                          THUMB

                          AREA ||i.arm_mat_cmplx_mult_q31||, CODE, READONLY, ALIGN=2

                  arm_mat_cmplx_mult_q31 PROC
;;;74     
;;;75     arm_status arm_mat_cmplx_mult_q31(
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;76       const arm_matrix_instance_q31 * pSrcA,
;;;77       const arm_matrix_instance_q31 * pSrcB,
;;;78       arm_matrix_instance_q31 * pDst)
;;;79     {
000004  b08a              SUB      sp,sp,#0x28
;;;80       q31_t *pIn1 = pSrcA->pData;                    /* input data matrix pointer A */
;;;81       q31_t *pIn2 = pSrcB->pData;                    /* input data matrix pointer B */
;;;82       q31_t *pInA = pSrcA->pData;                    /* input data matrix pointer A  */
000006  6841              LDR      r1,[r0,#4]
;;;83       q31_t *pOut = pDst->pData;                     /* output data matrix pointer */
000008  9101              STR      r1,[sp,#4]
00000a  6851              LDR      r1,[r2,#4]
;;;84       q31_t *px;                                     /* Temporary output data matrix pointer */
;;;85       uint16_t numRowsA = pSrcA->numRows;            /* number of rows of input matrix A */
00000c  9107              STR      r1,[sp,#0x1c]
;;;86       uint16_t numColsB = pSrcB->numCols;            /* number of columns of input matrix B */
00000e  9a0b              LDR      r2,[sp,#0x2c]
000010  8801              LDRH     r1,[r0,#0]            ;85
;;;87       uint16_t numColsA = pSrcA->numCols;            /* number of columns of input matrix A */
000012  8840              LDRH     r0,[r0,#2]
000014  8856              LDRH     r6,[r2,#2]            ;86
;;;88       q63_t sumReal1, sumImag1;                      /* accumulator */
;;;89       q31_t a0, b0, c0, d0;
;;;90       q31_t a1, b1, c1, d1;
;;;91     
;;;92     
;;;93       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;94     
;;;95       uint16_t col, i = 0u, j, row = numRowsA, colCnt;      /* loop counters */
000016  9004              STR      r0,[sp,#0x10]
000018  2000              MOVS     r0,#0
00001a  9000              STR      r0,[sp,#0]            ;87
;;;96       arm_status status;                             /* status of matrix multiplication */
;;;97     
;;;98     #ifdef ARM_MATH_MATRIX_CHECK
;;;99     
;;;100    
;;;101      /* Check for matrix mismatch condition */
;;;102      if((pSrcA->numCols != pSrcB->numRows) ||
;;;103         (pSrcA->numRows != pDst->numRows) || (pSrcB->numCols != pDst->numCols))
;;;104      {
;;;105    
;;;106        /* Set status as ARM_MATH_SIZE_MISMATCH */
;;;107        status = ARM_MATH_SIZE_MISMATCH;
;;;108      }
;;;109      else
;;;110    #endif /*      #ifdef ARM_MATH_MATRIX_CHECK    */
;;;111    
;;;112      {
;;;113        /* The following loop performs the dot-product of each row in pSrcA with each column in pSrcB */
;;;114        /* row loop */
;;;115        do
;;;116        {
;;;117          /* Output pointer is set to starting address of the row being processed */
;;;118          px = pOut + 2 * i;
;;;119    
;;;120          /* For every row wise process, the column loop counter is to be initiated */
;;;121          col = numColsB;
;;;122    
;;;123          /* For every row wise process, the pIn2 pointer is set     
;;;124           ** to the starting address of the pSrcB data */
;;;125          pIn2 = pSrcB->pData;
;;;126    
;;;127          j = 0u;
;;;128    
;;;129          /* column loop */
;;;130          do
;;;131          {
;;;132            /* Set the variable sum, that acts as accumulator, to zero */
;;;133            sumReal1 = 0.0;
;;;134            sumImag1 = 0.0;
;;;135    
;;;136            /* Initiate the pointer pIn1 to point to the starting address of the column being processed */
;;;137            pIn1 = pInA;
;;;138    
;;;139            /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;140            colCnt = numColsA >> 2;
00001c  9804              LDR      r0,[sp,#0x10]
00001e  9103              STR      r1,[sp,#0xc]          ;87
000020  0880              LSRS     r0,r0,#2
000022  9006              STR      r0,[sp,#0x18]
                  |L1.36|
000024  9900              LDR      r1,[sp,#0]            ;118
000026  9807              LDR      r0,[sp,#0x1c]         ;118
000028  9602              STR      r6,[sp,#8]            ;125
00002a  eb0000c1          ADD      r0,r0,r1,LSL #3       ;118
00002e  9005              STR      r0,[sp,#0x14]         ;125
000030  980b              LDR      r0,[sp,#0x2c]         ;125
000032  6843              LDR      r3,[r0,#4]            ;127
000034  2000              MOVS     r0,#0                 ;127
000036  9008              STR      r0,[sp,#0x20]         ;127
                  |L1.56|
000038  2200              MOVS     r2,#0                 ;127
00003a  4611              MOV      r1,r2                 ;127
00003c  4614              MOV      r4,r2                 ;127
00003e  4615              MOV      r5,r2                 ;127
;;;141    
;;;142            /* matrix multiplication        */
;;;143            while(colCnt > 0u)
000040  9f06              LDR      r7,[sp,#0x18]
000042  9801              LDR      r0,[sp,#4]
000044  e05e              B        |L1.260|
;;;144            {
;;;145    
;;;146              /* Reading real part of complex matrix A */
;;;147              a0 = *pIn1;
000046  bf00              NOP      
                  |L1.72|
000048  f850bb04          LDR      r11,[r0],#4
;;;148    
;;;149              /* Reading real part of complex matrix B */
;;;150              c0 = *pIn2;
;;;151    
;;;152              /* Reading imaginary part of complex matrix A */
;;;153              b0 = *(pIn1 + 1u);
00004c  f8d38000          LDR      r8,[r3,#0]
000050  f850ab04          LDR      r10,[r0],#4
;;;154    
;;;155              /* Reading imaginary part of complex matrix B */
;;;156              d0 = *(pIn2 + 1u);
;;;157    
;;;158              /* Multiply and Accumlates */
;;;159              sumReal1 += (q63_t) a0 *c0;
;;;160              sumImag1 += (q63_t) b0 *c0;
;;;161    
;;;162              /* update pointers */
;;;163              pIn1 += 2u;
;;;164              pIn2 += 2 * numColsB;
000054  f8d39004          LDR      r9,[r3,#4]
000058  fbca4508          SMLAL    r4,r5,r10,r8          ;160
00005c  fbcb2108          SMLAL    r2,r1,r11,r8          ;159
;;;165    
;;;166              /* Multiply and Accumlates */
;;;167              sumReal1 -= (q63_t) b0 *d0;
000060  fb8a8c09          SMULL    r8,r12,r10,r9
;;;168              sumImag1 += (q63_t) a0 *d0;
000064  fbcb4509          SMLAL    r4,r5,r11,r9
000068  ebb20208          SUBS     r2,r2,r8              ;167
00006c  eb0303c6          ADD      r3,r3,r6,LSL #3       ;164
000070  eb61010c          SBC      r1,r1,r12             ;167
;;;169    
;;;170              /* c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n) */
;;;171    
;;;172              /* read real and imag values from pSrcA and pSrcB buffer */
;;;173              a1 = *pIn1;
000074  f8509b04          LDR      r9,[r0],#4
;;;174              c1 = *pIn2;
;;;175              b1 = *(pIn1 + 1u);
000078  f8d3c000          LDR      r12,[r3,#0]
00007c  f8508b04          LDR      r8,[r0],#4
;;;176              d1 = *(pIn2 + 1u);
;;;177    
;;;178              /* Multiply and Accumlates */
;;;179              sumReal1 += (q63_t) a1 *c1;
000080  fbc9210c          SMLAL    r2,r1,r9,r12
;;;180              sumImag1 += (q63_t) b1 *c1;
000084  fbc8450c          SMLAL    r4,r5,r8,r12
;;;181    
;;;182              /* update pointers */
;;;183              pIn1 += 2u;
;;;184              pIn2 += 2 * numColsB;
000088  f8d3a004          LDR      r10,[r3,#4]
00008c  46a4              MOV      r12,r4                ;180
00008e  46ab              MOV      r11,r5                ;180
;;;185    
;;;186              /* Multiply and Accumlates */
;;;187              sumReal1 -= (q63_t) b1 *d1;
000090  fb88540a          SMULL    r5,r4,r8,r10
000094  1b52              SUBS     r2,r2,r5
000096  eb610104          SBC      r1,r1,r4
;;;188              sumImag1 += (q63_t) a1 *d1;
00009a  4664              MOV      r4,r12
00009c  eb0303c6          ADD      r3,r3,r6,LSL #3       ;184
0000a0  465d              MOV      r5,r11
0000a2  fbc9450a          SMLAL    r4,r5,r9,r10
;;;189    
;;;190              a0 = *pIn1;
0000a6  f8508b04          LDR      r8,[r0],#4
;;;191              c0 = *pIn2;
;;;192    
;;;193              b0 = *(pIn1 + 1u);
0000aa  f8d3c000          LDR      r12,[r3,#0]
0000ae  f8509b04          LDR      r9,[r0],#4
;;;194              d0 = *(pIn2 + 1u);
;;;195    
;;;196              /* Multiply and Accumlates */
;;;197              sumReal1 += (q63_t) a0 *c0;
0000b2  fbc8210c          SMLAL    r2,r1,r8,r12
;;;198              sumImag1 += (q63_t) b0 *c0;
0000b6  fbc9450c          SMLAL    r4,r5,r9,r12
;;;199    
;;;200              /* update pointers */
;;;201              pIn1 += 2u;
;;;202              pIn2 += 2 * numColsB;
0000ba  f8d3a004          LDR      r10,[r3,#4]
0000be  46a3              MOV      r11,r4                ;198
;;;203    
;;;204              /* Multiply and Accumlates */
;;;205              sumReal1 -= (q63_t) b0 *d0;
0000c0  fb89c40a          SMULL    r12,r4,r9,r10
0000c4  ebb2090c          SUBS     r9,r2,r12
0000c8  eb610104          SBC      r1,r1,r4
;;;206              sumImag1 += (q63_t) a0 *d0;
0000cc  465c              MOV      r4,r11
0000ce  fbc8450a          SMLAL    r4,r5,r8,r10
0000d2  eb0303c6          ADD      r3,r3,r6,LSL #3       ;202
;;;207    
;;;208              /* c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n) */
;;;209    
;;;210              a1 = *pIn1;
0000d6  f8508b04          LDR      r8,[r0],#4
;;;211              c1 = *pIn2;
;;;212    
;;;213              b1 = *(pIn1 + 1u);
;;;214              d1 = *(pIn2 + 1u);
;;;215    
;;;216              /* Multiply and Accumlates */
;;;217              sumReal1 += (q63_t) a1 *c1;
0000da  e9d3ca00          LDRD     r12,r10,[r3,#0]
0000de  c804              LDM      r0!,{r2}              ;213
0000e0  fbc8910c          SMLAL    r9,r1,r8,r12
;;;218              sumImag1 += (q63_t) b1 *c1;
0000e4  fbc2450c          SMLAL    r4,r5,r2,r12
0000e8  46a4              MOV      r12,r4
;;;219    
;;;220              /* update pointers */
;;;221              pIn1 += 2u;
;;;222              pIn2 += 2 * numColsB;
;;;223    
;;;224              /* Multiply and Accumlates */
;;;225              sumReal1 -= (q63_t) b1 *d1;
0000ea  fb82240a          SMULL    r2,r4,r2,r10
0000ee  ebb90202          SUBS     r2,r9,r2
0000f2  eb610104          SBC      r1,r1,r4
;;;226              sumImag1 += (q63_t) a1 *d1;
0000f6  4664              MOV      r4,r12
0000f8  fbc8450a          SMLAL    r4,r5,r8,r10
0000fc  1e7f              SUBS     r7,r7,#1
0000fe  eb0303c6          ADD      r3,r3,r6,LSL #3       ;222
;;;227    
;;;228              /* Decrement the loop count */
;;;229              colCnt--;
000102  b2bf              UXTH     r7,r7
                  |L1.260|
000104  2f00              CMP      r7,#0                 ;143
000106  d19f              BNE      |L1.72|
;;;230            }
;;;231    
;;;232            /* If the columns of pSrcA is not a multiple of 4, compute any remaining MACs here.     
;;;233             ** No loop unrolling is used. */
;;;234            colCnt = numColsA % 0x4u;
000108  9f04              LDR      r7,[sp,#0x10]
00010a  f0070703          AND      r7,r7,#3
;;;235    
;;;236            while(colCnt > 0u)
00010e  e017              B        |L1.320|
                  |L1.272|
;;;237            {
;;;238              /* c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n) */
;;;239              a1 = *pIn1;
000110  f850bb04          LDR      r11,[r0],#4
;;;240              c1 = *pIn2;
;;;241    
;;;242              b1 = *(pIn1 + 1u);
000114  f8d38000          LDR      r8,[r3,#0]
000118  f850ab04          LDR      r10,[r0],#4
;;;243              d1 = *(pIn2 + 1u);
;;;244    
;;;245              /* Multiply and Accumlates */
;;;246              sumReal1 += (q63_t) a1 *c1;
;;;247              sumImag1 += (q63_t) b1 *c1;
;;;248    
;;;249              /* update pointers */
;;;250              pIn1 += 2u;
;;;251              pIn2 += 2 * numColsB;
00011c  f8d39004          LDR      r9,[r3,#4]
000120  fbca4508          SMLAL    r4,r5,r10,r8          ;247
000124  fbcb2108          SMLAL    r2,r1,r11,r8          ;246
;;;252    
;;;253              /* Multiply and Accumlates */
;;;254              sumReal1 -= (q63_t) b1 *d1;
000128  fb8a8c09          SMULL    r8,r12,r10,r9
;;;255              sumImag1 += (q63_t) a1 *d1;
00012c  fbcb4509          SMLAL    r4,r5,r11,r9
000130  ebb20208          SUBS     r2,r2,r8              ;254
000134  eb61010c          SBC      r1,r1,r12             ;254
000138  1e7f              SUBS     r7,r7,#1
00013a  eb0303c6          ADD      r3,r3,r6,LSL #3       ;251
;;;256    
;;;257              /* Decrement the loop counter */
;;;258              colCnt--;
00013e  b2bf              UXTH     r7,r7
                  |L1.320|
000140  2f00              CMP      r7,#0                 ;236
000142  d1e5              BNE      |L1.272|
;;;259            }
;;;260    
;;;261            /* Store the result in the destination buffer */
;;;262            *px++ = (q31_t) clip_q63_to_q31(sumReal1 >> 31);
000144  0fd0              LSRS     r0,r2,#31
000146  ea400041          ORR      r0,r0,r1,LSL #1
00014a  17c9              ASRS     r1,r1,#31
00014c  f7fffffe          BL       clip_q63_to_q31
000150  9905              LDR      r1,[sp,#0x14]
000152  6008              STR      r0,[r1,#0]
;;;263            *px++ = (q31_t) clip_q63_to_q31(sumImag1 >> 31);
000154  0fe0              LSRS     r0,r4,#31
000156  ea400045          ORR      r0,r0,r5,LSL #1
00015a  17e9              ASRS     r1,r5,#31
00015c  9f05              LDR      r7,[sp,#0x14]
00015e  f7fffffe          BL       clip_q63_to_q31
000162  6078              STR      r0,[r7,#4]
;;;264            
;;;265            /* Update the pointer pIn2 to point to the  starting address of the next column */
;;;266            j++;
000164  9808              LDR      r0,[sp,#0x20]
000166  3708              ADDS     r7,r7,#8              ;263
000168  1c40              ADDS     r0,r0,#1
00016a  b280              UXTH     r0,r0
;;;267            pIn2 = pSrcB->pData + 2u * j;
00016c  9008              STR      r0,[sp,#0x20]
00016e  980b              LDR      r0,[sp,#0x2c]
000170  9705              STR      r7,[sp,#0x14]         ;266
000172  6841              LDR      r1,[r0,#4]
000174  9808              LDR      r0,[sp,#0x20]
000176  eb0103c0          ADD      r3,r1,r0,LSL #3
;;;268    
;;;269            /* Decrement the column loop counter */
;;;270            col--;
00017a  9802              LDR      r0,[sp,#8]
00017c  1e40              SUBS     r0,r0,#1
00017e  0400              LSLS     r0,r0,#16
000180  0c00              LSRS     r0,r0,#16
;;;271    
;;;272          } while(col > 0u);
000182  9002              STR      r0,[sp,#8]
000184  f47faf58          BNE      |L1.56|
;;;273    
;;;274          /* Update the pointer pInA to point to the  starting address of the next row */
;;;275          i = i + numColsB;
000188  9800              LDR      r0,[sp,#0]
;;;276          pInA = pInA + 2 * numColsA;
00018a  9904              LDR      r1,[sp,#0x10]
00018c  4430              ADD      r0,r0,r6              ;275
00018e  b280              UXTH     r0,r0                 ;275
000190  9000              STR      r0,[sp,#0]
000192  9801              LDR      r0,[sp,#4]
000194  eb0000c1          ADD      r0,r0,r1,LSL #3
;;;277    
;;;278          /* Decrement the row loop counter */
;;;279          row--;
000198  9001              STR      r0,[sp,#4]
00019a  9803              LDR      r0,[sp,#0xc]
00019c  1e40              SUBS     r0,r0,#1
00019e  0400              LSLS     r0,r0,#16
0001a0  0c00              LSRS     r0,r0,#16
;;;280    
;;;281        } while(row > 0u);
0001a2  9003              STR      r0,[sp,#0xc]
0001a4  f47faf3e          BNE      |L1.36|
;;;282    
;;;283        /* Set status as ARM_MATH_SUCCESS */
;;;284        status = ARM_MATH_SUCCESS;
;;;285      }
;;;286    
;;;287      /* Return to application */
;;;288      return (status);
;;;289    }
0001a8  b00d              ADD      sp,sp,#0x34
0001aa  e8bd8ff0          POP      {r4-r11,pc}
;;;290    
                          ENDP


                          AREA ||i.clip_q63_to_q31||, CODE, READONLY, ALIGN=1

                  clip_q63_to_q31 PROC
;;;458       */
;;;459      static __INLINE q31_t clip_q63_to_q31(
000000  17ca              ASRS     r2,r1,#31
;;;460      q63_t x)
;;;461      {
;;;462        return ((q31_t) (x >> 32) != ((q31_t) x >> 31)) ?
000002  ebb17fe0          CMP      r1,r0,ASR #31
000006  d002              BEQ      |L2.14|
;;;463          ((0x7FFFFFFF ^ ((q31_t) (x >> 63)))) : (q31_t) x;
000008  f06f4000          MVN      r0,#0x80000000
00000c  4050              EORS     r0,r0,r2
                  |L2.14|
;;;464      }
00000e  4770              BX       lr
;;;465    
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\MatrixFunctions\\arm_mat_cmplx_mult_q31.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___24_arm_mat_cmplx_mult_q31_c_ee9c8e44____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___24_arm_mat_cmplx_mult_q31_c_ee9c8e44____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___24_arm_mat_cmplx_mult_q31_c_ee9c8e44____REVSH|
#line 144
|__asm___24_arm_mat_cmplx_mult_q31_c_ee9c8e44____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___24_arm_mat_cmplx_mult_q31_c_ee9c8e44____RRX|
#line 300
|__asm___24_arm_mat_cmplx_mult_q31_c_ee9c8e44____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
