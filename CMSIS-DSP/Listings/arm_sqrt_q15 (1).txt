; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_sqrt_q15.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_sqrt_q15.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"Z:\GoogleDrive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_sqrt_q15.crf src\FastMathFunctions\arm_sqrt_q15.c]
                          THUMB

                          AREA ||i.arm_sqrt_q15||, CODE, READONLY, ALIGN=2

                  arm_sqrt_q15 PROC
;;;61     
;;;62     arm_status arm_sqrt_q15(
000000  b530              PUSH     {r4,r5,lr}
;;;63       q15_t in,
;;;64       q15_t * pOut)
;;;65     {
;;;66       q15_t number, temp1, var1, signBits1, half;
;;;67       q31_t bits_val1;
;;;68       float32_t temp_float1;
;;;69       union
;;;70       {
;;;71         q31_t fracval;
;;;72         float32_t floatval;
;;;73       } tempconv;
;;;74     
;;;75       number = in;
;;;76     
;;;77       /* If the input is a positive number then compute the signBits. */
;;;78       if(number > 0)
000002  2800              CMP      r0,#0
000004  dd57              BLE      |L1.182|
;;;79       {
;;;80         signBits1 = __CLZ(number) - 17;
000006  fab0f380          CLZ      r3,r0
00000a  f1a30211          SUB      r2,r3,#0x11
;;;81     
;;;82         /* Shift by the number of signBits1 */
;;;83         if((signBits1 % 2) == 0)
;;;84         {
;;;85           number = number << signBits1;
;;;86         }
;;;87         else
;;;88         {
;;;89           number = number << (signBits1 - 1);
;;;90         }
;;;91     
;;;92         /* Calculate half value of the number */
;;;93         half = number >> 1;
;;;94         /* Store the number for later use */
;;;95         temp1 = number;
;;;96     
;;;97         /* Convert to float */
;;;98         temp_float1 = number * 3.051757812500000e-005f;
;;;99         /*Store as integer */
;;;100        tempconv.floatval = temp_float1;
;;;101        bits_val1 = tempconv.fracval;
;;;102        /* Subtract the shifted value from the magic number to give intial guess */
;;;103        bits_val1 = 0x5f3759df - (bits_val1 >> 1);  /* gives initial guess */
;;;104        /* Store as float */
;;;105        tempconv.fracval = bits_val1;
;;;106        temp_float1 = tempconv.floatval;
;;;107        /* Convert to integer format */
;;;108        var1 = (q31_t) (temp_float1 * 16384);
;;;109    
;;;110        /* 1st iteration */
;;;111        var1 = ((q15_t) ((q31_t) var1 * (0x3000 -
;;;112                                         ((q15_t)
;;;113                                          ((((q15_t)
;;;114                                             (((q31_t) var1 * var1) >> 15)) *
;;;115                                            (q31_t) half) >> 15))) >> 15)) << 2;
;;;116        /* 2nd iteration */
;;;117        var1 = ((q15_t) ((q31_t) var1 * (0x3000 -
;;;118                                         ((q15_t)
;;;119                                          ((((q15_t)
;;;120                                             (((q31_t) var1 * var1) >> 15)) *
;;;121                                            (q31_t) half) >> 15))) >> 15)) << 2;
;;;122        /* 3rd iteration */
;;;123        var1 = ((q15_t) ((q31_t) var1 * (0x3000 -
;;;124                                         ((q15_t)
;;;125                                          ((((q15_t)
;;;126                                             (((q31_t) var1 * var1) >> 15)) *
;;;127                                            (q31_t) half) >> 15))) >> 15)) << 2;
;;;128    
;;;129        /* Multiply the inverse square root with the original value */
;;;130        var1 = ((q15_t) (((q31_t) temp1 * var1) >> 15)) << 1;
;;;131    
;;;132        /* Shift the output down accordingly */
;;;133        if((signBits1 % 2) == 0)
;;;134        {
;;;135          var1 = var1 >> (signBits1 / 2);
;;;136        }
;;;137        else
;;;138        {
;;;139          var1 = var1 >> ((signBits1 - 1) / 2);
;;;140        }
;;;141        *pOut = var1;
;;;142    
;;;143        return (ARM_MATH_SUCCESS);
;;;144      }
;;;145      /* If the number is a negative number then store zero as its square root value */
;;;146      else
;;;147      {
;;;148        *pOut = 0;
;;;149        return (ARM_MATH_ARGUMENT_ERROR);
;;;150      }
;;;151    }
00000e  07db              LSLS     r3,r3,#31
000010  f1b34f00          CMP      r3,#0x80000000
000014  d04d              BEQ      |L1.178|
000016  1e53              SUBS     r3,r2,#1              ;89
000018  4098              LSLS     r0,r0,r3              ;89
                  |L1.26|
00001a  b200              SXTH     r0,r0                 ;89
00001c  ee000a10          VMOV     s0,r0                 ;98
000020  eddf0a27          VLDR     s1,|L1.192|
000024  4d27              LDR      r5,|L1.196|
000026  eeb80ac0          VCVT.F32.S32 s0,s0                 ;98
00002a  1044              ASRS     r4,r0,#1              ;93
00002c  ee200a20          VMUL.F32 s0,s0,s1              ;98
000030  eddf0a25          VLDR     s1,|L1.200|
000034  ee103a10          VMOV     r3,s0                 ;101
000038  eba50363          SUB      r3,r5,r3,ASR #1       ;103
00003c  ee003a10          VMOV     s0,r3                 ;105
000040  ee200a20          VMUL.F32 s0,s0,s1              ;108
000044  eebd0ac0          VCVT.S32.F32 s0,s0                 ;108
000048  ee103a10          VMOV     r3,s0                 ;108
00004c  b21b              SXTH     r3,r3                 ;108
00004e  fb13f503          SMULBB   r5,r3,r3              ;111
000052  13ed              ASRS     r5,r5,#15             ;111
000054  fb15f504          SMULBB   r5,r5,r4              ;111
000058  13ed              ASRS     r5,r5,#15             ;111
00005a  f5c55540          RSB      r5,r5,#0x3000         ;111
00005e  435d              MULS     r5,r3,r5              ;111
000060  13eb              ASRS     r3,r5,#15             ;111
000062  009b              LSLS     r3,r3,#2              ;111
000064  b21b              SXTH     r3,r3                 ;111
000066  fb13f503          SMULBB   r5,r3,r3              ;117
00006a  13ed              ASRS     r5,r5,#15             ;117
00006c  fb15f504          SMULBB   r5,r5,r4              ;117
000070  13ed              ASRS     r5,r5,#15             ;117
000072  f5c55540          RSB      r5,r5,#0x3000         ;117
000076  435d              MULS     r5,r3,r5              ;117
000078  13eb              ASRS     r3,r5,#15             ;117
00007a  009b              LSLS     r3,r3,#2              ;117
00007c  b21b              SXTH     r3,r3                 ;117
00007e  fb13f503          SMULBB   r5,r3,r3              ;123
000082  13ed              ASRS     r5,r5,#15             ;123
000084  fb15f404          SMULBB   r4,r5,r4              ;123
000088  13e4              ASRS     r4,r4,#15             ;123
00008a  f5c45440          RSB      r4,r4,#0x3000         ;123
00008e  435c              MULS     r4,r3,r4              ;123
000090  13e3              ASRS     r3,r4,#15             ;123
000092  009b              LSLS     r3,r3,#2              ;123
000094  fb10f003          SMULBB   r0,r0,r3              ;130
000098  13c0              ASRS     r0,r0,#15             ;130
00009a  0040              LSLS     r0,r0,#1              ;130
00009c  b200              SXTH     r0,r0                 ;130
00009e  07d3              LSLS     r3,r2,#31             ;133
0000a0  d000              BEQ      |L1.164|
0000a2  1e52              SUBS     r2,r2,#1              ;133
                  |L1.164|
0000a4  eb0272d2          ADD      r2,r2,r2,LSR #31      ;135
0000a8  1052              ASRS     r2,r2,#1              ;135
0000aa  4110              ASRS     r0,r0,r2              ;135
0000ac  8008              STRH     r0,[r1,#0]            ;141
0000ae  2000              MOVS     r0,#0                 ;143
0000b0  bd30              POP      {r4,r5,pc}
                  |L1.178|
0000b2  4090              LSLS     r0,r0,r2              ;85
0000b4  e7b1              B        |L1.26|
                  |L1.182|
0000b6  2000              MOVS     r0,#0                 ;148
0000b8  8008              STRH     r0,[r1,#0]            ;148
0000ba  1e40              SUBS     r0,r0,#1              ;149
0000bc  bd30              POP      {r4,r5,pc}
;;;152    
                          ENDP

0000be  0000              DCW      0x0000
                  |L1.192|
0000c0  38000000          DCFS     0x38000000 ; 3.0517578125e-05
                  |L1.196|
                          DCD      0x5f3759df
                  |L1.200|
0000c8  46800000          DCFS     0x46800000 ; 16384

;*** Start embedded assembler ***

#line 1 "src\\FastMathFunctions\\arm_sqrt_q15.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_arm_sqrt_q15_c_93557576____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___14_arm_sqrt_q15_c_93557576____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_arm_sqrt_q15_c_93557576____REVSH|
#line 144
|__asm___14_arm_sqrt_q15_c_93557576____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___14_arm_sqrt_q15_c_93557576____RRX|
#line 300
|__asm___14_arm_sqrt_q15_c_93557576____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
