; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_fir_decimate_f32.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_fir_decimate_f32.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_fir_decimate_f32.crf src\FilteringFunctions\arm_fir_decimate_f32.c]
                          THUMB

                          AREA ||i.arm_fir_decimate_f32||, CODE, READONLY, ALIGN=2

                  arm_fir_decimate_f32 PROC
;;;140    
;;;141    void arm_fir_decimate_f32(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;142      const arm_fir_decimate_instance_f32 * S,
;;;143      float32_t * pSrc,
;;;144      float32_t * pDst,
;;;145      uint32_t blockSize)
;;;146    {
;;;147      float32_t *pState = S->pState;                 /* State pointer */
;;;148      float32_t *pCoeffs = S->pCoeffs;               /* Coefficient pointer */
;;;149      float32_t *pStateCurnt;                        /* Points to the current sample of the state */
;;;150      float32_t *px, *pb;                            /* Temporary pointers for state and coefficient buffers */
;;;151      float32_t sum0;                                /* Accumulator */
;;;152      float32_t x0, c0;                              /* Temporary variables to hold state and coefficient values */
;;;153      uint32_t numTaps = S->numTaps;                 /* Number of filter coefficients in the filter */
;;;154      uint32_t i, tapCnt, blkCnt, outBlockSize = blockSize / S->M;  /* Loop counters */
000004  7804              LDRB     r4,[r0,#0]
000006  e9d0e201          LDRD     lr,r2,[r0,#4]         ;146
00000a  fbb3f3f4          UDIV     r3,r3,r4
00000e  f8b09002          LDRH     r9,[r0,#2]            ;153
;;;155    
;;;156    #ifndef ARM_MATH_CM0_FAMILY
;;;157    
;;;158      uint32_t blkCntN4;
;;;159      float32_t *px0, *px1, *px2, *px3;
;;;160      float32_t acc0, acc1, acc2, acc3;
;;;161      float32_t x1, x2, x3;
;;;162    
;;;163      /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;164    
;;;165      /* S->pState buffer contains previous frame (numTaps - 1) samples */
;;;166      /* pStateCurnt points to the location where the new input data should be written */
;;;167      pStateCurnt = S->pState + (numTaps - 1u);
000012  f06f0503          MVN      r5,#3
000016  eb050489          ADD      r4,r5,r9,LSL #2
00001a  eb020c04          ADD      r12,r2,r4
;;;168    
;;;169      /* Total number of output samples to be computed */
;;;170      blkCnt = outBlockSize / 4;
00001e  ea4f0a93          LSR      r10,r3,#2
;;;171      blkCntN4 = outBlockSize - (4 * blkCnt);
000022  f1ca0400          RSB      r4,r10,#0
000026  b081              SUB      sp,sp,#4              ;146
000028  eb030b84          ADD      r11,r3,r4,LSL #2
;;;172    
;;;173      while(blkCnt > 0u)
;;;174      {
;;;175        /* Copy 4 * decimation factor number of new input samples into the state buffer */
;;;176        i = 4 * S->M;
;;;177    
;;;178        do
;;;179        {
;;;180          *pStateCurnt++ = *pSrc++;
;;;181    
;;;182        } while(--i);
;;;183    
;;;184        /* Set accumulators to zero */
;;;185        acc0 = 0.0f;
00002c  eddf2a89          VLDR     s5,|L1.596|
000030  e09e              B        |L1.368|
                  |L1.50|
000032  7803              LDRB     r3,[r0,#0]            ;176
000034  ea5f0383          LSLS.W   r3,r3,#2              ;176
                  |L1.56|
000038  ecb10a01          VLDM     r1!,{s0}              ;180
00003c  1e5b              SUBS     r3,r3,#1              ;180
00003e  ecac0a01          VSTM     r12!,{s0}             ;180
000042  d1f9              BNE      |L1.56|
;;;186        acc1 = 0.0f;
;;;187        acc2 = 0.0f;
;;;188        acc3 = 0.0f;
;;;189    
;;;190        /* Initialize state pointer for all the samples */
;;;191        px0 = pState;
;;;192        px1 = pState + S->M;
000044  7804              LDRB     r4,[r0,#0]
000046  eeb00a62          VMOV.F32 s0,s5                 ;185
00004a  eb020584          ADD      r5,r2,r4,LSL #2
;;;193        px2 = pState + 2 * S->M;
00004e  eb0206c4          ADD      r6,r2,r4,LSL #3
;;;194        px3 = pState + 3 * S->M;
000052  9400              STR      r4,[sp,#0]
000054  eb040444          ADD      r4,r4,r4,LSL #1
000058  eb020784          ADD      r7,r2,r4,LSL #2
00005c  eef00a40          VMOV.F32 s1,s0                 ;186
000060  eeb01a40          VMOV.F32 s2,s0                 ;187
000064  eef01a40          VMOV.F32 s3,s0                 ;188
000068  4613              MOV      r3,r2                 ;191
;;;195    
;;;196        /* Initialize coeff pointer */
;;;197        pb = pCoeffs;
00006a  4674              MOV      r4,lr
;;;198    
;;;199        /* Loop unrolling.  Process 4 taps at a time. */
;;;200        tapCnt = numTaps >> 2;
00006c  ea4f0899          LSR      r8,r9,#2
;;;201    
;;;202        /* Loop over the number of taps.  Unroll by a factor of 4.       
;;;203         ** Repeat until we've computed numTaps-4 coefficients. */
;;;204    
;;;205        while(tapCnt > 0u)
000070  e04f              B        |L1.274|
;;;206        {
;;;207          /* Read the b[numTaps-1] coefficient */
;;;208          c0 = *(pb++);
000072  bf00              NOP      
                  |L1.116|
000074  ed942a00          VLDR     s4,[r4,#0]
;;;209    
;;;210          /* Read x[n-numTaps-1] sample for acc0 */
;;;211          x0 = *(px0++);
000078  edd34a00          VLDR     s9,[r3,#0]
;;;212          /* Read x[n-numTaps-1] sample for acc1 */
;;;213          x1 = *(px1++);
00007c  ed954a00          VLDR     s8,[r5,#0]
;;;214          /* Read x[n-numTaps-1] sample for acc2 */
;;;215          x2 = *(px2++);
000080  edd63a00          VLDR     s7,[r6,#0]
;;;216          /* Read x[n-numTaps-1] sample for acc3 */
;;;217          x3 = *(px3++);
000084  ed973a00          VLDR     s6,[r7,#0]
;;;218    
;;;219          /* Perform the multiply-accumulate */
;;;220          acc0 += x0 * c0;
000088  ee040a82          VMLA.F32 s0,s9,s4
;;;221          acc1 += x1 * c0;
00008c  ee440a02          VMLA.F32 s1,s8,s4
;;;222          acc2 += x2 * c0;
000090  ee031a82          VMLA.F32 s2,s7,s4
;;;223          acc3 += x3 * c0;
000094  ee431a02          VMLA.F32 s3,s6,s4
;;;224    
;;;225          /* Read the b[numTaps-2] coefficient */
;;;226          c0 = *(pb++);
000098  ed942a01          VLDR     s4,[r4,#4]
;;;227    
;;;228          /* Read x[n-numTaps-2] sample for acc0, acc1, acc2, acc3 */
;;;229          x0 = *(px0++);
00009c  edd34a01          VLDR     s9,[r3,#4]
;;;230          x1 = *(px1++);
0000a0  ed954a01          VLDR     s8,[r5,#4]
;;;231          x2 = *(px2++);
0000a4  edd63a01          VLDR     s7,[r6,#4]
;;;232          x3 = *(px3++);
0000a8  ed973a01          VLDR     s6,[r7,#4]
;;;233    
;;;234          /* Perform the multiply-accumulate */
;;;235          acc0 += x0 * c0;
0000ac  ee040a82          VMLA.F32 s0,s9,s4
;;;236          acc1 += x1 * c0;
0000b0  ee440a02          VMLA.F32 s1,s8,s4
;;;237          acc2 += x2 * c0;
0000b4  ee031a82          VMLA.F32 s2,s7,s4
;;;238          acc3 += x3 * c0;
0000b8  ee431a02          VMLA.F32 s3,s6,s4
;;;239    
;;;240          /* Read the b[numTaps-3] coefficient */
;;;241          c0 = *(pb++);
0000bc  ed942a02          VLDR     s4,[r4,#8]
;;;242    
;;;243          /* Read x[n-numTaps-3] sample acc0, acc1, acc2, acc3 */
;;;244          x0 = *(px0++);
0000c0  edd34a02          VLDR     s9,[r3,#8]
;;;245          x1 = *(px1++);
0000c4  ed954a02          VLDR     s8,[r5,#8]
;;;246          x2 = *(px2++);
0000c8  ed963a02          VLDR     s6,[r6,#8]
;;;247          x3 = *(px3++);
0000cc  edd73a02          VLDR     s7,[r7,#8]
;;;248    
;;;249          /* Perform the multiply-accumulate */
;;;250          acc0 += x0 * c0;
0000d0  ee040a82          VMLA.F32 s0,s9,s4
;;;251          acc1 += x1 * c0;
0000d4  ee440a02          VMLA.F32 s1,s8,s4
;;;252          acc2 += x2 * c0;
0000d8  ee031a02          VMLA.F32 s2,s6,s4
;;;253          acc3 += x3 * c0;
0000dc  ee431a82          VMLA.F32 s3,s7,s4
;;;254    
;;;255          /* Read the b[numTaps-4] coefficient */
;;;256          c0 = *(pb++);
0000e0  ed942a03          VLDR     s4,[r4,#0xc]
;;;257    
;;;258          /* Read x[n-numTaps-4] sample acc0, acc1, acc2, acc3 */
;;;259          x0 = *(px0++);
0000e4  edd34a03          VLDR     s9,[r3,#0xc]
;;;260          x1 = *(px1++);
0000e8  ed954a03          VLDR     s8,[r5,#0xc]
;;;261          x2 = *(px2++);
0000ec  edd63a03          VLDR     s7,[r6,#0xc]
;;;262          x3 = *(px3++);
0000f0  ed973a03          VLDR     s6,[r7,#0xc]
;;;263    
;;;264          /* Perform the multiply-accumulate */
;;;265          acc0 += x0 * c0;
0000f4  ee040a82          VMLA.F32 s0,s9,s4
;;;266          acc1 += x1 * c0;
0000f8  ee440a02          VMLA.F32 s1,s8,s4
;;;267          acc2 += x2 * c0;
0000fc  ee031a82          VMLA.F32 s2,s7,s4
;;;268          acc3 += x3 * c0;
000100  ee431a02          VMLA.F32 s3,s6,s4
000104  3310              ADDS     r3,r3,#0x10
000106  3410              ADDS     r4,r4,#0x10
000108  3510              ADDS     r5,r5,#0x10
00010a  3610              ADDS     r6,r6,#0x10
00010c  3710              ADDS     r7,r7,#0x10
00010e  f1a80801          SUB      r8,r8,#1
                  |L1.274|
000112  f1b80f00          CMP      r8,#0                 ;205
000116  d1ad              BNE      |L1.116|
;;;269    
;;;270          /* Decrement the loop counter */
;;;271          tapCnt--;
;;;272        }
;;;273    
;;;274        /* If the filter length is not a multiple of 4, compute the remaining filter taps */
;;;275        tapCnt = numTaps % 0x4u;
000118  f0090803          AND      r8,r9,#3
;;;276    
;;;277        while(tapCnt > 0u)
00011c  e014              B        |L1.328|
;;;278        {
;;;279          /* Read coefficients */
;;;280          c0 = *(pb++);
00011e  bf00              NOP      
                  |L1.288|
000120  ecb42a01          VLDM     r4!,{s4}
;;;281    
;;;282          /* Fetch  state variables for acc0, acc1, acc2, acc3 */
;;;283          x0 = *(px0++);
;;;284          x1 = *(px1++);
;;;285          x2 = *(px2++);
;;;286          x3 = *(px3++);
;;;287    
;;;288          /* Perform the multiply-accumulate */
;;;289          acc0 += x0 * c0;
;;;290          acc1 += x1 * c0;
;;;291          acc2 += x2 * c0;
;;;292          acc3 += x3 * c0;
000124  f1a80801          SUB      r8,r8,#1
000128  ecf33a01          VLDM     r3!,{s7}              ;283
00012c  ecb54a01          VLDM     r5!,{s8}              ;284
000130  ecf64a01          VLDM     r6!,{s9}              ;285
000134  ee030a82          VMLA.F32 s0,s7,s4              ;289
000138  ecb73a01          VLDM     r7!,{s6}              ;286
00013c  ee440a02          VMLA.F32 s1,s8,s4              ;290
000140  ee041a82          VMLA.F32 s2,s9,s4              ;291
000144  ee431a02          VMLA.F32 s3,s6,s4
                  |L1.328|
000148  f1b80f00          CMP      r8,#0                 ;277
00014c  d1e8              BNE      |L1.288|
;;;293    
;;;294          /* Decrement the loop counter */
;;;295          tapCnt--;
;;;296        }
;;;297    
;;;298        /* Advance the state pointer by the decimation factor       
;;;299         * to process the next group of decimation factor number samples */
;;;300        pState = pState + 4 * S->M;
00014e  9b00              LDR      r3,[sp,#0]
;;;301    
;;;302        /* The result is in the accumulator, store in the destination buffer. */
;;;303        *pDst++ = acc0;
;;;304        *pDst++ = acc1;
;;;305        *pDst++ = acc2;
;;;306        *pDst++ = acc3;
;;;307    
;;;308        /* Decrement the loop counter */
;;;309        blkCnt--;
000150  f1aa0a01          SUB      r10,r10,#1
000154  eb021203          ADD      r2,r2,r3,LSL #4       ;300
000158  9b03              LDR      r3,[sp,#0xc]          ;303
00015a  ed830a00          VSTR     s0,[r3,#0]            ;303
00015e  9b03              LDR      r3,[sp,#0xc]          ;304
000160  edc30a01          VSTR     s1,[r3,#4]            ;304
000164  ed831a02          VSTR     s2,[r3,#8]            ;305
000168  edc31a03          VSTR     s3,[r3,#0xc]          ;306
00016c  3310              ADDS     r3,r3,#0x10           ;306
00016e  9303              STR      r3,[sp,#0xc]
                  |L1.368|
000170  f1ba0f00          CMP      r10,#0                ;173
000174  f47faf5d          BNE      |L1.50|
000178  e042              B        |L1.512|
                  |L1.378|
;;;310      }
;;;311    
;;;312      while(blkCntN4 > 0u)
;;;313      {
;;;314        /* Copy decimation factor number of new input samples into the state buffer */
;;;315        i = S->M;
00017a  7803              LDRB     r3,[r0,#0]
                  |L1.380|
;;;316    
;;;317        do
;;;318        {
;;;319          *pStateCurnt++ = *pSrc++;
00017c  ecb10a01          VLDM     r1!,{s0}
000180  1e5b              SUBS     r3,r3,#1
000182  ecac0a01          VSTM     r12!,{s0}
;;;320    
;;;321        } while(--i);
000186  d1f9              BNE      |L1.380|
;;;322    
;;;323        /* Set accumulator to zero */
;;;324        sum0 = 0.0f;
000188  eeb00a62          VMOV.F32 s0,s5
;;;325    
;;;326        /* Initialize state pointer */
;;;327        px = pState;
00018c  4614              MOV      r4,r2
;;;328    
;;;329        /* Initialize coeff pointer */
;;;330        pb = pCoeffs;
00018e  4673              MOV      r3,lr
;;;331    
;;;332        /* Loop unrolling.  Process 4 taps at a time. */
;;;333        tapCnt = numTaps >> 2;
000190  ea4f0599          LSR      r5,r9,#2
;;;334    
;;;335        /* Loop over the number of taps.  Unroll by a factor of 4.       
;;;336         ** Repeat until we've computed numTaps-4 coefficients. */
;;;337        while(tapCnt > 0u)
000194  e01b              B        |L1.462|
;;;338        {
;;;339          /* Read the b[numTaps-1] coefficient */
;;;340          c0 = *(pb++);
000196  bf00              NOP      
                  |L1.408|
000198  edd30a00          VLDR     s1,[r3,#0]
;;;341    
;;;342          /* Read x[n-numTaps-1] sample */
;;;343          x0 = *(px++);
00019c  ed941a00          VLDR     s2,[r4,#0]
;;;344    
;;;345          /* Perform the multiply-accumulate */
;;;346          sum0 += x0 * c0;
0001a0  ee010a20          VMLA.F32 s0,s2,s1
;;;347    
;;;348          /* Read the b[numTaps-2] coefficient */
;;;349          c0 = *(pb++);
0001a4  edd30a01          VLDR     s1,[r3,#4]
;;;350    
;;;351          /* Read x[n-numTaps-2] sample */
;;;352          x0 = *(px++);
0001a8  ed941a01          VLDR     s2,[r4,#4]
;;;353    
;;;354          /* Perform the multiply-accumulate */
;;;355          sum0 += x0 * c0;
0001ac  ee010a20          VMLA.F32 s0,s2,s1
;;;356    
;;;357          /* Read the b[numTaps-3] coefficient */
;;;358          c0 = *(pb++);
0001b0  ed931a02          VLDR     s2,[r3,#8]
;;;359    
;;;360          /* Read x[n-numTaps-3] sample */
;;;361          x0 = *(px++);
0001b4  edd40a02          VLDR     s1,[r4,#8]
;;;362    
;;;363          /* Perform the multiply-accumulate */
;;;364          sum0 += x0 * c0;
0001b8  ee000a81          VMLA.F32 s0,s1,s2
;;;365    
;;;366          /* Read the b[numTaps-4] coefficient */
;;;367          c0 = *(pb++);
0001bc  edd30a03          VLDR     s1,[r3,#0xc]
;;;368    
;;;369          /* Read x[n-numTaps-4] sample */
;;;370          x0 = *(px++);
0001c0  ed941a03          VLDR     s2,[r4,#0xc]
;;;371    
;;;372          /* Perform the multiply-accumulate */
;;;373          sum0 += x0 * c0;
0001c4  3310              ADDS     r3,r3,#0x10
0001c6  3410              ADDS     r4,r4,#0x10
0001c8  1e6d              SUBS     r5,r5,#1
0001ca  ee010a20          VMLA.F32 s0,s2,s1
                  |L1.462|
0001ce  2d00              CMP      r5,#0                 ;337
0001d0  d1e2              BNE      |L1.408|
;;;374    
;;;375          /* Decrement the loop counter */
;;;376          tapCnt--;
;;;377        }
;;;378    
;;;379        /* If the filter length is not a multiple of 4, compute the remaining filter taps */
;;;380        tapCnt = numTaps % 0x4u;
0001d2  f0090503          AND      r5,r9,#3
;;;381    
;;;382        while(tapCnt > 0u)
0001d6  e006              B        |L1.486|
                  |L1.472|
;;;383        {
;;;384          /* Read coefficients */
;;;385          c0 = *(pb++);
0001d8  ecf30a01          VLDM     r3!,{s1}
;;;386    
;;;387          /* Fetch 1 state variable */
;;;388          x0 = *(px++);
;;;389    
;;;390          /* Perform the multiply-accumulate */
;;;391          sum0 += x0 * c0;
0001dc  1e6d              SUBS     r5,r5,#1
0001de  ecb41a01          VLDM     r4!,{s2}              ;388
0001e2  ee010a20          VMLA.F32 s0,s2,s1
                  |L1.486|
0001e6  2d00              CMP      r5,#0                 ;382
0001e8  d1f6              BNE      |L1.472|
;;;392    
;;;393          /* Decrement the loop counter */
;;;394          tapCnt--;
;;;395        }
;;;396    
;;;397        /* Advance the state pointer by the decimation factor       
;;;398         * to process the next group of decimation factor number samples */
;;;399        pState = pState + S->M;
0001ea  7803              LDRB     r3,[r0,#0]
;;;400    
;;;401        /* The result is in the accumulator, store in the destination buffer. */
;;;402        *pDst++ = sum0;
;;;403    
;;;404        /* Decrement the loop counter */
;;;405        blkCntN4--;
0001ec  f1ab0b01          SUB      r11,r11,#1
0001f0  eb020283          ADD      r2,r2,r3,LSL #2       ;399
0001f4  9b03              LDR      r3,[sp,#0xc]          ;402
0001f6  ed830a00          VSTR     s0,[r3,#0]            ;402
0001fa  9b03              LDR      r3,[sp,#0xc]          ;402
0001fc  1d1b              ADDS     r3,r3,#4              ;402
0001fe  9303              STR      r3,[sp,#0xc]
                  |L1.512|
000200  f1bb0f00          CMP      r11,#0                ;312
000204  d1b9              BNE      |L1.378|
;;;406      }
;;;407    
;;;408      /* Processing is complete.    
;;;409       ** Now copy the last numTaps - 1 samples to the satrt of the state buffer.    
;;;410       ** This prepares the state buffer for the next function call. */
;;;411    
;;;412      /* Points to the start of the state buffer */
;;;413      pStateCurnt = S->pState;
;;;414    
;;;415      i = (numTaps - 1u) >> 2;
000206  f1a90301          SUB      r3,r9,#1
00020a  6880              LDR      r0,[r0,#8]            ;413
00020c  0899              LSRS     r1,r3,#2
;;;416    
;;;417      /* copy data */
;;;418      while(i > 0u)
00020e  e012              B        |L1.566|
                  |L1.528|
;;;419      {
;;;420        *pStateCurnt++ = *pState++;
000210  ed920a00          VLDR     s0,[r2,#0]
;;;421        *pStateCurnt++ = *pState++;
;;;422        *pStateCurnt++ = *pState++;
;;;423        *pStateCurnt++ = *pState++;
000214  1e49              SUBS     r1,r1,#1
000216  ed800a00          VSTR     s0,[r0,#0]            ;420
00021a  ed920a01          VLDR     s0,[r2,#4]            ;421
00021e  ed800a01          VSTR     s0,[r0,#4]            ;421
000222  ed920a02          VLDR     s0,[r2,#8]            ;422
000226  ed800a02          VSTR     s0,[r0,#8]            ;422
00022a  ed920a03          VLDR     s0,[r2,#0xc]
00022e  ed800a03          VSTR     s0,[r0,#0xc]
000232  3010              ADDS     r0,r0,#0x10
000234  3210              ADDS     r2,r2,#0x10
                  |L1.566|
000236  2900              CMP      r1,#0                 ;418
000238  d1ea              BNE      |L1.528|
;;;424    
;;;425        /* Decrement the loop counter */
;;;426        i--;
;;;427      }
;;;428    
;;;429      i = (numTaps - 1u) % 0x04u;
00023a  f0030103          AND      r1,r3,#3
;;;430    
;;;431      /* copy data */
;;;432      while(i > 0u)
00023e  e004              B        |L1.586|
                  |L1.576|
;;;433      {
;;;434        *pStateCurnt++ = *pState++;
000240  ecb20a01          VLDM     r2!,{s0}
000244  1e49              SUBS     r1,r1,#1
000246  eca00a01          VSTM     r0!,{s0}
                  |L1.586|
00024a  2900              CMP      r1,#0                 ;432
00024c  d1f8              BNE      |L1.576|
;;;435    
;;;436        /* Decrement the loop counter */
;;;437        i--;
;;;438      }
;;;439    
;;;440    #else
;;;441    
;;;442    /* Run the below code for Cortex-M0 */
;;;443    
;;;444      /* S->pState buffer contains previous frame (numTaps - 1) samples */
;;;445      /* pStateCurnt points to the location where the new input data should be written */
;;;446      pStateCurnt = S->pState + (numTaps - 1u);
;;;447    
;;;448      /* Total number of output samples to be computed */
;;;449      blkCnt = outBlockSize;
;;;450    
;;;451      while(blkCnt > 0u)
;;;452      {
;;;453        /* Copy decimation factor number of new input samples into the state buffer */
;;;454        i = S->M;
;;;455    
;;;456        do
;;;457        {
;;;458          *pStateCurnt++ = *pSrc++;
;;;459    
;;;460        } while(--i);
;;;461    
;;;462        /* Set accumulator to zero */
;;;463        sum0 = 0.0f;
;;;464    
;;;465        /* Initialize state pointer */
;;;466        px = pState;
;;;467    
;;;468        /* Initialize coeff pointer */
;;;469        pb = pCoeffs;
;;;470    
;;;471        tapCnt = numTaps;
;;;472    
;;;473        while(tapCnt > 0u)
;;;474        {
;;;475          /* Read coefficients */
;;;476          c0 = *pb++;
;;;477    
;;;478          /* Fetch 1 state variable */
;;;479          x0 = *px++;
;;;480    
;;;481          /* Perform the multiply-accumulate */
;;;482          sum0 += x0 * c0;
;;;483    
;;;484          /* Decrement the loop counter */
;;;485          tapCnt--;
;;;486        }
;;;487    
;;;488        /* Advance the state pointer by the decimation factor           
;;;489         * to process the next group of decimation factor number samples */
;;;490        pState = pState + S->M;
;;;491    
;;;492        /* The result is in the accumulator, store in the destination buffer. */
;;;493        *pDst++ = sum0;
;;;494    
;;;495        /* Decrement the loop counter */
;;;496        blkCnt--;
;;;497      }
;;;498    
;;;499      /* Processing is complete.         
;;;500       ** Now copy the last numTaps - 1 samples to the start of the state buffer.       
;;;501       ** This prepares the state buffer for the next function call. */
;;;502    
;;;503      /* Points to the start of the state buffer */
;;;504      pStateCurnt = S->pState;
;;;505    
;;;506      /* Copy numTaps number of values */
;;;507      i = (numTaps - 1u);
;;;508    
;;;509      /* copy data */
;;;510      while(i > 0u)
;;;511      {
;;;512        *pStateCurnt++ = *pState++;
;;;513    
;;;514        /* Decrement the loop counter */
;;;515        i--;
;;;516      }
;;;517    
;;;518    #endif /*   #ifndef ARM_MATH_CM0_FAMILY        */
;;;519    
;;;520    }
00024e  b005              ADD      sp,sp,#0x14
000250  e8bd8ff0          POP      {r4-r11,pc}
;;;521    
                          ENDP

                  |L1.596|
000254  00000000          DCFS     0x00000000 ; 0

;*** Start embedded assembler ***

#line 1 "src\\FilteringFunctions\\arm_fir_decimate_f32.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_arm_fir_decimate_f32_c_2e5f2033____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___22_arm_fir_decimate_f32_c_2e5f2033____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_arm_fir_decimate_f32_c_2e5f2033____REVSH|
#line 144
|__asm___22_arm_fir_decimate_f32_c_2e5f2033____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___22_arm_fir_decimate_f32_c_2e5f2033____RRX|
#line 300
|__asm___22_arm_fir_decimate_f32_c_2e5f2033____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
