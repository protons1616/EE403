; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_fir_sparse_f32.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_fir_sparse_f32.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_fir_sparse_f32.crf src\FilteringFunctions\arm_fir_sparse_f32.c]
                          THUMB

                          AREA ||i.arm_circularRead_f32||, CODE, READONLY, ALIGN=2

                  arm_circularRead_f32 PROC
;;;6193      */
;;;6194     static __INLINE void arm_circularRead_f32(
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;6195     int32_t * circBuffer,
;;;6196     int32_t L,
;;;6197     int32_t * readOffset,
;;;6198     int32_t bufferInc,
;;;6199     int32_t * dst,
;;;6200     int32_t * dst_base,
;;;6201     int32_t dst_length,
;;;6202     int32_t dstInc,
;;;6203     uint32_t blockSize)
;;;6204     {
000004  ac07              ADD      r4,sp,#0x1c
000006  e9dd960a          LDRD     r9,r6,[sp,#0x28]
00000a  e89410a0          LDM      r4,{r5,r7,r12}
00000e  6814              LDR      r4,[r2,#0]
;;;6205       uint32_t i = 0u;
;;;6206       int32_t rOffset, dst_end;
;;;6207   
;;;6208       /* Copy the value of Index pointer that points
;;;6209        * to the current location from where the input samples to be read */
;;;6210       rOffset = *readOffset;
;;;6211       dst_end = (int32_t) (dst_base + dst_length);
000010  eb070c8c          ADD      r12,r7,r12,LSL #2
000014  e00e              B        |L1.52|
;;;6212   
;;;6213       /* Loop over the blockSize */
;;;6214       i = blockSize;
;;;6215   
;;;6216       while(i > 0u)
;;;6217       {
;;;6218         /* copy the sample from the circular buffer to the destination buffer */
;;;6219         *dst = circBuffer[rOffset];
000016  bf00              NOP      
                  |L1.24|
000018  f8508024          LDR      r8,[r0,r4,LSL #2]
;;;6220   
;;;6221         /* Update the input pointer */
;;;6222         dst += dstInc;
00001c  f8c58000          STR      r8,[r5,#0]
000020  eb050589          ADD      r5,r5,r9,LSL #2
;;;6223   
;;;6224         if(dst == (int32_t *) dst_end)
000024  4565              CMP      r5,r12
000026  d100              BNE      |L1.42|
;;;6225         {
;;;6226           dst = dst_base;
000028  463d              MOV      r5,r7
                  |L1.42|
;;;6227         }
;;;6228   
;;;6229         /* Circularly update rOffset.  Watch out for positive and negative value  */
;;;6230         rOffset += bufferInc;
00002a  441c              ADD      r4,r4,r3
;;;6231   
;;;6232         if(rOffset >= L)
00002c  428c              CMP      r4,r1
00002e  db00              BLT      |L1.50|
;;;6233         {
;;;6234           rOffset -= L;
000030  1a64              SUBS     r4,r4,r1
                  |L1.50|
000032  1e76              SUBS     r6,r6,#1
                  |L1.52|
000034  2e00              CMP      r6,#0                 ;6216
000036  d1ef              BNE      |L1.24|
;;;6235         }
;;;6236   
;;;6237         /* Decrement the loop counter */
;;;6238         i--;
;;;6239       }
;;;6240   
;;;6241       /* Update the index pointer */
;;;6242       *readOffset = rOffset;
000038  6014              STR      r4,[r2,#0]
;;;6243     }
00003a  e8bd83f0          POP      {r4-r9,pc}
;;;6244   
                          ENDP


                          AREA ||i.arm_fir_sparse_f32||, CODE, READONLY, ALIGN=2

                  arm_fir_sparse_f32 PROC
;;;122    
;;;123    void arm_fir_sparse_f32(
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;124      arm_fir_sparse_instance_f32 * S,
;;;125      float32_t * pSrc,
;;;126      float32_t * pDst,
;;;127      float32_t * pScratchIn,
;;;128      uint32_t blockSize)
;;;129    {
000004  4606              MOV      r6,r0
000006  ed2d8b02          VPUSH    {d8}
00000a  b08b              SUB      sp,sp,#0x2c
00000c  4692              MOV      r10,r2
;;;130    
;;;131      float32_t *pState = S->pState;                 /* State pointer */
;;;132      float32_t *pCoeffs = S->pCoeffs;               /* Coefficient pointer */
;;;133      float32_t *px;                                 /* Scratch buffer pointer */
;;;134      float32_t *py = pState;                        /* Temporary pointers for state buffer */
;;;135      float32_t *pb = pScratchIn;                    /* Temporary pointers for scratch buffer */
;;;136      float32_t *pOut;                               /* Destination pointer */
;;;137      int32_t *pTapDelay = S->pTapDelay;             /* Pointer to the array containing offset of the non-zero tap values. */
00000e  9d16              LDR      r5,[sp,#0x58]
000010  f8d0b010          LDR      r11,[r0,#0x10]
;;;138      uint32_t delaySize = S->maxDelay + blockSize;  /* state length */
000014  89b2              LDRH     r2,[r6,#0xc]
000016  461c              MOV      r4,r3                 ;135
000018  e9d67001          LDRD     r7,r0,[r6,#4]         ;137
00001c  1953              ADDS     r3,r2,r5
;;;139      uint16_t numTaps = S->numTaps;                 /* Number of filter coefficients in the filter  */
00001e  8832              LDRH     r2,[r6,#0]
;;;140      int32_t readIndex;                             /* Read index of the state buffer */
;;;141      uint32_t tapCnt, blkCnt;                       /* loop counters */
;;;142      float32_t coeff = *pCoeffs++;                  /* Read the first coefficient value */
000020  9208              STR      r2,[sp,#0x20]
000022  4699              MOV      r9,r3                 ;138
000024  ecb08a01          VLDM     r0!,{s16}
;;;143    
;;;144    
;;;145    
;;;146      /* BlockSize of Input samples are copied into the state buffer */
;;;147      /* StateIndex points to the starting position to write in the state buffer */
;;;148      arm_circularWrite_f32((int32_t *) py, delaySize, &S->stateIndex, 1,
000028  9007              STR      r0,[sp,#0x1c]
00002a  2001              MOVS     r0,#1
00002c  9001              STR      r0,[sp,#4]
00002e  9000              STR      r0,[sp,#0]
000030  46bc              MOV      r12,r7
000032  f1060e02          ADD      lr,r6,#2
000036  462a              MOV      r2,r5
000038  8870              LDRH     r0,[r6,#2]
00003a  e00e              B        |L2.90|
                  |L2.60|
00003c  f8d18000          LDR      r8,[r1,#0]            ;129
000040  f84c8020          STR      r8,[r12,r0,LSL #2]    ;129
000044  f8dd8000          LDR      r8,[sp,#0]            ;129
000048  eb010188          ADD      r1,r1,r8,LSL #2       ;129
00004c  f8dd8004          LDR      r8,[sp,#4]            ;129
000050  4440              ADD      r0,r0,r8              ;129
000052  4298              CMP      r0,r3                 ;129
000054  db00              BLT      |L2.88|
000056  1ac0              SUBS     r0,r0,r3              ;129
                  |L2.88|
000058  1e52              SUBS     r2,r2,#1              ;129
                  |L2.90|
00005a  2a00              CMP      r2,#0                 ;129
00005c  d1ee              BNE      |L2.60|
00005e  f8ae0000          STRH     r0,[lr,#0]            ;129
;;;149                            (int32_t *) pSrc, 1, blockSize);
;;;150    
;;;151    
;;;152      /* Read Index, from where the state buffer should be read, is calculated. */
;;;153      readIndex = ((int32_t) S->stateIndex - (int32_t) blockSize) - *pTapDelay++;
000062  8870              LDRH     r0,[r6,#2]
000064  f10b0804          ADD      r8,r11,#4
000068  1b41              SUBS     r1,r0,r5
00006a  f8db0000          LDR      r0,[r11,#0]
00006e  1a08              SUBS     r0,r1,r0
;;;154    
;;;155      /* Wraparound of readIndex */
;;;156      if(readIndex < 0)
000070  9005              STR      r0,[sp,#0x14]
000072  d501              BPL      |L2.120|
;;;157      {
;;;158        readIndex += (int32_t) delaySize;
000074  4448              ADD      r0,r0,r9
000076  9005              STR      r0,[sp,#0x14]
                  |L2.120|
;;;159      }
;;;160    
;;;161      /* Working pointer for state buffer is updated */
;;;162      py = pState;
;;;163    
;;;164      /* blockSize samples are read from the state buffer */
;;;165      arm_circularRead_f32((int32_t *) py, delaySize, &readIndex, 1,
000078  2101              MOVS     r1,#1
00007a  e9cd5102          STRD     r5,r1,[sp,#8]
00007e  460b              MOV      r3,r1
000080  4660              MOV      r0,r12                ;162
000082  9401              STR      r4,[sp,#4]
000084  aa05              ADD      r2,sp,#0x14
000086  4649              MOV      r1,r9
000088  9504              STR      r5,[sp,#0x10]
00008a  9400              STR      r4,[sp,#0]
00008c  f7fffffe          BL       arm_circularRead_f32
;;;166                           (int32_t *) pb, (int32_t *) pb, blockSize, 1,
;;;167                           blockSize);
;;;168    
;;;169      /* Working pointer for the scratch buffer */
;;;170      px = pb;
;;;171    
;;;172      /* Working pointer for destination buffer */
;;;173      pOut = pDst;
;;;174    
;;;175    
;;;176    #ifndef ARM_MATH_CM0_FAMILY
;;;177    
;;;178      /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;179    
;;;180      /* Loop over the blockSize. Unroll by a factor of 4.    
;;;181       * Compute 4 Multiplications at a time. */
;;;182      blkCnt = blockSize >> 2u;
000090  08aa              LSRS     r2,r5,#2
000092  4620              MOV      r0,r4                 ;170
000094  4651              MOV      r1,r10                ;173
000096  4693              MOV      r11,r2
;;;183    
;;;184      while(blkCnt > 0u)
000098  e01b              B        |L2.210|
;;;185      {
;;;186        /* Perform Multiplications and store in destination buffer */
;;;187        *pOut++ = *px++ * coeff;
00009a  bf00              NOP      
                  |L2.156|
00009c  ed900a00          VLDR     s0,[r0,#0]
0000a0  ee200a08          VMUL.F32 s0,s0,s16
0000a4  ed810a00          VSTR     s0,[r1,#0]
;;;188        *pOut++ = *px++ * coeff;
0000a8  ed900a01          VLDR     s0,[r0,#4]
0000ac  ee200a08          VMUL.F32 s0,s0,s16
0000b0  ed810a01          VSTR     s0,[r1,#4]
;;;189        *pOut++ = *px++ * coeff;
0000b4  ed900a02          VLDR     s0,[r0,#8]
0000b8  ee200a08          VMUL.F32 s0,s0,s16
0000bc  ed810a02          VSTR     s0,[r1,#8]
;;;190        *pOut++ = *px++ * coeff;
0000c0  ed900a03          VLDR     s0,[r0,#0xc]
0000c4  3010              ADDS     r0,r0,#0x10
0000c6  ee200a08          VMUL.F32 s0,s0,s16
0000ca  ed810a03          VSTR     s0,[r1,#0xc]
0000ce  3110              ADDS     r1,r1,#0x10
0000d0  1e52              SUBS     r2,r2,#1
                  |L2.210|
0000d2  2a00              CMP      r2,#0                 ;184
0000d4  d1e2              BNE      |L2.156|
;;;191    
;;;192        /* Decrement the loop counter */
;;;193        blkCnt--;
;;;194      }
;;;195    
;;;196      /* If the blockSize is not a multiple of 4,    
;;;197       * compute the remaining samples */
;;;198      blkCnt = blockSize % 0x4u;
0000d6  f0050203          AND      r2,r5,#3
;;;199    
;;;200      while(blkCnt > 0u)
0000da  9206              STR      r2,[sp,#0x18]
0000dc  e007              B        |L2.238|
;;;201      {
;;;202        /* Perform Multiplications and store in destination buffer */
;;;203        *pOut++ = *px++ * coeff;
0000de  bf00              NOP      
                  |L2.224|
0000e0  ecb00a01          VLDM     r0!,{s0}
0000e4  1e52              SUBS     r2,r2,#1
0000e6  ee200a08          VMUL.F32 s0,s0,s16
0000ea  eca10a01          VSTM     r1!,{s0}
                  |L2.238|
0000ee  2a00              CMP      r2,#0                 ;200
0000f0  d1f6              BNE      |L2.224|
;;;204    
;;;205        /* Decrement the loop counter */
;;;206        blkCnt--;
;;;207      }
;;;208    
;;;209      /* Load the coefficient value and    
;;;210       * increment the coefficient buffer for the next set of state values */
;;;211      coeff = *pCoeffs++;
0000f2  9807              LDR      r0,[sp,#0x1c]
0000f4  ecb08a01          VLDM     r0!,{s16}
;;;212    
;;;213      /* Read Index, from where the state buffer should be read, is calculated. */
;;;214      readIndex = ((int32_t) S->stateIndex - (int32_t) blockSize) - *pTapDelay++;
0000f8  9007              STR      r0,[sp,#0x1c]
0000fa  8870              LDRH     r0,[r6,#2]
0000fc  1b41              SUBS     r1,r0,r5
0000fe  f8d80000          LDR      r0,[r8,#0]
000102  1a08              SUBS     r0,r1,r0
000104  f1080104          ADD      r1,r8,#4
;;;215    
;;;216      /* Wraparound of readIndex */
;;;217      if(readIndex < 0)
000108  9109              STR      r1,[sp,#0x24]
00010a  9005              STR      r0,[sp,#0x14]
00010c  d501              BPL      |L2.274|
;;;218      {
;;;219        readIndex += (int32_t) delaySize;
00010e  4448              ADD      r0,r0,r9
000110  9005              STR      r0,[sp,#0x14]
                  |L2.274|
;;;220      }
;;;221    
;;;222      /* Loop over the number of taps. */
;;;223      tapCnt = (uint32_t) numTaps - 2u;
000112  9808              LDR      r0,[sp,#0x20]
000114  1e80              SUBS     r0,r0,#2
;;;224    
;;;225      while(tapCnt > 0u)
000116  e04b              B        |L2.432|
                  |L2.280|
;;;226      {
;;;227    
;;;228        /* Working pointer for state buffer is updated */
;;;229        py = pState;
;;;230    
;;;231        /* blockSize samples are read from the state buffer */
;;;232        arm_circularRead_f32((int32_t *) py, delaySize, &readIndex, 1,
000118  f7fffffe          BL       arm_circularRead_f32
;;;233                             (int32_t *) pb, (int32_t *) pb, blockSize, 1,
;;;234                             blockSize);
;;;235    
;;;236        /* Working pointer for the scratch buffer */
;;;237        px = pb;
00011c  4621              MOV      r1,r4
;;;238    
;;;239        /* Working pointer for destination buffer */
;;;240        pOut = pDst;
00011e  4650              MOV      r0,r10
000120  465a              MOV      r2,r11
;;;241    
;;;242        /* Loop over the blockSize. Unroll by a factor of 4.    
;;;243         * Compute 4 MACS at a time. */
;;;244        blkCnt = blockSize >> 2u;
;;;245    
;;;246        while(blkCnt > 0u)
000122  e022              B        |L2.362|
                  |L2.292|
;;;247        {
;;;248          /* Perform Multiply-Accumulate */
;;;249          *pOut++ += *px++ * coeff;
000124  ed900a00          VLDR     s0,[r0,#0]
000128  edd10a00          VLDR     s1,[r1,#0]
00012c  ee000a88          VMLA.F32 s0,s1,s16
000130  ed800a00          VSTR     s0,[r0,#0]
;;;250          *pOut++ += *px++ * coeff;
000134  ed900a01          VLDR     s0,[r0,#4]
000138  edd10a01          VLDR     s1,[r1,#4]
00013c  ee000a88          VMLA.F32 s0,s1,s16
000140  ed800a01          VSTR     s0,[r0,#4]
;;;251          *pOut++ += *px++ * coeff;
000144  ed900a02          VLDR     s0,[r0,#8]
000148  edd10a02          VLDR     s1,[r1,#8]
00014c  ee000a88          VMLA.F32 s0,s1,s16
000150  ed800a02          VSTR     s0,[r0,#8]
;;;252          *pOut++ += *px++ * coeff;
000154  ed900a03          VLDR     s0,[r0,#0xc]
000158  edd10a03          VLDR     s1,[r1,#0xc]
00015c  3110              ADDS     r1,r1,#0x10
00015e  ee000a88          VMLA.F32 s0,s1,s16
000162  ed800a03          VSTR     s0,[r0,#0xc]
000166  3010              ADDS     r0,r0,#0x10
000168  1e52              SUBS     r2,r2,#1
                  |L2.362|
00016a  2a00              CMP      r2,#0                 ;246
00016c  d1da              BNE      |L2.292|
;;;253    
;;;254          /* Decrement the loop counter */
;;;255          blkCnt--;
;;;256        }
;;;257    
;;;258        /* If the blockSize is not a multiple of 4,    
;;;259         * compute the remaining samples */
;;;260        blkCnt = blockSize % 0x4u;
;;;261    
;;;262        while(blkCnt > 0u)
00016e  9a06              LDR      r2,[sp,#0x18]
000170  e009              B        |L2.390|
;;;263        {
;;;264          /* Perform Multiply-Accumulate */
;;;265          *pOut++ += *px++ * coeff;
000172  bf00              NOP      
                  |L2.372|
000174  ecf10a01          VLDM     r1!,{s1}
000178  ed900a00          VLDR     s0,[r0,#0]
00017c  1e52              SUBS     r2,r2,#1
00017e  ee000a88          VMLA.F32 s0,s1,s16
000182  eca00a01          VSTM     r0!,{s0}
                  |L2.390|
000186  2a00              CMP      r2,#0                 ;262
000188  d1f4              BNE      |L2.372|
;;;266    
;;;267          /* Decrement the loop counter */
;;;268          blkCnt--;
;;;269        }
;;;270    
;;;271        /* Load the coefficient value and    
;;;272         * increment the coefficient buffer for the next set of state values */
;;;273        coeff = *pCoeffs++;
00018a  9807              LDR      r0,[sp,#0x1c]
00018c  ecb08a01          VLDM     r0!,{s16}
;;;274    
;;;275        /* Read Index, from where the state buffer should be read, is calculated. */
;;;276        readIndex = ((int32_t) S->stateIndex -
000190  9007              STR      r0,[sp,#0x1c]
000192  8870              LDRH     r0,[r6,#2]
000194  1b41              SUBS     r1,r0,r5
000196  9809              LDR      r0,[sp,#0x24]
000198  6800              LDR      r0,[r0,#0]
00019a  1a08              SUBS     r0,r1,r0
00019c  9909              LDR      r1,[sp,#0x24]
00019e  9005              STR      r0,[sp,#0x14]
0001a0  f1010104          ADD      r1,r1,#4
;;;277                     (int32_t) blockSize) - *pTapDelay++;
;;;278    
;;;279        /* Wraparound of readIndex */
;;;280        if(readIndex < 0)
0001a4  9109              STR      r1,[sp,#0x24]
0001a6  d501              BPL      |L2.428|
;;;281        {
;;;282          readIndex += (int32_t) delaySize;
0001a8  4448              ADD      r0,r0,r9
0001aa  9005              STR      r0,[sp,#0x14]
                  |L2.428|
;;;283        }
;;;284    
;;;285        /* Decrement the tap loop counter */
;;;286        tapCnt--;
0001ac  f1a80001          SUB      r0,r8,#1
                  |L2.432|
;;;287      }
;;;288    	
;;;289    	/* Compute last tap without the final read of pTapDelay */
;;;290    
;;;291    	/* Working pointer for state buffer is updated */
;;;292    	py = pState;
;;;293    
;;;294    	/* blockSize samples are read from the state buffer */
;;;295    	arm_circularRead_f32((int32_t *) py, delaySize, &readIndex, 1,
0001b0  f04f0101          MOV      r1,#1
0001b4  e9cd5102          STRD     r5,r1,[sp,#8]
0001b8  ea5f0800          MOVS     r8,r0                 ;223
0001bc  460b              MOV      r3,r1
0001be  4638              MOV      r0,r7                 ;292
0001c0  9401              STR      r4,[sp,#4]
0001c2  aa05              ADD      r2,sp,#0x14
0001c4  4649              MOV      r1,r9
0001c6  9504              STR      r5,[sp,#0x10]
0001c8  9400              STR      r4,[sp,#0]
0001ca  d1a5              BNE      |L2.280|
0001cc  f7fffffe          BL       arm_circularRead_f32
;;;296    											 (int32_t *) pb, (int32_t *) pb, blockSize, 1,
;;;297    											 blockSize);
;;;298    
;;;299    	/* Working pointer for the scratch buffer */
;;;300    	px = pb;
;;;301    
;;;302    	/* Working pointer for destination buffer */
;;;303    	pOut = pDst;
0001d0  4650              MOV      r0,r10
0001d2  4659              MOV      r1,r11
;;;304    
;;;305    	/* Loop over the blockSize. Unroll by a factor of 4.    
;;;306    	 * Compute 4 MACS at a time. */
;;;307    	blkCnt = blockSize >> 2u;
;;;308    
;;;309    	while(blkCnt > 0u)
0001d4  e023              B        |L2.542|
;;;310    	{
;;;311    		/* Perform Multiply-Accumulate */
;;;312    		*pOut++ += *px++ * coeff;
0001d6  bf00              NOP      
                  |L2.472|
0001d8  ed900a00          VLDR     s0,[r0,#0]
0001dc  edd40a00          VLDR     s1,[r4,#0]
;;;313    		*pOut++ += *px++ * coeff;
;;;314    		*pOut++ += *px++ * coeff;
;;;315    		*pOut++ += *px++ * coeff;
0001e0  1e49              SUBS     r1,r1,#1
0001e2  ee000a88          VMLA.F32 s0,s1,s16             ;312
0001e6  ed800a00          VSTR     s0,[r0,#0]            ;312
0001ea  ed900a01          VLDR     s0,[r0,#4]            ;313
0001ee  edd40a01          VLDR     s1,[r4,#4]            ;313
0001f2  ee000a88          VMLA.F32 s0,s1,s16             ;313
0001f6  ed800a01          VSTR     s0,[r0,#4]            ;313
0001fa  ed900a02          VLDR     s0,[r0,#8]            ;314
0001fe  edd40a02          VLDR     s1,[r4,#8]            ;314
000202  ee000a88          VMLA.F32 s0,s1,s16             ;314
000206  ed800a02          VSTR     s0,[r0,#8]            ;314
00020a  ed900a03          VLDR     s0,[r0,#0xc]
00020e  edd40a03          VLDR     s1,[r4,#0xc]
000212  ee000a88          VMLA.F32 s0,s1,s16
000216  ed800a03          VSTR     s0,[r0,#0xc]
00021a  3010              ADDS     r0,r0,#0x10
00021c  3410              ADDS     r4,r4,#0x10
                  |L2.542|
00021e  2900              CMP      r1,#0                 ;309
000220  d1da              BNE      |L2.472|
;;;316    
;;;317    		/* Decrement the loop counter */
;;;318    		blkCnt--;
;;;319    	}
;;;320    
;;;321    	/* If the blockSize is not a multiple of 4,    
;;;322    	 * compute the remaining samples */
;;;323    	blkCnt = blockSize % 0x4u;
;;;324    
;;;325    	while(blkCnt > 0u)
000222  9906              LDR      r1,[sp,#0x18]
000224  e009              B        |L2.570|
;;;326    	{
;;;327    		/* Perform Multiply-Accumulate */
;;;328    		*pOut++ += *px++ * coeff;
000226  bf00              NOP      
                  |L2.552|
000228  ecf40a01          VLDM     r4!,{s1}
00022c  ed900a00          VLDR     s0,[r0,#0]
000230  1e49              SUBS     r1,r1,#1
000232  ee000a88          VMLA.F32 s0,s1,s16
000236  eca00a01          VSTM     r0!,{s0}
                  |L2.570|
00023a  2900              CMP      r1,#0                 ;325
00023c  d1f4              BNE      |L2.552|
;;;329    
;;;330    		/* Decrement the loop counter */
;;;331    		blkCnt--;
;;;332    	}
;;;333    
;;;334    #else
;;;335    
;;;336    /* Run the below code for Cortex-M0 */
;;;337    
;;;338      blkCnt = blockSize;
;;;339    
;;;340      while(blkCnt > 0u)
;;;341      {
;;;342        /* Perform Multiplications and store in destination buffer */
;;;343        *pOut++ = *px++ * coeff;
;;;344    
;;;345        /* Decrement the loop counter */
;;;346        blkCnt--;
;;;347      }
;;;348    
;;;349      /* Load the coefficient value and           
;;;350       * increment the coefficient buffer for the next set of state values */
;;;351      coeff = *pCoeffs++;
;;;352    
;;;353      /* Read Index, from where the state buffer should be read, is calculated. */
;;;354      readIndex = ((int32_t) S->stateIndex - (int32_t) blockSize) - *pTapDelay++;
;;;355    
;;;356      /* Wraparound of readIndex */
;;;357      if(readIndex < 0)
;;;358      {
;;;359        readIndex += (int32_t) delaySize;
;;;360      }
;;;361    
;;;362      /* Loop over the number of taps. */
;;;363      tapCnt = (uint32_t) numTaps - 2u;
;;;364    
;;;365      while(tapCnt > 0u)
;;;366      {
;;;367    
;;;368        /* Working pointer for state buffer is updated */
;;;369        py = pState;
;;;370    
;;;371        /* blockSize samples are read from the state buffer */
;;;372        arm_circularRead_f32((int32_t *) py, delaySize, &readIndex, 1,
;;;373                             (int32_t *) pb, (int32_t *) pb, blockSize, 1,
;;;374                             blockSize);
;;;375    
;;;376        /* Working pointer for the scratch buffer */
;;;377        px = pb;
;;;378    
;;;379        /* Working pointer for destination buffer */
;;;380        pOut = pDst;
;;;381    
;;;382        blkCnt = blockSize;
;;;383    
;;;384        while(blkCnt > 0u)
;;;385        {
;;;386          /* Perform Multiply-Accumulate */
;;;387          *pOut++ += *px++ * coeff;
;;;388    
;;;389          /* Decrement the loop counter */
;;;390          blkCnt--;
;;;391        }
;;;392    
;;;393        /* Load the coefficient value and           
;;;394         * increment the coefficient buffer for the next set of state values */
;;;395        coeff = *pCoeffs++;
;;;396    
;;;397        /* Read Index, from where the state buffer should be read, is calculated. */
;;;398        readIndex =
;;;399          ((int32_t) S->stateIndex - (int32_t) blockSize) - *pTapDelay++;
;;;400    
;;;401        /* Wraparound of readIndex */
;;;402        if(readIndex < 0)
;;;403        {
;;;404          readIndex += (int32_t) delaySize;
;;;405        }
;;;406    
;;;407        /* Decrement the tap loop counter */
;;;408        tapCnt--;
;;;409      }
;;;410    	
;;;411    	/* Compute last tap without the final read of pTapDelay */	
;;;412    	
;;;413    	/* Working pointer for state buffer is updated */
;;;414    	py = pState;
;;;415    
;;;416    	/* blockSize samples are read from the state buffer */
;;;417    	arm_circularRead_f32((int32_t *) py, delaySize, &readIndex, 1,
;;;418    											 (int32_t *) pb, (int32_t *) pb, blockSize, 1,
;;;419    											 blockSize);
;;;420    
;;;421    	/* Working pointer for the scratch buffer */
;;;422    	px = pb;
;;;423    
;;;424    	/* Working pointer for destination buffer */
;;;425    	pOut = pDst;
;;;426    
;;;427    	blkCnt = blockSize;
;;;428    
;;;429    	while(blkCnt > 0u)
;;;430    	{
;;;431    		/* Perform Multiply-Accumulate */
;;;432    		*pOut++ += *px++ * coeff;
;;;433    
;;;434    		/* Decrement the loop counter */
;;;435    		blkCnt--;
;;;436    	}
;;;437    
;;;438    #endif /*   #ifndef ARM_MATH_CM0_FAMILY        */
;;;439    
;;;440    }
00023e  b00b              ADD      sp,sp,#0x2c
000240  ecbd8b02          VPOP     {d8}
000244  e8bd8ff0          POP      {r4-r11,pc}
;;;441    
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\FilteringFunctions\\arm_fir_sparse_f32.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_arm_fir_sparse_f32_c_5ed9a274____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___20_arm_fir_sparse_f32_c_5ed9a274____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_arm_fir_sparse_f32_c_5ed9a274____REVSH|
#line 144
|__asm___20_arm_fir_sparse_f32_c_5ed9a274____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_arm_fir_sparse_f32_c_5ed9a274____RRX|
#line 300
|__asm___20_arm_fir_sparse_f32_c_5ed9a274____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
