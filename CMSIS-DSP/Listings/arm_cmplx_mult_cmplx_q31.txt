; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_cmplx_mult_cmplx_q31.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_cmplx_mult_cmplx_q31.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_cmplx_mult_cmplx_q31.crf src\ComplexMathFunctions\arm_cmplx_mult_cmplx_q31.c]
                          THUMB

                          AREA ||i.arm_cmplx_mult_cmplx_q31||, CODE, READONLY, ALIGN=1

                  arm_cmplx_mult_cmplx_q31 PROC
;;;66     
;;;67     void arm_cmplx_mult_cmplx_q31(
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;68       q31_t * pSrcA,
;;;69       q31_t * pSrcB,
;;;70       q31_t * pDst,
;;;71       uint32_t numSamples)
;;;72     {
;;;73       q31_t a, b, c, d;                              /* Temporary variables to store real and imaginary values */
;;;74       uint32_t blkCnt;                               /* loop counters */
;;;75       q31_t mul1, mul2, mul3, mul4;
;;;76       q31_t out1, out2;
;;;77     
;;;78     #ifndef ARM_MATH_CM0_FAMILY
;;;79     
;;;80       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;81     
;;;82       /* loop Unrolling */
;;;83       blkCnt = numSamples >> 2u;
000004  089c              LSRS     r4,r3,#2
000006  e056              B        |L1.182|
                  |L1.8|
000008  e8f05602          LDRD     r5,r6,[r0],#8         ;72
00000c  e8f17c02          LDRD     r7,r12,[r1],#8        ;72
;;;84     
;;;85       /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.    
;;;86        ** a second loop below computes the remaining 1 to 3 samples. */
;;;87       while(blkCnt > 0u)
;;;88       {
;;;89         /* C[2 * i] = A[2 * i] * B[2 * i] - A[2 * i + 1] * B[2 * i + 1].  */
;;;90         /* C[2 * i + 1] = A[2 * i] * B[2 * i + 1] + A[2 * i + 1] * B[2 * i].  */
;;;91         a = *pSrcA++;
;;;92         b = *pSrcA++;
;;;93         c = *pSrcB++;
;;;94         d = *pSrcB++;
;;;95     
;;;96         mul1 = (q31_t) (((q63_t) a * c) >> 32);
000010  fb55f907          SMMUL    r9,r5,r7
;;;97         mul2 = (q31_t) (((q63_t) b * d) >> 32);
000014  fb56f80c          SMMUL    r8,r6,r12
;;;98         mul3 = (q31_t) (((q63_t) a * d) >> 32);
000018  fb55f50c          SMMUL    r5,r5,r12
;;;99         mul4 = (q31_t) (((q63_t) b * c) >> 32);
00001c  fb56f607          SMMUL    r6,r6,r7
;;;100    
;;;101        mul1 = (mul1 >> 1);
000020  ea4f0769          ASR      r7,r9,#1
;;;102        mul2 = (mul2 >> 1);
;;;103        mul3 = (mul3 >> 1);
000024  106d              ASRS     r5,r5,#1
;;;104        mul4 = (mul4 >> 1);
;;;105    
;;;106        out1 = mul1 - mul2;
000026  eba70768          SUB      r7,r7,r8,ASR #1
;;;107        out2 = mul3 + mul4;
00002a  eb050566          ADD      r5,r5,r6,ASR #1
00002e  e8e27502          STRD     r7,r5,[r2],#8
000032  e8f05602          LDRD     r5,r6,[r0],#8
000036  e8f17c02          LDRD     r7,r12,[r1],#8
;;;108    
;;;109        /* store the real result in 3.29 format in the destination buffer. */
;;;110        *pDst++ = out1;
;;;111        /* store the imag result in 3.29 format in the destination buffer. */
;;;112        *pDst++ = out2;
;;;113    
;;;114        a = *pSrcA++;
;;;115        b = *pSrcA++;
;;;116        c = *pSrcB++;
;;;117        d = *pSrcB++;
;;;118    
;;;119        mul1 = (q31_t) (((q63_t) a * c) >> 32);
00003a  fb55f907          SMMUL    r9,r5,r7
;;;120        mul2 = (q31_t) (((q63_t) b * d) >> 32);
00003e  fb56f80c          SMMUL    r8,r6,r12
;;;121        mul3 = (q31_t) (((q63_t) a * d) >> 32);
000042  fb55f50c          SMMUL    r5,r5,r12
;;;122        mul4 = (q31_t) (((q63_t) b * c) >> 32);
000046  fb56f607          SMMUL    r6,r6,r7
;;;123    
;;;124        mul1 = (mul1 >> 1);
00004a  ea4f0769          ASR      r7,r9,#1
;;;125        mul2 = (mul2 >> 1);
;;;126        mul3 = (mul3 >> 1);
00004e  106d              ASRS     r5,r5,#1
;;;127        mul4 = (mul4 >> 1);
;;;128    
;;;129        out1 = mul1 - mul2;
000050  eba70768          SUB      r7,r7,r8,ASR #1
;;;130        out2 = mul3 + mul4;
000054  eb050566          ADD      r5,r5,r6,ASR #1
000058  e8e27502          STRD     r7,r5,[r2],#8
00005c  e8f05604          LDRD     r5,r6,[r0],#0x10
000060  e8f17c04          LDRD     r7,r12,[r1],#0x10
;;;131    
;;;132        /* store the real result in 3.29 format in the destination buffer. */
;;;133        *pDst++ = out1;
;;;134        /* store the imag result in 3.29 format in the destination buffer. */
;;;135        *pDst++ = out2;
;;;136    
;;;137        a = *pSrcA++;
;;;138        b = *pSrcA++;
;;;139        c = *pSrcB++;
;;;140        d = *pSrcB++;
;;;141    
;;;142        mul1 = (q31_t) (((q63_t) a * c) >> 32);
000064  fb55f907          SMMUL    r9,r5,r7
;;;143        mul2 = (q31_t) (((q63_t) b * d) >> 32);
000068  fb56f80c          SMMUL    r8,r6,r12
;;;144        mul3 = (q31_t) (((q63_t) a * d) >> 32);
00006c  fb55f50c          SMMUL    r5,r5,r12
;;;145        mul4 = (q31_t) (((q63_t) b * c) >> 32);
000070  fb56f607          SMMUL    r6,r6,r7
;;;146    
;;;147        mul1 = (mul1 >> 1);
000074  ea4f0769          ASR      r7,r9,#1
;;;148        mul2 = (mul2 >> 1);
;;;149        mul3 = (mul3 >> 1);
000078  106d              ASRS     r5,r5,#1
;;;150        mul4 = (mul4 >> 1);
;;;151    
;;;152        out1 = mul1 - mul2;
00007a  eba70768          SUB      r7,r7,r8,ASR #1
;;;153        out2 = mul3 + mul4;
00007e  eb050566          ADD      r5,r5,r6,ASR #1
000082  e8e27504          STRD     r7,r5,[r2],#0x10
000086  e9506502          LDRD     r6,r5,[r0,#-8]
;;;154    
;;;155        /* store the real result in 3.29 format in the destination buffer. */
;;;156        *pDst++ = out1;
;;;157        /* store the imag result in 3.29 format in the destination buffer. */
;;;158        *pDst++ = out2;
;;;159    
;;;160        a = *pSrcA++;
;;;161        b = *pSrcA++;
;;;162        c = *pSrcB++;
00008a  f8517c08          LDR      r7,[r1,#-8]
;;;163        d = *pSrcB++;
00008e  f851cc04          LDR      r12,[r1,#-4]
;;;164    
;;;165        mul1 = (q31_t) (((q63_t) a * c) >> 32);
000092  fb56f907          SMMUL    r9,r6,r7
;;;166        mul2 = (q31_t) (((q63_t) b * d) >> 32);
000096  fb55f80c          SMMUL    r8,r5,r12
;;;167        mul3 = (q31_t) (((q63_t) a * d) >> 32);
00009a  fb56f60c          SMMUL    r6,r6,r12
;;;168        mul4 = (q31_t) (((q63_t) b * c) >> 32);
00009e  fb55f507          SMMUL    r5,r5,r7
;;;169    
;;;170        mul1 = (mul1 >> 1);
;;;171        mul2 = (mul2 >> 1);
;;;172        mul3 = (mul3 >> 1);
0000a2  1076              ASRS     r6,r6,#1
0000a4  ea4f0769          ASR      r7,r9,#1              ;170
;;;173        mul4 = (mul4 >> 1);
;;;174    
;;;175        out1 = mul1 - mul2;
0000a8  eba70768          SUB      r7,r7,r8,ASR #1
;;;176        out2 = mul3 + mul4;
0000ac  eb060565          ADD      r5,r6,r5,ASR #1
0000b0  e9427502          STRD     r7,r5,[r2,#-8]
0000b4  1e64              SUBS     r4,r4,#1
                  |L1.182|
0000b6  2c00              CMP      r4,#0                 ;87
0000b8  d1a6              BNE      |L1.8|
;;;177    
;;;178        /* store the real result in 3.29 format in the destination buffer. */
;;;179        *pDst++ = out1;
;;;180        /* store the imag result in 3.29 format in the destination buffer. */
;;;181        *pDst++ = out2;
;;;182    
;;;183        /* Decrement the blockSize loop counter */
;;;184        blkCnt--;
;;;185      }
;;;186    
;;;187      /* If the blockSize is not a multiple of 4, compute any remaining output samples here.    
;;;188       ** No loop unrolling is used. */
;;;189      blkCnt = numSamples % 0x4u;
0000ba  f0030303          AND      r3,r3,#3
;;;190    
;;;191      while(blkCnt > 0u)
0000be  e015              B        |L1.236|
                  |L1.192|
0000c0  e8f04502          LDRD     r4,r5,[r0],#8
0000c4  e8f16702          LDRD     r6,r7,[r1],#8
;;;192      {
;;;193        /* C[2 * i] = A[2 * i] * B[2 * i] - A[2 * i + 1] * B[2 * i + 1].  */
;;;194        /* C[2 * i + 1] = A[2 * i] * B[2 * i + 1] + A[2 * i + 1] * B[2 * i].  */
;;;195        a = *pSrcA++;
;;;196        b = *pSrcA++;
;;;197        c = *pSrcB++;
;;;198        d = *pSrcB++;
;;;199    
;;;200        mul1 = (q31_t) (((q63_t) a * c) >> 32);
0000c8  fb54fc06          SMMUL    r12,r4,r6
;;;201        mul2 = (q31_t) (((q63_t) b * d) >> 32);
0000cc  fb55f807          SMMUL    r8,r5,r7
;;;202        mul3 = (q31_t) (((q63_t) a * d) >> 32);
0000d0  fb54f407          SMMUL    r4,r4,r7
;;;203        mul4 = (q31_t) (((q63_t) b * c) >> 32);
0000d4  fb55f506          SMMUL    r5,r5,r6
;;;204    
;;;205        mul1 = (mul1 >> 1);
;;;206        mul2 = (mul2 >> 1);
;;;207        mul3 = (mul3 >> 1);
0000d8  1064              ASRS     r4,r4,#1
0000da  ea4f066c          ASR      r6,r12,#1             ;205
;;;208        mul4 = (mul4 >> 1);
;;;209    
;;;210        out1 = mul1 - mul2;
0000de  eba60668          SUB      r6,r6,r8,ASR #1
;;;211        out2 = mul3 + mul4;
0000e2  eb040465          ADD      r4,r4,r5,ASR #1
0000e6  e8e26402          STRD     r6,r4,[r2],#8
0000ea  1e5b              SUBS     r3,r3,#1
                  |L1.236|
0000ec  2b00              CMP      r3,#0                 ;191
0000ee  d1e7              BNE      |L1.192|
;;;212    
;;;213        /* store the real result in 3.29 format in the destination buffer. */
;;;214        *pDst++ = out1;
;;;215        /* store the imag result in 3.29 format in the destination buffer. */
;;;216        *pDst++ = out2;
;;;217    
;;;218        /* Decrement the blockSize loop counter */
;;;219        blkCnt--;
;;;220      }
;;;221    
;;;222    #else
;;;223    
;;;224      /* Run the below code for Cortex-M0 */
;;;225    
;;;226      /* loop Unrolling */
;;;227      blkCnt = numSamples >> 1u;
;;;228    
;;;229      /* First part of the processing with loop unrolling.  Compute 2 outputs at a time.     
;;;230       ** a second loop below computes the remaining 1 sample. */
;;;231      while(blkCnt > 0u)
;;;232      {
;;;233        /* C[2 * i] = A[2 * i] * B[2 * i] - A[2 * i + 1] * B[2 * i + 1].  */
;;;234        /* C[2 * i + 1] = A[2 * i] * B[2 * i + 1] + A[2 * i + 1] * B[2 * i].  */
;;;235        a = *pSrcA++;
;;;236        b = *pSrcA++;
;;;237        c = *pSrcB++;
;;;238        d = *pSrcB++;
;;;239    
;;;240        mul1 = (q31_t) (((q63_t) a * c) >> 32);
;;;241        mul2 = (q31_t) (((q63_t) b * d) >> 32);
;;;242        mul3 = (q31_t) (((q63_t) a * d) >> 32);
;;;243        mul4 = (q31_t) (((q63_t) b * c) >> 32);
;;;244    
;;;245        mul1 = (mul1 >> 1);
;;;246        mul2 = (mul2 >> 1);
;;;247        mul3 = (mul3 >> 1);
;;;248        mul4 = (mul4 >> 1);
;;;249    
;;;250        out1 = mul1 - mul2;
;;;251        out2 = mul3 + mul4;
;;;252    
;;;253        /* store the real result in 3.29 format in the destination buffer. */
;;;254        *pDst++ = out1;
;;;255        /* store the imag result in 3.29 format in the destination buffer. */
;;;256        *pDst++ = out2;
;;;257    
;;;258        a = *pSrcA++;
;;;259        b = *pSrcA++;
;;;260        c = *pSrcB++;
;;;261        d = *pSrcB++;
;;;262    
;;;263        mul1 = (q31_t) (((q63_t) a * c) >> 32);
;;;264        mul2 = (q31_t) (((q63_t) b * d) >> 32);
;;;265        mul3 = (q31_t) (((q63_t) a * d) >> 32);
;;;266        mul4 = (q31_t) (((q63_t) b * c) >> 32);
;;;267    
;;;268        mul1 = (mul1 >> 1);
;;;269        mul2 = (mul2 >> 1);
;;;270        mul3 = (mul3 >> 1);
;;;271        mul4 = (mul4 >> 1);
;;;272    
;;;273        out1 = mul1 - mul2;
;;;274        out2 = mul3 + mul4;
;;;275    
;;;276        /* store the real result in 3.29 format in the destination buffer. */
;;;277        *pDst++ = out1;
;;;278        /* store the imag result in 3.29 format in the destination buffer. */
;;;279        *pDst++ = out2;
;;;280    
;;;281        /* Decrement the blockSize loop counter */
;;;282        blkCnt--;
;;;283      }
;;;284    
;;;285      /* If the blockSize is not a multiple of 2, compute any remaining output samples here.     
;;;286       ** No loop unrolling is used. */
;;;287      blkCnt = numSamples % 0x2u;
;;;288    
;;;289      while(blkCnt > 0u)
;;;290      {
;;;291        /* C[2 * i] = A[2 * i] * B[2 * i] - A[2 * i + 1] * B[2 * i + 1].  */
;;;292        /* C[2 * i + 1] = A[2 * i] * B[2 * i + 1] + A[2 * i + 1] * B[2 * i].  */
;;;293        a = *pSrcA++;
;;;294        b = *pSrcA++;
;;;295        c = *pSrcB++;
;;;296        d = *pSrcB++;
;;;297    
;;;298        mul1 = (q31_t) (((q63_t) a * c) >> 32);
;;;299        mul2 = (q31_t) (((q63_t) b * d) >> 32);
;;;300        mul3 = (q31_t) (((q63_t) a * d) >> 32);
;;;301        mul4 = (q31_t) (((q63_t) b * c) >> 32);
;;;302    
;;;303        mul1 = (mul1 >> 1);
;;;304        mul2 = (mul2 >> 1);
;;;305        mul3 = (mul3 >> 1);
;;;306        mul4 = (mul4 >> 1);
;;;307    
;;;308        out1 = mul1 - mul2;
;;;309        out2 = mul3 + mul4;
;;;310    
;;;311        /* store the real result in 3.29 format in the destination buffer. */
;;;312        *pDst++ = out1;
;;;313        /* store the imag result in 3.29 format in the destination buffer. */
;;;314        *pDst++ = out2;
;;;315    
;;;316        /* Decrement the blockSize loop counter */
;;;317        blkCnt--;
;;;318      }
;;;319    
;;;320    #endif /* #ifndef ARM_MATH_CM0_FAMILY */
;;;321    
;;;322    }
0000f0  e8bd83f0          POP      {r4-r9,pc}
;;;323    
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\ComplexMathFunctions\\arm_cmplx_mult_cmplx_q31.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___26_arm_cmplx_mult_cmplx_q31_c_77816546____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___26_arm_cmplx_mult_cmplx_q31_c_77816546____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___26_arm_cmplx_mult_cmplx_q31_c_77816546____REVSH|
#line 144
|__asm___26_arm_cmplx_mult_cmplx_q31_c_77816546____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___26_arm_cmplx_mult_cmplx_q31_c_77816546____RRX|
#line 300
|__asm___26_arm_cmplx_mult_cmplx_q31_c_77816546____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
