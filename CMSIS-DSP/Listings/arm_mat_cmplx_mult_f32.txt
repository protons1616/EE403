; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_mat_cmplx_mult_f32.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_mat_cmplx_mult_f32.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_mat_cmplx_mult_f32.crf src\MatrixFunctions\arm_mat_cmplx_mult_f32.c]
                          THUMB

                          AREA ||i.arm_mat_cmplx_mult_f32||, CODE, READONLY, ALIGN=2

                  arm_mat_cmplx_mult_f32 PROC
;;;72     
;;;73     arm_status arm_mat_cmplx_mult_f32(
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;74       const arm_matrix_instance_f32 * pSrcA,
;;;75       const arm_matrix_instance_f32 * pSrcB,
;;;76       arm_matrix_instance_f32 * pDst)
;;;77     {
000004  468a              MOV      r10,r1
;;;78       float32_t *pIn1 = pSrcA->pData;                /* input data matrix pointer A */
;;;79       float32_t *pIn2 = pSrcB->pData;                /* input data matrix pointer B */
;;;80       float32_t *pInA = pSrcA->pData;                /* input data matrix pointer A  */
;;;81       float32_t *pOut = pDst->pData;                 /* output data matrix pointer */
;;;82       float32_t *px;                                 /* Temporary output data matrix pointer */
;;;83       uint16_t numRowsA = pSrcA->numRows;            /* number of rows of input matrix A */
;;;84       uint16_t numColsB = pSrcB->numCols;            /* number of columns of input matrix B */
000006  f8d2b004          LDR      r11,[r2,#4]
00000a  6841              LDR      r1,[r0,#4]            ;81
00000c  f8b0e000          LDRH     lr,[r0,#0]            ;83
000010  f8ba2002          LDRH     r2,[r10,#2]
;;;85       uint16_t numColsA = pSrcA->numCols;            /* number of columns of input matrix A */
000014  f8b08002          LDRH     r8,[r0,#2]
;;;86       float32_t sumReal1, sumImag1;                  /* accumulator */
;;;87       float32_t a0, b0, c0, d0;
;;;88       float32_t a1, b1, c1, d1;
;;;89       float32_t sumReal2, sumImag2;                  /* accumulator */
;;;90     
;;;91     
;;;92       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;93     
;;;94       uint16_t col, i = 0u, j, row = numRowsA, colCnt;      /* loop counters */
000018  f04f0c00          MOV      r12,#0
;;;95       arm_status status;                             /* status of matrix multiplication */
;;;96     
;;;97     #ifdef ARM_MATH_MATRIX_CHECK
;;;98     
;;;99     
;;;100      /* Check for matrix mismatch condition */
;;;101      if((pSrcA->numCols != pSrcB->numRows) ||
;;;102         (pSrcA->numRows != pDst->numRows) || (pSrcB->numCols != pDst->numCols))
;;;103      {
;;;104    
;;;105        /* Set status as ARM_MATH_SIZE_MISMATCH */
;;;106        status = ARM_MATH_SIZE_MISMATCH;
;;;107      }
;;;108      else
;;;109    #endif /*      #ifdef ARM_MATH_MATRIX_CHECK    */
;;;110    
;;;111      {
;;;112        /* The following loop performs the dot-product of each row in pSrcA with each column in pSrcB */
;;;113        /* row loop */
;;;114        do
;;;115        {
;;;116          /* Output pointer is set to starting address of the row being processed */
;;;117          px = pOut + 2 * i;
;;;118    
;;;119          /* For every row wise process, the column loop counter is to be initiated */
;;;120          col = numColsB;
;;;121    
;;;122          /* For every row wise process, the pIn2 pointer is set      
;;;123           ** to the starting address of the pSrcB data */
;;;124          pIn2 = pSrcB->pData;
;;;125    
;;;126          j = 0u;
;;;127    
;;;128          /* column loop */
;;;129          do
;;;130          {
;;;131            /* Set the variable sum, that acts as accumulator, to zero */
;;;132            sumReal1 = 0.0f;
00001c  eddf3a4f          VLDR     s7,|L1.348|
;;;133            sumImag1 = 0.0f;
;;;134    
;;;135            sumReal2 = 0.0f;
;;;136            sumImag2 = 0.0f;
;;;137    
;;;138            /* Initiate the pointer pIn1 to point to the starting address of the column being processed */
;;;139            pIn1 = pInA;
;;;140    
;;;141            /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;142            colCnt = numColsA >> 2;
000020  ea4f0998          LSR      r9,r8,#2
                  |L1.36|
000024  f8da3004          LDR      r3,[r10,#4]           ;126
000028  eb0b04cc          ADD      r4,r11,r12,LSL #3     ;117
00002c  4616              MOV      r6,r2                 ;120
00002e  2700              MOVS     r7,#0                 ;126
                  |L1.48|
000030  eef01a63          VMOV.F32 s3,s7                 ;132
000034  4608              MOV      r0,r1                 ;139
000036  eeb00a61          VMOV.F32 s0,s3                 ;132
00003a  eef00a61          VMOV.F32 s1,s3                 ;133
00003e  eeb01a61          VMOV.F32 s2,s3                 ;135
000042  464d              MOV      r5,r9                 ;139
;;;143    
;;;144            /* matrix multiplication        */
;;;145            while(colCnt > 0u)
000044  e04b              B        |L1.222|
;;;146            {
;;;147    
;;;148              /* Reading real part of complex matrix A */
;;;149              a0 = *pIn1;
000046  bf00              NOP      
                  |L1.72|
;;;150    
;;;151              /* Reading real part of complex matrix B */
;;;152              c0 = *pIn2;
000048  edd32a00          VLDR     s5,[r3,#0]
;;;153    
;;;154              /* Reading imaginary part of complex matrix A */
;;;155              b0 = *(pIn1 + 1u);
;;;156    
;;;157              /* Reading imaginary part of complex matrix B */
;;;158              d0 = *(pIn2 + 1u);
00004c  ed933a01          VLDR     s6,[r3,#4]
000050  ed902a00          VLDR     s4,[r0,#0]            ;149
000054  ed904a01          VLDR     s8,[r0,#4]            ;155
;;;159    
;;;160              sumReal1 += a0 * c0;
;;;161              sumImag1 += b0 * c0;
;;;162    
;;;163              pIn1 += 2u;
;;;164              pIn2 += 2 * numColsB;
000058  eb0303c2          ADD      r3,r3,r2,LSL #3
00005c  ee020a22          VMLA.F32 s0,s4,s5              ;160
000060  ee440a22          VMLA.F32 s1,s8,s5              ;161
;;;165    
;;;166              sumReal2 -= b0 * d0;
000064  ee041a43          VMLS.F32 s2,s8,s6
;;;167              sumImag2 += a0 * d0;
000068  ee421a03          VMLA.F32 s3,s4,s6
;;;168    
;;;169              /* c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n) */
;;;170    
;;;171              a1 = *pIn1;
;;;172              c1 = *pIn2;
00006c  ed933a00          VLDR     s6,[r3,#0]
000070  ed902a02          VLDR     s4,[r0,#8]            ;171
;;;173    
;;;174              b1 = *(pIn1 + 1u);
000074  ed904a03          VLDR     s8,[r0,#0xc]
;;;175              d1 = *(pIn2 + 1u);
000078  edd32a01          VLDR     s5,[r3,#4]
;;;176    
;;;177              sumReal1 += a1 * c1;
;;;178              sumImag1 += b1 * c1;
;;;179    
;;;180              pIn1 += 2u;
;;;181              pIn2 += 2 * numColsB;
00007c  eb0303c2          ADD      r3,r3,r2,LSL #3
000080  ee020a03          VMLA.F32 s0,s4,s6              ;177
000084  ee440a03          VMLA.F32 s1,s8,s6              ;178
;;;182    
;;;183              sumReal2 -= b1 * d1;
000088  ee041a62          VMLS.F32 s2,s8,s5
;;;184              sumImag2 += a1 * d1;
00008c  ee421a22          VMLA.F32 s3,s4,s5
;;;185    
;;;186              a0 = *pIn1;
000090  ed902a04          VLDR     s4,[r0,#0x10]
;;;187              c0 = *pIn2;
000094  ed934a00          VLDR     s8,[r3,#0]
;;;188    
;;;189              b0 = *(pIn1 + 1u);
;;;190              d0 = *(pIn2 + 1u);
000098  edd32a01          VLDR     s5,[r3,#4]
00009c  ed903a05          VLDR     s6,[r0,#0x14]         ;189
;;;191    
;;;192              sumReal1 += a0 * c0;
;;;193              sumImag1 += b0 * c0;
;;;194    
;;;195              pIn1 += 2u;
;;;196              pIn2 += 2 * numColsB;
0000a0  eb0303c2          ADD      r3,r3,r2,LSL #3
;;;197    
;;;198              sumReal2 -= b0 * d0;
;;;199              sumImag2 += a0 * d0;
0000a4  ee421a22          VMLA.F32 s3,s4,s5
0000a8  ee430a04          VMLA.F32 s1,s6,s8              ;193
0000ac  ee020a04          VMLA.F32 s0,s4,s8              ;192
0000b0  ee031a62          VMLS.F32 s2,s6,s5              ;198
;;;200    
;;;201              /* c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n) */
;;;202    
;;;203              a1 = *pIn1;
0000b4  ed902a06          VLDR     s4,[r0,#0x18]
;;;204              c1 = *pIn2;
0000b8  ed933a00          VLDR     s6,[r3,#0]
;;;205    
;;;206              b1 = *(pIn1 + 1u);
0000bc  edd02a07          VLDR     s5,[r0,#0x1c]
;;;207              d1 = *(pIn2 + 1u);
0000c0  ed934a01          VLDR     s8,[r3,#4]
;;;208    
;;;209              sumReal1 += a1 * c1;
0000c4  ee020a03          VMLA.F32 s0,s4,s6
;;;210              sumImag1 += b1 * c1;
0000c8  ee420a83          VMLA.F32 s1,s5,s6
;;;211    
;;;212              pIn1 += 2u;
;;;213              pIn2 += 2 * numColsB;
;;;214    
;;;215              sumReal2 -= b1 * d1;
0000cc  ee021ac4          VMLS.F32 s2,s5,s8
;;;216              sumImag2 += a1 * d1;
0000d0  ee421a04          VMLA.F32 s3,s4,s8
0000d4  1e6d              SUBS     r5,r5,#1
0000d6  eb0303c2          ADD      r3,r3,r2,LSL #3       ;213
;;;217    
;;;218              /* Decrement the loop count */
;;;219              colCnt--;
0000da  b2ad              UXTH     r5,r5
0000dc  3020              ADDS     r0,r0,#0x20
                  |L1.222|
0000de  2d00              CMP      r5,#0                 ;145
0000e0  d1b2              BNE      |L1.72|
;;;220            }
;;;221    
;;;222            /* If the columns of pSrcA is not a multiple of 4, compute any remaining MACs here.      
;;;223             ** No loop unrolling is used. */
;;;224            colCnt = numColsA % 0x4u;
0000e2  f0080503          AND      r5,r8,#3
;;;225    
;;;226            while(colCnt > 0u)
0000e6  e014              B        |L1.274|
                  |L1.232|
;;;227            {
;;;228              /* c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n) */
;;;229              a1 = *pIn1;
0000e8  ed903a00          VLDR     s6,[r0,#0]
;;;230              c1 = *pIn2;
0000ec  ed932a00          VLDR     s4,[r3,#0]
;;;231    
;;;232              b1 = *(pIn1 + 1u);
0000f0  edd02a01          VLDR     s5,[r0,#4]
;;;233              d1 = *(pIn2 + 1u);
0000f4  ed934a01          VLDR     s8,[r3,#4]
;;;234    
;;;235              sumReal1 += a1 * c1;
0000f8  ee030a02          VMLA.F32 s0,s6,s4
;;;236              sumImag1 += b1 * c1;
0000fc  ee420a82          VMLA.F32 s1,s5,s4
;;;237    
;;;238              pIn1 += 2u;
;;;239              pIn2 += 2 * numColsB;
;;;240    
;;;241              sumReal2 -= b1 * d1;
000100  ee021ac4          VMLS.F32 s2,s5,s8
;;;242              sumImag2 += a1 * d1;
000104  ee431a04          VMLA.F32 s3,s6,s8
000108  1e6d              SUBS     r5,r5,#1
00010a  eb0303c2          ADD      r3,r3,r2,LSL #3       ;239
;;;243    
;;;244              /* Decrement the loop counter */
;;;245              colCnt--;
00010e  b2ad              UXTH     r5,r5
000110  3008              ADDS     r0,r0,#8
                  |L1.274|
000112  2d00              CMP      r5,#0                 ;226
000114  d1e8              BNE      |L1.232|
;;;246            }
;;;247    
;;;248            sumReal1 += sumReal2;
000116  ee300a01          VADD.F32 s0,s0,s2
;;;249            sumImag1 += sumImag2;
00011a  ee700aa1          VADD.F32 s1,s1,s3
;;;250    
;;;251            /* Store the result in the destination buffer */
;;;252            *px++ = sumReal1;
;;;253            *px++ = sumImag1;
00011e  1c7f              ADDS     r7,r7,#1
000120  ed840a00          VSTR     s0,[r4,#0]            ;252
000124  edc40a01          VSTR     s1,[r4,#4]
;;;254    
;;;255            /* Update the pointer pIn2 to point to the  starting address of the next column */
;;;256            j++;
;;;257            pIn2 = pSrcB->pData + 2u * j;
000128  3408              ADDS     r4,r4,#8
00012a  f8da0004          LDR      r0,[r10,#4]
00012e  1e76              SUBS     r6,r6,#1
000130  b2bf              UXTH     r7,r7                 ;256
;;;258    
;;;259            /* Decrement the column loop counter */
;;;260            col--;
000132  0436              LSLS     r6,r6,#16
000134  eb0003c7          ADD      r3,r0,r7,LSL #3       ;257
000138  0c36              LSRS     r6,r6,#16
;;;261    
;;;262          } while(col > 0u);
00013a  f47faf79          BNE      |L1.48|
;;;263    
;;;264          /* Update the pointer pInA to point to the  starting address of the next row */
;;;265          i = i + numColsB;
00013e  eb0c0002          ADD      r0,r12,r2
000142  fa1ffc80          UXTH     r12,r0
;;;266          pInA = pInA + 2 * numColsA;
;;;267    
;;;268          /* Decrement the row loop counter */
;;;269          row--;
000146  f1ae0001          SUB      r0,lr,#1
00014a  0400              LSLS     r0,r0,#16
00014c  0c00              LSRS     r0,r0,#16
00014e  eb0101c8          ADD      r1,r1,r8,LSL #3       ;266
000152  4686              MOV      lr,r0
;;;270    
;;;271        } while(row > 0u);
000154  f47faf66          BNE      |L1.36|
;;;272    
;;;273        /* Set status as ARM_MATH_SUCCESS */
;;;274        status = ARM_MATH_SUCCESS;
;;;275      }
;;;276    
;;;277      /* Return to application */
;;;278      return (status);
;;;279    }
000158  e8bd8ff0          POP      {r4-r11,pc}
;;;280    
                          ENDP

                  |L1.348|
00015c  00000000          DCFS     0x00000000 ; 0

;*** Start embedded assembler ***

#line 1 "src\\MatrixFunctions\\arm_mat_cmplx_mult_f32.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___24_arm_mat_cmplx_mult_f32_c_6efc6a0b____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___24_arm_mat_cmplx_mult_f32_c_6efc6a0b____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___24_arm_mat_cmplx_mult_f32_c_6efc6a0b____REVSH|
#line 144
|__asm___24_arm_mat_cmplx_mult_f32_c_6efc6a0b____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___24_arm_mat_cmplx_mult_f32_c_6efc6a0b____RRX|
#line 300
|__asm___24_arm_mat_cmplx_mult_f32_c_6efc6a0b____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
