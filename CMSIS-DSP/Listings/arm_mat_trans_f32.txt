; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_mat_trans_f32.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_mat_trans_f32.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_mat_trans_f32.crf src\MatrixFunctions\arm_mat_trans_f32.c]
                          THUMB

                          AREA ||i.arm_mat_trans_f32||, CODE, READONLY, ALIGN=1

                  arm_mat_trans_f32 PROC
;;;68     
;;;69     arm_status arm_mat_trans_f32(
000000  b5f0              PUSH     {r4-r7,lr}
;;;70       const arm_matrix_instance_f32 * pSrc,
;;;71       arm_matrix_instance_f32 * pDst)
;;;72     {
;;;73       float32_t *pIn = pSrc->pData;                  /* input data matrix pointer */
;;;74       float32_t *pOut = pDst->pData;                 /* output data matrix pointer */
;;;75       float32_t *px;                                 /* Temporary output data matrix pointer */
;;;76       uint16_t nRows = pSrc->numRows;                /* number of rows */
000002  684f              LDR      r7,[r1,#4]
000004  8801              LDRH     r1,[r0,#0]
;;;77       uint16_t nColumns = pSrc->numCols;             /* number of columns */
000006  8846              LDRH     r6,[r0,#2]
000008  6842              LDR      r2,[r0,#4]            ;74
;;;78     
;;;79     #ifndef ARM_MATH_CM0_FAMILY
;;;80     
;;;81       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;82     
;;;83       uint16_t blkCnt, i = 0u, row = nRows;          /* loop counters */
00000a  2400              MOVS     r4,#0
00000c  460b              MOV      r3,r1
;;;84       arm_status status;                             /* status of matrix transpose  */
;;;85     
;;;86     
;;;87     #ifdef ARM_MATH_MATRIX_CHECK
;;;88     
;;;89     
;;;90       /* Check for matrix mismatch condition */
;;;91       if((pSrc->numRows != pDst->numCols) || (pSrc->numCols != pDst->numRows))
;;;92       {
;;;93         /* Set status as ARM_MATH_SIZE_MISMATCH */
;;;94         status = ARM_MATH_SIZE_MISMATCH;
;;;95       }
;;;96       else
;;;97     #endif /*    #ifdef ARM_MATH_MATRIX_CHECK    */
;;;98     
;;;99       {
;;;100        /* Matrix transpose by exchanging the rows with columns */
;;;101        /* row loop     */
;;;102        do
;;;103        {
;;;104          /* Loop Unrolling */
;;;105          blkCnt = nColumns >> 2;
00000e  08b5              LSRS     r5,r6,#2
                  |L1.16|
000010  4628              MOV      r0,r5
;;;106    
;;;107          /* The pointer px is set to starting address of the column being processed */
;;;108          px = pOut + i;
000012  eb070c84          ADD      r12,r7,r4,LSL #2
;;;109    
;;;110          /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.    
;;;111           ** a second loop below computes the remaining 1 to 3 samples. */
;;;112          while(blkCnt > 0u)        /* column loop */
000016  e01a              B        |L1.78|
                  |L1.24|
;;;113          {
;;;114            /* Read and store the input element in the destination */
;;;115            *px = *pIn++;
000018  ed920a00          VLDR     s0,[r2,#0]
;;;116    
;;;117            /* Update the pointer px to point to the next row of the transposed matrix */
;;;118            px += nRows;
;;;119    
;;;120            /* Read and store the input element in the destination */
;;;121            *px = *pIn++;
;;;122    
;;;123            /* Update the pointer px to point to the next row of the transposed matrix */
;;;124            px += nRows;
;;;125    
;;;126            /* Read and store the input element in the destination */
;;;127            *px = *pIn++;
;;;128    
;;;129            /* Update the pointer px to point to the next row of the transposed matrix */
;;;130            px += nRows;
;;;131    
;;;132            /* Read and store the input element in the destination */
;;;133            *px = *pIn++;
;;;134    
;;;135            /* Update the pointer px to point to the next row of the transposed matrix */
;;;136            px += nRows;
00001c  1e40              SUBS     r0,r0,#1
00001e  ed8c0a00          VSTR     s0,[r12,#0]           ;115
000022  eb0c0c81          ADD      r12,r12,r1,LSL #2     ;118
000026  ed920a01          VLDR     s0,[r2,#4]            ;121
;;;137    
;;;138            /* Decrement the column loop counter */
;;;139            blkCnt--;
00002a  b280              UXTH     r0,r0
00002c  ed8c0a00          VSTR     s0,[r12,#0]           ;121
000030  eb0c0c81          ADD      r12,r12,r1,LSL #2     ;124
000034  ed920a02          VLDR     s0,[r2,#8]            ;127
000038  ed8c0a00          VSTR     s0,[r12,#0]           ;127
00003c  eb0c0c81          ADD      r12,r12,r1,LSL #2     ;130
000040  ed920a03          VLDR     s0,[r2,#0xc]          ;133
000044  3210              ADDS     r2,r2,#0x10
000046  ed8c0a00          VSTR     s0,[r12,#0]           ;133
00004a  eb0c0c81          ADD      r12,r12,r1,LSL #2     ;136
                  |L1.78|
00004e  2800              CMP      r0,#0                 ;112
000050  d1e2              BNE      |L1.24|
;;;140          }
;;;141    
;;;142          /* Perform matrix transpose for last 3 samples here. */
;;;143          blkCnt = nColumns % 0x4u;
000052  f0060003          AND      r0,r6,#3
;;;144    
;;;145          while(blkCnt > 0u)
000056  e007              B        |L1.104|
                  |L1.88|
;;;146          {
;;;147            /* Read and store the input element in the destination */
;;;148            *px = *pIn++;
000058  ecb20a01          VLDM     r2!,{s0}
;;;149    
;;;150            /* Update the pointer px to point to the next row of the transposed matrix */
;;;151            px += nRows;
00005c  1e40              SUBS     r0,r0,#1
;;;152    
;;;153            /* Decrement the column loop counter */
;;;154            blkCnt--;
00005e  b280              UXTH     r0,r0
000060  ed8c0a00          VSTR     s0,[r12,#0]           ;148
000064  eb0c0c81          ADD      r12,r12,r1,LSL #2     ;151
                  |L1.104|
000068  2800              CMP      r0,#0                 ;145
00006a  d1f5              BNE      |L1.88|
00006c  1c64              ADDS     r4,r4,#1              ;145
;;;155          }
;;;156    
;;;157    #else
;;;158    
;;;159      /* Run the below code for Cortex-M0 */
;;;160    
;;;161      uint16_t col, i = 0u, row = nRows;             /* loop counters */
;;;162      arm_status status;                             /* status of matrix transpose  */
;;;163    
;;;164    
;;;165    #ifdef ARM_MATH_MATRIX_CHECK
;;;166    
;;;167      /* Check for matrix mismatch condition */
;;;168      if((pSrc->numRows != pDst->numCols) || (pSrc->numCols != pDst->numRows))
;;;169      {
;;;170        /* Set status as ARM_MATH_SIZE_MISMATCH */
;;;171        status = ARM_MATH_SIZE_MISMATCH;
;;;172      }
;;;173      else
;;;174    #endif /*      #ifdef ARM_MATH_MATRIX_CHECK    */
;;;175    
;;;176      {
;;;177        /* Matrix transpose by exchanging the rows with columns */
;;;178        /* row loop     */
;;;179        do
;;;180        {
;;;181          /* The pointer px is set to starting address of the column being processed */
;;;182          px = pOut + i;
;;;183    
;;;184          /* Initialize column loop counter */
;;;185          col = nColumns;
;;;186    
;;;187          while(col > 0u)
;;;188          {
;;;189            /* Read and store the input element in the destination */
;;;190            *px = *pIn++;
;;;191    
;;;192            /* Update the pointer px to point to the next row of the transposed matrix */
;;;193            px += nRows;
;;;194    
;;;195            /* Decrement the column loop counter */
;;;196            col--;
;;;197          }
;;;198    
;;;199    #endif /* #ifndef ARM_MATH_CM0_FAMILY */
;;;200    
;;;201          i++;
00006e  1e5b              SUBS     r3,r3,#1
;;;202    
;;;203          /* Decrement the row loop counter */
;;;204          row--;
000070  041b              LSLS     r3,r3,#16
000072  b2a4              UXTH     r4,r4                 ;201
000074  0c1b              LSRS     r3,r3,#16
;;;205    
;;;206        } while(row > 0u);          /* row loop end  */
000076  d1cb              BNE      |L1.16|
;;;207    
;;;208        /* Set status as ARM_MATH_SUCCESS */
;;;209        status = ARM_MATH_SUCCESS;
;;;210      }
;;;211    
;;;212      /* Return to application */
;;;213      return (status);
;;;214    }
000078  bdf0              POP      {r4-r7,pc}
;;;215    
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\MatrixFunctions\\arm_mat_trans_f32.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_mat_trans_f32_c_57f6fe7b____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___19_arm_mat_trans_f32_c_57f6fe7b____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_mat_trans_f32_c_57f6fe7b____REVSH|
#line 144
|__asm___19_arm_mat_trans_f32_c_57f6fe7b____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_mat_trans_f32_c_57f6fe7b____RRX|
#line 300
|__asm___19_arm_mat_trans_f32_c_57f6fe7b____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
