; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_mat_sub_q31.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_mat_sub_q31.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_mat_sub_q31.crf src\MatrixFunctions\arm_mat_sub_q31.c]
                          THUMB

                          AREA ||i.arm_mat_sub_q31||, CODE, READONLY, ALIGN=1

                  arm_mat_sub_q31 PROC
;;;66     
;;;67     arm_status arm_mat_sub_q31(
000000  b5f0              PUSH     {r4-r7,lr}
;;;68       const arm_matrix_instance_q31 * pSrcA,
;;;69       const arm_matrix_instance_q31 * pSrcB,
;;;70       arm_matrix_instance_q31 * pDst)
;;;71     {
;;;72       q31_t *pIn1 = pSrcA->pData;                    /* input data matrix pointer A */
;;;73       q31_t *pIn2 = pSrcB->pData;                    /* input data matrix pointer B */
000002  6843              LDR      r3,[r0,#4]
;;;74       q31_t *pOut = pDst->pData;                     /* output data matrix pointer */
;;;75       q31_t inA1, inB1;                              /* temporary variables */
;;;76     
;;;77     #ifndef ARM_MATH_CM0_FAMILY
;;;78     
;;;79       q31_t inA2, inB2;                              /* temporary variables */
;;;80       q31_t out1, out2;                              /* temporary variables */
;;;81     
;;;82     #endif //      #ifndef ARM_MATH_CM0_FAMILY
;;;83     
;;;84       uint32_t numSamples;                           /* total number of elements in the matrix  */
;;;85       uint32_t blkCnt;                               /* loop counters */
;;;86       arm_status status;                             /* status of matrix subtraction */
;;;87     
;;;88     
;;;89     #ifdef ARM_MATH_MATRIX_CHECK
;;;90       /* Check for matrix mismatch condition  */
;;;91       if((pSrcA->numRows != pSrcB->numRows) ||
;;;92          (pSrcA->numCols != pSrcB->numCols) ||
;;;93          (pSrcA->numRows != pDst->numRows) || (pSrcA->numCols != pDst->numCols))
;;;94       {
;;;95         /* Set status as ARM_MATH_SIZE_MISMATCH */
;;;96         status = ARM_MATH_SIZE_MISMATCH;
;;;97       }
;;;98       else
;;;99     #endif
;;;100      {
;;;101        /* Total number of samples in the input matrix */
;;;102        numSamples = (uint32_t) pSrcA->numRows * pSrcA->numCols;
000004  8804              LDRH     r4,[r0,#0]
000006  8840              LDRH     r0,[r0,#2]
000008  6849              LDR      r1,[r1,#4]            ;73
00000a  4344              MULS     r4,r0,r4
00000c  6852              LDR      r2,[r2,#4]            ;74
;;;103    
;;;104    #ifndef ARM_MATH_CM0_FAMILY
;;;105    
;;;106        /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;107    
;;;108        /* Loop Unrolling */
;;;109        blkCnt = numSamples >> 2u;
00000e  08a0              LSRS     r0,r4,#2
000010  e018              B        |L1.68|
                  |L1.18|
;;;110    
;;;111        /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.    
;;;112         ** a second loop below computes the remaining 1 to 3 samples. */
;;;113        while(blkCnt > 0u)
;;;114        {
;;;115          /* C(m,n) = A(m,n) - B(m,n) */
;;;116          /* Subtract, saturate and then store the results in the destination buffer. */
;;;117          /* Read values from source A */
;;;118          inA1 = pIn1[0];
000012  cb80              LDM      r3!,{r7}
;;;119    
;;;120          /* Read values from source B */
;;;121          inB1 = pIn2[0];
000014  c940              LDM      r1!,{r6}
;;;122    
;;;123          /* Read values from source A */
;;;124          inA2 = pIn1[1];
000016  cb20              LDM      r3!,{r5}
;;;125    
;;;126          /* Subtract and saturate */
;;;127          out1 = __QSUB(inA1, inB1);
000018  fa86f6a7          QSUB     r6,r7,r6
;;;128    
;;;129          /* Read values from source B */
;;;130          inB2 = pIn2[1];
00001c  c980              LDM      r1!,{r7}
;;;131    
;;;132          /* Read values from source A */
;;;133          inA1 = pIn1[2];
00001e  f853cb08          LDR      r12,[r3],#8
;;;134    
;;;135          /* Subtract and saturate */
;;;136          out2 = __QSUB(inA2, inB2);
000022  fa87f7a5          QSUB     r7,r5,r7
;;;137    
;;;138          /* Read values from source B */
;;;139          inB1 = pIn2[2];
000026  f8515b08          LDR      r5,[r1],#8
00002a  e8e26702          STRD     r6,r7,[r2],#8
;;;140    
;;;141          /* Store result in destination */
;;;142          pOut[0] = out1;
;;;143          pOut[1] = out2;
;;;144    
;;;145          /* Read values from source A */
;;;146          inA2 = pIn1[3];
00002e  f8536c04          LDR      r6,[r3,#-4]
;;;147    
;;;148          /* Read values from source B */
;;;149          inB2 = pIn2[3];
000032  f8517c04          LDR      r7,[r1,#-4]
;;;150    
;;;151          /* Subtract and saturate */
;;;152          out1 = __QSUB(inA1, inB1);
000036  fa85f5ac          QSUB     r5,r12,r5
;;;153    
;;;154          /* Subtract and saturate */
;;;155          out2 = __QSUB(inA2, inB2);
00003a  fa87f6a6          QSUB     r6,r6,r7
00003e  e8e25602          STRD     r5,r6,[r2],#8
000042  1e40              SUBS     r0,r0,#1
                  |L1.68|
000044  2800              CMP      r0,#0                 ;113
000046  d1e4              BNE      |L1.18|
;;;156    
;;;157          /* Store result in destination */
;;;158          pOut[2] = out1;
;;;159          pOut[3] = out2;
;;;160    
;;;161          /* update pointers to process next samples */
;;;162          pIn1 += 4u;
;;;163          pIn2 += 4u;
;;;164          pOut += 4u;
;;;165    
;;;166          /* Decrement the loop counter */
;;;167          blkCnt--;
;;;168        }
;;;169    
;;;170        /* If the numSamples is not a multiple of 4, compute any remaining output samples here.        
;;;171         ** No loop unrolling is used. */
;;;172        blkCnt = numSamples % 0x4u;
000048  f0040003          AND      r0,r4,#3
;;;173    
;;;174    #else
;;;175    
;;;176        /* Run the below code for Cortex-M0 */
;;;177    
;;;178        /* Initialize blkCnt with number of samples */
;;;179        blkCnt = numSamples;
;;;180    
;;;181    #endif /* #ifndef ARM_MATH_CM0_FAMILY */
;;;182    
;;;183        while(blkCnt > 0u)
00004c  e005              B        |L1.90|
                  |L1.78|
;;;184        {
;;;185          /* C(m,n) = A(m,n) - B(m,n) */
;;;186          /* Subtract, saturate and then store the results in the destination buffer. */
;;;187          inA1 = *pIn1++;
00004e  cb10              LDM      r3!,{r4}
;;;188          inB1 = *pIn2++;
000050  c920              LDM      r1!,{r5}
;;;189    
;;;190          inA1 = __QSUB(inA1, inB1);
000052  fa85f4a4          QSUB     r4,r4,r5
;;;191    
;;;192          *pOut++ = inA1;
000056  c210              STM      r2!,{r4}
000058  1e40              SUBS     r0,r0,#1
                  |L1.90|
00005a  2800              CMP      r0,#0                 ;183
00005c  d1f7              BNE      |L1.78|
;;;193    
;;;194          /* Decrement the loop counter */
;;;195          blkCnt--;
;;;196        }
;;;197    
;;;198        /* Set status as ARM_MATH_SUCCESS */
;;;199        status = ARM_MATH_SUCCESS;
;;;200      }
;;;201    
;;;202      /* Return to application */
;;;203      return (status);
;;;204    }
00005e  bdf0              POP      {r4-r7,pc}
;;;205    
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\MatrixFunctions\\arm_mat_sub_q31.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___17_arm_mat_sub_q31_c_a27e58eb____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___17_arm_mat_sub_q31_c_a27e58eb____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___17_arm_mat_sub_q31_c_a27e58eb____REVSH|
#line 144
|__asm___17_arm_mat_sub_q31_c_a27e58eb____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___17_arm_mat_sub_q31_c_a27e58eb____RRX|
#line 300
|__asm___17_arm_mat_sub_q31_c_a27e58eb____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
