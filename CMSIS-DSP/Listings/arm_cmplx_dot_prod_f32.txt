; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_cmplx_dot_prod_f32.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_cmplx_dot_prod_f32.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_cmplx_dot_prod_f32.crf src\ComplexMathFunctions\arm_cmplx_dot_prod_f32.c]
                          THUMB

                          AREA ||i.arm_cmplx_dot_prod_f32||, CODE, READONLY, ALIGN=2

                  arm_cmplx_dot_prod_f32 PROC
;;;87     
;;;88     void arm_cmplx_dot_prod_f32(
000000  b530              PUSH     {r4,r5,lr}
;;;89       float32_t * pSrcA,
;;;90       float32_t * pSrcB,
;;;91       uint32_t numSamples,
;;;92       float32_t * realResult,
;;;93       float32_t * imagResult)
;;;94     {
;;;95       float32_t real_sum = 0.0f, imag_sum = 0.0f;    /* Temporary result storage */
000002  ed9f0a34          VLDR     s0,|L1.212|
;;;96       float32_t a0,b0,c0,d0;
;;;97     
;;;98     #ifndef ARM_MATH_CM0_FAMILY
;;;99     
;;;100      /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;101      uint32_t blkCnt;                               /* loop counter */
;;;102    
;;;103      /*loop Unrolling */
;;;104      blkCnt = numSamples >> 2u;
000006  0894              LSRS     r4,r2,#2
000008  9d03              LDR      r5,[sp,#0xc]          ;94
00000a  eef00a40          VMOV.F32 s1,s0                 ;95
00000e  e042              B        |L1.150|
                  |L1.16|
;;;105    
;;;106      /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.    
;;;107       ** a second loop below computes the remaining 1 to 3 samples. */
;;;108      while(blkCnt > 0u)
;;;109      {
;;;110          a0 = *pSrcA++;
000010  edd02a00          VLDR     s5,[r0,#0]
;;;111          b0 = *pSrcA++;
;;;112          c0 = *pSrcB++;
000014  ed911a00          VLDR     s2,[r1,#0]
;;;113          d0 = *pSrcB++;  
000018  ed912a01          VLDR     s4,[r1,#4]
00001c  edd01a01          VLDR     s3,[r0,#4]            ;111
;;;114      
;;;115          real_sum += a0 * c0;
000020  ee020a81          VMLA.F32 s0,s5,s2
;;;116          imag_sum += a0 * d0;
000024  ee420a82          VMLA.F32 s1,s5,s4
;;;117          real_sum -= b0 * d0;
;;;118          imag_sum += b0 * c0;
;;;119        
;;;120          a0 = *pSrcA++;
;;;121          b0 = *pSrcA++;
;;;122          c0 = *pSrcB++;
000028  edd12a02          VLDR     s5,[r1,#8]
00002c  ee010ac2          VMLS.F32 s0,s3,s4              ;117
000030  ee410a81          VMLA.F32 s1,s3,s2              ;118
000034  edd01a02          VLDR     s3,[r0,#8]            ;120
;;;123          d0 = *pSrcB++; 
000038  ed911a03          VLDR     s2,[r1,#0xc]
00003c  ed902a03          VLDR     s4,[r0,#0xc]          ;121
;;;124      
;;;125          real_sum += a0 * c0;
000040  ee010aa2          VMLA.F32 s0,s3,s5
;;;126          imag_sum += a0 * d0;
000044  ee410a81          VMLA.F32 s1,s3,s2
;;;127          real_sum -= b0 * d0;
;;;128          imag_sum += b0 * c0;
;;;129          
;;;130          a0 = *pSrcA++;
000048  edd01a04          VLDR     s3,[r0,#0x10]
00004c  ee020a41          VMLS.F32 s0,s4,s2              ;127
000050  ee420a22          VMLA.F32 s1,s4,s5              ;128
;;;131          b0 = *pSrcA++;
;;;132          c0 = *pSrcB++;
000054  ed912a04          VLDR     s4,[r1,#0x10]
;;;133          d0 = *pSrcB++;  
000058  edd12a05          VLDR     s5,[r1,#0x14]
00005c  ed901a05          VLDR     s2,[r0,#0x14]         ;131
;;;134      
;;;135          real_sum += a0 * c0;
000060  ee010a82          VMLA.F32 s0,s3,s4
;;;136          imag_sum += a0 * d0;
000064  ee410aa2          VMLA.F32 s1,s3,s5
;;;137          real_sum -= b0 * d0;
;;;138          imag_sum += b0 * c0;
;;;139        
;;;140          a0 = *pSrcA++;
;;;141          b0 = *pSrcA++;
;;;142          c0 = *pSrcB++;
000068  edd11a06          VLDR     s3,[r1,#0x18]
00006c  ee010a62          VMLS.F32 s0,s2,s5              ;137
000070  ee410a02          VMLA.F32 s1,s2,s4              ;138
000074  ed902a06          VLDR     s4,[r0,#0x18]         ;140
;;;143          d0 = *pSrcB++; 
000078  edd12a07          VLDR     s5,[r1,#0x1c]
00007c  ed901a07          VLDR     s2,[r0,#0x1c]         ;141
;;;144      
;;;145          real_sum += a0 * c0;
;;;146          imag_sum += a0 * d0;
;;;147          real_sum -= b0 * d0;
;;;148          imag_sum += b0 * c0;
000080  3020              ADDS     r0,r0,#0x20
000082  ee020a21          VMLA.F32 s0,s4,s3              ;145
000086  ee420a22          VMLA.F32 s1,s4,s5              ;146
00008a  3120              ADDS     r1,r1,#0x20
00008c  1e64              SUBS     r4,r4,#1
00008e  ee010a62          VMLS.F32 s0,s2,s5              ;147
000092  ee410a21          VMLA.F32 s1,s2,s3
                  |L1.150|
000096  2c00              CMP      r4,#0                 ;108
000098  d1ba              BNE      |L1.16|
;;;149    
;;;150          /* Decrement the loop counter */
;;;151          blkCnt--;
;;;152      }
;;;153    
;;;154      /* If the numSamples is not a multiple of 4, compute any remaining output samples here.    
;;;155       ** No loop unrolling is used. */
;;;156      blkCnt = numSamples & 0x3u;
00009a  f0020203          AND      r2,r2,#3
;;;157    
;;;158      while(blkCnt > 0u)
00009e  e012              B        |L1.198|
                  |L1.160|
;;;159      {
;;;160          a0 = *pSrcA++;
0000a0  edd02a00          VLDR     s5,[r0,#0]
;;;161          b0 = *pSrcA++;
;;;162          c0 = *pSrcB++;
0000a4  edd11a00          VLDR     s3,[r1,#0]
;;;163          d0 = *pSrcB++;  
0000a8  ed912a01          VLDR     s4,[r1,#4]
0000ac  ed901a01          VLDR     s2,[r0,#4]            ;161
;;;164      
;;;165          real_sum += a0 * c0;
0000b0  ee020aa1          VMLA.F32 s0,s5,s3
;;;166          imag_sum += a0 * d0;
0000b4  ee420a82          VMLA.F32 s1,s5,s4
;;;167          real_sum -= b0 * d0;
;;;168          imag_sum += b0 * c0;
0000b8  3008              ADDS     r0,r0,#8
0000ba  3108              ADDS     r1,r1,#8
0000bc  1e52              SUBS     r2,r2,#1
0000be  ee010a42          VMLS.F32 s0,s2,s4              ;167
0000c2  ee410a21          VMLA.F32 s1,s2,s3
                  |L1.198|
0000c6  2a00              CMP      r2,#0                 ;158
0000c8  d1ea              BNE      |L1.160|
;;;169    
;;;170          /* Decrement the loop counter */
;;;171          blkCnt--;
;;;172      }
;;;173    
;;;174    #else
;;;175    
;;;176      /* Run the below code for Cortex-M0 */
;;;177    
;;;178      while(numSamples > 0u)
;;;179      {
;;;180          a0 = *pSrcA++;
;;;181          b0 = *pSrcA++;
;;;182          c0 = *pSrcB++;
;;;183          d0 = *pSrcB++;  
;;;184      
;;;185          real_sum += a0 * c0;
;;;186          imag_sum += a0 * d0;
;;;187          real_sum -= b0 * d0;
;;;188          imag_sum += b0 * c0;
;;;189    
;;;190          /* Decrement the loop counter */
;;;191          numSamples--;
;;;192      }
;;;193    
;;;194    #endif /* #ifndef ARM_MATH_CM0_FAMILY */
;;;195    
;;;196      /* Store the real and imaginary results in the destination buffers */
;;;197      *realResult = real_sum;
0000ca  ed830a00          VSTR     s0,[r3,#0]
;;;198      *imagResult = imag_sum;
0000ce  edc50a00          VSTR     s1,[r5,#0]
;;;199    }
0000d2  bd30              POP      {r4,r5,pc}
;;;200    
                          ENDP

                  |L1.212|
0000d4  00000000          DCFS     0x00000000 ; 0

;*** Start embedded assembler ***

#line 1 "src\\ComplexMathFunctions\\arm_cmplx_dot_prod_f32.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___24_arm_cmplx_dot_prod_f32_c_ed20674d____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___24_arm_cmplx_dot_prod_f32_c_ed20674d____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___24_arm_cmplx_dot_prod_f32_c_ed20674d____REVSH|
#line 144
|__asm___24_arm_cmplx_dot_prod_f32_c_ed20674d____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___24_arm_cmplx_dot_prod_f32_c_ed20674d____RRX|
#line 300
|__asm___24_arm_cmplx_dot_prod_f32_c_ed20674d____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
