; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_shift_q7.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_shift_q7.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"Z:\GoogleDrive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_shift_q7.crf src\BasicMathFunctions\arm_shift_q7.c]
                          THUMB

                          AREA ||i.arm_shift_q7||, CODE, READONLY, ALIGN=2

                  arm_shift_q7 PROC
;;;70     
;;;71     void arm_shift_q7(
000000  b5f0              PUSH     {r4-r7,lr}
;;;72       q7_t * pSrc,
;;;73       int8_t shiftBits,
;;;74       q7_t * pDst,
;;;75       uint32_t blockSize)
;;;76     {
;;;77       uint32_t blkCnt;                               /* loop counter */
;;;78       uint8_t sign;                                  /* Sign of shiftBits */
;;;79     
;;;80     #ifndef ARM_MATH_CM0_FAMILY
;;;81     
;;;82     /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;83       q7_t in1;                                      /* Input value1 */
;;;84       q7_t in2;                                      /* Input value2 */
;;;85       q7_t in3;                                      /* Input value3 */
;;;86       q7_t in4;                                      /* Input value4 */
;;;87     
;;;88     
;;;89       /*loop Unrolling */
;;;90       blkCnt = blockSize >> 2u;
000002  089c              LSRS     r4,r3,#2
;;;91     
;;;92       /* Getting the sign of shiftBits */
;;;93       sign = (shiftBits & 0x80);
000004  f0110f80          TST      r1,#0x80
;;;94     
;;;95       /* If the shift value is positive then do right shift else left shift */
;;;96       if(sign == 0u)
;;;97       {
;;;98         /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.    
;;;99          ** a second loop below computes the remaining 1 to 3 samples. */
;;;100        while(blkCnt > 0u)
;;;101        {
;;;102          /* C = A << shiftBits */
;;;103          /* Read 4 inputs */
;;;104          in1 = *pSrc;
;;;105          in2 = *(pSrc + 1);
;;;106          in3 = *(pSrc + 2);
;;;107          in4 = *(pSrc + 3);
;;;108    
;;;109          /* Store the Shifted result in the destination buffer in single cycle by packing the outputs */
;;;110          *__SIMD32(pDst)++ = __PACKq7(__SSAT((in1 << shiftBits), 8),
;;;111                                       __SSAT((in2 << shiftBits), 8),
;;;112                                       __SSAT((in3 << shiftBits), 8),
;;;113                                       __SSAT((in4 << shiftBits), 8));
;;;114          /* Update source pointer to process next sampels */
;;;115          pSrc += 4u;
;;;116    
;;;117          /* Decrement the loop counter */
;;;118          blkCnt--;
;;;119        }
;;;120    
;;;121        /* If the blockSize is not a multiple of 4, compute any remaining output samples here.        
;;;122         ** No loop unrolling is used. */
;;;123        blkCnt = blockSize % 0x4u;
000008  f0030303          AND      r3,r3,#3
00000c  f64f75ff          MOV      r5,#0xffff            ;110
000010  d024              BEQ      |L1.92|
;;;124    
;;;125        while(blkCnt > 0u)
;;;126        {
;;;127          /* C = A << shiftBits */
;;;128          /* Shift the input and then store the result in the destination buffer. */
;;;129          *pDst++ = (q7_t) __SSAT((*pSrc++ << shiftBits), 8);
;;;130    
;;;131          /* Decrement the loop counter */
;;;132          blkCnt--;
;;;133        }
;;;134      }
;;;135      else
;;;136      {
;;;137        shiftBits = -shiftBits;
000012  4249              RSBS     r1,r1,#0
000014  b249              SXTB     r1,r1
;;;138        /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.    
;;;139         ** a second loop below computes the remaining 1 to 3 samples. */
;;;140        while(blkCnt > 0u)
000016  e04d              B        |L1.180|
                  |L1.24|
000018  f9106b01          LDRSB    r6,[r0],#1            ;104
00001c  f9107b01          LDRSB    r7,[r0],#1            ;105
000020  408e              LSLS     r6,r6,r1              ;110
000022  408f              LSLS     r7,r7,r1              ;110
000024  f910cb02          LDRSB    r12,[r0],#2           ;106
000028  f3060607          SSAT     r6,#8,r6              ;110
00002c  f3070707          SSAT     r7,#8,r7              ;110
000030  b2f6              UXTB     r6,r6                 ;110
000032  ea052707          AND      r7,r5,r7,LSL #8       ;110
000036  433e              ORRS     r6,r6,r7              ;110
000038  fa0cfc01          LSL      r12,r12,r1            ;110
00003c  f910ec01          LDRSB    lr,[r0,#-1]           ;107
000040  f30c0707          SSAT     r7,#8,r12             ;110
000044  b2ff              UXTB     r7,r7                 ;110
000046  fa0efe01          LSL      lr,lr,r1              ;110
00004a  ea464607          ORR      r6,r6,r7,LSL #16      ;110
00004e  f30e0707          SSAT     r7,#8,lr              ;110
000052  ea466607          ORR      r6,r6,r7,LSL #24      ;110
000056  f8426b04          STR      r6,[r2],#4            ;110
00005a  1e64              SUBS     r4,r4,#1              ;110
                  |L1.92|
00005c  2c00              CMP      r4,#0                 ;100
00005e  d1db              BNE      |L1.24|
000060  e008              B        |L1.116|
000062  bf00              NOP                            ;129
                  |L1.100|
000064  f9104b01          LDRSB    r4,[r0],#1            ;129
000068  408c              LSLS     r4,r4,r1              ;129
00006a  f3040407          SSAT     r4,#8,r4              ;129
00006e  f8024b01          STRB     r4,[r2],#1            ;129
000072  1e5b              SUBS     r3,r3,#1              ;129
                  |L1.116|
000074  2b00              CMP      r3,#0                 ;125
000076  d1f5              BNE      |L1.100|
;;;141        {
;;;142          /* C = A >> shiftBits */
;;;143          /* Read 4 inputs */
;;;144          in1 = *pSrc;
;;;145          in2 = *(pSrc + 1);
;;;146          in3 = *(pSrc + 2);
;;;147          in4 = *(pSrc + 3);
;;;148    
;;;149          /* Store the Shifted result in the destination buffer in single cycle by packing the outputs */
;;;150          *__SIMD32(pDst)++ = __PACKq7((in1 >> shiftBits), (in2 >> shiftBits),
;;;151                                       (in3 >> shiftBits), (in4 >> shiftBits));
;;;152    
;;;153    
;;;154          pSrc += 4u;
;;;155    
;;;156          /* Decrement the loop counter */
;;;157          blkCnt--;
;;;158        }
;;;159    
;;;160        /* If the blockSize is not a multiple of 4, compute any remaining output samples here.    
;;;161         ** No loop unrolling is used. */
;;;162        blkCnt = blockSize % 0x4u;
;;;163    
;;;164        while(blkCnt > 0u)
;;;165        {
;;;166          /* C = A >> shiftBits */
;;;167          /* Shift the input and then store the result in the destination buffer. */
;;;168          in1 = *pSrc++;
;;;169          *pDst++ = (in1 >> shiftBits);
;;;170    
;;;171          /* Decrement the loop counter */
;;;172          blkCnt--;
;;;173        }
;;;174      }
;;;175    
;;;176    #else
;;;177    
;;;178      /* Run the below code for Cortex-M0 */
;;;179    
;;;180      /* Getting the sign of shiftBits */
;;;181      sign = (shiftBits & 0x80);
;;;182    
;;;183      /* If the shift value is positive then do right shift else left shift */
;;;184      if(sign == 0u)
;;;185      {
;;;186        /* Initialize blkCnt with number of samples */
;;;187        blkCnt = blockSize;
;;;188    
;;;189        while(blkCnt > 0u)
;;;190        {
;;;191          /* C = A << shiftBits */
;;;192          /* Shift the input and then store the result in the destination buffer. */
;;;193          *pDst++ = (q7_t) __SSAT(((q15_t) * pSrc++ << shiftBits), 8);
;;;194    
;;;195          /* Decrement the loop counter */
;;;196          blkCnt--;
;;;197        }
;;;198      }
;;;199      else
;;;200      {
;;;201        /* Initialize blkCnt with number of samples */
;;;202        blkCnt = blockSize;
;;;203    
;;;204        while(blkCnt > 0u)
;;;205        {
;;;206          /* C = A >> shiftBits */
;;;207          /* Shift the input and then store the result in the destination buffer. */
;;;208          *pDst++ = (*pSrc++ >> -shiftBits);
;;;209    
;;;210          /* Decrement the loop counter */
;;;211          blkCnt--;
;;;212        }
;;;213      }
;;;214    
;;;215    #endif /* #ifndef ARM_MATH_CM0_FAMILY */
;;;216    }
000078  bdf0              POP      {r4-r7,pc}
00007a  bf00              NOP                            ;144
                  |L1.124|
00007c  f910eb01          LDRSB    lr,[r0],#1            ;144
000080  f910cb01          LDRSB    r12,[r0],#1           ;145
000084  fa4efe01          ASR      lr,lr,r1              ;150
000088  f9106b02          LDRSB    r6,[r0],#2            ;146
00008c  fa4cfc01          ASR      r12,r12,r1            ;150
000090  410e              ASRS     r6,r6,r1              ;150
000092  f9107c01          LDRSB    r7,[r0,#-1]           ;147
000096  f00e0eff          AND      lr,lr,#0xff           ;150
00009a  ea052c0c          AND      r12,r5,r12,LSL #8     ;150
00009e  ea4e0e0c          ORR      lr,lr,r12             ;150
0000a2  b2f6              UXTB     r6,r6                 ;150
0000a4  410f              ASRS     r7,r7,r1              ;150
0000a6  ea4e4606          ORR      r6,lr,r6,LSL #16      ;150
0000aa  ea466607          ORR      r6,r6,r7,LSL #24      ;150
0000ae  f8426b04          STR      r6,[r2],#4            ;150
0000b2  1e64              SUBS     r4,r4,#1              ;150
                  |L1.180|
0000b4  2c00              CMP      r4,#0                 ;140
0000b6  d1e1              BNE      |L1.124|
0000b8  e006              B        |L1.200|
0000ba  bf00              NOP                            ;168
                  |L1.188|
0000bc  f9104b01          LDRSB    r4,[r0],#1            ;168
0000c0  410c              ASRS     r4,r4,r1              ;169
0000c2  f8024b01          STRB     r4,[r2],#1            ;169
0000c6  1e5b              SUBS     r3,r3,#1              ;169
                  |L1.200|
0000c8  2b00              CMP      r3,#0                 ;164
0000ca  d1f7              BNE      |L1.188|
0000cc  bdf0              POP      {r4-r7,pc}
;;;217    
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\BasicMathFunctions\\arm_shift_q7.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_arm_shift_q7_c_49b5f72d____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___14_arm_shift_q7_c_49b5f72d____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_arm_shift_q7_c_49b5f72d____REVSH|
#line 144
|__asm___14_arm_shift_q7_c_49b5f72d____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___14_arm_shift_q7_c_49b5f72d____RRX|
#line 300
|__asm___14_arm_shift_q7_c_49b5f72d____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
