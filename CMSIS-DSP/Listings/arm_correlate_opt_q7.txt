; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_correlate_opt_q7.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_correlate_opt_q7.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_correlate_opt_q7.crf src\FilteringFunctions\arm_correlate_opt_q7.c]
                          THUMB

                          AREA ||i.arm_correlate_opt_q7||, CODE, READONLY, ALIGN=2

                  arm_correlate_opt_q7 PROC
;;;82     
;;;83     void arm_correlate_opt_q7(
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;84       q7_t * pSrcA,
;;;85       uint32_t srcALen,
;;;86       q7_t * pSrcB,
;;;87       uint32_t srcBLen,
;;;88       q7_t * pDst,
;;;89       q15_t * pScratch1,
;;;90       q15_t * pScratch2)
;;;91     {
000004  b087              SUB      sp,sp,#0x1c
000006  461c              MOV      r4,r3
;;;92       q7_t *pOut = pDst;                             /* output pointer                */
;;;93       q15_t *pScr1 = pScratch1;                      /* Temporary pointer for scratch */
;;;94       q15_t *pScr2 = pScratch2;                      /* Temporary pointer for scratch */
000008  e9dd9811          LDRD     r9,r8,[sp,#0x44]
;;;95       q7_t *pIn1;                                    /* inputA pointer                */
;;;96       q7_t *pIn2;                                    /* inputB pointer                */
;;;97       q15_t *py;                                     /* Intermediate inputB pointer   */
;;;98       q31_t acc0, acc1, acc2, acc3;                  /* Accumulators                  */
;;;99       uint32_t j, k = 0u, blkCnt;                    /* loop counter                  */
;;;100      int32_t inc = 1;                               /* output pointer increment          */
00000c  2501              MOVS     r5,#1
00000e  460e              MOV      r6,r1                 ;91
000010  9b10              LDR      r3,[sp,#0x40]
;;;101      uint32_t outBlockSize;                         /* loop counter                  */
;;;102      q15_t x4;                                      /* Temporary input variable      */
;;;103      uint32_t tapCnt;                               /* loop counter                  */
;;;104      q31_t x1, x2, x3, y1;                          /* Temporary input variables     */
;;;105    
;;;106      /* The algorithm implementation is based on the lengths of the inputs. */
;;;107      /* srcB is always made to slide across srcA. */
;;;108      /* So srcBLen is always considered as shorter or equal to srcALen */
;;;109      /* But CORR(x, y) is reverse of CORR(y, x) */
;;;110      /* So, when srcBLen > srcALen, output pointer is made to point to the end of the output buffer */
;;;111      /* and the destination pointer modifier, inc is set to -1 */
;;;112      /* If srcALen > srcBLen, zero pad has to be done to srcB to make the two inputs of same length */
;;;113      /* But to improve the performance,        
;;;114       * we include zeroes in the output instead of zero padding either of the the inputs*/
;;;115      /* If srcALen > srcBLen,        
;;;116       * (srcALen - srcBLen) zeroes has to included in the starting of the output buffer */
;;;117      /* If srcALen < srcBLen,        
;;;118       * (srcALen - srcBLen) zeroes has to included in the ending of the output buffer */
;;;119      if(srcALen >= srcBLen)
;;;120      {
;;;121        /* Initialization of inputA pointer */
;;;122        pIn1 = (pSrcA);
;;;123    
;;;124        /* Initialization of inputB pointer */
;;;125        pIn2 = (pSrcB);
;;;126    
;;;127        /* Number of output samples is calculated */
;;;128        outBlockSize = (2u * srcALen) - 1u;
000012  1eaf              SUBS     r7,r5,#2
000014  4641              MOV      r1,r8                 ;94
000016  9501              STR      r5,[sp,#4]            ;119
000018  42a6              CMP      r6,r4                 ;119
00001a  d309              BCC      |L1.48|
00001c  4605              MOV      r5,r0                 ;122
00001e  4610              MOV      r0,r2                 ;125
000020  eb070246          ADD      r2,r7,r6,LSL #1
;;;129    
;;;130        /* When srcALen > srcBLen, zero padding is done to srcB        
;;;131         * to make their lengths equal.        
;;;132         * Instead, (outBlockSize - (srcALen + srcBLen - 1))        
;;;133         * number of output samples are made zero */
;;;134        j = outBlockSize - (srcALen + (srcBLen - 1u));
000024  1937              ADDS     r7,r6,r4
000026  1bd2              SUBS     r2,r2,r7
000028  1c52              ADDS     r2,r2,#1
;;;135    
;;;136        /* Updating the pointer position to non zero value */
;;;137        pOut += j;
00002a  441a              ADD      r2,r2,r3
00002c  9200              STR      r2,[sp,#0]
00002e  e008              B        |L1.66|
                  |L1.48|
;;;138    
;;;139      }
;;;140      else
;;;141      {
;;;142        /* Initialization of inputA pointer */
;;;143        pIn1 = (pSrcB);
000030  4615              MOV      r5,r2
;;;144    
;;;145        /* Initialization of inputB pointer */
;;;146        pIn2 = (pSrcA);
;;;147    
;;;148        /* srcBLen is always considered as shorter or equal to srcALen */
;;;149        j = srcBLen;
000032  4622              MOV      r2,r4
;;;150        srcBLen = srcALen;
000034  4634              MOV      r4,r6
;;;151        srcALen = j;
000036  4616              MOV      r6,r2
;;;152    
;;;153        /* CORR(x, y) = Reverse order(CORR(y, x)) */
;;;154        /* Hence set the destination pointer to point to the last output sample */
;;;155        pOut = pDst + ((srcALen + srcBLen) - 2u);
000038  4422              ADD      r2,r2,r4
00003a  441a              ADD      r2,r2,r3
00003c  1e92              SUBS     r2,r2,#2
00003e  e9cd2700          STRD     r2,r7,[sp,#0]
                  |L1.66|
;;;156    
;;;157        /* Destination address modifier is set to -1 */
;;;158        inc = -1;
;;;159    
;;;160      }
;;;161    
;;;162    
;;;163      /* Copy (srcBLen) samples in scratch buffer */
;;;164      k = srcBLen >> 2u;
000042  08a2              LSRS     r2,r4,#2
;;;165    
;;;166      /* First part of the processing with loop unrolling copies 4 data points at a time.       
;;;167       ** a second loop below copies for the remaining 1 to 3 samples. */
;;;168      while(k > 0u)
000044  9205              STR      r2,[sp,#0x14]
000046  e010              B        |L1.106|
                  |L1.72|
;;;169      {
;;;170        /* copy second buffer in reversal manner */
;;;171        x4 = (q15_t) * pIn2++;
000048  f9103b01          LDRSB    r3,[r0],#1
;;;172        *pScr2++ = x4;
00004c  f8213b02          STRH     r3,[r1],#2
;;;173        x4 = (q15_t) * pIn2++;
000050  f9103b01          LDRSB    r3,[r0],#1
;;;174        *pScr2++ = x4;
000054  f8213b02          STRH     r3,[r1],#2
;;;175        x4 = (q15_t) * pIn2++;
000058  f9103b02          LDRSB    r3,[r0],#2
;;;176        *pScr2++ = x4;
00005c  f8213b04          STRH     r3,[r1],#4
;;;177        x4 = (q15_t) * pIn2++;
000060  f9103c01          LDRSB    r3,[r0,#-1]
;;;178        *pScr2++ = x4;
000064  f8213c02          STRH     r3,[r1,#-2]
000068  1e52              SUBS     r2,r2,#1
                  |L1.106|
00006a  2a00              CMP      r2,#0                 ;168
00006c  d1ec              BNE      |L1.72|
;;;179    
;;;180        /* Decrement the loop counter */
;;;181        k--;
;;;182      }
;;;183    
;;;184      /* If the count is not a multiple of 4, copy remaining samples here.       
;;;185       ** No loop unrolling is used. */
;;;186      k = srcBLen % 0x4u;
00006e  f0040203          AND      r2,r4,#3
;;;187    
;;;188      while(k > 0u)
000072  9204              STR      r2,[sp,#0x10]
000074  e005              B        |L1.130|
;;;189      {
;;;190        /* copy second buffer in reversal manner for remaining samples */
;;;191        x4 = (q15_t) * pIn2++;
000076  bf00              NOP      
                  |L1.120|
000078  f9103b01          LDRSB    r3,[r0],#1
;;;192        *pScr2++ = x4;
00007c  f8213b02          STRH     r3,[r1],#2
000080  1e52              SUBS     r2,r2,#1
                  |L1.130|
000082  2a00              CMP      r2,#0                 ;188
000084  d1f8              BNE      |L1.120|
;;;193    
;;;194        /* Decrement the loop counter */
;;;195        k--;
;;;196      }
;;;197    
;;;198      /* Fill (srcBLen - 1u) zeros in scratch buffer */
;;;199      arm_fill_q15(0, pScr1, (srcBLen - 1u));
000086  1e62              SUBS     r2,r4,#1
000088  4649              MOV      r1,r9
00008a  2000              MOVS     r0,#0
00008c  f7fffffe          BL       arm_fill_q15
;;;200    
;;;201      /* Update temporary scratch pointer */
;;;202      pScr1 += (srcBLen - 1u);
000090  eb090144          ADD      r1,r9,r4,LSL #1
;;;203    
;;;204      /* Copy (srcALen) samples in scratch buffer */
;;;205      k = srcALen >> 2u;
000094  08b0              LSRS     r0,r6,#2
000096  1e89              SUBS     r1,r1,#2
;;;206    
;;;207      /* First part of the processing with loop unrolling copies 4 data points at a time.       
;;;208       ** a second loop below copies for the remaining 1 to 3 samples. */
;;;209      while(k > 0u)
000098  e011              B        |L1.190|
;;;210      {
;;;211        /* copy second buffer in reversal manner */
;;;212        x4 = (q15_t) * pIn1++;
00009a  bf00              NOP      
                  |L1.156|
00009c  f9152b01          LDRSB    r2,[r5],#1
;;;213        *pScr1++ = x4;
0000a0  f8212b02          STRH     r2,[r1],#2
;;;214        x4 = (q15_t) * pIn1++;
0000a4  f9152b01          LDRSB    r2,[r5],#1
;;;215        *pScr1++ = x4;
0000a8  f8212b02          STRH     r2,[r1],#2
;;;216        x4 = (q15_t) * pIn1++;
0000ac  f9152b02          LDRSB    r2,[r5],#2
;;;217        *pScr1++ = x4;
0000b0  f8212b04          STRH     r2,[r1],#4
;;;218        x4 = (q15_t) * pIn1++;
0000b4  f9152c01          LDRSB    r2,[r5,#-1]
;;;219        *pScr1++ = x4;
0000b8  f8212c02          STRH     r2,[r1,#-2]
0000bc  1e40              SUBS     r0,r0,#1
                  |L1.190|
0000be  2800              CMP      r0,#0                 ;209
0000c0  d1ec              BNE      |L1.156|
;;;220    
;;;221        /* Decrement the loop counter */
;;;222        k--;
;;;223      }
;;;224    
;;;225      /* If the count is not a multiple of 4, copy remaining samples here.       
;;;226       ** No loop unrolling is used. */
;;;227      k = srcALen % 0x4u;
0000c2  f0060003          AND      r0,r6,#3
;;;228    
;;;229      while(k > 0u)
0000c6  e004              B        |L1.210|
                  |L1.200|
;;;230      {
;;;231        /* copy second buffer in reversal manner for remaining samples */
;;;232        x4 = (q15_t) * pIn1++;
0000c8  f9152b01          LDRSB    r2,[r5],#1
;;;233        *pScr1++ = x4;
0000cc  f8212b02          STRH     r2,[r1],#2
0000d0  1e40              SUBS     r0,r0,#1
                  |L1.210|
0000d2  2800              CMP      r0,#0                 ;229
0000d4  d1f8              BNE      |L1.200|
;;;234    
;;;235        /* Decrement the loop counter */
;;;236        k--;
;;;237      }
;;;238    
;;;239    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;240    
;;;241      /* Fill (srcBLen - 1u) zeros at end of scratch buffer */
;;;242      arm_fill_q15(0, pScr1, (srcBLen - 1u));
0000d6  1e62              SUBS     r2,r4,#1
0000d8  f7fffffe          BL       arm_fill_q15
;;;243    
;;;244      /* Update pointer */
;;;245      pScr1 += (srcBLen - 1u);
;;;246    
;;;247    #else
;;;248    
;;;249    /* Apply loop unrolling and do 4 Copies simultaneously. */
;;;250      k = (srcBLen - 1u) >> 2u;
;;;251    
;;;252      /* First part of the processing with loop unrolling copies 4 data points at a time.       
;;;253       ** a second loop below copies for the remaining 1 to 3 samples. */
;;;254      while(k > 0u)
;;;255      {
;;;256        /* copy second buffer in reversal manner */
;;;257        *pScr1++ = 0;
;;;258        *pScr1++ = 0;
;;;259        *pScr1++ = 0;
;;;260        *pScr1++ = 0;
;;;261    
;;;262        /* Decrement the loop counter */
;;;263        k--;
;;;264      }
;;;265    
;;;266      /* If the count is not a multiple of 4, copy remaining samples here.       
;;;267       ** No loop unrolling is used. */
;;;268      k = (srcBLen - 1u) % 0x4u;
;;;269    
;;;270      while(k > 0u)
;;;271      {
;;;272        /* copy second buffer in reversal manner for remaining samples */
;;;273        *pScr1++ = 0;
;;;274    
;;;275        /* Decrement the loop counter */
;;;276        k--;
;;;277      }
;;;278    
;;;279    #endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE	*/
;;;280    
;;;281      /* Temporary pointer for second sequence */
;;;282      py = pScratch2;
;;;283    
;;;284      /* Initialization of pScr2 pointer */
;;;285      pScr2 = pScratch2;
;;;286    
;;;287      /* Actual correlation process starts here */
;;;288      blkCnt = (srcALen + srcBLen - 1u) >> 2;
0000dc  1931              ADDS     r1,r6,r4
0000de  1e49              SUBS     r1,r1,#1
;;;289    
;;;290      while(blkCnt > 0)
0000e0  e9cd8102          STRD     r8,r1,[sp,#8]
0000e4  4640              MOV      r0,r8                 ;285
0000e6  ea4f0e91          LSR      lr,r1,#2              ;288
0000ea  e067              B        |L1.444|
                  |L1.236|
;;;291      {
;;;292        /* Initialze temporary scratch pointer as scratch1 */
;;;293        pScr1 = pScratch1;
;;;294    
;;;295        /* Clear Accumlators */
;;;296        acc0 = 0;
;;;297        acc1 = 0;
;;;298        acc2 = 0;
;;;299        acc3 = 0;
;;;300    
;;;301        /* Read two samples from scratch1 buffer */
;;;302        x1 = *__SIMD32(pScr1)++;
0000ec  9f11              LDR      r7,[sp,#0x44]
0000ee  2300              MOVS     r3,#0                 ;296
0000f0  461d              MOV      r5,r3                 ;297
0000f2  f8572b04          LDR      r2,[r7],#4
0000f6  461e              MOV      r6,r3                 ;298
;;;303    
;;;304        /* Read next two samples from scratch1 buffer */
;;;305        x2 = *__SIMD32(pScr1)++;
0000f8  f8571b04          LDR      r1,[r7],#4
0000fc  46bb              MOV      r11,r7
0000fe  469c              MOV      r12,r3                ;299
;;;306    
;;;307        tapCnt = (srcBLen) >> 2u;
;;;308    
;;;309        while(tapCnt > 0u)
000100  9f05              LDR      r7,[sp,#0x14]
000102  e022              B        |L1.330|
                  |L1.260|
;;;310        {
;;;311    
;;;312          /* Read four samples from smaller buffer */
;;;313          y1 = _SIMD32_OFFSET(pScr2);
000104  f8507b04          LDR      r7,[r0],#4
;;;314    
;;;315          /* multiply and accumlate */
;;;316          acc0 = __SMLAD(x1, y1, acc0);
000108  fb223307          SMLAD    r3,r2,r7,r3
;;;317          acc2 = __SMLAD(x2, y1, acc2);
00010c  fb216607          SMLAD    r6,r1,r7,r6
;;;318    
;;;319          /* pack input data */
;;;320    #ifndef ARM_MATH_BIG_ENDIAN
;;;321          x3 = __PKHBT(x2, x1, 0);
000110  eac10202          PKHBT    r2,r1,r2
;;;322    #else
;;;323          x3 = __PKHBT(x1, x2, 0);
;;;324    #endif
;;;325    
;;;326          /* multiply and accumlate */
;;;327          acc1 = __SMLADX(x3, y1, acc1);
000114  fb225917          SMLADX   r9,r2,r7,r5
;;;328    
;;;329          /* Read next two samples from scratch1 buffer */
;;;330          x1 = *__SIMD32(pScr1)++;
000118  f8db2000          LDR      r2,[r11,#0]
00011c  f10b0804          ADD      r8,r11,#4
;;;331    
;;;332          /* pack input data */
;;;333    #ifndef ARM_MATH_BIG_ENDIAN
;;;334          x3 = __PKHBT(x1, x2, 0);
000120  eac20501          PKHBT    r5,r2,r1
;;;335    #else
;;;336          x3 = __PKHBT(x2, x1, 0);
;;;337    #endif
;;;338    
;;;339          acc3 = __SMLADX(x3, y1, acc3);
000124  fb25cc17          SMLADX   r12,r5,r7,r12
;;;340    
;;;341          /* Read four samples from smaller buffer */
;;;342          y1 = _SIMD32_OFFSET(pScr2 + 2u);
000128  f8507b04          LDR      r7,[r0],#4
;;;343    
;;;344          acc0 = __SMLAD(x2, y1, acc0);
00012c  fb213307          SMLAD    r3,r1,r7,r3
;;;345    
;;;346          acc2 = __SMLAD(x1, y1, acc2);
000130  fb226607          SMLAD    r6,r2,r7,r6
;;;347    
;;;348          acc1 = __SMLADX(x3, y1, acc1);
000134  fb259517          SMLADX   r5,r5,r7,r9
;;;349    
;;;350          x2 = *__SIMD32(pScr1)++;
000138  f8581b04          LDR      r1,[r8],#4
00013c  46c3              MOV      r11,r8
;;;351    
;;;352    #ifndef ARM_MATH_BIG_ENDIAN
;;;353          x3 = __PKHBT(x2, x1, 0);
00013e  eac10802          PKHBT    r8,r1,r2
;;;354    #else
;;;355          x3 = __PKHBT(x1, x2, 0);
;;;356    #endif
;;;357    
;;;358          acc3 = __SMLADX(x3, y1, acc3);
000142  fb28cc17          SMLADX   r12,r8,r7,r12
;;;359    
;;;360          pScr2 += 4u;
;;;361    
;;;362    
;;;363          /* Decrement the loop counter */
;;;364          tapCnt--;
000146  f1aa0701          SUB      r7,r10,#1
                  |L1.330|
00014a  ea5f0a07          MOVS     r10,r7                ;307
00014e  d1d9              BNE      |L1.260|
;;;365        }
;;;366    
;;;367    
;;;368    
;;;369        /* Update scratch pointer for remaining samples of smaller length sequence */
;;;370        pScr1 -= 4u;
000150  f1ab0808          SUB      r8,r11,#8
;;;371    
;;;372    
;;;373        /* apply same above for remaining samples of smaller length sequence */
;;;374        tapCnt = (srcBLen) & 3u;
;;;375    
;;;376        while(tapCnt > 0u)
000154  9904              LDR      r1,[sp,#0x10]
000156  e012              B        |L1.382|
                  |L1.344|
;;;377        {
;;;378    
;;;379          /* accumlate the results */
;;;380          acc0 += (*pScr1++ * *pScr2);
000158  f8387b02          LDRH     r7,[r8],#2
00015c  f8302b02          LDRH     r2,[r0],#2
000160  fb173302          SMLABB   r3,r7,r2,r3
;;;381          acc1 += (*pScr1++ * *pScr2);
000164  f8b87000          LDRH     r7,[r8,#0]
000168  fb175502          SMLABB   r5,r7,r2,r5
;;;382          acc2 += (*pScr1++ * *pScr2);
00016c  f8b87002          LDRH     r7,[r8,#2]
000170  fb176602          SMLABB   r6,r7,r2,r6
;;;383          acc3 += (*pScr1++ * *pScr2++);
000174  f8b87004          LDRH     r7,[r8,#4]
000178  fb17cc02          SMLABB   r12,r7,r2,r12
00017c  1e49              SUBS     r1,r1,#1
                  |L1.382|
00017e  2900              CMP      r1,#0                 ;376
000180  d1ea              BNE      |L1.344|
;;;384    
;;;385          pScr1 -= 3u;
;;;386    
;;;387          /* Decrement the loop counter */
;;;388          tapCnt--;
;;;389        }
;;;390    
;;;391        blkCnt--;
;;;392    
;;;393        /* Store the result in the accumulator in the destination buffer. */
;;;394        *pOut = (q7_t) (__SSAT(acc0 >> 7u, 8));
000182  9800              LDR      r0,[sp,#0]
000184  f32311c7          SSAT     r1,#8,r3,ASR #7
000188  f1ae0e01          SUB      lr,lr,#1              ;391
00018c  7001              STRB     r1,[r0,#0]
00018e  e9dd0100          LDRD     r0,r1,[sp,#0]
;;;395        pOut += inc;
000192  4408              ADD      r0,r0,r1
;;;396        *pOut = (q7_t) (__SSAT(acc1 >> 7u, 8));
000194  f32511c7          SSAT     r1,#8,r5,ASR #7
000198  7001              STRB     r1,[r0,#0]
;;;397        pOut += inc;
00019a  9901              LDR      r1,[sp,#4]
00019c  4408              ADD      r0,r0,r1
;;;398        *pOut = (q7_t) (__SSAT(acc2 >> 7u, 8));
00019e  f32611c7          SSAT     r1,#8,r6,ASR #7
0001a2  7001              STRB     r1,[r0,#0]
;;;399        pOut += inc;
0001a4  9901              LDR      r1,[sp,#4]
0001a6  4408              ADD      r0,r0,r1
;;;400        *pOut = (q7_t) (__SSAT(acc3 >> 7u, 8));
0001a8  f32c11c7          SSAT     r1,#8,r12,ASR #7
0001ac  7001              STRB     r1,[r0,#0]
;;;401        pOut += inc;
0001ae  9901              LDR      r1,[sp,#4]
0001b0  4408              ADD      r0,r0,r1
;;;402    
;;;403        /* Initialization of inputB pointer */
;;;404        pScr2 = py;
;;;405    
;;;406        pScratch1 += 4u;
0001b2  9911              LDR      r1,[sp,#0x44]
0001b4  9000              STR      r0,[sp,#0]            ;404
0001b6  3108              ADDS     r1,r1,#8
0001b8  9802              LDR      r0,[sp,#8]
0001ba  9111              STR      r1,[sp,#0x44]
                  |L1.444|
0001bc  f1be0f00          CMP      lr,#0                 ;290
0001c0  d194              BNE      |L1.236|
;;;407    
;;;408      }
;;;409    
;;;410    
;;;411      blkCnt = (srcALen + srcBLen - 1u) & 0x3;
0001c2  9903              LDR      r1,[sp,#0xc]
0001c4  f0010503          AND      r5,r1,#3
;;;412    
;;;413      /* Calculate correlation for remaining samples of Bigger length sequence */
;;;414      while(blkCnt > 0)
0001c8  e02c              B        |L1.548|
                  |L1.458|
;;;415      {
;;;416        /* Initialze temporary scratch pointer as scratch1 */
;;;417        pScr1 = pScratch1;
;;;418    
;;;419        /* Clear Accumlators */
;;;420        acc0 = 0;
0001ca  2200              MOVS     r2,#0
;;;421    
;;;422        tapCnt = (srcBLen) >> 1u;
0001cc  0863              LSRS     r3,r4,#1
;;;423    
;;;424        while(tapCnt > 0u)
0001ce  9911              LDR      r1,[sp,#0x44]
0001d0  e00d              B        |L1.494|
;;;425        {
;;;426          acc0 += (*pScr1++ * *pScr2++);
0001d2  bf00              NOP      
                  |L1.468|
0001d4  f8316b02          LDRH     r6,[r1],#2
0001d8  f8307b02          LDRH     r7,[r0],#2
0001dc  fb162207          SMLABB   r2,r6,r7,r2
;;;427          acc0 += (*pScr1++ * *pScr2++);
0001e0  f8316b02          LDRH     r6,[r1],#2
0001e4  f8307b02          LDRH     r7,[r0],#2
0001e8  fb162207          SMLABB   r2,r6,r7,r2
0001ec  1e5b              SUBS     r3,r3,#1
                  |L1.494|
0001ee  2b00              CMP      r3,#0                 ;424
0001f0  d1f0              BNE      |L1.468|
;;;428    
;;;429          /* Decrement the loop counter */
;;;430          tapCnt--;
;;;431        }
;;;432    
;;;433        tapCnt = (srcBLen) & 1u;
0001f2  f0040301          AND      r3,r4,#1
;;;434    
;;;435        /* apply same above for remaining samples of smaller length sequence */
;;;436        while(tapCnt > 0u)
0001f6  e006              B        |L1.518|
                  |L1.504|
;;;437        {
;;;438    
;;;439          /* accumlate the results */
;;;440          acc0 += (*pScr1++ * *pScr2++);
0001f8  f8316b02          LDRH     r6,[r1],#2
0001fc  f8307b02          LDRH     r7,[r0],#2
000200  fb162207          SMLABB   r2,r6,r7,r2
000204  1e5b              SUBS     r3,r3,#1
                  |L1.518|
000206  2b00              CMP      r3,#0                 ;436
000208  d1f6              BNE      |L1.504|
;;;441    
;;;442          /* Decrement the loop counter */
;;;443          tapCnt--;
;;;444        }
;;;445    
;;;446        blkCnt--;
;;;447    
;;;448        /* Store the result in the accumulator in the destination buffer. */
;;;449        *pOut = (q7_t) (__SSAT(acc0 >> 7u, 8));
00020a  9800              LDR      r0,[sp,#0]
00020c  f32211c7          SSAT     r1,#8,r2,ASR #7
000210  7001              STRB     r1,[r0,#0]
000212  e9dd0100          LDRD     r0,r1,[sp,#0]
;;;450    
;;;451        pOut += inc;
000216  4408              ADD      r0,r0,r1
;;;452    
;;;453        /* Initialization of inputB pointer */
;;;454        pScr2 = py;
;;;455    
;;;456        pScratch1 += 1u;
000218  9911              LDR      r1,[sp,#0x44]
00021a  9000              STR      r0,[sp,#0]            ;454
00021c  1c89              ADDS     r1,r1,#2
00021e  9802              LDR      r0,[sp,#8]
000220  1e6d              SUBS     r5,r5,#1
000222  9111              STR      r1,[sp,#0x44]
                  |L1.548|
000224  2d00              CMP      r5,#0                 ;414
000226  d1d0              BNE      |L1.458|
;;;457    
;;;458      }
;;;459    
;;;460    }
000228  b007              ADD      sp,sp,#0x1c
00022a  e8bd8ff0          POP      {r4-r11,pc}
;;;461    
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\FilteringFunctions\\arm_correlate_opt_q7.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___22_arm_correlate_opt_q7_c_3f380595____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___22_arm_correlate_opt_q7_c_3f380595____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___22_arm_correlate_opt_q7_c_3f380595____REVSH|
#line 144
|__asm___22_arm_correlate_opt_q7_c_3f380595____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___22_arm_correlate_opt_q7_c_3f380595____RRX|
#line 300
|__asm___22_arm_correlate_opt_q7_c_3f380595____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
