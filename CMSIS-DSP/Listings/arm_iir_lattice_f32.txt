; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_iir_lattice_f32.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_iir_lattice_f32.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_iir_lattice_f32.crf src\FilteringFunctions\arm_iir_lattice_f32.c]
                          THUMB

                          AREA ||i.arm_iir_lattice_f32||, CODE, READONLY, ALIGN=2

                  arm_iir_lattice_f32 PROC
;;;133    
;;;134    void arm_iir_lattice_f32(
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;135      const arm_iir_lattice_instance_f32 * S,
;;;136      float32_t * pSrc,
;;;137      float32_t * pDst,
;;;138      uint32_t blockSize)
;;;139    {
;;;140      float32_t fnext1, gcurr1, gnext;               /* Temporary variables for lattice stages */
;;;141      float32_t acc;                                 /* Accumlator */
;;;142      uint32_t blkCnt, tapCnt;                       /* temporary variables for counts */
;;;143      float32_t *px1, *px2, *pk, *pv;                /* temporary pointers for state and coef */
;;;144      uint32_t numStages = S->numStages;             /* number of stages */
000004  8806              LDRH     r6,[r0,#0]
000006  469a              MOV      r10,r3                ;139
000008  4693              MOV      r11,r2                ;139
00000a  4689              MOV      r9,r1                 ;139
;;;145      float32_t *pState;                             /* State pointer */
;;;146      float32_t *pStateCurnt;                        /* State current pointer */
;;;147      float32_t k1, k2;
;;;148      float32_t v1, v2, v3, v4;
;;;149      float32_t gcurr2;
;;;150      float32_t fnext2;
;;;151    
;;;152      /* initialise loop count */
;;;153      blkCnt = blockSize;
00000c  4698              MOV      r8,r3
;;;154    
;;;155      /* initialise state pointer */
;;;156      pState = &S->pState[0];
;;;157    
;;;158      /* Sample processing */
;;;159      while(blkCnt > 0u)
;;;160      {
;;;161        /* Read Sample from input buffer */
;;;162        /* fN(n) = x(n) */
;;;163        fnext2 = *pSrc++;
;;;164    
;;;165        /* Initialize Ladder coeff pointer */
;;;166        pv = &S->pvCoeffs[0];
;;;167        /* Initialize Reflection coeff pointer */
;;;168        pk = &S->pkCoeffs[0];
;;;169    
;;;170        /* Initialize state read pointer */
;;;171        px1 = pState;
;;;172        /* Initialize state write pointer */
;;;173        px2 = pState;
;;;174    
;;;175        /* Set accumulator to zero */
;;;176        acc = 0.0;
;;;177    
;;;178        /* Loop unrolling.  Process 4 taps at a time. */
;;;179        tapCnt = (numStages) >> 2;
00000e  08b5              LSRS     r5,r6,#2
000010  6847              LDR      r7,[r0,#4]            ;139
000012  e073              B        |L1.252|
                  |L1.20|
000014  ecb90a01          VLDM     r9!,{s0}              ;163
000018  463a              MOV      r2,r7                 ;171
00001a  4639              MOV      r1,r7                 ;173
00001c  eddf0a4c          VLDR     s1,|L1.336|
000020  e9d04302          LDRD     r4,r3,[r0,#8]
000024  46ac              MOV      r12,r5
;;;180    
;;;181        while(tapCnt > 0u)
000026  e045              B        |L1.180|
                  |L1.40|
;;;182        {
;;;183          /* Read gN-1(n-1) from state buffer */
;;;184          gcurr1 = *px1;
000028  ed923a00          VLDR     s6,[r2,#0]
;;;185    
;;;186          /* read reflection coefficient kN */
;;;187          k1 = *pk;
00002c  ed942a00          VLDR     s4,[r4,#0]
;;;188    
;;;189          /* fN-1(n) = fN(n) - kN * gN-1(n-1) */
;;;190          fnext1 = fnext2 - (k1 * gcurr1);
;;;191    
;;;192          /* read ladder coefficient vN */
;;;193          v1 = *pv;
;;;194    
;;;195          /* read next reflection coefficient kN-1 */
;;;196          k2 = *(pk + 1u);
000030  edd44a01          VLDR     s9,[r4,#4]
;;;197    
;;;198          /* Read gN-2(n-1) from state buffer */
;;;199          gcurr2 = *(px1 + 1u);
000034  edd21a01          VLDR     s3,[r2,#4]
000038  ee020a43          VMLS.F32 s0,s4,s6              ;190
00003c  edd33a00          VLDR     s7,[r3,#0]            ;193
;;;200    
;;;201          /* read next ladder coefficient vN-1 */
;;;202          v2 = *(pv + 1u);
000040  ed935a01          VLDR     s10,[r3,#4]
;;;203    
;;;204          /* fN-2(n) = fN-1(n) - kN-1 * gN-2(n-1) */
;;;205          fnext2 = fnext1 - (k2 * gcurr2);
;;;206    
;;;207          /* gN(n)   = kN * fN-1(n) + gN-1(n-1) */
;;;208          gnext = gcurr1 + (k1 * fnext1);
;;;209    
;;;210          /* read reflection coefficient kN-2 */
;;;211          k1 = *(pk + 2u);
000044  edd42a02          VLDR     s5,[r4,#8]
;;;212    
;;;213          /* write gN(n) into state for next sample processing */
;;;214          *px2++ = gnext;
;;;215    
;;;216          /* Read gN-3(n-1) from state buffer */
;;;217          gcurr1 = *(px1 + 2u);
;;;218    
;;;219          /* y(n) += gN(n) * vN  */
;;;220          acc += (gnext * v1);
;;;221    
;;;222          /* fN-3(n) = fN-2(n) - kN-2 * gN-3(n-1) */
;;;223          fnext1 = fnext2 - (k1 * gcurr1);
;;;224    
;;;225          /* gN-1(n)   = kN-1 * fN-2(n) + gN-2(n-1) */
;;;226          gnext = gcurr2 + (k2 * fnext2);
;;;227    
;;;228          /* Read gN-4(n-1) from state buffer */
;;;229          gcurr2 = *(px1 + 3u);
;;;230    
;;;231          /* y(n) += gN-1(n) * vN-1  */
;;;232          acc += (gnext * v2);
;;;233    
;;;234          /* read reflection coefficient kN-3 */
;;;235          k2 = *(pk + 3u);
;;;236    
;;;237          /* write gN-1(n) into state for next sample processing */
;;;238          *px2++ = gnext;
;;;239    
;;;240          /* fN-4(n) = fN-3(n) - kN-3 * gN-4(n-1) */
;;;241          fnext2 = fnext1 - (k2 * gcurr2);
;;;242    
;;;243          /* gN-2(n) = kN-2 * fN-3(n) + gN-3(n-1) */
;;;244          gnext = gcurr1 + (k1 * fnext1);
;;;245    
;;;246          /* read ladder coefficient vN-2 */
;;;247          v3 = *(pv + 2u);
;;;248    
;;;249          /* y(n) += gN-2(n) * vN-2  */
;;;250          acc += (gnext * v3);
;;;251    
;;;252          /* write gN-2(n) into state for next sample processing */
;;;253          *px2++ = gnext;
;;;254    
;;;255          /* update pointer */
;;;256          pk += 4u;
;;;257    
;;;258          /* gN-3(n) = kN-3 * fN-4(n) + gN-4(n-1) */
;;;259          gnext = (fnext2 * k2) + gcurr2;
;;;260    
;;;261          /* read next ladder coefficient vN-3 */
;;;262          v4 = *(pv + 3u);
;;;263    
;;;264          /* y(n) += gN-4(n) * vN-4  */
;;;265          acc += (gnext * v4);
;;;266    
;;;267          /* write gN-3(n) into state for next sample processing */
;;;268          *px2++ = gnext;
000048  f1ac0c01          SUB      r12,r12,#1
00004c  eeb01a40          VMOV.F32 s2,s0                 ;202
000050  ee023a00          VMLA.F32 s6,s4,s0              ;208
000054  ee041ae1          VMLS.F32 s2,s9,s3              ;205
000058  ed813a00          VSTR     s6,[r1,#0]            ;214
00005c  ed922a02          VLDR     s4,[r2,#8]            ;217
000060  eeb04a41          VMOV.F32 s8,s2                 ;205
000064  ee430a23          VMLA.F32 s1,s6,s7              ;220
000068  ee021ac2          VMLS.F32 s2,s5,s4              ;223
00006c  ee441a84          VMLA.F32 s3,s9,s8              ;226
000070  ed923a03          VLDR     s6,[r2,#0xc]          ;229
000074  ed944a03          VLDR     s8,[r4,#0xc]          ;235
000078  3210              ADDS     r2,r2,#0x10
00007a  eef03a41          VMOV.F32 s7,s2                 ;223
00007e  ee410a85          VMLA.F32 s1,s3,s10             ;232
000082  eeb00a63          VMOV.F32 s0,s7                 ;238
000086  ee022aa3          VMLA.F32 s4,s5,s7              ;244
00008a  ee040a43          VMLS.F32 s0,s8,s6              ;241
00008e  edc11a01          VSTR     s3,[r1,#4]            ;238
000092  ed931a02          VLDR     s2,[r3,#8]            ;247
000096  ed812a02          VSTR     s4,[r1,#8]            ;253
00009a  ee420a01          VMLA.F32 s1,s4,s2              ;250
00009e  ee003a04          VMLA.F32 s6,s0,s8              ;259
0000a2  ed931a03          VLDR     s2,[r3,#0xc]          ;262
0000a6  3310              ADDS     r3,r3,#0x10
0000a8  ed813a03          VSTR     s6,[r1,#0xc]
0000ac  ee430a01          VMLA.F32 s1,s6,s2              ;265
0000b0  3110              ADDS     r1,r1,#0x10
0000b2  3410              ADDS     r4,r4,#0x10
                  |L1.180|
0000b4  f1bc0f00          CMP      r12,#0                ;181
0000b8  d1b6              BNE      |L1.40|
;;;269    
;;;270          /* update pointers */
;;;271          px1 += 4u;
;;;272          pv += 4u;
;;;273    
;;;274          tapCnt--;
;;;275    
;;;276        }
;;;277    
;;;278        /* If the filter length is not a multiple of 4, compute the remaining filter taps */
;;;279        tapCnt = (numStages) % 0x4u;
0000ba  f0060c03          AND      r12,r6,#3
;;;280    
;;;281        while(tapCnt > 0u)
0000be  e00f              B        |L1.224|
                  |L1.192|
;;;282        {
;;;283          gcurr1 = *px1++;
0000c0  ecb21a01          VLDM     r2!,{s2}
;;;284          /* Process sample for last taps */
;;;285          fnext1 = fnext2 - ((*pk) * gcurr1);
;;;286          gnext = (fnext1 * (*pk++)) + gcurr1;
;;;287          /* Output samples for last taps */
;;;288          acc += (gnext * (*pv++));
;;;289          *px2++ = gnext;
0000c4  f1ac0c01          SUB      r12,r12,#1
0000c8  ecf41a01          VLDM     r4!,{s3}              ;285
0000cc  ee010ac1          VMLS.F32 s0,s3,s2              ;285
0000d0  ee001a21          VMLA.F32 s2,s0,s3              ;286
0000d4  ecf31a01          VLDM     r3!,{s3}              ;288
0000d8  eca11a01          VSTM     r1!,{s2}
0000dc  ee410a21          VMLA.F32 s1,s2,s3              ;288
                  |L1.224|
0000e0  f1bc0f00          CMP      r12,#0                ;281
0000e4  d1ec              BNE      |L1.192|
;;;290          fnext2 = fnext1;
;;;291    
;;;292          tapCnt--;
;;;293    
;;;294        }
;;;295    
;;;296        /* y(n) += g0(n) * v0 */
;;;297        acc += (fnext2 * (*pv));
0000e6  ed931a00          VLDR     s2,[r3,#0]
;;;298    
;;;299        *px2++ = fnext2;
0000ea  ed810a00          VSTR     s0,[r1,#0]
;;;300    
;;;301        /* write out into pDst */
;;;302        *pDst++ = acc;
0000ee  1d3f              ADDS     r7,r7,#4
0000f0  ee400a01          VMLA.F32 s1,s0,s2              ;297
0000f4  f1a80801          SUB      r8,r8,#1
0000f8  eceb0a01          VSTM     r11!,{s1}
                  |L1.252|
0000fc  f1b80f00          CMP      r8,#0                 ;159
000100  d188              BNE      |L1.20|
;;;303    
;;;304        /* Advance the state pointer by 4 to process the next group of 4 samples */
;;;305        pState = pState + 1u;
;;;306    
;;;307        blkCnt--;
;;;308    
;;;309      }
;;;310    
;;;311      /* Processing is complete. Now copy last S->numStages samples to start of the buffer        
;;;312         for the preperation of next frame process */
;;;313    
;;;314      /* Points to the start of the state buffer */
;;;315      pStateCurnt = &S->pState[0];
000102  6840              LDR      r0,[r0,#4]
;;;316      pState = &S->pState[blockSize];
000104  eb00018a          ADD      r1,r0,r10,LSL #2
;;;317    
;;;318      tapCnt = numStages >> 2u;
;;;319    
;;;320      /* copy data */
;;;321      while(tapCnt > 0u)
000108  e013              B        |L1.306|
;;;322      {
;;;323        *pStateCurnt++ = *pState++;
00010a  bf00              NOP      
                  |L1.268|
00010c  ed910a00          VLDR     s0,[r1,#0]
000110  ed800a00          VSTR     s0,[r0,#0]
;;;324        *pStateCurnt++ = *pState++;
000114  ed910a01          VLDR     s0,[r1,#4]
000118  ed800a01          VSTR     s0,[r0,#4]
;;;325        *pStateCurnt++ = *pState++;
00011c  ed910a02          VLDR     s0,[r1,#8]
000120  ed800a02          VSTR     s0,[r0,#8]
;;;326        *pStateCurnt++ = *pState++;
000124  ed910a03          VLDR     s0,[r1,#0xc]
000128  3110              ADDS     r1,r1,#0x10
00012a  ed800a03          VSTR     s0,[r0,#0xc]
00012e  3010              ADDS     r0,r0,#0x10
000130  1e6d              SUBS     r5,r5,#1
                  |L1.306|
000132  2d00              CMP      r5,#0                 ;321
000134  d1ea              BNE      |L1.268|
;;;327    
;;;328        /* Decrement the loop counter */
;;;329        tapCnt--;
;;;330    
;;;331      }
;;;332    
;;;333      /* Calculate remaining number of copies */
;;;334      tapCnt = (numStages) % 0x4u;
000136  f0060203          AND      r2,r6,#3
;;;335    
;;;336      /* Copy the remaining q31_t data */
;;;337      while(tapCnt > 0u)
00013a  e004              B        |L1.326|
                  |L1.316|
;;;338      {
;;;339        *pStateCurnt++ = *pState++;
00013c  ecb10a01          VLDM     r1!,{s0}
000140  1e52              SUBS     r2,r2,#1
000142  eca00a01          VSTM     r0!,{s0}
                  |L1.326|
000146  2a00              CMP      r2,#0                 ;337
000148  d1f8              BNE      |L1.316|
;;;340    
;;;341        /* Decrement the loop counter */
;;;342        tapCnt--;
;;;343      }
;;;344    }
00014a  e8bd8ff0          POP      {r4-r11,pc}
;;;345    
                          ENDP

00014e  0000              DCW      0x0000
                  |L1.336|
000150  00000000          DCFS     0x00000000 ; 0

;*** Start embedded assembler ***

#line 1 "src\\FilteringFunctions\\arm_iir_lattice_f32.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___21_arm_iir_lattice_f32_c_cc182ffe____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___21_arm_iir_lattice_f32_c_cc182ffe____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___21_arm_iir_lattice_f32_c_cc182ffe____REVSH|
#line 144
|__asm___21_arm_iir_lattice_f32_c_cc182ffe____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___21_arm_iir_lattice_f32_c_cc182ffe____RRX|
#line 300
|__asm___21_arm_iir_lattice_f32_c_cc182ffe____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
