; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_lms_q15.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_lms_q15.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_lms_q15.crf src\FilteringFunctions\arm_lms_q15.c]
                          THUMB

                          AREA ||i.arm_lms_q15||, CODE, READONLY, ALIGN=2

                  arm_lms_q15 PROC
;;;73     
;;;74     void arm_lms_q15(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;75       const arm_lms_instance_q15 * S,
;;;76       q15_t * pSrc,
;;;77       q15_t * pRef,
;;;78       q15_t * pOut,
;;;79       q15_t * pErr,
;;;80       uint32_t blockSize)
;;;81     {
000004  468b              MOV      r11,r1
000006  b085              SUB      sp,sp,#0x14
;;;82       q15_t *pState = S->pState;                     /* State pointer */
;;;83       uint32_t numTaps = S->numTaps;                 /* Number of filter coefficients in the filter */
;;;84       q15_t *pCoeffs = S->pCoeffs;                   /* Coefficient pointer */
;;;85       q15_t *pStateCurnt;                            /* Points to the current sample of the state */
;;;86       q15_t mu = S->mu;                              /* Adaptive factor */
000008  e9d01e01          LDRD     r1,lr,[r0,#4]
00000c  9a13              LDR      r2,[sp,#0x4c]         ;82
00000e  8806              LDRH     r6,[r0,#0]            ;83
000010  f9b0300c          LDRSH    r3,[r0,#0xc]
;;;87       q15_t *px;                                     /* Temporary pointer for state */
;;;88       q15_t *pb;                                     /* Temporary pointer for coefficient buffer */
;;;89       uint32_t tapCnt, blkCnt;                       /* Loop counters */
;;;90       q63_t acc;                                     /* Accumulator */
;;;91       q15_t e = 0;                                   /* error of data sample */
;;;92       q15_t alpha;                                   /* Intermediate constant for taps update */
;;;93       q31_t coef;                                    /* Teporary variable for coefficient */
;;;94       q31_t acc_l, acc_h;
;;;95       int32_t lShift = (15 - (int32_t) S->postShift);       /*  Post shift  */
000014  9304              STR      r3,[sp,#0x10]
000016  6903              LDR      r3,[r0,#0x10]
000018  f1c3030f          RSB      r3,r3,#0xf
;;;96       int32_t uShift = (32 - lShift);
00001c  9300              STR      r3,[sp,#0]
00001e  f1c30320          RSB      r3,r3,#0x20
;;;97     
;;;98     
;;;99     #ifndef ARM_MATH_CM0_FAMILY
;;;100    
;;;101      /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;102    
;;;103    
;;;104      /* S->pState points to buffer which contains previous frame (numTaps - 1) samples */
;;;105      /* pStateCurnt points to the location where the new input data should be written */
;;;106      pStateCurnt = &(S->pState[(numTaps - 1u)]);
000022  9303              STR      r3,[sp,#0xc]
000024  f06f0301          MVN      r3,#1
000028  eb030346          ADD      r3,r3,r6,LSL #1
00002c  eb010903          ADD      r9,r1,r3
                  |L1.48|
;;;107    
;;;108      /* Initializing blkCnt with blockSize */
;;;109      blkCnt = blockSize;
000030  ea5f0a02          MOVS     r10,r2
000034  d07d              BEQ      |L1.306|
;;;110    
;;;111      while(blkCnt > 0u)
;;;112      {
;;;113        /* Copy the new input sample into the state buffer */
;;;114        *pStateCurnt++ = *pSrc++;
000036  f83b3b02          LDRH     r3,[r11],#2
;;;115    
;;;116        /* Initialize state pointer */
;;;117        px = pState;
;;;118    
;;;119        /* Initialize coefficient pointer */
;;;120        pb = pCoeffs;
00003a  2200              MOVS     r2,#0
00003c  f8293b02          STRH     r3,[r9],#2            ;114
;;;121    
;;;122        /* Set the accumulator to zero */
;;;123        acc = 0;
;;;124    
;;;125        /* Loop unrolling.  Process 4 taps at a time. */
;;;126        tapCnt = numTaps >> 2u;
000040  08b7              LSRS     r7,r6,#2
000042  460d              MOV      r5,r1                 ;117
000044  4674              MOV      r4,lr                 ;120
000046  4613              MOV      r3,r2                 ;120
;;;127    
;;;128        while(tapCnt > 0u)
000048  9702              STR      r7,[sp,#8]
00004a  e00c              B        |L1.102|
                  |L1.76|
;;;129        {
;;;130          /* acc +=  b[N] * x[n-N] + b[N-1] * x[n-N-1] */
;;;131          /* Perform the multiply-accumulate */
;;;132    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;133    
;;;134          acc = __SMLALD(*__SIMD32(px)++, (*__SIMD32(pb)++), acc);
00004c  f8558b04          LDR      r8,[r5],#4
000050  f854cb04          LDR      r12,[r4],#4
000054  fbc823cc          SMLALD   r2,r3,r8,r12
;;;135          acc = __SMLALD(*__SIMD32(px)++, (*__SIMD32(pb)++), acc);
000058  f8558b04          LDR      r8,[r5],#4
00005c  f854cb04          LDR      r12,[r4],#4
000060  fbc823cc          SMLALD   r2,r3,r8,r12
000064  1e7f              SUBS     r7,r7,#1
                  |L1.102|
000066  2f00              CMP      r7,#0                 ;128
000068  d1f0              BNE      |L1.76|
;;;136    
;;;137    #else
;;;138    
;;;139          acc += (q63_t) (((q31_t) (*px++) * (*pb++)));
;;;140          acc += (q63_t) (((q31_t) (*px++) * (*pb++)));
;;;141          acc += (q63_t) (((q31_t) (*px++) * (*pb++)));
;;;142          acc += (q63_t) (((q31_t) (*px++) * (*pb++)));
;;;143    
;;;144    
;;;145    #endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE	*/
;;;146    
;;;147          /* Decrement the loop counter */
;;;148          tapCnt--;
;;;149        }
;;;150    
;;;151        /* If the filter length is not a multiple of 4, compute the remaining filter taps */
;;;152        tapCnt = numTaps % 0x4u;
00006a  f0060703          AND      r7,r6,#3
;;;153    
;;;154        while(tapCnt > 0u)
00006e  9701              STR      r7,[sp,#4]
000070  e007              B        |L1.130|
;;;155        {
;;;156          /* Perform the multiply-accumulate */
;;;157          acc += (q63_t) (((q31_t) (*px++) * (*pb++)));
000072  bf00              NOP      
                  |L1.116|
000074  f9358b02          LDRSH    r8,[r5],#2
000078  f934cb02          LDRSH    r12,[r4],#2
00007c  fbc8238c          SMLALBB  r2,r3,r8,r12
000080  1e7f              SUBS     r7,r7,#1
                  |L1.130|
000082  2f00              CMP      r7,#0                 ;154
000084  d1f6              BNE      |L1.116|
;;;158    
;;;159          /* Decrement the loop counter */
;;;160          tapCnt--;
;;;161        }
;;;162    
;;;163        /* Calc lower part of acc */
;;;164        acc_l = acc & 0xffffffff;
;;;165    
;;;166        /* Calc upper part of acc */
;;;167        acc_h = (acc >> 32) & 0xffffffff;
;;;168    
;;;169        /* Apply shift for lower part of acc and upper part of acc */
;;;170        acc = (uint32_t) acc_l >> lShift | acc_h << uShift;
000086  9c00              LDR      r4,[sp,#0]
000088  40e2              LSRS     r2,r2,r4
00008a  9c03              LDR      r4,[sp,#0xc]
00008c  40a3              LSLS     r3,r3,r4
00008e  431a              ORRS     r2,r2,r3
;;;171    
;;;172        /* Converting the result to 1.15 format and saturate the output */
;;;173        acc = __SSAT(acc, 16);
;;;174    
;;;175        /* Store the result from accumulator into the destination buffer. */
;;;176        *pOut++ = (q15_t) acc;
000090  9b08              LDR      r3,[sp,#0x20]
000092  f302020f          SSAT     r2,#16,r2             ;173
000096  801a              STRH     r2,[r3,#0]
000098  9b08              LDR      r3,[sp,#0x20]
00009a  1c9b              ADDS     r3,r3,#2
;;;177    
;;;178        /* Compute and store error */
;;;179        e = *pRef++ - (q15_t) acc;
00009c  9308              STR      r3,[sp,#0x20]
00009e  9b07              LDR      r3,[sp,#0x1c]
0000a0  881b              LDRH     r3,[r3,#0]
0000a2  1a9a              SUBS     r2,r3,r2
0000a4  9b07              LDR      r3,[sp,#0x1c]
0000a6  1c9b              ADDS     r3,r3,#2
;;;180    
;;;181        *pErr++ = (q15_t) e;
0000a8  9307              STR      r3,[sp,#0x1c]
0000aa  9b12              LDR      r3,[sp,#0x48]
0000ac  801a              STRH     r2,[r3,#0]
0000ae  9b12              LDR      r3,[sp,#0x48]
0000b0  1c9b              ADDS     r3,r3,#2
;;;182    
;;;183        /* Compute alpha i.e. intermediate constant for taps update */
;;;184        alpha = (q15_t) (((q31_t) e * (mu)) >> 15);
0000b2  9312              STR      r3,[sp,#0x48]
0000b4  9b04              LDR      r3,[sp,#0x10]
0000b6  fb12f203          SMULBB   r2,r2,r3
0000ba  f34234cf          SBFX     r4,r2,#15,#16
;;;185    
;;;186        /* Initialize state pointer */
;;;187        /* Advance state pointer by 1 for the next sample */
;;;188        px = pState++;
0000be  460b              MOV      r3,r1
0000c0  1c89              ADDS     r1,r1,#2
;;;189    
;;;190        /* Initialize coefficient pointer */
;;;191        pb = pCoeffs;
0000c2  4672              MOV      r2,lr
;;;192    
;;;193        /* Loop unrolling.  Process 4 taps at a time. */
;;;194        tapCnt = numTaps >> 2u;
;;;195    
;;;196        /* Update filter coefficients */
;;;197        while(tapCnt > 0u)
0000c4  9d02              LDR      r5,[sp,#8]
0000c6  e030              B        |L1.298|
                  |L1.200|
;;;198        {
;;;199          coef = (q31_t) * pb + (((q31_t) alpha * (*px++)) >> 15);
0000c8  f9b27000          LDRSH    r7,[r2,#0]
0000cc  f833cb02          LDRH     r12,[r3],#2
0000d0  fb1cfc04          SMULBB   r12,r12,r4
0000d4  eb0737ec          ADD      r7,r7,r12,ASR #15
;;;200          *pb++ = (q15_t) __SSAT((coef), 16);
0000d8  f307070f          SSAT     r7,#16,r7
0000dc  f8227b02          STRH     r7,[r2],#2
;;;201          coef = (q31_t) * pb + (((q31_t) alpha * (*px++)) >> 15);
0000e0  f833cb02          LDRH     r12,[r3],#2
0000e4  f9327b02          LDRSH    r7,[r2],#2
0000e8  fb1cfc04          SMULBB   r12,r12,r4
0000ec  eb0737ec          ADD      r7,r7,r12,ASR #15
;;;202          *pb++ = (q15_t) __SSAT((coef), 16);
0000f0  f307070f          SSAT     r7,#16,r7
0000f4  f8227c02          STRH     r7,[r2,#-2]
;;;203          coef = (q31_t) * pb + (((q31_t) alpha * (*px++)) >> 15);
0000f8  f9327b04          LDRSH    r7,[r2],#4
0000fc  f833cb02          LDRH     r12,[r3],#2
000100  fb1cfc04          SMULBB   r12,r12,r4
000104  eb0737ec          ADD      r7,r7,r12,ASR #15
;;;204          *pb++ = (q15_t) __SSAT((coef), 16);
000108  f307070f          SSAT     r7,#16,r7
00010c  f8227c04          STRH     r7,[r2,#-4]
;;;205          coef = (q31_t) * pb + (((q31_t) alpha * (*px++)) >> 15);
000110  f9327c02          LDRSH    r7,[r2,#-2]
000114  f833cb02          LDRH     r12,[r3],#2
000118  fb1cfc04          SMULBB   r12,r12,r4
00011c  eb0737ec          ADD      r7,r7,r12,ASR #15
;;;206          *pb++ = (q15_t) __SSAT((coef), 16);
000120  f307070f          SSAT     r7,#16,r7
000124  f8227c02          STRH     r7,[r2,#-2]
000128  1e6d              SUBS     r5,r5,#1
                  |L1.298|
00012a  2d00              CMP      r5,#0                 ;197
00012c  d1cc              BNE      |L1.200|
;;;207    
;;;208          /* Decrement the loop counter */
;;;209          tapCnt--;
;;;210        }
;;;211    
;;;212        /* If the filter length is not a multiple of 4, compute the remaining filter taps */
;;;213        tapCnt = numTaps % 0x4u;
;;;214    
;;;215        while(tapCnt > 0u)
00012e  9d01              LDR      r5,[sp,#4]
000130  e00d              B        |L1.334|
                  |L1.306|
000132  e011              B        |L1.344|
                  |L1.308|
;;;216        {
;;;217          /* Perform the multiply-accumulate */
;;;218          coef = (q31_t) * pb + (((q31_t) alpha * (*px++)) >> 15);
000134  f9b27000          LDRSH    r7,[r2,#0]
000138  f833cb02          LDRH     r12,[r3],#2
00013c  fb1cfc04          SMULBB   r12,r12,r4
000140  eb0737ec          ADD      r7,r7,r12,ASR #15
;;;219          *pb++ = (q15_t) __SSAT((coef), 16);
000144  f307070f          SSAT     r7,#16,r7
000148  f8227b02          STRH     r7,[r2],#2
00014c  1e6d              SUBS     r5,r5,#1
                  |L1.334|
00014e  2d00              CMP      r5,#0                 ;215
000150  d1f0              BNE      |L1.308|
;;;220    
;;;221          /* Decrement the loop counter */
;;;222          tapCnt--;
;;;223        }
;;;224    
;;;225        /* Decrement the loop counter */
;;;226        blkCnt--;
000152  f1aa0201          SUB      r2,r10,#1
000156  e76b              B        |L1.48|
                  |L1.344|
;;;227    
;;;228      }
;;;229    
;;;230      /* Processing is complete. Now copy the last numTaps - 1 samples to the    
;;;231         satrt of the state buffer. This prepares the state buffer for the    
;;;232         next function call. */
;;;233    
;;;234      /* Points to the start of the pState buffer */
;;;235      pStateCurnt = S->pState;
000158  1e76              SUBS     r6,r6,#1
00015a  6840              LDR      r0,[r0,#4]
;;;236    
;;;237      /* Calculation of count for copying integer writes */
;;;238      tapCnt = (numTaps - 1u) >> 2;
00015c  08b2              LSRS     r2,r6,#2
;;;239    
;;;240      while(tapCnt > 0u)
00015e  e008              B        |L1.370|
                  |L1.352|
;;;241      {
;;;242    
;;;243    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;244    
;;;245        *__SIMD32(pStateCurnt)++ = *__SIMD32(pState)++;
000160  f8513b04          LDR      r3,[r1],#4
000164  f8403b04          STR      r3,[r0],#4
;;;246        *__SIMD32(pStateCurnt)++ = *__SIMD32(pState)++;
000168  f8513b04          LDR      r3,[r1],#4
00016c  f8403b04          STR      r3,[r0],#4
000170  1e52              SUBS     r2,r2,#1
                  |L1.370|
000172  2a00              CMP      r2,#0                 ;240
000174  d1f4              BNE      |L1.352|
;;;247    #else
;;;248        *pStateCurnt++ = *pState++;
;;;249        *pStateCurnt++ = *pState++;
;;;250        *pStateCurnt++ = *pState++;
;;;251        *pStateCurnt++ = *pState++;
;;;252    #endif
;;;253    
;;;254        tapCnt--;
;;;255    
;;;256      }
;;;257    
;;;258      /* Calculation of count for remaining q15_t data */
;;;259      tapCnt = (numTaps - 1u) % 0x4u;
000176  f0060203          AND      r2,r6,#3
;;;260    
;;;261      /* copy data */
;;;262      while(tapCnt > 0u)
00017a  e004              B        |L1.390|
                  |L1.380|
;;;263      {
;;;264        *pStateCurnt++ = *pState++;
00017c  f8313b02          LDRH     r3,[r1],#2
000180  f8203b02          STRH     r3,[r0],#2
000184  1e52              SUBS     r2,r2,#1
                  |L1.390|
000186  2a00              CMP      r2,#0                 ;262
000188  d1f8              BNE      |L1.380|
;;;265    
;;;266        /* Decrement the loop counter */
;;;267        tapCnt--;
;;;268      }
;;;269    
;;;270    #else
;;;271    
;;;272      /* Run the below code for Cortex-M0 */
;;;273    
;;;274      /* S->pState points to buffer which contains previous frame (numTaps - 1) samples */
;;;275      /* pStateCurnt points to the location where the new input data should be written */
;;;276      pStateCurnt = &(S->pState[(numTaps - 1u)]);
;;;277    
;;;278      /* Loop over blockSize number of values */
;;;279      blkCnt = blockSize;
;;;280    
;;;281      while(blkCnt > 0u)
;;;282      {
;;;283        /* Copy the new input sample into the state buffer */
;;;284        *pStateCurnt++ = *pSrc++;
;;;285    
;;;286        /* Initialize pState pointer */
;;;287        px = pState;
;;;288    
;;;289        /* Initialize pCoeffs pointer */
;;;290        pb = pCoeffs;
;;;291    
;;;292        /* Set the accumulator to zero */
;;;293        acc = 0;
;;;294    
;;;295        /* Loop over numTaps number of values */
;;;296        tapCnt = numTaps;
;;;297    
;;;298        while(tapCnt > 0u)
;;;299        {
;;;300          /* Perform the multiply-accumulate */
;;;301          acc += (q63_t) ((q31_t) (*px++) * (*pb++));
;;;302    
;;;303          /* Decrement the loop counter */
;;;304          tapCnt--;
;;;305        }
;;;306    
;;;307        /* Calc lower part of acc */
;;;308        acc_l = acc & 0xffffffff;
;;;309    
;;;310        /* Calc upper part of acc */
;;;311        acc_h = (acc >> 32) & 0xffffffff;
;;;312    
;;;313        /* Apply shift for lower part of acc and upper part of acc */
;;;314        acc = (uint32_t) acc_l >> lShift | acc_h << uShift;
;;;315    
;;;316        /* Converting the result to 1.15 format and saturate the output */
;;;317        acc = __SSAT(acc, 16);
;;;318    
;;;319        /* Store the result from accumulator into the destination buffer. */
;;;320        *pOut++ = (q15_t) acc;
;;;321    
;;;322        /* Compute and store error */
;;;323        e = *pRef++ - (q15_t) acc;
;;;324    
;;;325        *pErr++ = (q15_t) e;
;;;326    
;;;327        /* Compute alpha i.e. intermediate constant for taps update */
;;;328        alpha = (q15_t) (((q31_t) e * (mu)) >> 15);
;;;329    
;;;330        /* Initialize pState pointer */
;;;331        /* Advance state pointer by 1 for the next sample */
;;;332        px = pState++;
;;;333    
;;;334        /* Initialize pCoeffs pointer */
;;;335        pb = pCoeffs;
;;;336    
;;;337        /* Loop over numTaps number of values */
;;;338        tapCnt = numTaps;
;;;339    
;;;340        while(tapCnt > 0u)
;;;341        {
;;;342          /* Perform the multiply-accumulate */
;;;343          coef = (q31_t) * pb + (((q31_t) alpha * (*px++)) >> 15);
;;;344          *pb++ = (q15_t) __SSAT((coef), 16);
;;;345    
;;;346          /* Decrement the loop counter */
;;;347          tapCnt--;
;;;348        }
;;;349    
;;;350        /* Decrement the loop counter */
;;;351        blkCnt--;
;;;352    
;;;353      }
;;;354    
;;;355      /* Processing is complete. Now copy the last numTaps - 1 samples to the        
;;;356         start of the state buffer. This prepares the state buffer for the   
;;;357         next function call. */
;;;358    
;;;359      /* Points to the start of the pState buffer */
;;;360      pStateCurnt = S->pState;
;;;361    
;;;362      /*  Copy (numTaps - 1u) samples  */
;;;363      tapCnt = (numTaps - 1u);
;;;364    
;;;365      /* Copy the data */
;;;366      while(tapCnt > 0u)
;;;367      {
;;;368        *pStateCurnt++ = *pState++;
;;;369    
;;;370        /* Decrement the loop counter */
;;;371        tapCnt--;
;;;372      }
;;;373    
;;;374    #endif /*   #ifndef ARM_MATH_CM0_FAMILY */
;;;375    
;;;376    }
00018a  b009              ADD      sp,sp,#0x24
00018c  e8bd8ff0          POP      {r4-r11,pc}
;;;377    
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\FilteringFunctions\\arm_lms_q15.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_arm_lms_q15_c_39f65420____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___13_arm_lms_q15_c_39f65420____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_arm_lms_q15_c_39f65420____REVSH|
#line 144
|__asm___13_arm_lms_q15_c_39f65420____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___13_arm_lms_q15_c_39f65420____RRX|
#line 300
|__asm___13_arm_lms_q15_c_39f65420____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
