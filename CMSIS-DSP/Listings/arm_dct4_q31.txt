; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_dct4_q31.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_dct4_q31.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_dct4_q31.crf src\TransformFunctions\arm_dct4_q31.c]
                          THUMB

                          AREA ||i.arm_dct4_q31||, CODE, READONLY, ALIGN=2

                  arm_dct4_q31 PROC
;;;63     
;;;64     void arm_dct4_q31(
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;65       const arm_dct4_instance_q31 * S,
;;;66       q31_t * pState,
;;;67       q31_t * pInlineBuffer)
;;;68     {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  e9d47102          LDRD     r7,r1,[r4,#8]
;;;69       uint16_t i;                                    /* Loop counter */
;;;70       q31_t *weights = S->pTwiddle;                  /* Pointer to the Weights table */
;;;71       q31_t *cosFact = S->pCosFactor;                /* Pointer to the cos factors table */
;;;72       q31_t *pS1, *pS2, *pbuff;                      /* Temporary pointers for input buffer and pState buffer */
;;;73       q31_t in;                                      /* Temporary variable */
;;;74     
;;;75     
;;;76       /* DCT4 computation involves DCT2 (which is calculated using RFFT)    
;;;77        * along with some pre-processing and post-processing.    
;;;78        * Computational procedure is explained as follows:    
;;;79        * (a) Pre-processing involves multiplying input with cos factor,    
;;;80        *     r(n) = 2 * u(n) * cos(pi*(2*n+1)/(4*n))    
;;;81        *              where,    
;;;82        *                 r(n) -- output of preprocessing    
;;;83        *                 u(n) -- input to preprocessing(actual Source buffer)    
;;;84        * (b) Calculation of DCT2 using FFT is divided into three steps:    
;;;85        *                  Step1: Re-ordering of even and odd elements of input.    
;;;86        *                  Step2: Calculating FFT of the re-ordered input.    
;;;87        *                  Step3: Taking the real part of the product of FFT output and weights.    
;;;88        * (c) Post-processing - DCT4 can be obtained from DCT2 output using the following equation:    
;;;89        *                   Y4(k) = Y2(k) - Y4(k-1) and Y4(-1) = Y4(0)    
;;;90        *                        where,    
;;;91        *                           Y4 -- DCT4 output,   Y2 -- DCT2 output    
;;;92        * (d) Multiplying the output with the normalizing factor sqrt(2/N).    
;;;93        */
;;;94     
;;;95             /*-------- Pre-processing ------------*/
;;;96       /* Multiplying input with cos factor i.e. r(n) = 2 * x(n) * cos(pi*(2*n+1)/(4*n)) */
;;;97       arm_mult_q31(pInlineBuffer, cosFact, pInlineBuffer, S->N);
00000c  8803              LDRH     r3,[r0,#0]
00000e  4615              MOV      r5,r2                 ;68
000010  4610              MOV      r0,r2
000012  f7fffffe          BL       arm_mult_q31
;;;98       arm_shift_q31(pInlineBuffer, 1, pInlineBuffer, S->N);
000016  462a              MOV      r2,r5
000018  8823              LDRH     r3,[r4,#0]
00001a  2101              MOVS     r1,#1
00001c  4610              MOV      r0,r2
00001e  f7fffffe          BL       arm_shift_q31
;;;99     
;;;100      /* ----------------------------------------------------------------    
;;;101       * Step1: Re-ordering of even and odd elements as    
;;;102       *             pState[i] =  pInlineBuffer[2*i] and    
;;;103       *             pState[N-i-1] = pInlineBuffer[2*i+1] where i = 0 to N/2    
;;;104       ---------------------------------------------------------------------*/
;;;105    
;;;106      /* pS1 initialized to pState */
;;;107      pS1 = pState;
;;;108    
;;;109      /* pS2 initialized to pState+N-1, so that it points to the end of the state buffer */
;;;110      pS2 = pState + (S->N - 1u);
000022  8820              LDRH     r0,[r4,#0]
;;;111    
;;;112      /* pbuff initialized to input buffer */
;;;113      pbuff = pInlineBuffer;
;;;114    
;;;115    #ifndef ARM_MATH_CM0_FAMILY
;;;116    
;;;117      /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;118    
;;;119      /* Initializing the loop counter to N/2 >> 2 for loop unrolling by 4 */
;;;120      i = S->Nby2 >> 2u;
000024  8863              LDRH     r3,[r4,#2]
000026  eb060280          ADD      r2,r6,r0,LSL #2       ;110
00002a  089b              LSRS     r3,r3,#2
00002c  4631              MOV      r1,r6                 ;110
00002e  4628              MOV      r0,r5                 ;113
000030  f1b20204          SUBS.W   r2,r2,#4
                  |L1.52|
;;;121    
;;;122      /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.    
;;;123       ** a second loop below computes the remaining 1 to 3 samples. */
;;;124      do
;;;125      {
;;;126        /* Re-ordering of even and odd elements */
;;;127        /* pState[i] =  pInlineBuffer[2*i] */
;;;128        *pS1++ = *pbuff++;
000034  f850cb04          LDR      r12,[r0],#4
000038  f841cb04          STR      r12,[r1],#4
;;;129        /* pState[N-i-1] = pInlineBuffer[2*i+1] */
;;;130        *pS2-- = *pbuff++;
00003c  f850cb04          LDR      r12,[r0],#4
;;;131    
;;;132        *pS1++ = *pbuff++;
000040  f8c2c000          STR      r12,[r2,#0]
000044  f850eb04          LDR      lr,[r0],#4
000048  f841eb04          STR      lr,[r1],#4
;;;133        *pS2-- = *pbuff++;
00004c  f850eb04          LDR      lr,[r0],#4
000050  f842ec04          STR      lr,[r2,#-4]
;;;134    
;;;135        *pS1++ = *pbuff++;
000054  f850eb04          LDR      lr,[r0],#4
000058  f841eb04          STR      lr,[r1],#4
;;;136        *pS2-- = *pbuff++;
00005c  f850eb04          LDR      lr,[r0],#4
000060  f842ec08          STR      lr,[r2,#-8]
;;;137    
;;;138        *pS1++ = *pbuff++;
000064  f850eb04          LDR      lr,[r0],#4
000068  f841eb04          STR      lr,[r1],#4
;;;139        *pS2-- = *pbuff++;
00006c  f850eb04          LDR      lr,[r0],#4
000070  f842ec0c          STR      lr,[r2,#-0xc]
000074  3a10              SUBS     r2,r2,#0x10
000076  1e5b              SUBS     r3,r3,#1
;;;140    
;;;141        /* Decrement the loop counter */
;;;142        i--;
000078  041b              LSLS     r3,r3,#16
00007a  0c1b              LSRS     r3,r3,#16
;;;143      } while(i > 0u);
00007c  d1da              BNE      |L1.52|
;;;144    
;;;145      /* pbuff initialized to input buffer */
;;;146      pbuff = pInlineBuffer;
;;;147    
;;;148      /* pS1 initialized to pState */
;;;149      pS1 = pState;
;;;150    
;;;151      /* Initializing the loop counter to N/4 instead of N for loop unrolling */
;;;152      i = S->N >> 2u;
00007e  8822              LDRH     r2,[r4,#0]
000080  4628              MOV      r0,r5                 ;146
000082  4631              MOV      r1,r6                 ;149
000084  0892              LSRS     r2,r2,#2
                  |L1.134|
;;;153    
;;;154      /* Processing with loop unrolling 4 times as N is always multiple of 4.    
;;;155       * Compute 4 outputs at a time */
;;;156      do
;;;157      {
;;;158        /* Writing the re-ordered output back to inplace input buffer */
;;;159        *pbuff++ = *pS1++;
000086  c908              LDM      r1!,{r3}
;;;160        *pbuff++ = *pS1++;
;;;161        *pbuff++ = *pS1++;
;;;162        *pbuff++ = *pS1++;
000088  1e52              SUBS     r2,r2,#1
00008a  c008              STM      r0!,{r3}              ;159
00008c  c908              LDM      r1!,{r3}              ;160
;;;163    
;;;164        /* Decrement the loop counter */
;;;165        i--;
00008e  0412              LSLS     r2,r2,#16
000090  c008              STM      r0!,{r3}              ;160
000092  f8513b08          LDR      r3,[r1],#8            ;161
000096  f8403b08          STR      r3,[r0],#8            ;161
00009a  f8513c04          LDR      r3,[r1,#-4]           ;162
00009e  f8403c04          STR      r3,[r0,#-4]           ;162
0000a2  0c12              LSRS     r2,r2,#16
;;;166      } while(i > 0u);
0000a4  d1ef              BNE      |L1.134|
;;;167    
;;;168    
;;;169      /* ---------------------------------------------------------    
;;;170       *     Step2: Calculate RFFT for N-point input    
;;;171       * ---------------------------------------------------------- */
;;;172      /* pInlineBuffer is real input of length N , pState is the complex output of length 2N */
;;;173      arm_rfft_q31(S->pRfft, pInlineBuffer, pState);
0000a6  4632              MOV      r2,r6
0000a8  4629              MOV      r1,r5
0000aa  6920              LDR      r0,[r4,#0x10]
0000ac  f7fffffe          BL       arm_rfft_q31
;;;174    
;;;175      /*----------------------------------------------------------------------    
;;;176       *  Step3: Multiply the FFT output with the weights.    
;;;177       *----------------------------------------------------------------------*/
;;;178      arm_cmplx_mult_cmplx_q31(pState, weights, pState, S->N);
0000b0  4632              MOV      r2,r6
0000b2  8823              LDRH     r3,[r4,#0]
0000b4  4639              MOV      r1,r7
0000b6  4610              MOV      r0,r2
0000b8  f7fffffe          BL       arm_cmplx_mult_cmplx_q31
;;;179    
;;;180      /* The output of complex multiplication is in 3.29 format.    
;;;181       * Hence changing the format of N (i.e. 2*N elements) complex numbers to 1.31 format by shifting left by 2 bits. */
;;;182      arm_shift_q31(pState, 2, pState, S->N * 2);
0000bc  8820              LDRH     r0,[r4,#0]
0000be  4632              MOV      r2,r6
0000c0  0043              LSLS     r3,r0,#1
0000c2  2102              MOVS     r1,#2
0000c4  4610              MOV      r0,r2
0000c6  f7fffffe          BL       arm_shift_q31
;;;183    
;;;184      /* ----------- Post-processing ---------- */
;;;185      /* DCT-IV can be obtained from DCT-II by the equation,    
;;;186       *       Y4(k) = Y2(k) - Y4(k-1) and Y4(-1) = Y4(0)    
;;;187       *       Hence, Y4(0) = Y2(0)/2  */
;;;188      /* Getting only real part from the output and Converting to DCT-IV */
;;;189    
;;;190      /* Initializing the loop counter to N >> 2 for loop unrolling by 4 */
;;;191      i = (S->N - 1u) >> 2u;
0000ca  8820              LDRH     r0,[r4,#0]
;;;192    
;;;193      /* pbuff initialized to input buffer. */
;;;194      pbuff = pInlineBuffer;
;;;195    
;;;196      /* pS1 initialized to pState */
;;;197      pS1 = pState;
;;;198    
;;;199      /* Calculating Y4(0) from Y2(0) using Y4(0) = Y2(0)/2 */
;;;200      in = *pS1++ >> 1u;
0000cc  f8562b08          LDR      r2,[r6],#8
0000d0  1e40              SUBS     r0,r0,#1              ;191
0000d2  1052              ASRS     r2,r2,#1
0000d4  f3c0018f          UBFX     r1,r0,#2,#16          ;191
;;;201      /* input buffer acts as inplace, so output values are stored in the input itself. */
;;;202      *pbuff++ = in;
0000d8  1d28              ADDS     r0,r5,#4
0000da  602a              STR      r2,[r5,#0]
                  |L1.220|
;;;203    
;;;204      /* pState pointer is incremented twice as the real values are located alternatively in the array */
;;;205      pS1++;
;;;206    
;;;207      /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.    
;;;208       ** a second loop below computes the remaining 1 to 3 samples. */
;;;209      do
;;;210      {
;;;211        /* Calculating Y4(1) to Y4(N-1) from Y2 using equation Y4(k) = Y2(k) - Y4(k-1) */
;;;212        /* pState pointer (pS1) is incremented twice as the real values are located alternatively in the array */
;;;213        in = *pS1++ - in;
0000dc  f8563b08          LDR      r3,[r6],#8
0000e0  1a9a              SUBS     r2,r3,r2
;;;214        *pbuff++ = in;
0000e2  c004              STM      r0!,{r2}
;;;215        /* points to the next real value */
;;;216        pS1++;
;;;217    
;;;218        in = *pS1++ - in;
0000e4  f8563b08          LDR      r3,[r6],#8
0000e8  1a9a              SUBS     r2,r3,r2
;;;219        *pbuff++ = in;
0000ea  c004              STM      r0!,{r2}
;;;220        pS1++;
;;;221    
;;;222        in = *pS1++ - in;
0000ec  f8563b10          LDR      r3,[r6],#0x10
0000f0  1a9a              SUBS     r2,r3,r2
;;;223        *pbuff++ = in;
0000f2  f8402b08          STR      r2,[r0],#8
;;;224        pS1++;
;;;225    
;;;226        in = *pS1++ - in;
0000f6  f8563c08          LDR      r3,[r6,#-8]
0000fa  1a9a              SUBS     r2,r3,r2
;;;227        *pbuff++ = in;
0000fc  1e49              SUBS     r1,r1,#1
;;;228        pS1++;
;;;229    
;;;230        /* Decrement the loop counter */
;;;231        i--;
0000fe  0409              LSLS     r1,r1,#16
000100  f8402c04          STR      r2,[r0,#-4]           ;227
000104  0c09              LSRS     r1,r1,#16
;;;232      } while(i > 0u);
000106  d1e9              BNE      |L1.220|
;;;233    
;;;234      /* If the blockSize is not a multiple of 4, compute any remaining output samples here.    
;;;235       ** No loop unrolling is used. */
;;;236      i = (S->N - 1u) % 0x4u;
000108  7821              LDRB     r1,[r4,#0]
00010a  1e49              SUBS     r1,r1,#1
00010c  f0010103          AND      r1,r1,#3
;;;237    
;;;238      while(i > 0u)
000110  e006              B        |L1.288|
;;;239      {
;;;240        /* Calculating Y4(1) to Y4(N-1) from Y2 using equation Y4(k) = Y2(k) - Y4(k-1) */
;;;241        /* pState pointer (pS1) is incremented twice as the real values are located alternatively in the array */
;;;242        in = *pS1++ - in;
000112  bf00              NOP      
                  |L1.276|
000114  f8563b08          LDR      r3,[r6],#8
000118  1a9a              SUBS     r2,r3,r2
;;;243        *pbuff++ = in;
00011a  c004              STM      r0!,{r2}
00011c  1e49              SUBS     r1,r1,#1
;;;244        /* points to the next real value */
;;;245        pS1++;
;;;246    
;;;247        /* Decrement the loop counter */
;;;248        i--;
00011e  b289              UXTH     r1,r1
                  |L1.288|
000120  2900              CMP      r1,#0                 ;238
000122  d1f7              BNE      |L1.276|
;;;249      }
;;;250    
;;;251    
;;;252            /*------------ Normalizing the output by multiplying with the normalizing factor ----------*/
;;;253    
;;;254      /* Initializing the loop counter to N/4 instead of N for loop unrolling */
;;;255      i = S->N >> 2u;
000124  8820              LDRH     r0,[r4,#0]
000126  0880              LSRS     r0,r0,#2
                  |L1.296|
;;;256    
;;;257      /* pbuff initialized to the pInlineBuffer(now contains the output values) */
;;;258      pbuff = pInlineBuffer;
;;;259    
;;;260      /* Processing with loop unrolling 4 times as N is always multiple of 4.  Compute 4 outputs at a time */
;;;261      do
;;;262      {
;;;263        /* Multiplying pInlineBuffer with the normalizing factor sqrt(2/N) */
;;;264        in = *pbuff;
;;;265        *pbuff++ = ((q31_t) (((q63_t) in * S->normalize) >> 31));
000128  6829              LDR      r1,[r5,#0]
00012a  6862              LDR      r2,[r4,#4]
;;;266    
;;;267        in = *pbuff;
;;;268        *pbuff++ = ((q31_t) (((q63_t) in * S->normalize) >> 31));
;;;269    
;;;270        in = *pbuff;
;;;271        *pbuff++ = ((q31_t) (((q63_t) in * S->normalize) >> 31));
;;;272    
;;;273        in = *pbuff;
;;;274        *pbuff++ = ((q31_t) (((q63_t) in * S->normalize) >> 31));
00012c  1e40              SUBS     r0,r0,#1
00012e  fb812102          SMULL    r2,r1,r1,r2           ;265
000132  004b              LSLS     r3,r1,#1              ;265
000134  ea4371d2          ORR      r1,r3,r2,LSR #31      ;265
000138  c502              STM      r5!,{r1}              ;265
00013a  6862              LDR      r2,[r4,#4]            ;268
00013c  cd02              LDM      r5!,{r1}              ;267
;;;275    
;;;276        /* Decrement the loop counter */
;;;277        i--;
00013e  0400              LSLS     r0,r0,#16
000140  fb811202          SMULL    r1,r2,r1,r2           ;268
000144  0fc9              LSRS     r1,r1,#31             ;268
000146  ea410142          ORR      r1,r1,r2,LSL #1       ;268
00014a  f8451c04          STR      r1,[r5,#-4]           ;268
00014e  f8551b08          LDR      r1,[r5],#8            ;270
000152  6862              LDR      r2,[r4,#4]            ;271
000154  fb812102          SMULL    r2,r1,r1,r2           ;271
000158  004b              LSLS     r3,r1,#1              ;271
00015a  ea4371d2          ORR      r1,r3,r2,LSR #31      ;271
00015e  f8451c08          STR      r1,[r5,#-8]           ;271
000162  f8551c04          LDR      r1,[r5,#-4]           ;273
000166  6862              LDR      r2,[r4,#4]            ;274
000168  fb811202          SMULL    r1,r2,r1,r2           ;274
00016c  0fc9              LSRS     r1,r1,#31             ;274
00016e  ea410142          ORR      r1,r1,r2,LSL #1       ;274
000172  f8451c04          STR      r1,[r5,#-4]           ;274
000176  0c00              LSRS     r0,r0,#16
;;;278      } while(i > 0u);
000178  d1d6              BNE      |L1.296|
;;;279    
;;;280    
;;;281    #else
;;;282    
;;;283      /* Run the below code for Cortex-M0 */
;;;284    
;;;285      /* Initializing the loop counter to N/2 */
;;;286      i = S->Nby2;
;;;287    
;;;288      do
;;;289      {
;;;290        /* Re-ordering of even and odd elements */
;;;291        /* pState[i] =  pInlineBuffer[2*i] */
;;;292        *pS1++ = *pbuff++;
;;;293        /* pState[N-i-1] = pInlineBuffer[2*i+1] */
;;;294        *pS2-- = *pbuff++;
;;;295    
;;;296        /* Decrement the loop counter */
;;;297        i--;
;;;298      } while(i > 0u);
;;;299    
;;;300      /* pbuff initialized to input buffer */
;;;301      pbuff = pInlineBuffer;
;;;302    
;;;303      /* pS1 initialized to pState */
;;;304      pS1 = pState;
;;;305    
;;;306      /* Initializing the loop counter */
;;;307      i = S->N;
;;;308    
;;;309      do
;;;310      {
;;;311        /* Writing the re-ordered output back to inplace input buffer */
;;;312        *pbuff++ = *pS1++;
;;;313    
;;;314        /* Decrement the loop counter */
;;;315        i--;
;;;316      } while(i > 0u);
;;;317    
;;;318    
;;;319      /* ---------------------------------------------------------    
;;;320       *     Step2: Calculate RFFT for N-point input    
;;;321       * ---------------------------------------------------------- */
;;;322      /* pInlineBuffer is real input of length N , pState is the complex output of length 2N */
;;;323      arm_rfft_q31(S->pRfft, pInlineBuffer, pState);
;;;324    
;;;325      /*----------------------------------------------------------------------    
;;;326       *  Step3: Multiply the FFT output with the weights.    
;;;327       *----------------------------------------------------------------------*/
;;;328      arm_cmplx_mult_cmplx_q31(pState, weights, pState, S->N);
;;;329    
;;;330      /* The output of complex multiplication is in 3.29 format.    
;;;331       * Hence changing the format of N (i.e. 2*N elements) complex numbers to 1.31 format by shifting left by 2 bits. */
;;;332      arm_shift_q31(pState, 2, pState, S->N * 2);
;;;333    
;;;334      /* ----------- Post-processing ---------- */
;;;335      /* DCT-IV can be obtained from DCT-II by the equation,    
;;;336       *       Y4(k) = Y2(k) - Y4(k-1) and Y4(-1) = Y4(0)    
;;;337       *       Hence, Y4(0) = Y2(0)/2  */
;;;338      /* Getting only real part from the output and Converting to DCT-IV */
;;;339    
;;;340      /* pbuff initialized to input buffer. */
;;;341      pbuff = pInlineBuffer;
;;;342    
;;;343      /* pS1 initialized to pState */
;;;344      pS1 = pState;
;;;345    
;;;346      /* Calculating Y4(0) from Y2(0) using Y4(0) = Y2(0)/2 */
;;;347      in = *pS1++ >> 1u;
;;;348      /* input buffer acts as inplace, so output values are stored in the input itself. */
;;;349      *pbuff++ = in;
;;;350    
;;;351      /* pState pointer is incremented twice as the real values are located alternatively in the array */
;;;352      pS1++;
;;;353    
;;;354      /* Initializing the loop counter */
;;;355      i = (S->N - 1u);
;;;356    
;;;357      while(i > 0u)
;;;358      {
;;;359        /* Calculating Y4(1) to Y4(N-1) from Y2 using equation Y4(k) = Y2(k) - Y4(k-1) */
;;;360        /* pState pointer (pS1) is incremented twice as the real values are located alternatively in the array */
;;;361        in = *pS1++ - in;
;;;362        *pbuff++ = in;
;;;363        /* points to the next real value */
;;;364        pS1++;
;;;365    
;;;366        /* Decrement the loop counter */
;;;367        i--;
;;;368      }
;;;369    
;;;370    
;;;371            /*------------ Normalizing the output by multiplying with the normalizing factor ----------*/
;;;372    
;;;373      /* Initializing the loop counter */
;;;374      i = S->N;
;;;375    
;;;376      /* pbuff initialized to the pInlineBuffer(now contains the output values) */
;;;377      pbuff = pInlineBuffer;
;;;378    
;;;379      do
;;;380      {
;;;381        /* Multiplying pInlineBuffer with the normalizing factor sqrt(2/N) */
;;;382        in = *pbuff;
;;;383        *pbuff++ = ((q31_t) (((q63_t) in * S->normalize) >> 31));
;;;384    
;;;385        /* Decrement the loop counter */
;;;386        i--;
;;;387      } while(i > 0u);
;;;388    
;;;389    #endif /* #ifndef ARM_MATH_CM0_FAMILY */
;;;390    
;;;391    }
00017a  e8bd81f0          POP      {r4-r8,pc}
;;;392    
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\TransformFunctions\\arm_dct4_q31.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_arm_dct4_q31_c_ae9bdd6c____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___14_arm_dct4_q31_c_ae9bdd6c____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_arm_dct4_q31_c_ae9bdd6c____REVSH|
#line 144
|__asm___14_arm_dct4_q31_c_ae9bdd6c____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___14_arm_dct4_q31_c_ae9bdd6c____RRX|
#line 300
|__asm___14_arm_dct4_q31_c_ae9bdd6c____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
