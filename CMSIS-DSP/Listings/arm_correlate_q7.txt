; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_correlate_q7.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_correlate_q7.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_correlate_q7.crf src\FilteringFunctions\arm_correlate_q7.c]
                          THUMB

                          AREA ||i.arm_correlate_q7||, CODE, READONLY, ALIGN=2

                  arm_correlate_q7 PROC
;;;75     
;;;76     void arm_correlate_q7(
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;77       q7_t * pSrcA,
;;;78       uint32_t srcALen,
;;;79       q7_t * pSrcB,
;;;80       uint32_t srcBLen,
;;;81       q7_t * pDst)
;;;82     {
000004  b099              SUB      sp,sp,#0x64
;;;83     
;;;84     
;;;85     #ifndef ARM_MATH_CM0_FAMILY
;;;86     
;;;87       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;88     
;;;89       q7_t *pIn1;                                    /* inputA pointer               */
;;;90       q7_t *pIn2;                                    /* inputB pointer               */
;;;91       q7_t *pOut = pDst;                             /* output pointer               */
;;;92       q7_t *px;                                      /* Intermediate inputA pointer  */
;;;93       q7_t *py;                                      /* Intermediate inputB pointer  */
;;;94       q7_t *pSrc1;                                   /* Intermediate pointers        */
;;;95       q31_t sum, acc0, acc1, acc2, acc3;             /* Accumulators                  */
;;;96       q31_t input1, input2;                          /* temporary variables */
;;;97       q15_t in1, in2;                                /* temporary variables */
;;;98       q7_t x0, x1, x2, x3, c0, c1;                   /* temporary variables for holding input and coefficient values */
;;;99       uint32_t j, k = 0u, count, blkCnt, outBlockSize, blockSize1, blockSize2, blockSize3;  /* loop counter                 */
;;;100      int32_t inc = 1;
000006  2501              MOVS     r5,#1
000008  9c22              LDR      r4,[sp,#0x88]
;;;101    
;;;102    
;;;103      /* The algorithm implementation is based on the lengths of the inputs. */
;;;104      /* srcB is always made to slide across srcA. */
;;;105      /* So srcBLen is always considered as shorter or equal to srcALen */
;;;106      /* But CORR(x, y) is reverse of CORR(y, x) */
;;;107      /* So, when srcBLen > srcALen, output pointer is made to point to the end of the output buffer */
;;;108      /* and the destination pointer modifier, inc is set to -1 */
;;;109      /* If srcALen > srcBLen, zero pad has to be done to srcB to make the two inputs of same length */
;;;110      /* But to improve the performance,   
;;;111       * we include zeroes in the output instead of zero padding either of the the inputs*/
;;;112      /* If srcALen > srcBLen,   
;;;113       * (srcALen - srcBLen) zeroes has to included in the starting of the output buffer */
;;;114      /* If srcALen < srcBLen,   
;;;115       * (srcALen - srcBLen) zeroes has to included in the ending of the output buffer */
;;;116      if(srcALen >= srcBLen)
;;;117      {
;;;118        /* Initialization of inputA pointer */
;;;119        pIn1 = (pSrcA);
;;;120    
;;;121        /* Initialization of inputB pointer */
;;;122        pIn2 = (pSrcB);
;;;123    
;;;124        /* Number of output samples is calculated */
;;;125        outBlockSize = (2u * srcALen) - 1u;
00000a  9509              STR      r5,[sp,#0x24]
00000c  1ead              SUBS     r5,r5,#2
00000e  4299              CMP      r1,r3                 ;116
000010  d309              BCC      |L1.38|
000012  9215              STR      r2,[sp,#0x54]
000014  900e              STR      r0,[sp,#0x38]
000016  eb050041          ADD      r0,r5,r1,LSL #1
;;;126    
;;;127        /* When srcALen > srcBLen, zero padding is done to srcB   
;;;128         * to make their lengths equal.   
;;;129         * Instead, (outBlockSize - (srcALen + srcBLen - 1))   
;;;130         * number of output samples are made zero */
;;;131        j = outBlockSize - (srcALen + (srcBLen - 1u));
00001a  18ca              ADDS     r2,r1,r3
00001c  1a80              SUBS     r0,r0,r2
00001e  1c40              ADDS     r0,r0,#1
;;;132    
;;;133        /* Updating the pointer position to non zero value */
;;;134        pOut += j;
000020  4420              ADD      r0,r0,r4
000022  9002              STR      r0,[sp,#8]
000024  e009              B        |L1.58|
                  |L1.38|
;;;135    
;;;136      }
;;;137      else
;;;138      {
;;;139        /* Initialization of inputA pointer */
;;;140        pIn1 = (pSrcB);
;;;141    
;;;142        /* Initialization of inputB pointer */
;;;143        pIn2 = (pSrcA);
;;;144    
;;;145        /* srcBLen is always considered as shorter or equal to srcALen */
;;;146        j = srcBLen;
000026  9015              STR      r0,[sp,#0x54]
000028  4618              MOV      r0,r3
;;;147        srcBLen = srcALen;
00002a  460b              MOV      r3,r1
;;;148        srcALen = j;
00002c  4601              MOV      r1,r0
;;;149    
;;;150        /* CORR(x, y) = Reverse order(CORR(y, x)) */
;;;151        /* Hence set the destination pointer to point to the last output sample */
;;;152        pOut = pDst + ((srcALen + srcBLen) - 2u);
00002e  4418              ADD      r0,r0,r3
000030  4420              ADD      r0,r0,r4
000032  920e              STR      r2,[sp,#0x38]         ;146
000034  1e80              SUBS     r0,r0,#2
;;;153    
;;;154        /* Destination address modifier is set to -1 */
;;;155        inc = -1;
000036  9509              STR      r5,[sp,#0x24]
000038  9002              STR      r0,[sp,#8]
                  |L1.58|
;;;156    
;;;157      }
;;;158    
;;;159      /* The function is internally   
;;;160       * divided into three parts according to the number of multiplications that has to be   
;;;161       * taken place between inputA samples and inputB samples. In the first part of the   
;;;162       * algorithm, the multiplications increase by one for every iteration.   
;;;163       * In the second part of the algorithm, srcBLen number of multiplications are done.   
;;;164       * In the third part of the algorithm, the multiplications decrease by one   
;;;165       * for every iteration.*/
;;;166      /* The algorithm is implemented in three stages.   
;;;167       * The loop counters of each stage is initiated here. */
;;;168      blockSize1 = srcBLen - 1u;
;;;169      blockSize2 = srcALen - (srcBLen - 1u);
00003a  1ac8              SUBS     r0,r1,r3
;;;170      blockSize3 = blockSize1;
;;;171    
;;;172      /* --------------------------   
;;;173       * Initializations of stage1   
;;;174       * -------------------------*/
;;;175    
;;;176      /* sum = x[0] * y[srcBlen - 1]   
;;;177       * sum = x[0] * y[srcBlen - 2] + x[1] * y[srcBlen - 1]   
;;;178       * ....   
;;;179       * sum = x[0] * y[0] + x[1] * y[1] +...+ x[srcBLen - 1] * y[srcBLen - 1]   
;;;180       */
;;;181    
;;;182      /* In this stage the MAC operations are increased by 1 for every iteration.   
;;;183         The count variable holds the number of MAC operations performed */
;;;184      count = 1u;
00003c  900d              STR      r0,[sp,#0x34]
00003e  1e5a              SUBS     r2,r3,#1              ;168
000040  1c40              ADDS     r0,r0,#1
000042  e9cd2016          STRD     r2,r0,[sp,#0x58]
;;;185    
;;;186      /* Working pointer of inputA */
;;;187      px = pIn1;
;;;188    
;;;189      /* Working pointer of inputB */
;;;190      pSrc1 = pIn2 + (srcBLen - 1u);
000046  9815              LDR      r0,[sp,#0x54]
000048  2501              MOVS     r5,#1                 ;184
00004a  4418              ADD      r0,r0,r3
00004c  1e40              SUBS     r0,r0,#1
00004e  4681              MOV      r9,r0
;;;191      py = pSrc1;
;;;192    
;;;193      /* ------------------------   
;;;194       * Stage1 process   
;;;195       * ----------------------*/
;;;196    
;;;197      /* The first stage starts here */
;;;198      while(blockSize1 > 0u)
000050  9c0e              LDR      r4,[sp,#0x38]
000052  e03b              B        |L1.204|
                  |L1.84|
;;;199      {
;;;200        /* Accumulator is made zero for every iteration */
;;;201        sum = 0;
000054  2100              MOVS     r1,#0
;;;202    
;;;203        /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;204        k = count >> 2;
000056  08af              LSRS     r7,r5,#2
;;;205    
;;;206        /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;207         ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;208        while(k > 0u)
000058  e01d              B        |L1.150|
;;;209        {
;;;210          /* x[0] , x[1] */
;;;211          in1 = (q15_t) * px++;
00005a  bf00              NOP      
                  |L1.92|
00005c  f9146b01          LDRSB    r6,[r4],#1
;;;212          in2 = (q15_t) * px++;
000060  f914cb01          LDRSB    r12,[r4],#1
;;;213          input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
000064  f36c461f          BFI      r6,r12,#16,#16
;;;214    
;;;215          /* y[srcBLen - 4] , y[srcBLen - 3] */
;;;216          in1 = (q15_t) * py++;
000068  f910cb01          LDRSB    r12,[r0],#1
;;;217          in2 = (q15_t) * py++;
00006c  f9108b01          LDRSB    r8,[r0],#1
;;;218          input2 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
000070  f3684c1f          BFI      r12,r8,#16,#16
;;;219    
;;;220          /* x[0] * y[srcBLen - 4] */
;;;221          /* x[1] * y[srcBLen - 3] */
;;;222          sum = __SMLAD(input1, input2, sum);
000074  fb26160c          SMLAD    r6,r6,r12,r1
;;;223    
;;;224          /* x[2] , x[3] */
;;;225          in1 = (q15_t) * px++;
000078  f9141b02          LDRSB    r1,[r4],#2
;;;226          in2 = (q15_t) * px++;
00007c  f914cc01          LDRSB    r12,[r4,#-1]
;;;227          input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
000080  f36c411f          BFI      r1,r12,#16,#16
;;;228    
;;;229          /* y[srcBLen - 2] , y[srcBLen - 1] */
;;;230          in1 = (q15_t) * py++;
000084  f910cb01          LDRSB    r12,[r0],#1
;;;231          in2 = (q15_t) * py++;
000088  f9108b01          LDRSB    r8,[r0],#1
;;;232          input2 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
00008c  f3684c1f          BFI      r12,r8,#16,#16
;;;233    
;;;234          /* x[2] * y[srcBLen - 2] */
;;;235          /* x[3] * y[srcBLen - 1] */
;;;236          sum = __SMLAD(input1, input2, sum);
000090  fb21610c          SMLAD    r1,r1,r12,r6
000094  1e7f              SUBS     r7,r7,#1
                  |L1.150|
000096  2f00              CMP      r7,#0                 ;208
000098  d1e0              BNE      |L1.92|
;;;237    
;;;238    
;;;239          /* Decrement the loop counter */
;;;240          k--;
;;;241        }
;;;242    
;;;243        /* If the count is not a multiple of 4, compute any remaining MACs here.   
;;;244         ** No loop unrolling is used. */
;;;245        k = count % 0x4u;
00009a  f0050603          AND      r6,r5,#3
;;;246    
;;;247        while(k > 0u)
00009e  e006              B        |L1.174|
                  |L1.160|
;;;248        {
;;;249          /* Perform the multiply-accumulates */
;;;250          /* x[0] * y[srcBLen - 1] */
;;;251          sum += (q31_t) ((q15_t) * px++ * *py++);
0000a0  f9147b01          LDRSB    r7,[r4],#1
0000a4  f910cb01          LDRSB    r12,[r0],#1
0000a8  fb17110c          SMLABB   r1,r7,r12,r1
0000ac  1e76              SUBS     r6,r6,#1
                  |L1.174|
0000ae  2e00              CMP      r6,#0                 ;247
0000b0  d1f6              BNE      |L1.160|
;;;252    
;;;253          /* Decrement the loop counter */
;;;254          k--;
;;;255        }
;;;256    
;;;257        /* Store the result in the accumulator in the destination buffer. */
;;;258        *pOut = (q7_t) (__SSAT(sum >> 7, 8));
0000b2  9802              LDR      r0,[sp,#8]
0000b4  f32111c7          SSAT     r1,#8,r1,ASR #7
;;;259        /* Destination pointer is updated according to the address modifier, inc */
;;;260        pOut += inc;
;;;261    
;;;262        /* Update the inputA and inputB pointers for next MAC calculation */
;;;263        py = pSrc1 - count;
;;;264        px = pIn1;
0000b8  1e52              SUBS     r2,r2,#1
0000ba  7001              STRB     r1,[r0,#0]            ;258
0000bc  9909              LDR      r1,[sp,#0x24]         ;260
0000be  9802              LDR      r0,[sp,#8]            ;260
0000c0  9c0e              LDR      r4,[sp,#0x38]
0000c2  4408              ADD      r0,r0,r1              ;260
0000c4  9002              STR      r0,[sp,#8]            ;263
0000c6  eba90005          SUB      r0,r9,r5              ;263
0000ca  1c6d              ADDS     r5,r5,#1
                  |L1.204|
0000cc  2a00              CMP      r2,#0                 ;198
0000ce  d1c1              BNE      |L1.84|
;;;265    
;;;266        /* Increment the MAC count */
;;;267        count++;
;;;268    
;;;269        /* Decrement the loop counter */
;;;270        blockSize1--;
;;;271      }
;;;272    
;;;273      /* --------------------------   
;;;274       * Initializations of stage2   
;;;275       * ------------------------*/
;;;276    
;;;277      /* sum = x[0] * y[0] + x[1] * y[1] +...+ x[srcBLen-1] * y[srcBLen-1]   
;;;278       * sum = x[1] * y[0] + x[2] * y[1] +...+ x[srcBLen] * y[srcBLen-1]   
;;;279       * ....   
;;;280       * sum = x[srcALen-srcBLen-2] * y[0] + x[srcALen-srcBLen-1] * y[1] +...+ x[srcALen-1] * y[srcBLen-1]   
;;;281       */
;;;282    
;;;283      /* Working pointer of inputA */
;;;284      px = pIn1;
;;;285    
;;;286      /* Working pointer of inputB */
;;;287      py = pIn2;
;;;288    
;;;289      /* count is index by which the pointer pIn1 to be incremented */
;;;290      count = 0u;
0000d0  2000              MOVS     r0,#0
0000d2  9a15              LDR      r2,[sp,#0x54]
;;;291    
;;;292      /* -------------------   
;;;293       * Stage2 process   
;;;294       * ------------------*/
;;;295    
;;;296      /* Stage2 depends on srcBLen as in this stage srcBLen number of MACS are performed.   
;;;297       * So, to loop unroll over blockSize2,   
;;;298       * srcBLen should be greater than or equal to 4 */
;;;299      if(srcBLen >= 4u)
0000d4  9010              STR      r0,[sp,#0x40]
0000d6  2b04              CMP      r3,#4
0000d8  d37e              BCC      |L1.472|
;;;300      {
;;;301        /* Loop unroll over blockSize2, by 4 */
;;;302        blkCnt = blockSize2 >> 2u;
0000da  9817              LDR      r0,[sp,#0x5c]
0000dc  0880              LSRS     r0,r0,#2
;;;303    
;;;304        while(blkCnt > 0u)
0000de  e087              B        |L1.496|
                  |L1.224|
;;;305        {
;;;306          /* Set all accumulators to zero */
;;;307          acc0 = 0;
;;;308          acc1 = 0;
;;;309          acc2 = 0;
;;;310          acc3 = 0;
;;;311    
;;;312          /* read x[0], x[1], x[2] samples */
;;;313          x0 = *px++;
0000e0  f9145b01          LDRSB    r5,[r4],#1
0000e4  f04f0c00          MOV      r12,#0                ;307
;;;314          x1 = *px++;
0000e8  f9140b01          LDRSB    r0,[r4],#1
;;;315          x2 = *px++;
;;;316    
;;;317          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;318          k = srcBLen >> 2u;
0000ec  089e              LSRS     r6,r3,#2
0000ee  f9141b01          LDRSB    r1,[r4],#1            ;315
0000f2  46e2              MOV      r10,r12               ;308
0000f4  46e3              MOV      r11,r12               ;309
0000f6  4667              MOV      r7,r12                ;310
0000f8  f8cd6044          STR.W    r6,[sp,#0x44]
                  |L1.252|
;;;319    
;;;320          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;321           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;322          do
;;;323          {
;;;324            /* Read y[0] sample */
;;;325            c0 = *py++;
0000fc  f9128b01          LDRSB    r8,[r2],#1
;;;326            /* Read y[1] sample */
;;;327            c1 = *py++;
;;;328    
;;;329            /* Read x[3] sample */
;;;330            x3 = *px++;
000100  f9146b01          LDRSB    r6,[r4],#1
000104  f9129b01          LDRSB    r9,[r2],#1            ;327
;;;331    
;;;332            /* x[0] and x[1] are packed */
;;;333            in1 = (q15_t) x0;
;;;334            in2 = (q15_t) x1;
;;;335    
;;;336            input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
000108  f360451f          BFI      r5,r0,#16,#16
;;;337    
;;;338            /* y[0] and y[1] are packed */
;;;339            in1 = (q15_t) c0;
;;;340            in2 = (q15_t) c1;
;;;341    
;;;342            input2 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
00010c  f369481f          BFI      r8,r9,#16,#16
;;;343    
;;;344            /* acc0 += x[0] * y[0] + x[1] * y[1]  */
;;;345            acc0 = __SMLAD(input1, input2, acc0);
000110  fb25cc08          SMLAD    r12,r5,r8,r12
;;;346    
;;;347            /* x[1] and x[2] are packed */
;;;348            in1 = (q15_t) x1;
;;;349            in2 = (q15_t) x2;
;;;350    
;;;351            input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
000114  f361401f          BFI      r0,r1,#16,#16
;;;352    
;;;353            /* acc1 += x[1] * y[0] + x[2] * y[1] */
;;;354            acc1 = __SMLAD(input1, input2, acc1);
000118  fb20aa08          SMLAD    r10,r0,r8,r10
00011c  4608              MOV      r0,r1
;;;355    
;;;356            /* x[2] and x[3] are packed */
;;;357            in1 = (q15_t) x2;
;;;358            in2 = (q15_t) x3;
;;;359    
;;;360            input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
00011e  f366401f          BFI      r0,r6,#16,#16
;;;361    
;;;362            /* acc2 += x[2] * y[0] + x[3] * y[1]  */
;;;363            acc2 = __SMLAD(input1, input2, acc2);
000122  fb20bb08          SMLAD    r11,r0,r8,r11
;;;364    
;;;365            /* Read x[4] sample */
;;;366            x0 = *(px++);
000126  f8cdc00c          STR      r12,[sp,#0xc]
00012a  f9145b01          LDRSB    r5,[r4],#1
00012e  4630              MOV      r0,r6
;;;367    
;;;368            /* x[3] and x[4] are packed */
;;;369            in1 = (q15_t) x3;
;;;370            in2 = (q15_t) x0;
;;;371    
;;;372            input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
000130  f365401f          BFI      r0,r5,#16,#16
;;;373    
;;;374            /* acc3 += x[3] * y[0] + x[4] * y[1]  */
;;;375            acc3 = __SMLAD(input1, input2, acc3);
000134  fb207808          SMLAD    r8,r0,r8,r7
;;;376    
;;;377            /* Read y[2] sample */
;;;378            c0 = *py++;
000138  f9127b01          LDRSB    r7,[r2],#1
;;;379            /* Read y[3] sample */
;;;380            c1 = *py++;
;;;381    
;;;382            /* Read x[5] sample */
;;;383            x1 = *px++;
00013c  f9140b02          LDRSB    r0,[r4],#2
000140  f912cb01          LDRSB    r12,[r2],#1           ;380
;;;384    
;;;385            /* x[2] and x[3] are packed */
;;;386            in1 = (q15_t) x2;
;;;387            in2 = (q15_t) x3;
;;;388    
;;;389            input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
000144  f366411f          BFI      r1,r6,#16,#16
;;;390    
;;;391            /* y[2] and y[3] are packed */
;;;392            in1 = (q15_t) c0;
;;;393            in2 = (q15_t) c1;
;;;394    
;;;395            input2 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
000148  f36c471f          BFI      r7,r12,#16,#16
;;;396    
;;;397            /* acc0 += x[2] * y[2] + x[3] * y[3]  */
;;;398            acc0 = __SMLAD(input1, input2, acc0);
00014c  f8ddc00c          LDR      r12,[sp,#0xc]
000150  fb21cc07          SMLAD    r12,r1,r7,r12
;;;399    
;;;400            /* x[3] and x[4] are packed */
;;;401            in1 = (q15_t) x3;
;;;402            in2 = (q15_t) x0;
;;;403    
;;;404            input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
000154  f365461f          BFI      r6,r5,#16,#16
;;;405    
;;;406            /* acc1 += x[3] * y[2] + x[4] * y[3]  */
;;;407            acc1 = __SMLAD(input1, input2, acc1);
000158  fb26aa07          SMLAD    r10,r6,r7,r10
;;;408    
;;;409            /* x[4] and x[5] are packed */
;;;410            in1 = (q15_t) x0;
00015c  4629              MOV      r1,r5
;;;411            in2 = (q15_t) x1;
;;;412    
;;;413            input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
00015e  f360411f          BFI      r1,r0,#16,#16
;;;414    
;;;415            /* acc2 += x[4] * y[2] + x[5] * y[3]  */
;;;416            acc2 = __SMLAD(input1, input2, acc2);
000162  fb21bb07          SMLAD    r11,r1,r7,r11
;;;417    
;;;418            /* Read x[6] sample */
;;;419            x2 = *px++;
000166  f9141c01          LDRSB    r1,[r4,#-1]
;;;420    
;;;421            /* x[5] and x[6] are packed */
;;;422            in1 = (q15_t) x1;
;;;423            in2 = (q15_t) x2;
;;;424    
;;;425            input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
00016a  4606              MOV      r6,r0
00016c  f361461f          BFI      r6,r1,#16,#16
;;;426    
;;;427            /* acc3 += x[5] * y[2] + x[6] * y[3]  */
;;;428            acc3 = __SMLAD(input1, input2, acc3);
000170  fb268707          SMLAD    r7,r6,r7,r8
;;;429    
;;;430          } while(--k);
000174  9e11              LDR      r6,[sp,#0x44]
000176  1e76              SUBS     r6,r6,#1
000178  9611              STR      r6,[sp,#0x44]
00017a  d1bf              BNE      |L1.252|
;;;431    
;;;432          /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.   
;;;433           ** No loop unrolling is used. */
;;;434          k = srcBLen % 0x4u;
00017c  f0030603          AND      r6,r3,#3
;;;435    
;;;436          while(k > 0u)
000180  e011              B        |L1.422|
;;;437          {
;;;438            /* Read y[4] sample */
;;;439            c0 = *py++;
000182  bf00              NOP      
                  |L1.388|
000184  f9126b01          LDRSB    r6,[r2],#1
;;;440    
;;;441            /* Read x[7] sample */
;;;442            x3 = *px++;
000188  f9148b01          LDRSB    r8,[r4],#1
;;;443    
;;;444            /* Perform the multiply-accumulates */
;;;445            /* acc0 +=  x[4] * y[4] */
;;;446            acc0 += ((q15_t) x0 * c0);
00018c  fb05cc06          MLA      r12,r5,r6,r12
;;;447            /* acc1 +=  x[5] * y[4] */
;;;448            acc1 += ((q15_t) x1 * c0);
000190  fb00aa06          MLA      r10,r0,r6,r10
;;;449            /* acc2 +=  x[6] * y[4] */
;;;450            acc2 += ((q15_t) x2 * c0);
000194  fb11bb06          SMLABB   r11,r1,r6,r11
;;;451            /* acc3 +=  x[7] * y[4] */
;;;452            acc3 += ((q15_t) x3 * c0);
000198  fb187706          SMLABB   r7,r8,r6,r7
;;;453    
;;;454            /* Reuse the present samples for the next MAC */
;;;455            x0 = x1;
00019c  4605              MOV      r5,r0
;;;456            x1 = x2;
00019e  4608              MOV      r0,r1
;;;457            x2 = x3;
0001a0  4641              MOV      r1,r8
;;;458    
;;;459            /* Decrement the loop counter */
;;;460            k--;
0001a2  f1a90601          SUB      r6,r9,#1
                  |L1.422|
0001a6  ea5f0906          MOVS     r9,r6                 ;434
0001aa  d1eb              BNE      |L1.388|
;;;461          }
;;;462    
;;;463          /* Store the result in the accumulator in the destination buffer. */
;;;464          *pOut = (q7_t) (__SSAT(acc0 >> 7, 8));
0001ac  9802              LDR      r0,[sp,#8]
0001ae  f32c11c7          SSAT     r1,#8,r12,ASR #7
0001b2  7001              STRB     r1,[r0,#0]
;;;465          /* Destination pointer is updated according to the address modifier, inc */
;;;466          pOut += inc;
0001b4  9909              LDR      r1,[sp,#0x24]
0001b6  9802              LDR      r0,[sp,#8]
0001b8  4408              ADD      r0,r0,r1
;;;467    
;;;468          *pOut = (q7_t) (__SSAT(acc1 >> 7, 8));
0001ba  f32a11c7          SSAT     r1,#8,r10,ASR #7
0001be  7001              STRB     r1,[r0,#0]
;;;469          pOut += inc;
0001c0  9909              LDR      r1,[sp,#0x24]
0001c2  4408              ADD      r0,r0,r1
;;;470    
;;;471          *pOut = (q7_t) (__SSAT(acc2 >> 7, 8));
0001c4  f32b11c7          SSAT     r1,#8,r11,ASR #7
0001c8  7001              STRB     r1,[r0,#0]
;;;472          pOut += inc;
0001ca  9909              LDR      r1,[sp,#0x24]
0001cc  4408              ADD      r0,r0,r1
;;;473    
;;;474          *pOut = (q7_t) (__SSAT(acc3 >> 7, 8));
0001ce  f32711c7          SSAT     r1,#8,r7,ASR #7
0001d2  7001              STRB     r1,[r0,#0]
;;;475          pOut += inc;
0001d4  9909              LDR      r1,[sp,#0x24]
0001d6  e000              B        |L1.474|
                  |L1.472|
0001d8  e054              B        |L1.644|
                  |L1.474|
0001da  4408              ADD      r0,r0,r1
;;;476    
;;;477    	  count += 4u;
0001dc  9002              STR      r0,[sp,#8]
0001de  9810              LDR      r0,[sp,#0x40]
0001e0  1d00              ADDS     r0,r0,#4
;;;478          /* Update the inputA and inputB pointers for next MAC calculation */
;;;479          px = pIn1 + count;
0001e2  9010              STR      r0,[sp,#0x40]
0001e4  9910              LDR      r1,[sp,#0x40]
0001e6  980e              LDR      r0,[sp,#0x38]
;;;480          py = pIn2;
;;;481    
;;;482          /* Decrement the loop counter */
;;;483          blkCnt--;
0001e8  9a15              LDR      r2,[sp,#0x54]
0001ea  1844              ADDS     r4,r0,r1              ;479
0001ec  9818              LDR      r0,[sp,#0x60]
0001ee  1e40              SUBS     r0,r0,#1
                  |L1.496|
0001f0  9018              STR      r0,[sp,#0x60]         ;302
0001f2  2800              CMP      r0,#0                 ;302
0001f4  f47faf74          BNE      |L1.224|
;;;484        }
;;;485    
;;;486        /* If the blockSize2 is not a multiple of 4, compute any remaining output samples here.   
;;;487         ** No loop unrolling is used. */
;;;488        blkCnt = blockSize2 % 0x4u;
0001f8  9817              LDR      r0,[sp,#0x5c]
0001fa  f0000703          AND      r7,r0,#3
;;;489    
;;;490        while(blkCnt > 0u)
0001fe  e03e              B        |L1.638|
                  |L1.512|
;;;491        {
;;;492          /* Accumulator is made zero for every iteration */
;;;493          sum = 0;
000200  2000              MOVS     r0,#0
;;;494    
;;;495          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;496          k = srcBLen >> 2u;
000202  089e              LSRS     r6,r3,#2
;;;497    
;;;498          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;499           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;500          while(k > 0u)
000204  e01d              B        |L1.578|
;;;501          {
;;;502            /* Reading two inputs of SrcA buffer and packing */
;;;503            in1 = (q15_t) * px++;
000206  bf00              NOP      
                  |L1.520|
000208  f9141b01          LDRSB    r1,[r4],#1
;;;504            in2 = (q15_t) * px++;
00020c  f9145b01          LDRSB    r5,[r4],#1
;;;505            input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
000210  f365411f          BFI      r1,r5,#16,#16
;;;506    
;;;507            /* Reading two inputs of SrcB buffer and packing */
;;;508            in1 = (q15_t) * py++;
000214  f9125b01          LDRSB    r5,[r2],#1
;;;509            in2 = (q15_t) * py++;
000218  f912cb01          LDRSB    r12,[r2],#1
;;;510            input2 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
00021c  f36c451f          BFI      r5,r12,#16,#16
;;;511    
;;;512            /* Perform the multiply-accumulates */
;;;513            sum = __SMLAD(input1, input2, sum);
000220  fb210105          SMLAD    r1,r1,r5,r0
;;;514    
;;;515            /* Reading two inputs of SrcA buffer and packing */
;;;516            in1 = (q15_t) * px++;
000224  f9140b02          LDRSB    r0,[r4],#2
;;;517            in2 = (q15_t) * px++;
000228  f9145c01          LDRSB    r5,[r4,#-1]
;;;518            input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
00022c  f365401f          BFI      r0,r5,#16,#16
;;;519    
;;;520            /* Reading two inputs of SrcB buffer and packing */
;;;521            in1 = (q15_t) * py++;
000230  f9125b02          LDRSB    r5,[r2],#2
;;;522            in2 = (q15_t) * py++;
000234  f912cc01          LDRSB    r12,[r2,#-1]
;;;523            input2 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
000238  f36c451f          BFI      r5,r12,#16,#16
;;;524    
;;;525            /* Perform the multiply-accumulates */
;;;526            sum = __SMLAD(input1, input2, sum);
00023c  fb201005          SMLAD    r0,r0,r5,r1
000240  1e76              SUBS     r6,r6,#1
                  |L1.578|
000242  2e00              CMP      r6,#0                 ;500
000244  d1e0              BNE      |L1.520|
;;;527    
;;;528            /* Decrement the loop counter */
;;;529            k--;
;;;530          }
;;;531    
;;;532          /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.   
;;;533           ** No loop unrolling is used. */
;;;534          k = srcBLen % 0x4u;
000246  f0030103          AND      r1,r3,#3
;;;535    
;;;536          while(k > 0u)
00024a  e006              B        |L1.602|
                  |L1.588|
;;;537          {
;;;538            /* Perform the multiply-accumulates */
;;;539            sum += ((q15_t) * px++ * *py++);
00024c  f9146b01          LDRSB    r6,[r4],#1
000250  f9125b01          LDRSB    r5,[r2],#1
000254  fb160005          SMLABB   r0,r6,r5,r0
000258  1e49              SUBS     r1,r1,#1
                  |L1.602|
00025a  2900              CMP      r1,#0                 ;536
00025c  d1f6              BNE      |L1.588|
;;;540    
;;;541            /* Decrement the loop counter */
;;;542            k--;
;;;543          }
;;;544    
;;;545          /* Store the result in the accumulator in the destination buffer. */
;;;546          *pOut = (q7_t) (__SSAT(sum >> 7, 8));
00025e  f32011c7          SSAT     r1,#8,r0,ASR #7
000262  9802              LDR      r0,[sp,#8]
000264  7001              STRB     r1,[r0,#0]
;;;547          /* Destination pointer is updated according to the address modifier, inc */
;;;548          pOut += inc;
000266  9909              LDR      r1,[sp,#0x24]
000268  9802              LDR      r0,[sp,#8]
00026a  4408              ADD      r0,r0,r1
;;;549    
;;;550          /* Increment the pointer pIn1 index, count by 1 */
;;;551    	  count++;
00026c  9002              STR      r0,[sp,#8]
00026e  9810              LDR      r0,[sp,#0x40]
000270  1c40              ADDS     r0,r0,#1
;;;552    
;;;553          /* Update the inputA and inputB pointers for next MAC calculation */
;;;554          px = pIn1 + count;
000272  9010              STR      r0,[sp,#0x40]
000274  9910              LDR      r1,[sp,#0x40]
000276  980e              LDR      r0,[sp,#0x38]
;;;555          py = pIn2;
000278  9a15              LDR      r2,[sp,#0x54]
00027a  1844              ADDS     r4,r0,r1              ;554
00027c  1e7f              SUBS     r7,r7,#1
                  |L1.638|
00027e  2f00              CMP      r7,#0                 ;490
000280  d1be              BNE      |L1.512|
000282  e01f              B        |L1.708|
                  |L1.644|
;;;556    
;;;557          /* Decrement the loop counter */
;;;558          blkCnt--;
;;;559        }
;;;560      }
;;;561      else
;;;562      {
;;;563        /* If the srcBLen is not a multiple of 4,   
;;;564         * the blockSize2 loop cannot be unrolled by 4 */
;;;565        blkCnt = blockSize2;
;;;566    
;;;567        while(blkCnt > 0u)
000284  9917              LDR      r1,[sp,#0x5c]
000286  e01b              B        |L1.704|
                  |L1.648|
;;;568        {
;;;569          /* Accumulator is made zero for every iteration */
;;;570          sum = 0;
000288  2500              MOVS     r5,#0
;;;571    
;;;572          /* Loop over srcBLen */
;;;573          k = srcBLen;
00028a  4618              MOV      r0,r3
;;;574    
;;;575          while(k > 0u)
00028c  e007              B        |L1.670|
;;;576          {
;;;577            /* Perform the multiply-accumulate */
;;;578            sum += ((q15_t) * px++ * *py++);
00028e  bf00              NOP      
                  |L1.656|
000290  f9146b01          LDRSB    r6,[r4],#1
000294  f9127b01          LDRSB    r7,[r2],#1
000298  fb165507          SMLABB   r5,r6,r7,r5
00029c  1e40              SUBS     r0,r0,#1
                  |L1.670|
00029e  2800              CMP      r0,#0                 ;575
0002a0  d1f6              BNE      |L1.656|
;;;579    
;;;580            /* Decrement the loop counter */
;;;581            k--;
;;;582          }
;;;583    
;;;584          /* Store the result in the accumulator in the destination buffer. */
;;;585          *pOut = (q7_t) (__SSAT(sum >> 7, 8));
0002a2  9802              LDR      r0,[sp,#8]
0002a4  f32512c7          SSAT     r2,#8,r5,ASR #7
0002a8  7002              STRB     r2,[r0,#0]
;;;586          /* Destination pointer is updated according to the address modifier, inc */
;;;587          pOut += inc;
0002aa  9a09              LDR      r2,[sp,#0x24]
0002ac  9802              LDR      r0,[sp,#8]
0002ae  4410              ADD      r0,r0,r2
;;;588    
;;;589          /* Increment the MAC count */
;;;590          count++;
0002b0  9002              STR      r0,[sp,#8]
0002b2  9810              LDR      r0,[sp,#0x40]
;;;591    
;;;592          /* Update the inputA and inputB pointers for next MAC calculation */
;;;593          px = pIn1 + count;
0002b4  9a0e              LDR      r2,[sp,#0x38]
0002b6  1c40              ADDS     r0,r0,#1              ;590
0002b8  9010              STR      r0,[sp,#0x40]
0002ba  1814              ADDS     r4,r2,r0
;;;594          py = pIn2;
0002bc  9a15              LDR      r2,[sp,#0x54]
0002be  1e49              SUBS     r1,r1,#1
                  |L1.704|
0002c0  2900              CMP      r1,#0                 ;567
0002c2  d1e1              BNE      |L1.648|
                  |L1.708|
0002c4  e9dd010d          LDRD     r0,r1,[sp,#0x34]      ;567
;;;595    
;;;596    
;;;597          /* Decrement the loop counter */
;;;598          blkCnt--;
;;;599        }
;;;600      }
;;;601    
;;;602      /* --------------------------   
;;;603       * Initializations of stage3   
;;;604       * -------------------------*/
;;;605    
;;;606      /* sum += x[srcALen-srcBLen+1] * y[0] + x[srcALen-srcBLen+2] * y[1] +...+ x[srcALen-1] * y[srcBLen-1]   
;;;607       * sum += x[srcALen-srcBLen+2] * y[0] + x[srcALen-srcBLen+3] * y[1] +...+ x[srcALen-1] * y[srcBLen-1]   
;;;608       * ....   
;;;609       * sum +=  x[srcALen-2] * y[0] + x[srcALen-1] * y[1]   
;;;610       * sum +=  x[srcALen-1] * y[0]   
;;;611       */
;;;612    
;;;613      /* In this stage the MAC operations are decreased by 1 for every iteration.   
;;;614         The count variable holds the number of MAC operations performed */
;;;615      count = srcBLen - 1u;
;;;616    
;;;617      /* Working pointer of inputA */
;;;618      pSrc1 = pIn1 + (srcALen - (srcBLen - 1u));
0002c8  4401              ADD      r1,r1,r0
0002ca  1c49              ADDS     r1,r1,#1
;;;619      px = pSrc1;
0002cc  4608              MOV      r0,r1
;;;620    
;;;621      /* Working pointer of inputB */
;;;622      py = pIn2;
;;;623    
;;;624      /* -------------------   
;;;625       * Stage3 process   
;;;626       * ------------------*/
;;;627    
;;;628      while(blockSize3 > 0u)
0002ce  9c16              LDR      r4,[sp,#0x58]
0002d0  e03b              B        |L1.842|
                  |L1.722|
;;;629      {
;;;630        /* Accumulator is made zero for every iteration */
;;;631        sum = 0;
0002d2  2400              MOVS     r4,#0
;;;632    
;;;633        /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;634        k = count >> 2u;
0002d4  089e              LSRS     r6,r3,#2
;;;635    
;;;636        /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;637         ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;638        while(k > 0u)
0002d6  e01c              B        |L1.786|
                  |L1.728|
;;;639        {
;;;640          /* x[srcALen - srcBLen + 1] , x[srcALen - srcBLen + 2]  */
;;;641          in1 = (q15_t) * px++;
0002d8  f9105b01          LDRSB    r5,[r0],#1
;;;642          in2 = (q15_t) * px++;
0002dc  f9107b01          LDRSB    r7,[r0],#1
;;;643          input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
0002e0  f367451f          BFI      r5,r7,#16,#16
;;;644    
;;;645          /* y[0] , y[1] */
;;;646          in1 = (q15_t) * py++;
0002e4  f9127b01          LDRSB    r7,[r2],#1
;;;647          in2 = (q15_t) * py++;
0002e8  f912cb01          LDRSB    r12,[r2],#1
;;;648          input2 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
0002ec  f36c471f          BFI      r7,r12,#16,#16
;;;649    
;;;650          /* sum += x[srcALen - srcBLen + 1] * y[0] */
;;;651          /* sum += x[srcALen - srcBLen + 2] * y[1] */
;;;652          sum = __SMLAD(input1, input2, sum);
0002f0  fb254707          SMLAD    r7,r5,r7,r4
;;;653    
;;;654          /* x[srcALen - srcBLen + 3] , x[srcALen - srcBLen + 4] */
;;;655          in1 = (q15_t) * px++;
0002f4  f9104b02          LDRSB    r4,[r0],#2
;;;656          in2 = (q15_t) * px++;
0002f8  f9105c01          LDRSB    r5,[r0,#-1]
;;;657          input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
0002fc  f365441f          BFI      r4,r5,#16,#16
;;;658    
;;;659          /* y[2] , y[3] */
;;;660          in1 = (q15_t) * py++;
000300  f9125b02          LDRSB    r5,[r2],#2
;;;661          in2 = (q15_t) * py++;
000304  f912cc01          LDRSB    r12,[r2,#-1]
;;;662          input2 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16);
000308  f36c451f          BFI      r5,r12,#16,#16
;;;663    
;;;664          /* sum += x[srcALen - srcBLen + 3] * y[2] */
;;;665          /* sum += x[srcALen - srcBLen + 4] * y[3] */
;;;666          sum = __SMLAD(input1, input2, sum);
00030c  fb247405          SMLAD    r4,r4,r5,r7
000310  1e76              SUBS     r6,r6,#1
                  |L1.786|
000312  2e00              CMP      r6,#0                 ;638
000314  d1e0              BNE      |L1.728|
;;;667    
;;;668          /* Decrement the loop counter */
;;;669          k--;
;;;670        }
;;;671    
;;;672        /* If the count is not a multiple of 4, compute any remaining MACs here.   
;;;673         ** No loop unrolling is used. */
;;;674        k = count % 0x4u;
000316  f0030503          AND      r5,r3,#3
;;;675    
;;;676        while(k > 0u)
00031a  e006              B        |L1.810|
                  |L1.796|
;;;677        {
;;;678          /* Perform the multiply-accumulates */
;;;679          sum += ((q15_t) * px++ * *py++);
00031c  f9106b01          LDRSB    r6,[r0],#1
000320  f9127b01          LDRSB    r7,[r2],#1
000324  fb164407          SMLABB   r4,r6,r7,r4
000328  1e6d              SUBS     r5,r5,#1
                  |L1.810|
00032a  2d00              CMP      r5,#0                 ;676
00032c  d1f6              BNE      |L1.796|
;;;680    
;;;681          /* Decrement the loop counter */
;;;682          k--;
;;;683        }
;;;684    
;;;685        /* Store the result in the accumulator in the destination buffer. */
;;;686        *pOut = (q7_t) (__SSAT(sum >> 7, 8));
00032e  9802              LDR      r0,[sp,#8]
000330  f32412c7          SSAT     r2,#8,r4,ASR #7
000334  7002              STRB     r2,[r0,#0]
;;;687        /* Destination pointer is updated according to the address modifier, inc */
;;;688        pOut += inc;
000336  9a09              LDR      r2,[sp,#0x24]
000338  9802              LDR      r0,[sp,#8]
00033a  4410              ADD      r0,r0,r2
;;;689    
;;;690        /* Update the inputA and inputB pointers for next MAC calculation */
;;;691        px = ++pSrc1;
00033c  9002              STR      r0,[sp,#8]
00033e  e9dd2415          LDRD     r2,r4,[sp,#0x54]
000342  1c48              ADDS     r0,r1,#1
000344  1e64              SUBS     r4,r4,#1
000346  4601              MOV      r1,r0
;;;692        py = pIn2;
;;;693    
;;;694        /* Decrement the MAC count */
;;;695        count--;
;;;696    
;;;697        /* Decrement the loop counter */
;;;698        blockSize3--;
000348  9416              STR      r4,[sp,#0x58]
                  |L1.842|
00034a  1e5b              SUBS     r3,r3,#1
00034c  2c00              CMP      r4,#0
00034e  d1c0              BNE      |L1.722|
;;;699      }
;;;700    
;;;701    #else
;;;702    
;;;703    /* Run the below code for Cortex-M0 */
;;;704    
;;;705      q7_t *pIn1 = pSrcA;                            /* inputA pointer */
;;;706      q7_t *pIn2 = pSrcB + (srcBLen - 1u);           /* inputB pointer */
;;;707      q31_t sum;                                     /* Accumulator */
;;;708      uint32_t i = 0u, j;                            /* loop counters */
;;;709      uint32_t inv = 0u;                             /* Reverse order flag */
;;;710      uint32_t tot = 0u;                             /* Length */
;;;711    
;;;712      /* The algorithm implementation is based on the lengths of the inputs. */
;;;713      /* srcB is always made to slide across srcA. */
;;;714      /* So srcBLen is always considered as shorter or equal to srcALen */
;;;715      /* But CORR(x, y) is reverse of CORR(y, x) */
;;;716      /* So, when srcBLen > srcALen, output pointer is made to point to the end of the output buffer */
;;;717      /* and a varaible, inv is set to 1 */
;;;718      /* If lengths are not equal then zero pad has to be done to  make the two   
;;;719       * inputs of same length. But to improve the performance, we include zeroes   
;;;720       * in the output instead of zero padding either of the the inputs*/
;;;721      /* If srcALen > srcBLen, (srcALen - srcBLen) zeroes has to included in the   
;;;722       * starting of the output buffer */
;;;723      /* If srcALen < srcBLen, (srcALen - srcBLen) zeroes has to included in the  
;;;724       * ending of the output buffer */
;;;725      /* Once the zero padding is done the remaining of the output is calcualted  
;;;726       * using convolution but with the shorter signal time shifted. */
;;;727    
;;;728      /* Calculate the length of the remaining sequence */
;;;729      tot = ((srcALen + srcBLen) - 2u);
;;;730    
;;;731      if(srcALen > srcBLen)
;;;732      {
;;;733        /* Calculating the number of zeros to be padded to the output */
;;;734        j = srcALen - srcBLen;
;;;735    
;;;736        /* Initialise the pointer after zero padding */
;;;737        pDst += j;
;;;738      }
;;;739    
;;;740      else if(srcALen < srcBLen)
;;;741      {
;;;742        /* Initialization to inputB pointer */
;;;743        pIn1 = pSrcB;
;;;744    
;;;745        /* Initialization to the end of inputA pointer */
;;;746        pIn2 = pSrcA + (srcALen - 1u);
;;;747    
;;;748        /* Initialisation of the pointer after zero padding */
;;;749        pDst = pDst + tot;
;;;750    
;;;751        /* Swapping the lengths */
;;;752        j = srcALen;
;;;753        srcALen = srcBLen;
;;;754        srcBLen = j;
;;;755    
;;;756        /* Setting the reverse flag */
;;;757        inv = 1;
;;;758    
;;;759      }
;;;760    
;;;761      /* Loop to calculate convolution for output length number of times */
;;;762      for (i = 0u; i <= tot; i++)
;;;763      {
;;;764        /* Initialize sum with zero to carry on MAC operations */
;;;765        sum = 0;
;;;766    
;;;767        /* Loop to perform MAC operations according to convolution equation */
;;;768        for (j = 0u; j <= i; j++)
;;;769        {
;;;770          /* Check the array limitations */
;;;771          if((((i - j) < srcBLen) && (j < srcALen)))
;;;772          {
;;;773            /* z[i] += x[i-j] * y[j] */
;;;774            sum += ((q15_t) pIn1[j] * pIn2[-((int32_t) i - j)]);
;;;775          }
;;;776        }
;;;777        /* Store the output in the destination buffer */
;;;778        if(inv == 1)
;;;779          *pDst-- = (q7_t) __SSAT((sum >> 7u), 8u);
;;;780        else
;;;781          *pDst++ = (q7_t) __SSAT((sum >> 7u), 8u);
;;;782      }
;;;783    
;;;784    #endif /*   #ifndef ARM_MATH_CM0_FAMILY */
;;;785    
;;;786    }
000350  b019              ADD      sp,sp,#0x64
000352  e8bd8ff0          POP      {r4-r11,pc}
;;;787    
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\FilteringFunctions\\arm_correlate_q7.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_correlate_q7_c_8efad202____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___18_arm_correlate_q7_c_8efad202____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_correlate_q7_c_8efad202____REVSH|
#line 144
|__asm___18_arm_correlate_q7_c_8efad202____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_correlate_q7_c_8efad202____RRX|
#line 300
|__asm___18_arm_correlate_q7_c_8efad202____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
