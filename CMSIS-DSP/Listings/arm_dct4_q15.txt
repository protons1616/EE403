; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_dct4_q15.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_dct4_q15.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_dct4_q15.crf src\TransformFunctions\arm_dct4_q15.c]
                          THUMB

                          AREA ||i.arm_dct4_q15||, CODE, READONLY, ALIGN=2

                  arm_dct4_q15 PROC
;;;62     
;;;63     void arm_dct4_q15(
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;64       const arm_dct4_instance_q15 * S,
;;;65       q15_t * pState,
;;;66       q15_t * pInlineBuffer)
;;;67     {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  e9d47102          LDRD     r7,r1,[r4,#8]
;;;68       uint32_t i;                                    /* Loop counter */
;;;69       q15_t *weights = S->pTwiddle;                  /* Pointer to the Weights table */
;;;70       q15_t *cosFact = S->pCosFactor;                /* Pointer to the cos factors table */
;;;71       q15_t *pS1, *pS2, *pbuff;                      /* Temporary pointers for input buffer and pState buffer */
;;;72       q15_t in;                                      /* Temporary variable */
;;;73     
;;;74     
;;;75       /* DCT4 computation involves DCT2 (which is calculated using RFFT)    
;;;76        * along with some pre-processing and post-processing.    
;;;77        * Computational procedure is explained as follows:    
;;;78        * (a) Pre-processing involves multiplying input with cos factor,    
;;;79        *     r(n) = 2 * u(n) * cos(pi*(2*n+1)/(4*n))    
;;;80        *              where,    
;;;81        *                 r(n) -- output of preprocessing    
;;;82        *                 u(n) -- input to preprocessing(actual Source buffer)    
;;;83        * (b) Calculation of DCT2 using FFT is divided into three steps:    
;;;84        *                  Step1: Re-ordering of even and odd elements of input.    
;;;85        *                  Step2: Calculating FFT of the re-ordered input.    
;;;86        *                  Step3: Taking the real part of the product of FFT output and weights.    
;;;87        * (c) Post-processing - DCT4 can be obtained from DCT2 output using the following equation:    
;;;88        *                   Y4(k) = Y2(k) - Y4(k-1) and Y4(-1) = Y4(0)    
;;;89        *                        where,    
;;;90        *                           Y4 -- DCT4 output,   Y2 -- DCT2 output    
;;;91        * (d) Multiplying the output with the normalizing factor sqrt(2/N).    
;;;92        */
;;;93     
;;;94             /*-------- Pre-processing ------------*/
;;;95       /* Multiplying input with cos factor i.e. r(n) = 2 * x(n) * cos(pi*(2*n+1)/(4*n)) */
;;;96       arm_mult_q15(pInlineBuffer, cosFact, pInlineBuffer, S->N);
00000c  8803              LDRH     r3,[r0,#0]
00000e  4615              MOV      r5,r2                 ;67
000010  4610              MOV      r0,r2
000012  f7fffffe          BL       arm_mult_q15
;;;97       arm_shift_q15(pInlineBuffer, 1, pInlineBuffer, S->N);
000016  462a              MOV      r2,r5
000018  8823              LDRH     r3,[r4,#0]
00001a  2101              MOVS     r1,#1
00001c  4610              MOV      r0,r2
00001e  f7fffffe          BL       arm_shift_q15
;;;98     
;;;99       /* ----------------------------------------------------------------    
;;;100       * Step1: Re-ordering of even and odd elements as    
;;;101       *             pState[i] =  pInlineBuffer[2*i] and    
;;;102       *             pState[N-i-1] = pInlineBuffer[2*i+1] where i = 0 to N/2    
;;;103       ---------------------------------------------------------------------*/
;;;104    
;;;105      /* pS1 initialized to pState */
;;;106      pS1 = pState;
;;;107    
;;;108      /* pS2 initialized to pState+N-1, so that it points to the end of the state buffer */
;;;109      pS2 = pState + (S->N - 1u);
000022  8820              LDRH     r0,[r4,#0]
;;;110    
;;;111      /* pbuff initialized to input buffer */
;;;112      pbuff = pInlineBuffer;
;;;113    
;;;114    
;;;115    #ifndef ARM_MATH_CM0_FAMILY
;;;116    
;;;117      /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;118    
;;;119      /* Initializing the loop counter to N/2 >> 2 for loop unrolling by 4 */
;;;120      i = (uint32_t) S->Nby2 >> 2u;
000024  8863              LDRH     r3,[r4,#2]
000026  eb060240          ADD      r2,r6,r0,LSL #1       ;109
00002a  089b              LSRS     r3,r3,#2
00002c  4631              MOV      r1,r6                 ;109
00002e  4628              MOV      r0,r5                 ;112
000030  f1b20202          SUBS.W   r2,r2,#2
                  |L1.52|
;;;121    
;;;122      /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.    
;;;123       ** a second loop below computes the remaining 1 to 3 samples. */
;;;124      do
;;;125      {
;;;126        /* Re-ordering of even and odd elements */
;;;127        /* pState[i] =  pInlineBuffer[2*i] */
;;;128        *pS1++ = *pbuff++;
000034  f830cb02          LDRH     r12,[r0],#2
000038  f821cb02          STRH     r12,[r1],#2
;;;129        /* pState[N-i-1] = pInlineBuffer[2*i+1] */
;;;130        *pS2-- = *pbuff++;
00003c  f830cb02          LDRH     r12,[r0],#2
000040  f8a2c000          STRH     r12,[r2,#0]
;;;131    
;;;132        *pS1++ = *pbuff++;
000044  f830eb02          LDRH     lr,[r0],#2
000048  f821eb02          STRH     lr,[r1],#2
;;;133        *pS2-- = *pbuff++;
00004c  f830eb02          LDRH     lr,[r0],#2
000050  f822ec02          STRH     lr,[r2,#-2]
;;;134    
;;;135        *pS1++ = *pbuff++;
000054  f830eb02          LDRH     lr,[r0],#2
000058  f821eb02          STRH     lr,[r1],#2
;;;136        *pS2-- = *pbuff++;
00005c  f830eb02          LDRH     lr,[r0],#2
000060  f822ec04          STRH     lr,[r2,#-4]
;;;137    
;;;138        *pS1++ = *pbuff++;
000064  f830eb02          LDRH     lr,[r0],#2
000068  f821eb02          STRH     lr,[r1],#2
;;;139        *pS2-- = *pbuff++;
00006c  f830eb02          LDRH     lr,[r0],#2
000070  f822ec06          STRH     lr,[r2,#-6]
000074  3a08              SUBS     r2,r2,#8
000076  1e5b              SUBS     r3,r3,#1
;;;140    
;;;141        /* Decrement the loop counter */
;;;142        i--;
;;;143      } while(i > 0u);
000078  d1dc              BNE      |L1.52|
;;;144    
;;;145      /* pbuff initialized to input buffer */
;;;146      pbuff = pInlineBuffer;
;;;147    
;;;148      /* pS1 initialized to pState */
;;;149      pS1 = pState;
;;;150    
;;;151      /* Initializing the loop counter to N/4 instead of N for loop unrolling */
;;;152      i = (uint32_t) S->N >> 2u;
00007a  8822              LDRH     r2,[r4,#0]
00007c  4629              MOV      r1,r5                 ;146
00007e  4630              MOV      r0,r6                 ;149
000080  ea5f0292          LSRS.W   r2,r2,#2
                  |L1.132|
;;;153    
;;;154      /* Processing with loop unrolling 4 times as N is always multiple of 4.    
;;;155       * Compute 4 outputs at a time */
;;;156      do
;;;157      {
;;;158        /* Writing the re-ordered output back to inplace input buffer */
;;;159        *pbuff++ = *pS1++;
000084  f8303b02          LDRH     r3,[r0],#2
000088  f8213b02          STRH     r3,[r1],#2
;;;160        *pbuff++ = *pS1++;
00008c  f8303b02          LDRH     r3,[r0],#2
000090  f8213b02          STRH     r3,[r1],#2
;;;161        *pbuff++ = *pS1++;
000094  f8303b04          LDRH     r3,[r0],#4
000098  f8213b04          STRH     r3,[r1],#4
;;;162        *pbuff++ = *pS1++;
00009c  f8303c02          LDRH     r3,[r0,#-2]
0000a0  f8213c02          STRH     r3,[r1,#-2]
0000a4  1e52              SUBS     r2,r2,#1
;;;163    
;;;164        /* Decrement the loop counter */
;;;165        i--;
;;;166      } while(i > 0u);
0000a6  d1ed              BNE      |L1.132|
;;;167    
;;;168    
;;;169      /* ---------------------------------------------------------    
;;;170       *     Step2: Calculate RFFT for N-point input    
;;;171       * ---------------------------------------------------------- */
;;;172      /* pInlineBuffer is real input of length N , pState is the complex output of length 2N */
;;;173      arm_rfft_q15(S->pRfft, pInlineBuffer, pState);
0000a8  4632              MOV      r2,r6
0000aa  4629              MOV      r1,r5
0000ac  6920              LDR      r0,[r4,#0x10]
0000ae  f7fffffe          BL       arm_rfft_q15
;;;174    
;;;175     /*----------------------------------------------------------------------    
;;;176      *  Step3: Multiply the FFT output with the weights.    
;;;177      *----------------------------------------------------------------------*/
;;;178      arm_cmplx_mult_cmplx_q15(pState, weights, pState, S->N);
0000b2  4632              MOV      r2,r6
0000b4  8823              LDRH     r3,[r4,#0]
0000b6  4639              MOV      r1,r7
0000b8  4610              MOV      r0,r2
0000ba  f7fffffe          BL       arm_cmplx_mult_cmplx_q15
;;;179    
;;;180      /* The output of complex multiplication is in 3.13 format.    
;;;181       * Hence changing the format of N (i.e. 2*N elements) complex numbers to 1.15 format by shifting left by 2 bits. */
;;;182      arm_shift_q15(pState, 2, pState, S->N * 2);
0000be  8820              LDRH     r0,[r4,#0]
0000c0  4632              MOV      r2,r6
0000c2  0043              LSLS     r3,r0,#1
0000c4  2102              MOVS     r1,#2
0000c6  4610              MOV      r0,r2
0000c8  f7fffffe          BL       arm_shift_q15
;;;183    
;;;184      /* ----------- Post-processing ---------- */
;;;185      /* DCT-IV can be obtained from DCT-II by the equation,    
;;;186       *       Y4(k) = Y2(k) - Y4(k-1) and Y4(-1) = Y4(0)    
;;;187       *       Hence, Y4(0) = Y2(0)/2  */
;;;188      /* Getting only real part from the output and Converting to DCT-IV */
;;;189    
;;;190      /* Initializing the loop counter to N >> 2 for loop unrolling by 4 */
;;;191      i = ((uint32_t) S->N - 1u) >> 2u;
0000cc  8820              LDRH     r0,[r4,#0]
;;;192    
;;;193      /* pbuff initialized to input buffer. */
;;;194      pbuff = pInlineBuffer;
;;;195    
;;;196      /* pS1 initialized to pState */
;;;197      pS1 = pState;
;;;198    
;;;199      /* Calculating Y4(0) from Y2(0) using Y4(0) = Y2(0)/2 */
;;;200      in = *pS1++ >> 1u;
0000ce  f9362b04          LDRSH    r2,[r6],#4
0000d2  1e40              SUBS     r0,r0,#1              ;191
0000d4  1052              ASRS     r2,r2,#1
0000d6  0881              LSRS     r1,r0,#2              ;191
;;;201      /* input buffer acts as inplace, so output values are stored in the input itself. */
;;;202      *pbuff++ = in;
0000d8  802a              STRH     r2,[r5,#0]
0000da  1ca8              ADDS     r0,r5,#2
                  |L1.220|
;;;203    
;;;204      /* pState pointer is incremented twice as the real values are located alternatively in the array */
;;;205      pS1++;
;;;206    
;;;207      /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.    
;;;208       ** a second loop below computes the remaining 1 to 3 samples. */
;;;209      do
;;;210      {
;;;211        /* Calculating Y4(1) to Y4(N-1) from Y2 using equation Y4(k) = Y2(k) - Y4(k-1) */
;;;212        /* pState pointer (pS1) is incremented twice as the real values are located alternatively in the array */
;;;213        in = *pS1++ - in;
0000dc  f8363b04          LDRH     r3,[r6],#4
0000e0  1a9a              SUBS     r2,r3,r2
;;;214        *pbuff++ = in;
0000e2  f8202b02          STRH     r2,[r0],#2
;;;215        /* points to the next real value */
;;;216        pS1++;
;;;217    
;;;218        in = *pS1++ - in;
0000e6  f8363b04          LDRH     r3,[r6],#4
0000ea  1a9a              SUBS     r2,r3,r2
;;;219        *pbuff++ = in;
0000ec  f8202b02          STRH     r2,[r0],#2
;;;220        pS1++;
;;;221    
;;;222        in = *pS1++ - in;
0000f0  f8363b08          LDRH     r3,[r6],#8
0000f4  1a9a              SUBS     r2,r3,r2
;;;223        *pbuff++ = in;
0000f6  f8202b04          STRH     r2,[r0],#4
;;;224        pS1++;
;;;225    
;;;226        in = *pS1++ - in;
0000fa  f8363c04          LDRH     r3,[r6,#-4]
0000fe  1a9a              SUBS     r2,r3,r2
000100  b212              SXTH     r2,r2
;;;227        *pbuff++ = in;
000102  f8202c02          STRH     r2,[r0,#-2]
000106  1e49              SUBS     r1,r1,#1
;;;228        pS1++;
;;;229    
;;;230        /* Decrement the loop counter */
;;;231        i--;
;;;232      } while(i > 0u);
000108  d1e8              BNE      |L1.220|
;;;233    
;;;234      /* If the blockSize is not a multiple of 4, compute any remaining output samples here.    
;;;235       ** No loop unrolling is used. */
;;;236      i = ((uint32_t) S->N - 1u) % 0x4u;
00010a  7821              LDRB     r1,[r4,#0]
00010c  1e49              SUBS     r1,r1,#1
00010e  f0010103          AND      r1,r1,#3
;;;237    
;;;238      while(i > 0u)
000112  e006              B        |L1.290|
                  |L1.276|
;;;239      {
;;;240        /* Calculating Y4(1) to Y4(N-1) from Y2 using equation Y4(k) = Y2(k) - Y4(k-1) */
;;;241        /* pState pointer (pS1) is incremented twice as the real values are located alternatively in the array */
;;;242        in = *pS1++ - in;
000114  f8363b04          LDRH     r3,[r6],#4
000118  1a9a              SUBS     r2,r3,r2
00011a  b212              SXTH     r2,r2
;;;243        *pbuff++ = in;
00011c  f8202b02          STRH     r2,[r0],#2
000120  1e49              SUBS     r1,r1,#1
                  |L1.290|
000122  2900              CMP      r1,#0                 ;238
000124  d1f6              BNE      |L1.276|
;;;244        /* points to the next real value */
;;;245        pS1++;
;;;246    
;;;247        /* Decrement the loop counter */
;;;248        i--;
;;;249      }
;;;250    
;;;251    
;;;252       /*------------ Normalizing the output by multiplying with the normalizing factor ----------*/
;;;253    
;;;254      /* Initializing the loop counter to N/4 instead of N for loop unrolling */
;;;255      i = (uint32_t) S->N >> 2u;
000126  8820              LDRH     r0,[r4,#0]
000128  0880              LSRS     r0,r0,#2
                  |L1.298|
;;;256    
;;;257      /* pbuff initialized to the pInlineBuffer(now contains the output values) */
;;;258      pbuff = pInlineBuffer;
;;;259    
;;;260      /* Processing with loop unrolling 4 times as N is always multiple of 4.  Compute 4 outputs at a time */
;;;261      do
;;;262      {
;;;263        /* Multiplying pInlineBuffer with the normalizing factor sqrt(2/N) */
;;;264        in = *pbuff;
00012a  8829              LDRH     r1,[r5,#0]
;;;265        *pbuff++ = ((q15_t) (((q31_t) in * S->normalize) >> 15));
00012c  88a2              LDRH     r2,[r4,#4]
00012e  fb12f101          SMULBB   r1,r2,r1
000132  13c9              ASRS     r1,r1,#15
000134  f8251b02          STRH     r1,[r5],#2
;;;266    
;;;267        in = *pbuff;
;;;268        *pbuff++ = ((q15_t) (((q31_t) in * S->normalize) >> 15));
000138  88a2              LDRH     r2,[r4,#4]
00013a  f8351b02          LDRH     r1,[r5],#2            ;267
00013e  fb12f101          SMULBB   r1,r2,r1
000142  13c9              ASRS     r1,r1,#15
000144  f8251c02          STRH     r1,[r5,#-2]
;;;269    
;;;270        in = *pbuff;
000148  f8351b04          LDRH     r1,[r5],#4
;;;271        *pbuff++ = ((q15_t) (((q31_t) in * S->normalize) >> 15));
00014c  88a2              LDRH     r2,[r4,#4]
00014e  fb12f101          SMULBB   r1,r2,r1
000152  13c9              ASRS     r1,r1,#15
000154  f8251c04          STRH     r1,[r5,#-4]
;;;272    
;;;273        in = *pbuff;
000158  f8351c02          LDRH     r1,[r5,#-2]
;;;274        *pbuff++ = ((q15_t) (((q31_t) in * S->normalize) >> 15));
00015c  88a2              LDRH     r2,[r4,#4]
00015e  fb12f101          SMULBB   r1,r2,r1
000162  13c9              ASRS     r1,r1,#15
000164  f8251c02          STRH     r1,[r5,#-2]
000168  1e40              SUBS     r0,r0,#1
;;;275    
;;;276        /* Decrement the loop counter */
;;;277        i--;
;;;278      } while(i > 0u);
00016a  d1de              BNE      |L1.298|
;;;279    
;;;280    
;;;281    #else
;;;282    
;;;283      /* Run the below code for Cortex-M0 */
;;;284    
;;;285      /* Initializing the loop counter to N/2 */
;;;286      i = (uint32_t) S->Nby2;
;;;287    
;;;288      do
;;;289      {
;;;290        /* Re-ordering of even and odd elements */
;;;291        /* pState[i] =  pInlineBuffer[2*i] */
;;;292        *pS1++ = *pbuff++;
;;;293        /* pState[N-i-1] = pInlineBuffer[2*i+1] */
;;;294        *pS2-- = *pbuff++;
;;;295    
;;;296        /* Decrement the loop counter */
;;;297        i--;
;;;298      } while(i > 0u);
;;;299    
;;;300      /* pbuff initialized to input buffer */
;;;301      pbuff = pInlineBuffer;
;;;302    
;;;303      /* pS1 initialized to pState */
;;;304      pS1 = pState;
;;;305    
;;;306      /* Initializing the loop counter */
;;;307      i = (uint32_t) S->N;
;;;308    
;;;309      do
;;;310      {
;;;311        /* Writing the re-ordered output back to inplace input buffer */
;;;312        *pbuff++ = *pS1++;
;;;313    
;;;314        /* Decrement the loop counter */
;;;315        i--;
;;;316      } while(i > 0u);
;;;317    
;;;318    
;;;319      /* ---------------------------------------------------------    
;;;320       *     Step2: Calculate RFFT for N-point input    
;;;321       * ---------------------------------------------------------- */
;;;322      /* pInlineBuffer is real input of length N , pState is the complex output of length 2N */
;;;323      arm_rfft_q15(S->pRfft, pInlineBuffer, pState);
;;;324    
;;;325     /*----------------------------------------------------------------------    
;;;326      *  Step3: Multiply the FFT output with the weights.    
;;;327      *----------------------------------------------------------------------*/
;;;328      arm_cmplx_mult_cmplx_q15(pState, weights, pState, S->N);
;;;329    
;;;330      /* The output of complex multiplication is in 3.13 format.    
;;;331       * Hence changing the format of N (i.e. 2*N elements) complex numbers to 1.15 format by shifting left by 2 bits. */
;;;332      arm_shift_q15(pState, 2, pState, S->N * 2);
;;;333    
;;;334      /* ----------- Post-processing ---------- */
;;;335      /* DCT-IV can be obtained from DCT-II by the equation,    
;;;336       *       Y4(k) = Y2(k) - Y4(k-1) and Y4(-1) = Y4(0)    
;;;337       *       Hence, Y4(0) = Y2(0)/2  */
;;;338      /* Getting only real part from the output and Converting to DCT-IV */
;;;339    
;;;340      /* Initializing the loop counter */
;;;341      i = ((uint32_t) S->N - 1u);
;;;342    
;;;343      /* pbuff initialized to input buffer. */
;;;344      pbuff = pInlineBuffer;
;;;345    
;;;346      /* pS1 initialized to pState */
;;;347      pS1 = pState;
;;;348    
;;;349      /* Calculating Y4(0) from Y2(0) using Y4(0) = Y2(0)/2 */
;;;350      in = *pS1++ >> 1u;
;;;351      /* input buffer acts as inplace, so output values are stored in the input itself. */
;;;352      *pbuff++ = in;
;;;353    
;;;354      /* pState pointer is incremented twice as the real values are located alternatively in the array */
;;;355      pS1++;
;;;356    
;;;357      do
;;;358      {
;;;359        /* Calculating Y4(1) to Y4(N-1) from Y2 using equation Y4(k) = Y2(k) - Y4(k-1) */
;;;360        /* pState pointer (pS1) is incremented twice as the real values are located alternatively in the array */
;;;361        in = *pS1++ - in;
;;;362        *pbuff++ = in;
;;;363        /* points to the next real value */
;;;364        pS1++;
;;;365    
;;;366        /* Decrement the loop counter */
;;;367        i--;
;;;368      } while(i > 0u);
;;;369    
;;;370       /*------------ Normalizing the output by multiplying with the normalizing factor ----------*/
;;;371    
;;;372      /* Initializing the loop counter */
;;;373      i = (uint32_t) S->N;
;;;374    
;;;375      /* pbuff initialized to the pInlineBuffer(now contains the output values) */
;;;376      pbuff = pInlineBuffer;
;;;377    
;;;378      do
;;;379      {
;;;380        /* Multiplying pInlineBuffer with the normalizing factor sqrt(2/N) */
;;;381        in = *pbuff;
;;;382        *pbuff++ = ((q15_t) (((q31_t) in * S->normalize) >> 15));
;;;383    
;;;384        /* Decrement the loop counter */
;;;385        i--;
;;;386      } while(i > 0u);
;;;387    
;;;388    #endif /* #ifndef ARM_MATH_CM0_FAMILY */
;;;389    
;;;390    }
00016c  e8bd81f0          POP      {r4-r8,pc}
;;;391    
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\TransformFunctions\\arm_dct4_q15.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_arm_dct4_q15_c_9bc07bf7____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___14_arm_dct4_q15_c_9bc07bf7____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_arm_dct4_q15_c_9bc07bf7____REVSH|
#line 144
|__asm___14_arm_dct4_q15_c_9bc07bf7____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___14_arm_dct4_q15_c_9bc07bf7____RRX|
#line 300
|__asm___14_arm_dct4_q15_c_9bc07bf7____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
