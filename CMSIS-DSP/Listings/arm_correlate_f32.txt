; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_correlate_f32.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_correlate_f32.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_correlate_f32.crf src\FilteringFunctions\arm_correlate_f32.c]
                          THUMB

                          AREA ||i.arm_correlate_f32||, CODE, READONLY, ALIGN=2

                  arm_correlate_f32 PROC
;;;115    
;;;116    void arm_correlate_f32(
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;117      float32_t * pSrcA,
;;;118      uint32_t srcALen,
;;;119      float32_t * pSrcB,
;;;120      uint32_t srcBLen,
;;;121      float32_t * pDst)
;;;122    {
;;;123    
;;;124    
;;;125    #ifndef ARM_MATH_CM0_FAMILY
;;;126    
;;;127      /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;128    
;;;129      float32_t *pIn1;                               /* inputA pointer */
;;;130      float32_t *pIn2;                               /* inputB pointer */
;;;131      float32_t *pOut = pDst;                        /* output pointer */
;;;132      float32_t *px;                                 /* Intermediate inputA pointer */
;;;133      float32_t *py;                                 /* Intermediate inputB pointer */
;;;134      float32_t *pSrc1;                              /* Intermediate pointers */
;;;135      float32_t sum, acc0, acc1, acc2, acc3;         /* Accumulators */
;;;136      float32_t x0, x1, x2, x3, c0;                  /* temporary variables for holding input and coefficient values */
;;;137      uint32_t j, k = 0u, count, blkCnt, outBlockSize, blockSize1, blockSize2, blockSize3;  /* loop counters */
;;;138      int32_t inc = 1;                               /* Destination address modifier */
000004  2701              MOVS     r7,#1
;;;139    
;;;140    
;;;141      /* The algorithm implementation is based on the lengths of the inputs. */
;;;142      /* srcB is always made to slide across srcA. */
;;;143      /* So srcBLen is always considered as shorter or equal to srcALen */
;;;144      /* But CORR(x, y) is reverse of CORR(y, x) */
;;;145      /* So, when srcBLen > srcALen, output pointer is made to point to the end of the output buffer */
;;;146      /* and the destination pointer modifier, inc is set to -1 */
;;;147      /* If srcALen > srcBLen, zero pad has to be done to srcB to make the two inputs of same length */
;;;148      /* But to improve the performance,    
;;;149       * we assume zeroes in the output instead of zero padding either of the the inputs*/
;;;150      /* If srcALen > srcBLen,    
;;;151       * (srcALen - srcBLen) zeroes has to included in the starting of the output buffer */
;;;152      /* If srcALen < srcBLen,    
;;;153       * (srcALen - srcBLen) zeroes has to included in the ending of the output buffer */
;;;154      if(srcALen >= srcBLen)
000006  9d09              LDR      r5,[sp,#0x24]
;;;155      {
;;;156        /* Initialization of inputA pointer */
;;;157        pIn1 = pSrcA;
;;;158    
;;;159        /* Initialization of inputB pointer */
;;;160        pIn2 = pSrcB;
;;;161    
;;;162        /* Number of output samples is calculated */
;;;163        outBlockSize = (2u * srcALen) - 1u;
000008  f04f3cff          MOV      r12,#0xffffffff
00000c  4299              CMP      r1,r3                 ;154
00000e  d309              BCC      |L1.36|
000010  4604              MOV      r4,r0                 ;157
000012  4616              MOV      r6,r2                 ;160
000014  eb0c0041          ADD      r0,r12,r1,LSL #1
;;;164    
;;;165        /* When srcALen > srcBLen, zero padding has to be done to srcB    
;;;166         * to make their lengths equal.    
;;;167         * Instead, (outBlockSize - (srcALen + srcBLen - 1))    
;;;168         * number of output samples are made zero */
;;;169        j = outBlockSize - (srcALen + (srcBLen - 1u));
000018  18ca              ADDS     r2,r1,r3
00001a  1a80              SUBS     r0,r0,r2
00001c  1c40              ADDS     r0,r0,#1
;;;170    
;;;171        /* Updating the pointer position to non zero value */
;;;172        pOut += j;
00001e  eb050580          ADD      r5,r5,r0,LSL #2
000022  e009              B        |L1.56|
                  |L1.36|
;;;173    
;;;174        //while(j > 0u)   
;;;175        //{   
;;;176        //  /* Zero is stored in the destination buffer */   
;;;177        //  *pOut++ = 0.0f;   
;;;178    
;;;179        //  /* Decrement the loop counter */   
;;;180        //  j--;   
;;;181        //}   
;;;182    
;;;183      }
;;;184      else
;;;185      {
;;;186        /* Initialization of inputA pointer */
;;;187        pIn1 = pSrcB;
;;;188    
;;;189        /* Initialization of inputB pointer */
;;;190        pIn2 = pSrcA;
000024  4606              MOV      r6,r0
;;;191    
;;;192        /* srcBLen is always considered as shorter or equal to srcALen */
;;;193        j = srcBLen;
000026  4618              MOV      r0,r3
;;;194        srcBLen = srcALen;
000028  460b              MOV      r3,r1
;;;195        srcALen = j;
00002a  4601              MOV      r1,r0
;;;196    
;;;197        /* CORR(x, y) = Reverse order(CORR(y, x)) */
;;;198        /* Hence set the destination pointer to point to the last output sample */
;;;199        pOut = pDst + ((srcALen + srcBLen) - 2u);
00002c  4418              ADD      r0,r0,r3
00002e  eb050580          ADD      r5,r5,r0,LSL #2
000032  4614              MOV      r4,r2                 ;187
;;;200    
;;;201        /* Destination address modifier is set to -1 */
;;;202        inc = -1;
000034  4667              MOV      r7,r12
000036  3d08              SUBS     r5,r5,#8
                  |L1.56|
;;;203    
;;;204      }
;;;205    
;;;206      /* The function is internally    
;;;207       * divided into three parts according to the number of multiplications that has to be    
;;;208       * taken place between inputA samples and inputB samples. In the first part of the    
;;;209       * algorithm, the multiplications increase by one for every iteration.    
;;;210       * In the second part of the algorithm, srcBLen number of multiplications are done.    
;;;211       * In the third part of the algorithm, the multiplications decrease by one    
;;;212       * for every iteration.*/
;;;213      /* The algorithm is implemented in three stages.    
;;;214       * The loop counters of each stage is initiated here. */
;;;215      blockSize1 = srcBLen - 1u;
;;;216      blockSize2 = srcALen - (srcBLen - 1u);
;;;217      blockSize3 = blockSize1;
;;;218    
;;;219      /* --------------------------    
;;;220       * Initializations of stage1    
;;;221       * -------------------------*/
;;;222    
;;;223      /* sum = x[0] * y[srcBlen - 1]    
;;;224       * sum = x[0] * y[srcBlen-2] + x[1] * y[srcBlen - 1]    
;;;225       * ....    
;;;226       * sum = x[0] * y[0] + x[1] * y[1] +...+ x[srcBLen - 1] * y[srcBLen - 1]    
;;;227       */
;;;228    
;;;229      /* In this stage the MAC operations are increased by 1 for every iteration.    
;;;230         The count variable holds the number of MAC operations performed */
;;;231      count = 1u;
;;;232    
;;;233      /* Working pointer of inputA */
;;;234      px = pIn1;
;;;235    
;;;236      /* Working pointer of inputB */
;;;237      pSrc1 = pIn2 + (srcBLen - 1u);
000038  eb060083          ADD      r0,r6,r3,LSL #2
00003c  f1a30c01          SUB      r12,r3,#1             ;215
000040  eba10e03          SUB      lr,r1,r3              ;216
000044  1f00              SUBS     r0,r0,#4
000046  f10e0801          ADD      r8,lr,#1              ;216
00004a  46e2              MOV      r10,r12               ;217
00004c  f04f0901          MOV      r9,#1                 ;231
000050  4622              MOV      r2,r4                 ;234
000052  4683              MOV      r11,r0
;;;238      py = pSrc1;
;;;239    
;;;240      /* ------------------------    
;;;241       * Stage1 process    
;;;242       * ----------------------*/
;;;243    
;;;244      /* The first stage starts here */
;;;245      while(blockSize1 > 0u)
;;;246      {
;;;247        /* Accumulator is made zero for every iteration */
;;;248        sum = 0.0f;
000054  eddf4ab5          VLDR     s9,|L1.812|
000058  e03a              B        |L1.208|
00005a  bf00              NOP      
                  |L1.92|
00005c  eeb02a64          VMOV.F32 s4,s9
;;;249    
;;;250        /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;251        k = count >> 2u;
000060  ea4f0199          LSR      r1,r9,#2
;;;252    
;;;253        /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.    
;;;254         ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;255        while(k > 0u)
000064  e01b              B        |L1.158|
;;;256        {
;;;257          /* x[0] * y[srcBLen - 4] */
;;;258          sum += *px++ * *py++;
000066  bf00              NOP      
                  |L1.104|
000068  ed920a00          VLDR     s0,[r2,#0]
00006c  edd00a00          VLDR     s1,[r0,#0]
;;;259          /* x[1] * y[srcBLen - 3] */
;;;260          sum += *px++ * *py++;
;;;261          /* x[2] * y[srcBLen - 2] */
;;;262          sum += *px++ * *py++;
;;;263          /* x[3] * y[srcBLen - 1] */
;;;264          sum += *px++ * *py++;
000070  1e49              SUBS     r1,r1,#1
000072  ee002a20          VMLA.F32 s4,s0,s1              ;258
000076  ed920a01          VLDR     s0,[r2,#4]            ;260
00007a  edd00a01          VLDR     s1,[r0,#4]            ;260
00007e  ee002a20          VMLA.F32 s4,s0,s1              ;260
000082  ed920a02          VLDR     s0,[r2,#8]            ;262
000086  edd00a02          VLDR     s1,[r0,#8]            ;262
00008a  ee002a20          VMLA.F32 s4,s0,s1              ;262
00008e  ed920a03          VLDR     s0,[r2,#0xc]
000092  edd00a03          VLDR     s1,[r0,#0xc]
000096  3010              ADDS     r0,r0,#0x10
000098  3210              ADDS     r2,r2,#0x10
00009a  ee002a20          VMLA.F32 s4,s0,s1
                  |L1.158|
00009e  2900              CMP      r1,#0                 ;255
0000a0  d1e2              BNE      |L1.104|
;;;265    
;;;266          /* Decrement the loop counter */
;;;267          k--;
;;;268        }
;;;269    
;;;270        /* If the count is not a multiple of 4, compute any remaining MACs here.    
;;;271         ** No loop unrolling is used. */
;;;272        k = count % 0x4u;
0000a2  f0090103          AND      r1,r9,#3
;;;273    
;;;274        while(k > 0u)
0000a6  e006              B        |L1.182|
                  |L1.168|
;;;275        {
;;;276          /* Perform the multiply-accumulate */
;;;277          /* x[0] * y[srcBLen - 1] */
;;;278          sum += *px++ * *py++;
0000a8  ecb20a01          VLDM     r2!,{s0}
0000ac  1e49              SUBS     r1,r1,#1
0000ae  ecf00a01          VLDM     r0!,{s1}
0000b2  ee002a20          VMLA.F32 s4,s0,s1
                  |L1.182|
0000b6  2900              CMP      r1,#0                 ;274
0000b8  d1f6              BNE      |L1.168|
;;;279    
;;;280          /* Decrement the loop counter */
;;;281          k--;
;;;282        }
;;;283    
;;;284        /* Store the result in the accumulator in the destination buffer. */
;;;285        *pOut = sum;
0000ba  ed852a00          VSTR     s4,[r5,#0]
;;;286        /* Destination pointer is updated according to the address modifier, inc */
;;;287        pOut += inc;
;;;288    
;;;289        /* Update the inputA and inputB pointers for next MAC calculation */
;;;290        py = pSrc1 - count;
0000be  ebab0089          SUB      r0,r11,r9,LSL #2
0000c2  eb050587          ADD      r5,r5,r7,LSL #2       ;287
;;;291        px = pIn1;
0000c6  4622              MOV      r2,r4
;;;292    
;;;293        /* Increment the MAC count */
;;;294        count++;
0000c8  f1090901          ADD      r9,r9,#1
0000cc  f1ac0c01          SUB      r12,r12,#1
                  |L1.208|
0000d0  f1bc0f00          CMP      r12,#0                ;245
0000d4  d1c2              BNE      |L1.92|
;;;295    
;;;296        /* Decrement the loop counter */
;;;297        blockSize1--;
;;;298      }
;;;299    
;;;300      /* --------------------------    
;;;301       * Initializations of stage2    
;;;302       * ------------------------*/
;;;303    
;;;304      /* sum = x[0] * y[0] + x[1] * y[1] +...+ x[srcBLen-1] * y[srcBLen-1]    
;;;305       * sum = x[1] * y[0] + x[2] * y[1] +...+ x[srcBLen] * y[srcBLen-1]    
;;;306       * ....    
;;;307       * sum = x[srcALen-srcBLen-2] * y[0] + x[srcALen-srcBLen-1] * y[1] +...+ x[srcALen-1] * y[srcBLen-1]    
;;;308       */
;;;309    
;;;310      /* Working pointer of inputA */
;;;311      px = pIn1;
;;;312    
;;;313      /* Working pointer of inputB */
;;;314      py = pIn2;
;;;315    
;;;316      /* count is index by which the pointer pIn1 to be incremented */
;;;317      count = 0u;
0000d6  2100              MOVS     r1,#0
0000d8  4630              MOV      r0,r6                 ;314
;;;318    
;;;319      /* -------------------    
;;;320       * Stage2 process    
;;;321       * ------------------*/
;;;322    
;;;323      /* Stage2 depends on srcBLen as in this stage srcBLen number of MACS are performed.    
;;;324       * So, to loop unroll over blockSize2,    
;;;325       * srcBLen should be greater than or equal to 4, to loop unroll the srcBLen loop */
;;;326      if(srcBLen >= 4u)
0000da  2b04              CMP      r3,#4
0000dc  d37e              BCC      |L1.476|
;;;327      {
;;;328        /* Loop unroll over blockSize2, by 4 */
;;;329        blkCnt = blockSize2 >> 2u;
0000de  ea4f0c98          LSR      r12,r8,#2
;;;330    
;;;331        while(blkCnt > 0u)
0000e2  e07a              B        |L1.474|
                  |L1.228|
;;;332        {
;;;333          /* Set all accumulators to zero */
;;;334          acc0 = 0.0f;
0000e4  eef00a64          VMOV.F32 s1,s9
;;;335          acc1 = 0.0f;
;;;336          acc2 = 0.0f;
;;;337          acc3 = 0.0f;
;;;338    
;;;339          /* read x[0], x[1], x[2] samples */
;;;340          x0 = *(px++);
0000e8  edd22a00          VLDR     s5,[r2,#0]
;;;341          x1 = *(px++);
0000ec  edd23a01          VLDR     s7,[r2,#4]
;;;342          x2 = *(px++);
0000f0  ed924a02          VLDR     s8,[r2,#8]
0000f4  eeb00a60          VMOV.F32 s0,s1                 ;334
0000f8  eeb01a60          VMOV.F32 s2,s1                 ;336
0000fc  eef01a60          VMOV.F32 s3,s1                 ;337
;;;343    
;;;344          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;345          k = srcBLen >> 2u;
000100  ea4f0c93          LSR      r12,r3,#2
000104  f112020c          ADDS.W   r2,r2,#0xc
                  |L1.264|
;;;346    
;;;347          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.    
;;;348           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;349          do
;;;350          {
;;;351            /* Read y[0] sample */
;;;352            c0 = *(py++);
000108  ed905a00          VLDR     s10,[r0,#0]
;;;353    
;;;354            /* Read x[3] sample */
;;;355            x3 = *(px++);
00010c  ed923a00          VLDR     s6,[r2,#0]
;;;356    
;;;357            /* Perform the multiply-accumulate */
;;;358            /* acc0 +=  x[0] * y[0] */
;;;359            acc0 += x0 * c0;
000110  eeb02a60          VMOV.F32 s4,s1
000114  ee020a85          VMLA.F32 s0,s5,s10
;;;360            /* acc1 +=  x[1] * y[0] */
;;;361            acc1 += x1 * c0;
000118  ee032a85          VMLA.F32 s4,s7,s10
;;;362            /* acc2 +=  x[2] * y[0] */
;;;363            acc2 += x2 * c0;
00011c  ee041a05          VMLA.F32 s2,s8,s10
;;;364            /* acc3 +=  x[3] * y[0] */
;;;365            acc3 += x3 * c0;
000120  ee431a05          VMLA.F32 s3,s6,s10
;;;366    
;;;367            /* Read y[1] sample */
;;;368            c0 = *(py++);
000124  edd00a01          VLDR     s1,[r0,#4]
;;;369    
;;;370            /* Read x[4] sample */
;;;371            x0 = *(px++);
000128  edd22a01          VLDR     s5,[r2,#4]
;;;372    
;;;373            /* Perform the multiply-accumulate */
;;;374            /* acc0 +=  x[1] * y[1] */
;;;375            acc0 += x1 * c0;
;;;376            /* acc1 +=  x[2] * y[1] */
;;;377            acc1 += x2 * c0;
;;;378            /* acc2 +=  x[3] * y[1] */
;;;379            acc2 += x3 * c0;
;;;380            /* acc3 +=  x[4] * y[1] */
;;;381            acc3 += x0 * c0;
;;;382    
;;;383            /* Read y[2] sample */
;;;384            c0 = *(py++);
;;;385    
;;;386            /* Read x[5] sample */
;;;387            x1 = *(px++);
;;;388    
;;;389            /* Perform the multiply-accumulates */
;;;390            /* acc0 +=  x[2] * y[2] */
;;;391            acc0 += x2 * c0;
;;;392            /* acc1 +=  x[3] * y[2] */
;;;393            acc1 += x3 * c0;
;;;394            /* acc2 +=  x[4] * y[2] */
;;;395            acc2 += x0 * c0;
;;;396            /* acc3 +=  x[5] * y[2] */
;;;397            acc3 += x1 * c0;
;;;398    
;;;399            /* Read y[3] sample */
;;;400            c0 = *(py++);
00012c  ed905a03          VLDR     s10,[r0,#0xc]
000130  ee030aa0          VMLA.F32 s0,s7,s1              ;375
000134  ee042a20          VMLA.F32 s4,s8,s1              ;377
000138  ee031a20          VMLA.F32 s2,s6,s1              ;379
00013c  ee421aa0          VMLA.F32 s3,s5,s1              ;381
000140  edd00a02          VLDR     s1,[r0,#8]            ;384
000144  edd23a02          VLDR     s7,[r2,#8]            ;387
;;;401    
;;;402            /* Read x[6] sample */
;;;403            x2 = *(px++);
;;;404    
;;;405            /* Perform the multiply-accumulates */
;;;406            /* acc0 +=  x[3] * y[3] */
;;;407            acc0 += x3 * c0;
;;;408            /* acc1 +=  x[4] * y[3] */
;;;409            acc1 += x0 * c0;
;;;410            /* acc2 +=  x[5] * y[3] */
;;;411            acc2 += x1 * c0;
;;;412            /* acc3 +=  x[6] * y[3] */
;;;413            acc3 += x2 * c0;
000148  3010              ADDS     r0,r0,#0x10
00014a  ee032a20          VMLA.F32 s4,s6,s1              ;393
00014e  ee040a20          VMLA.F32 s0,s8,s1              ;391
000152  ee021aa0          VMLA.F32 s2,s5,s1              ;395
000156  ee431aa0          VMLA.F32 s3,s7,s1              ;397
00015a  ed924a03          VLDR     s8,[r2,#0xc]          ;403
00015e  3210              ADDS     r2,r2,#0x10
000160  eef00a42          VMOV.F32 s1,s4                 ;407
000164  ee030a05          VMLA.F32 s0,s6,s10             ;407
000168  ee420a85          VMLA.F32 s1,s5,s10             ;409
00016c  ee031a85          VMLA.F32 s2,s7,s10             ;411
000170  ee441a05          VMLA.F32 s3,s8,s10
000174  f1bc0c01          SUBS     r12,r12,#1
;;;414    
;;;415    
;;;416          } while(--k);
000178  d1c6              BNE      |L1.264|
;;;417    
;;;418          /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.    
;;;419           ** No loop unrolling is used. */
;;;420          k = srcBLen % 0x4u;
00017a  f0030c03          AND      r12,r3,#3
;;;421    
;;;422          while(k > 0u)
00017e  e013              B        |L1.424|
                  |L1.384|
;;;423          {
;;;424            /* Read y[4] sample */
;;;425            c0 = *(py++);
000180  ecb03a01          VLDM     r0!,{s6}
;;;426    
;;;427            /* Read x[7] sample */
;;;428            x3 = *(px++);
;;;429    
;;;430            /* Perform the multiply-accumulates */
;;;431            /* acc0 +=  x[4] * y[4] */
;;;432            acc0 += x0 * c0;
;;;433            /* acc1 +=  x[5] * y[4] */
;;;434            acc1 += x1 * c0;
;;;435            /* acc2 +=  x[6] * y[4] */
;;;436            acc2 += x2 * c0;
;;;437            /* acc3 +=  x[7] * y[4] */
;;;438            acc3 += x3 * c0;
;;;439    
;;;440            /* Reuse the present samples for the next MAC */
;;;441            x0 = x1;
;;;442            x1 = x2;
;;;443            x2 = x3;
000184  f1ac0c01          SUB      r12,r12,#1
000188  ecb22a01          VLDM     r2!,{s4}              ;428
00018c  ee020a83          VMLA.F32 s0,s5,s6              ;432
000190  ee430a83          VMLA.F32 s1,s7,s6              ;434
000194  ee041a03          VMLA.F32 s2,s8,s6              ;436
000198  ee421a03          VMLA.F32 s3,s4,s6              ;438
00019c  eef02a63          VMOV.F32 s5,s7                 ;441
0001a0  eef03a44          VMOV.F32 s7,s8                 ;442
0001a4  eeb04a42          VMOV.F32 s8,s4
                  |L1.424|
0001a8  f1bc0f00          CMP      r12,#0                ;422
0001ac  d1e8              BNE      |L1.384|
;;;444    
;;;445            /* Decrement the loop counter */
;;;446            k--;
;;;447          }
;;;448    
;;;449          /* Store the result in the accumulator in the destination buffer. */
;;;450          *pOut = acc0;
;;;451          /* Destination pointer is updated according to the address modifier, inc */
;;;452          pOut += inc;
0001ae  eb050087          ADD      r0,r5,r7,LSL #2
0001b2  ed850a00          VSTR     s0,[r5,#0]            ;450
;;;453    
;;;454          *pOut = acc1;
0001b6  edc00a00          VSTR     s1,[r0,#0]
;;;455          pOut += inc;
0001ba  eb000087          ADD      r0,r0,r7,LSL #2
;;;456    
;;;457          *pOut = acc2;
;;;458          pOut += inc;
;;;459    
;;;460          *pOut = acc3;
;;;461          pOut += inc;
0001be  1d09              ADDS     r1,r1,#4
0001c0  ed801a00          VSTR     s2,[r0,#0]            ;457
0001c4  eb000087          ADD      r0,r0,r7,LSL #2       ;458
0001c8  eb000587          ADD      r5,r0,r7,LSL #2
0001cc  edc01a00          VSTR     s3,[r0,#0]            ;460
;;;462    
;;;463          /* Increment the pointer pIn1 index, count by 4 */
;;;464          count += 4u;
;;;465    
;;;466          /* Update the inputA and inputB pointers for next MAC calculation */
;;;467          px = pIn1 + count;
0001d0  eb040281          ADD      r2,r4,r1,LSL #2
;;;468          py = pIn2;
0001d4  4630              MOV      r0,r6
;;;469    
;;;470          /* Decrement the loop counter */
;;;471          blkCnt--;
0001d6  f1a90c01          SUB      r12,r9,#1
                  |L1.474|
0001da  e000              B        |L1.478|
                  |L1.476|
0001dc  e061              B        |L1.674|
                  |L1.478|
0001de  ea5f090c          MOVS     r9,r12                ;329
0001e2  f47faf7f          BNE      |L1.228|
;;;472        }
;;;473    
;;;474        /* If the blockSize2 is not a multiple of 4, compute any remaining output samples here.    
;;;475         ** No loop unrolling is used. */
;;;476        blkCnt = blockSize2 % 0x4u;
0001e6  f0080803          AND      r8,r8,#3
;;;477    
;;;478        while(blkCnt > 0u)
0001ea  e03c              B        |L1.614|
                  |L1.492|
;;;479        {
;;;480          /* Accumulator is made zero for every iteration */
;;;481          sum = 0.0f;
0001ec  eef02a64          VMOV.F32 s5,s9
;;;482    
;;;483          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;484          k = srcBLen >> 2u;
0001f0  ea4f0c93          LSR      r12,r3,#2
;;;485    
;;;486          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.    
;;;487           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;488          while(k > 0u)
0001f4  e01c              B        |L1.560|
;;;489          {
;;;490            /* Perform the multiply-accumulates */
;;;491            sum += *px++ * *py++;
0001f6  bf00              NOP      
                  |L1.504|
0001f8  ed920a00          VLDR     s0,[r2,#0]
0001fc  edd00a00          VLDR     s1,[r0,#0]
;;;492            sum += *px++ * *py++;
;;;493            sum += *px++ * *py++;
;;;494            sum += *px++ * *py++;
000200  f1ac0c01          SUB      r12,r12,#1
000204  ee402a20          VMLA.F32 s5,s0,s1              ;491
000208  ed920a01          VLDR     s0,[r2,#4]            ;492
00020c  edd00a01          VLDR     s1,[r0,#4]            ;492
000210  ee402a20          VMLA.F32 s5,s0,s1              ;492
000214  ed920a02          VLDR     s0,[r2,#8]            ;493
000218  edd00a02          VLDR     s1,[r0,#8]            ;493
00021c  ee402a20          VMLA.F32 s5,s0,s1              ;493
000220  ed920a03          VLDR     s0,[r2,#0xc]
000224  edd00a03          VLDR     s1,[r0,#0xc]
000228  3010              ADDS     r0,r0,#0x10
00022a  3210              ADDS     r2,r2,#0x10
00022c  ee402a20          VMLA.F32 s5,s0,s1
                  |L1.560|
000230  f1bc0f00          CMP      r12,#0                ;488
000234  d1e0              BNE      |L1.504|
;;;495    
;;;496            /* Decrement the loop counter */
;;;497            k--;
;;;498          }
;;;499    
;;;500          /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.    
;;;501           ** No loop unrolling is used. */
;;;502          k = srcBLen % 0x4u;
000236  f0030c03          AND      r12,r3,#3
;;;503    
;;;504          while(k > 0u)
00023a  e007              B        |L1.588|
                  |L1.572|
;;;505          {
;;;506            /* Perform the multiply-accumulate */
;;;507            sum += *px++ * *py++;
00023c  ecb20a01          VLDM     r2!,{s0}
000240  f1ac0c01          SUB      r12,r12,#1
000244  ecf00a01          VLDM     r0!,{s1}
000248  ee402a20          VMLA.F32 s5,s0,s1
                  |L1.588|
00024c  f1bc0f00          CMP      r12,#0                ;504
000250  d1f4              BNE      |L1.572|
;;;508    
;;;509            /* Decrement the loop counter */
;;;510            k--;
;;;511          }
;;;512    
;;;513          /* Store the result in the accumulator in the destination buffer. */
;;;514          *pOut = sum;
000252  edc52a00          VSTR     s5,[r5,#0]
;;;515          /* Destination pointer is updated according to the address modifier, inc */
;;;516          pOut += inc;
000256  1c49              ADDS     r1,r1,#1
000258  eb050587          ADD      r5,r5,r7,LSL #2
;;;517    
;;;518          /* Increment the pointer pIn1 index, count by 1 */
;;;519          count++;
;;;520    
;;;521          /* Update the inputA and inputB pointers for next MAC calculation */
;;;522          px = pIn1 + count;
00025c  eb040281          ADD      r2,r4,r1,LSL #2
;;;523          py = pIn2;
000260  4630              MOV      r0,r6
000262  f1a80801          SUB      r8,r8,#1
                  |L1.614|
000266  f1b80f00          CMP      r8,#0                 ;478
00026a  d1bf              BNE      |L1.492|
00026c  e01c              B        |L1.680|
;;;524    
;;;525          /* Decrement the loop counter */
;;;526          blkCnt--;
;;;527        }
;;;528      }
;;;529      else
;;;530      {
;;;531        /* If the srcBLen is not a multiple of 4,    
;;;532         * the blockSize2 loop cannot be unrolled by 4 */
;;;533        blkCnt = blockSize2;
;;;534    
;;;535        while(blkCnt > 0u)
;;;536        {
;;;537          /* Accumulator is made zero for every iteration */
;;;538          sum = 0.0f;
00026e  bf00              NOP      
                  |L1.624|
000270  eeb00a64          VMOV.F32 s0,s9
;;;539    
;;;540          /* Loop over srcBLen */
;;;541          k = srcBLen;
000274  469c              MOV      r12,r3
;;;542    
;;;543          while(k > 0u)
000276  e007              B        |L1.648|
                  |L1.632|
;;;544          {
;;;545            /* Perform the multiply-accumulate */
;;;546            sum += *px++ * *py++;
000278  ecf20a01          VLDM     r2!,{s1}
00027c  f1ac0c01          SUB      r12,r12,#1
000280  ecb01a01          VLDM     r0!,{s2}
000284  ee000a81          VMLA.F32 s0,s1,s2
                  |L1.648|
000288  f1bc0f00          CMP      r12,#0                ;543
00028c  d1f4              BNE      |L1.632|
;;;547    
;;;548            /* Decrement the loop counter */
;;;549            k--;
;;;550          }
;;;551    
;;;552          /* Store the result in the accumulator in the destination buffer. */
;;;553          *pOut = sum;
00028e  ed850a00          VSTR     s0,[r5,#0]
;;;554          /* Destination pointer is updated according to the address modifier, inc */
;;;555          pOut += inc;
000292  1c49              ADDS     r1,r1,#1
000294  eb050587          ADD      r5,r5,r7,LSL #2
;;;556    
;;;557          /* Increment the pointer pIn1 index, count by 1 */
;;;558          count++;
;;;559    
;;;560          /* Update the inputA and inputB pointers for next MAC calculation */
;;;561          px = pIn1 + count;
000298  eb040281          ADD      r2,r4,r1,LSL #2
;;;562          py = pIn2;
00029c  4630              MOV      r0,r6
00029e  f1a80801          SUB      r8,r8,#1
                  |L1.674|
0002a2  f1b80f00          CMP      r8,#0                 ;535
0002a6  d1e3              BNE      |L1.624|
                  |L1.680|
;;;563    
;;;564          /* Decrement the loop counter */
;;;565          blkCnt--;
;;;566        }
;;;567      }
;;;568    
;;;569      /* --------------------------    
;;;570       * Initializations of stage3    
;;;571       * -------------------------*/
;;;572    
;;;573      /* sum += x[srcALen-srcBLen+1] * y[0] + x[srcALen-srcBLen+2] * y[1] +...+ x[srcALen-1] * y[srcBLen-1]    
;;;574       * sum += x[srcALen-srcBLen+2] * y[0] + x[srcALen-srcBLen+3] * y[1] +...+ x[srcALen-1] * y[srcBLen-1]    
;;;575       * ....    
;;;576       * sum +=  x[srcALen-2] * y[0] + x[srcALen-1] * y[1]    
;;;577       * sum +=  x[srcALen-1] * y[0]    
;;;578       */
;;;579    
;;;580      /* In this stage the MAC operations are decreased by 1 for every iteration.    
;;;581         The count variable holds the number of MAC operations performed */
;;;582      count = srcBLen - 1u;
;;;583    
;;;584      /* Working pointer of inputA */
;;;585      pSrc1 = pIn1 + (srcALen - (srcBLen - 1u));
0002a8  eb04028e          ADD      r2,r4,lr,LSL #2
0002ac  1d12              ADDS     r2,r2,#4
;;;586      px = pSrc1;
0002ae  4611              MOV      r1,r2
;;;587    
;;;588      /* Working pointer of inputB */
;;;589      py = pIn2;
;;;590    
;;;591      /* -------------------    
;;;592       * Stage3 process    
;;;593       * ------------------*/
;;;594    
;;;595      while(blockSize3 > 0u)
0002b0  e036              B        |L1.800|
;;;596      {
;;;597        /* Accumulator is made zero for every iteration */
;;;598        sum = 0.0f;
0002b2  bf00              NOP      
                  |L1.692|
0002b4  eeb03a64          VMOV.F32 s6,s9
;;;599    
;;;600        /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;601        k = count >> 2u;
0002b8  089c              LSRS     r4,r3,#2
;;;602    
;;;603        /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.    
;;;604         ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;605        while(k > 0u)
0002ba  e01a              B        |L1.754|
                  |L1.700|
;;;606        {
;;;607          /* Perform the multiply-accumulates */
;;;608          /* sum += x[srcALen - srcBLen + 4] * y[3] */
;;;609          sum += *px++ * *py++;
0002bc  ed910a00          VLDR     s0,[r1,#0]
0002c0  edd00a00          VLDR     s1,[r0,#0]
0002c4  ee003a20          VMLA.F32 s6,s0,s1
;;;610          /* sum += x[srcALen - srcBLen + 3] * y[2] */
;;;611          sum += *px++ * *py++;
0002c8  ed910a01          VLDR     s0,[r1,#4]
0002cc  edd00a01          VLDR     s1,[r0,#4]
0002d0  ee003a20          VMLA.F32 s6,s0,s1
;;;612          /* sum += x[srcALen - srcBLen + 2] * y[1] */
;;;613          sum += *px++ * *py++;
0002d4  ed910a02          VLDR     s0,[r1,#8]
0002d8  edd00a02          VLDR     s1,[r0,#8]
0002dc  ee003a20          VMLA.F32 s6,s0,s1
;;;614          /* sum += x[srcALen - srcBLen + 1] * y[0] */
;;;615          sum += *px++ * *py++;
0002e0  ed910a03          VLDR     s0,[r1,#0xc]
0002e4  edd00a03          VLDR     s1,[r0,#0xc]
0002e8  3010              ADDS     r0,r0,#0x10
0002ea  3110              ADDS     r1,r1,#0x10
0002ec  1e64              SUBS     r4,r4,#1
0002ee  ee003a20          VMLA.F32 s6,s0,s1
                  |L1.754|
0002f2  2c00              CMP      r4,#0                 ;605
0002f4  d1e2              BNE      |L1.700|
;;;616    
;;;617          /* Decrement the loop counter */
;;;618          k--;
;;;619        }
;;;620    
;;;621        /* If the count is not a multiple of 4, compute any remaining MACs here.    
;;;622         ** No loop unrolling is used. */
;;;623        k = count % 0x4u;
0002f6  f0030403          AND      r4,r3,#3
;;;624    
;;;625        while(k > 0u)
0002fa  e006              B        |L1.778|
                  |L1.764|
;;;626        {
;;;627          /* Perform the multiply-accumulates */
;;;628          sum += *px++ * *py++;
0002fc  ecb10a01          VLDM     r1!,{s0}
000300  1e64              SUBS     r4,r4,#1
000302  ecf00a01          VLDM     r0!,{s1}
000306  ee003a20          VMLA.F32 s6,s0,s1
                  |L1.778|
00030a  2c00              CMP      r4,#0                 ;625
00030c  d1f6              BNE      |L1.764|
;;;629    
;;;630          /* Decrement the loop counter */
;;;631          k--;
;;;632        }
;;;633    
;;;634        /* Store the result in the accumulator in the destination buffer. */
;;;635        *pOut = sum;
00030e  ed853a00          VSTR     s6,[r5,#0]
;;;636        /* Destination pointer is updated according to the address modifier, inc */
;;;637        pOut += inc;
;;;638    
;;;639        /* Update the inputA and inputB pointers for next MAC calculation */
;;;640        px = ++pSrc1;
000312  1d11              ADDS     r1,r2,#4
000314  eb050587          ADD      r5,r5,r7,LSL #2       ;637
000318  460a              MOV      r2,r1
;;;641        py = pIn2;
00031a  4630              MOV      r0,r6
;;;642    
;;;643        /* Decrement the MAC count */
;;;644        count--;
;;;645    
;;;646        /* Decrement the loop counter */
;;;647        blockSize3--;
00031c  f1aa0a01          SUB      r10,r10,#1
                  |L1.800|
000320  1e5b              SUBS     r3,r3,#1
000322  f1ba0f00          CMP      r10,#0                ;595
000326  d1c5              BNE      |L1.692|
;;;648      }
;;;649    
;;;650    #else
;;;651    
;;;652      /* Run the below code for Cortex-M0 */
;;;653    
;;;654      float32_t *pIn1 = pSrcA;                       /* inputA pointer */
;;;655      float32_t *pIn2 = pSrcB + (srcBLen - 1u);      /* inputB pointer */
;;;656      float32_t sum;                                 /* Accumulator */
;;;657      uint32_t i = 0u, j;                            /* loop counters */
;;;658      uint32_t inv = 0u;                             /* Reverse order flag */
;;;659      uint32_t tot = 0u;                             /* Length */
;;;660    
;;;661      /* The algorithm implementation is based on the lengths of the inputs. */
;;;662      /* srcB is always made to slide across srcA. */
;;;663      /* So srcBLen is always considered as shorter or equal to srcALen */
;;;664      /* But CORR(x, y) is reverse of CORR(y, x) */
;;;665      /* So, when srcBLen > srcALen, output pointer is made to point to the end of the output buffer */
;;;666      /* and a varaible, inv is set to 1 */
;;;667      /* If lengths are not equal then zero pad has to be done to  make the two    
;;;668       * inputs of same length. But to improve the performance, we assume zeroes    
;;;669       * in the output instead of zero padding either of the the inputs*/
;;;670      /* If srcALen > srcBLen, (srcALen - srcBLen) zeroes has to included in the    
;;;671       * starting of the output buffer */
;;;672      /* If srcALen < srcBLen, (srcALen - srcBLen) zeroes has to included in the   
;;;673       * ending of the output buffer */
;;;674      /* Once the zero padding is done the remaining of the output is calcualted   
;;;675       * using convolution but with the shorter signal time shifted. */
;;;676    
;;;677      /* Calculate the length of the remaining sequence */
;;;678      tot = ((srcALen + srcBLen) - 2u);
;;;679    
;;;680      if(srcALen > srcBLen)
;;;681      {
;;;682        /* Calculating the number of zeros to be padded to the output */
;;;683        j = srcALen - srcBLen;
;;;684    
;;;685        /* Initialise the pointer after zero padding */
;;;686        pDst += j;
;;;687      }
;;;688    
;;;689      else if(srcALen < srcBLen)
;;;690      {
;;;691        /* Initialization to inputB pointer */
;;;692        pIn1 = pSrcB;
;;;693    
;;;694        /* Initialization to the end of inputA pointer */
;;;695        pIn2 = pSrcA + (srcALen - 1u);
;;;696    
;;;697        /* Initialisation of the pointer after zero padding */
;;;698        pDst = pDst + tot;
;;;699    
;;;700        /* Swapping the lengths */
;;;701        j = srcALen;
;;;702        srcALen = srcBLen;
;;;703        srcBLen = j;
;;;704    
;;;705        /* Setting the reverse flag */
;;;706        inv = 1;
;;;707    
;;;708      }
;;;709    
;;;710      /* Loop to calculate convolution for output length number of times */
;;;711      for (i = 0u; i <= tot; i++)
;;;712      {
;;;713        /* Initialize sum with zero to carry on MAC operations */
;;;714        sum = 0.0f;
;;;715    
;;;716        /* Loop to perform MAC operations according to convolution equation */
;;;717        for (j = 0u; j <= i; j++)
;;;718        {
;;;719          /* Check the array limitations */
;;;720          if((((i - j) < srcBLen) && (j < srcALen)))
;;;721          {
;;;722            /* z[i] += x[i-j] * y[j] */
;;;723            sum += pIn1[j] * pIn2[-((int32_t) i - j)];
;;;724          }
;;;725        }
;;;726        /* Store the output in the destination buffer */
;;;727        if(inv == 1)
;;;728          *pDst-- = sum;
;;;729        else
;;;730          *pDst++ = sum;
;;;731      }
;;;732    
;;;733    #endif /*   #ifndef ARM_MATH_CM0_FAMILY */
;;;734    
;;;735    }
000328  e8bd8ff0          POP      {r4-r11,pc}
;;;736    
                          ENDP

                  |L1.812|
00032c  00000000          DCFS     0x00000000 ; 0

;*** Start embedded assembler ***

#line 1 "src\\FilteringFunctions\\arm_correlate_f32.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_correlate_f32_c_89505502____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___19_arm_correlate_f32_c_89505502____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_correlate_f32_c_89505502____REVSH|
#line 144
|__asm___19_arm_correlate_f32_c_89505502____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_correlate_f32_c_89505502____RRX|
#line 300
|__asm___19_arm_correlate_f32_c_89505502____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
