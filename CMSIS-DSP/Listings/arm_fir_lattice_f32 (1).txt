; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_fir_lattice_f32.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_fir_lattice_f32.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"Z:\GoogleDrive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_fir_lattice_f32.crf src\FilteringFunctions\arm_fir_lattice_f32.c]
                          THUMB

                          AREA ||i.arm_fir_lattice_f32||, CODE, READONLY, ALIGN=2

                  arm_fir_lattice_f32 PROC
;;;130    
;;;131    void arm_fir_lattice_f32(
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;132      const arm_fir_lattice_instance_f32 * S,
;;;133      float32_t * pSrc,
;;;134      float32_t * pDst,
;;;135      uint32_t blockSize)
;;;136    {
;;;137      float32_t *pState;                             /* State pointer */
;;;138      float32_t *pCoeffs = S->pCoeffs;               /* Coefficient pointer */
;;;139      float32_t *px;                                 /* temporary state pointer */
;;;140      float32_t *pk;                                 /* temporary coefficient pointer */
;;;141    
;;;142    
;;;143    #ifndef ARM_MATH_CM0_FAMILY
;;;144    
;;;145      /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;146    
;;;147      float32_t fcurr1, fnext1, gcurr1, gnext1;      /* temporary variables for first sample in loop unrolling */
;;;148      float32_t fcurr2, fnext2, gnext2;              /* temporary variables for second sample in loop unrolling */
;;;149      float32_t fcurr3, fnext3, gnext3;              /* temporary variables for third sample in loop unrolling */
;;;150      float32_t fcurr4, fnext4, gnext4;              /* temporary variables for fourth sample in loop unrolling */
;;;151      uint32_t numStages = S->numStages;             /* Number of stages in the filter */
;;;152      uint32_t blkCnt, stageCnt;                     /* temporary variables for counts */
;;;153    
;;;154      gcurr1 = 0.0f;
;;;155      pState = &S->pState[0];
;;;156    
;;;157      blkCnt = blockSize >> 2;
000004  ea4f0893          LSR      r8,r3,#2
000008  ed2d8b02          VPUSH    {d8}                  ;136
00000c  e9d05601          LDRD     r5,r6,[r0,#4]         ;136
000010  8807              LDRH     r7,[r0,#0]            ;151
000012  e11d              B        |L1.592|
                  |L1.20|
;;;158    
;;;159      /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.    
;;;160         a second loop below computes the remaining 1 to 3 samples. */
;;;161      while(blkCnt > 0u)
;;;162      {
;;;163    
;;;164        /* Read two samples from input buffer */
;;;165        /* f0(n) = x(n) */
;;;166        fcurr1 = *pSrc++;
000014  ed914a00          VLDR     s8,[r1,#0]
;;;167        fcurr2 = *pSrc++;
;;;168    
;;;169        /* Initialize coeff pointer */
;;;170        pk = (pCoeffs);
;;;171    
;;;172        /* Initialize state pointer */
;;;173        px = pState;
;;;174    
;;;175        /* Read g0(n-1) from state */
;;;176        gcurr1 = *px;
;;;177    
;;;178        /* Process first sample for first tap */
;;;179        /* f1(n) = f0(n) +  K1 * g0(n-1) */
;;;180        fnext1 = fcurr1 + ((*pk) * gcurr1);
000018  ed961a00          VLDR     s2,[r6,#0]
00001c  edd10a01          VLDR     s1,[r1,#4]            ;167
000020  ed953a00          VLDR     s6,[r5,#0]            ;176
000024  eef01a44          VMOV.F32 s3,s8
;;;181        /* g1(n) = f0(n) * K1  +  g0(n-1) */
;;;182        gnext1 = (fcurr1 * (*pk)) + gcurr1;
000028  eeb02a60          VMOV.F32 s4,s1
00002c  ee411a03          VMLA.F32 s3,s2,s6              ;180
;;;183    
;;;184        /* Process second sample for first tap */
;;;185        /* for sample 2 processing */
;;;186        fnext2 = fcurr2 + ((*pk) * fcurr1);
;;;187        gnext2 = (fcurr2 * (*pk)) + fcurr1;
000030  eeb00a44          VMOV.F32 s0,s8
000034  ee043a01          VMLA.F32 s6,s8,s2              ;182
000038  ee012a04          VMLA.F32 s4,s2,s8              ;186
00003c  ee000a81          VMLA.F32 s0,s1,s2
;;;188    
;;;189        /* Read next two samples from input buffer */
;;;190        /* f0(n+2) = x(n+2) */
;;;191        fcurr3 = *pSrc++;
;;;192        fcurr4 = *pSrc++;
000040  ed914a03          VLDR     s8,[r1,#0xc]
000044  ed911a02          VLDR     s2,[r1,#8]            ;191
;;;193    
;;;194        /* Copy only last input samples into the state buffer    
;;;195           which will be used for next four samples processing */
;;;196        *px++ = fcurr4;
000048  ed854a00          VSTR     s8,[r5,#0]
;;;197    
;;;198        /* Process third sample for first tap */
;;;199        fnext3 = fcurr3 + ((*pk) * fcurr2);
00004c  edd64a00          VLDR     s9,[r6,#0]
000050  eef02a41          VMOV.F32 s5,s2
;;;200        gnext3 = (fcurr3 * (*pk)) + fcurr2;
;;;201    
;;;202        /* Process fourth sample for first tap */
;;;203        fnext4 = fcurr4 + ((*pk) * fcurr3);
000054  eef03a44          VMOV.F32 s7,s8
000058  ee442aa0          VMLA.F32 s5,s9,s1              ;199
00005c  ee410a24          VMLA.F32 s1,s2,s9              ;200
000060  ee443a81          VMLA.F32 s7,s9,s2
;;;204        gnext4 = (fcurr4 * (*pk++)) + fcurr3;
;;;205    
;;;206        /* Update of f values for next coefficient set processing */
;;;207        fcurr1 = fnext1;
;;;208        fcurr2 = fnext2;
;;;209        fcurr3 = fnext3;
;;;210        fcurr4 = fnext4;
;;;211    
;;;212        /* Loop unrolling.  Process 4 taps at a time . */
;;;213        stageCnt = (numStages - 1u) >> 2u;
000064  f1a70c01          SUB      r12,r7,#1
000068  1d28              ADDS     r0,r5,#4              ;196
00006a  ee041a24          VMLA.F32 s2,s8,s9              ;204
00006e  1d34              ADDS     r4,r6,#4              ;204
000070  46e1              MOV      r9,r12
000072  ea4f0c9c          LSR      r12,r12,#2
000076  3110              ADDS     r1,r1,#0x10
;;;214    
;;;215        /* Loop over the number of taps.  Unroll by a factor of 4.    
;;;216         ** Repeat until we've computed numStages-3 coefficients. */
;;;217    
;;;218        /* Process 2nd, 3rd, 4th and 5th taps ... here */
;;;219        while(stageCnt > 0u)
000078  e09e              B        |L1.440|
;;;220        {
;;;221          /* Read g1(n-1), g3(n-1) .... from state */
;;;222          gcurr1 = *px;
00007a  bf00              NOP      
                  |L1.124|
00007c  edd04a00          VLDR     s9,[r0,#0]
;;;223    
;;;224          /* save g1(n) in state buffer */
;;;225          *px++ = gnext4;
000080  ed801a00          VSTR     s2,[r0,#0]
;;;226    
;;;227          /* Process first sample for 2nd, 6th .. tap */
;;;228          /* Sample processing for K2, K6.... */
;;;229          /* f2(n) = f1(n) +  K2 * g1(n-1) */
;;;230          fnext1 = fcurr1 + ((*pk) * gcurr1);
000084  ed945a00          VLDR     s10,[r4,#0]
000088  eeb04a61          VMOV.F32 s8,s3
;;;231          /* Process second sample for 2nd, 6th .. tap */
;;;232          /* for sample 2 processing */
;;;233          fnext2 = fcurr2 + ((*pk) * gnext1);
;;;234          /* Process third sample for 2nd, 6th .. tap */
;;;235          fnext3 = fcurr3 + ((*pk) * gnext2);
;;;236          /* Process fourth sample for 2nd, 6th .. tap */
;;;237          fnext4 = fcurr4 + ((*pk) * gnext3);
00008c  eeb01a63          VMOV.F32 s2,s7
000090  ee054a24          VMLA.F32 s8,s10,s9             ;230
000094  ee051a20          VMLA.F32 s2,s10,s1
;;;238    
;;;239          /* g2(n) = f1(n) * K2  +  g1(n-1) */
;;;240          /* Calculation of state values for next stage */
;;;241          gnext4 = (fcurr4 * (*pk)) + gnext3;
;;;242          gnext3 = (fcurr3 * (*pk)) + gnext2;
;;;243          gnext2 = (fcurr2 * (*pk)) + gnext1;
;;;244          gnext1 = (fcurr1 * (*pk++)) + gcurr1;
000098  ee414a85          VMLA.F32 s9,s3,s10
00009c  eef05a44          VMOV.F32 s11,s8                ;230
0000a0  eeb04a42          VMOV.F32 s8,s4                 ;230
0000a4  eeb06a41          VMOV.F32 s12,s2                ;237
0000a8  ee054a03          VMLA.F32 s8,s10,s6             ;233
0000ac  eeb01a60          VMOV.F32 s2,s1                 ;237
0000b0  eef00a40          VMOV.F32 s1,s0                 ;241
0000b4  ee031a85          VMLA.F32 s2,s7,s10             ;241
0000b8  ee420a85          VMLA.F32 s1,s5,s10             ;242
0000bc  ee023a05          VMLA.F32 s6,s4,s10             ;243
0000c0  eeb07a44          VMOV.F32 s14,s8                ;233
0000c4  eeb04a62          VMOV.F32 s8,s5                 ;233
;;;245    
;;;246    
;;;247          /* Read g2(n-1), g4(n-1) .... from state */
;;;248          gcurr1 = *px;
;;;249    
;;;250          /* save g2(n) in state buffer */
;;;251          *px++ = gnext4;
;;;252    
;;;253          /* Sample processing for K3, K7.... */
;;;254          /* Process first sample for 3rd, 7th .. tap */
;;;255          /* f3(n) = f2(n) +  K3 * g2(n-1) */
;;;256          fcurr1 = fnext1 + ((*pk) * gcurr1);
0000c8  eef01a65          VMOV.F32 s3,s11
0000cc  ee054a00          VMLA.F32 s8,s10,s0             ;235
0000d0  ed905a01          VLDR     s10,[r0,#4]           ;248
0000d4  ed801a01          VSTR     s2,[r0,#4]            ;251
0000d8  ed940a01          VLDR     s0,[r4,#4]
;;;257          /* Process second sample for 3rd, 7th .. tap */
;;;258          fcurr2 = fnext2 + ((*pk) * gnext1);
;;;259          /* Process third sample for 3rd, 7th .. tap */
;;;260          fcurr3 = fnext3 + ((*pk) * gnext2);
0000dc  eef06a46          VMOV.F32 s13,s12
0000e0  eef07a44          VMOV.F32 s15,s8                ;235
0000e4  eeb04a47          VMOV.F32 s8,s14                ;258
0000e8  ee401a05          VMLA.F32 s3,s0,s10             ;256
0000ec  ee004a24          VMLA.F32 s8,s0,s9              ;258
;;;261          /* Process fourth sample for 3rd, 7th .. tap */
;;;262          fcurr4 = fnext4 + ((*pk) * gnext3);
0000f0  ee406a20          VMLA.F32 s13,s0,s1
;;;263    
;;;264          /* Calculation of state values for next stage */
;;;265          /* g3(n) = f2(n) * K3  +  g2(n-1) */
;;;266          gnext4 = (fnext4 * (*pk)) + gnext3;
0000f4  ee460a00          VMLA.F32 s1,s12,s0
;;;267          gnext3 = (fnext3 * (*pk)) + gnext2;
;;;268          gnext2 = (fnext2 * (*pk)) + gnext1;
;;;269          gnext1 = (fnext1 * (*pk++)) + gcurr1;
0000f8  ee055a80          VMLA.F32 s10,s11,s0
;;;270    
;;;271    
;;;272          /* Read g1(n-1), g3(n-1) .... from state */
;;;273          gcurr1 = *px;
0000fc  edd05a02          VLDR     s11,[r0,#8]
000100  ee474a00          VMLA.F32 s9,s14,s0             ;268
000104  eef02a44          VMOV.F32 s5,s8                 ;258
000108  eeb04a67          VMOV.F32 s8,s15                ;260
;;;274    
;;;275          /* save g3(n) in state buffer */
;;;276          *px++ = gnext4;
00010c  edc00a02          VSTR     s1,[r0,#8]
000110  ee004a03          VMLA.F32 s8,s0,s6              ;260
000114  ee073a80          VMLA.F32 s6,s15,s0             ;267
;;;277    
;;;278          /* Sample processing for K4, K8.... */
;;;279          /* Process first sample for 4th, 8th .. tap */
;;;280          /* f4(n) = f3(n) +  K4 * g3(n-1) */
;;;281          fnext1 = fcurr1 + ((*pk) * gcurr1);
000118  ed940a02          VLDR     s0,[r4,#8]
00011c  eeb02a61          VMOV.F32 s4,s3                 ;256
;;;282          /* Process second sample for 4th, 8th .. tap */
;;;283          /* for sample 2 processing */
;;;284          fnext2 = fcurr2 + ((*pk) * gnext1);
;;;285          /* Process third sample for 4th, 8th .. tap */
;;;286          fnext3 = fcurr3 + ((*pk) * gnext2);
;;;287          /* Process fourth sample for 4th, 8th .. tap */
;;;288          fnext4 = fcurr4 + ((*pk) * gnext3);
;;;289    
;;;290          /* g4(n) = f3(n) * K4  +  g3(n-1) */
;;;291          /* Calculation of state values for next stage */
;;;292          gnext4 = (fcurr4 * (*pk)) + gnext3;
000120  eeb01a64          VMOV.F32 s2,s9
000124  eeb06a42          VMOV.F32 s12,s4                ;281
000128  eef03a44          VMOV.F32 s7,s8                 ;260
00012c  ee006a25          VMLA.F32 s12,s0,s11            ;281
000130  eef00a63          VMOV.F32 s1,s7                 ;286
;;;293          gnext3 = (fcurr3 * (*pk)) + gnext2;
;;;294          gnext2 = (fcurr2 * (*pk)) + gnext1;
;;;295          gnext1 = (fcurr1 * (*pk++)) + gcurr1;
000134  ee425a00          VMLA.F32 s11,s4,s0
000138  ee400a24          VMLA.F32 s1,s0,s9              ;286
;;;296    
;;;297          /* Read g2(n-1), g4(n-1) .... from state */
;;;298          gcurr1 = *px;
00013c  edd04a03          VLDR     s9,[r0,#0xc]
000140  ee031a80          VMLA.F32 s2,s7,s0              ;293
000144  eeb07a46          VMOV.F32 s14,s12               ;281
000148  eeb06a62          VMOV.F32 s12,s5                ;281
;;;299    
;;;300          /* save g4(n) in state buffer */
;;;301          *px++ = gnext4;
;;;302    
;;;303          /* Sample processing for K5, K9.... */
;;;304          /* Process first sample for 5th, 9th .. tap */
;;;305          /* f5(n) = f4(n) +  K5 * g4(n-1) */
;;;306          fcurr1 = fnext1 + ((*pk) * gcurr1);
00014c  eef01a47          VMOV.F32 s3,s14
000150  eeb08a60          VMOV.F32 s16,s1                ;286
000154  eef00a66          VMOV.F32 s1,s13                ;286
000158  ee006a05          VMLA.F32 s12,s0,s10            ;284
00015c  ee400a03          VMLA.F32 s1,s0,s6              ;288
000160  ee063a80          VMLA.F32 s6,s13,s0             ;292
000164  ee025a80          VMLA.F32 s10,s5,s0             ;294
;;;307          /* Process second sample for 5th, 9th .. tap */
;;;308          fcurr2 = fnext2 + ((*pk) * gnext1);
000168  eef02a48          VMOV.F32 s5,s16
00016c  eeb00a65          VMOV.F32 s0,s11                ;295
000170  eef07a46          VMOV.F32 s15,s12               ;284
000174  ed803a03          VSTR     s6,[r0,#0xc]          ;301
000178  ed944a03          VLDR     s8,[r4,#0xc]          ;306
00017c  eef08a60          VMOV.F32 s17,s1                ;288
000180  eeb02a67          VMOV.F32 s4,s15                ;306
;;;309          /* Process third sample for 5th, 9th .. tap */
;;;310          fcurr3 = fnext3 + ((*pk) * gnext2);
000184  ee442a05          VMLA.F32 s5,s8,s10
000188  eef03a68          VMOV.F32 s7,s17
;;;311          /* Process fourth sample for 5th, 9th .. tap */
;;;312          fcurr4 = fnext4 + ((*pk) * gnext3);
;;;313    
;;;314          /* Calculation of state values for next stage */
;;;315          /* g5(n) = f4(n) * K5  +  g4(n-1) */
;;;316          gnext4 = (fnext4 * (*pk)) + gnext3;
;;;317          gnext3 = (fnext3 * (*pk)) + gnext2;
00018c  ee085a04          VMLA.F32 s10,s16,s8
000190  ee042a00          VMLA.F32 s4,s8,s0              ;308
000194  ee443a01          VMLA.F32 s7,s8,s2              ;312
000198  ee441a24          VMLA.F32 s3,s8,s9              ;306
00019c  ee081a84          VMLA.F32 s2,s17,s8             ;316
;;;318          gnext2 = (fnext2 * (*pk)) + gnext1;
0001a0  ee070a84          VMLA.F32 s0,s15,s8
0001a4  eef00a45          VMOV.F32 s1,s10                ;317
0001a8  eeb03a64          VMOV.F32 s6,s9
;;;319          gnext1 = (fnext1 * (*pk++)) + gcurr1;
0001ac  3010              ADDS     r0,r0,#0x10
0001ae  ee073a04          VMLA.F32 s6,s14,s8
0001b2  3410              ADDS     r4,r4,#0x10
0001b4  f1ac0c01          SUB      r12,r12,#1
                  |L1.440|
0001b8  f1bc0f00          CMP      r12,#0                ;219
0001bc  f47faf5e          BNE      |L1.124|
;;;320    
;;;321          stageCnt--;
;;;322        }
;;;323    
;;;324        /* If the (filter length -1) is not a multiple of 4, compute the remaining filter taps */
;;;325        stageCnt = (numStages - 1u) % 0x4u;
0001c0  f0090c03          AND      r12,r9,#3
;;;326    
;;;327        while(stageCnt > 0u)
0001c4  e036              B        |L1.564|
;;;328        {
;;;329          gcurr1 = *px;
0001c6  bf00              NOP      
                  |L1.456|
0001c8  ed906a00          VLDR     s12,[r0,#0]
;;;330    
;;;331          /* save g value in state buffer */
;;;332          *px++ = gnext4;
0001cc  ed801a00          VSTR     s2,[r0,#0]
;;;333    
;;;334          /* Process four samples for last three taps here */
;;;335          fnext1 = fcurr1 + ((*pk) * gcurr1);
0001d0  ed944a00          VLDR     s8,[r4,#0]
0001d4  eef05a61          VMOV.F32 s11,s3
;;;336          fnext2 = fcurr2 + ((*pk) * gnext1);
;;;337          fnext3 = fcurr3 + ((*pk) * gnext2);
0001d8  eeb05a63          VMOV.F32 s10,s7
0001dc  eef04a62          VMOV.F32 s9,s5                 ;336
0001e0  ee445a06          VMLA.F32 s11,s8,s12            ;335
;;;338          fnext4 = fcurr4 + ((*pk) * gnext3);
0001e4  ee045a20          VMLA.F32 s10,s8,s1
0001e8  ee444a00          VMLA.F32 s9,s8,s0              ;337
;;;339    
;;;340          /* g1(n) = f0(n) * K1  +  g0(n-1) */
;;;341          gnext4 = (fcurr4 * (*pk)) + gnext3;
0001ec  ee430a84          VMLA.F32 s1,s7,s8
;;;342          gnext3 = (fcurr3 * (*pk)) + gnext2;
0001f0  ee020a84          VMLA.F32 s0,s5,s8
;;;343          gnext2 = (fcurr2 * (*pk)) + gnext1;
;;;344          gnext1 = (fcurr1 * (*pk++)) + gcurr1;
;;;345    
;;;346          /* Update of f values for next coefficient set processing */
;;;347          fcurr1 = fnext1;
;;;348          fcurr2 = fnext2;
;;;349          fcurr3 = fnext3;
;;;350          fcurr4 = fnext4;
0001f4  1d00              ADDS     r0,r0,#4
0001f6  eeb07a65          VMOV.F32 s14,s11               ;335
0001fa  eef05a42          VMOV.F32 s11,s4                ;335
0001fe  eef02a64          VMOV.F32 s5,s9                 ;349
000202  eeb01a60          VMOV.F32 s2,s1                 ;341
000206  eef00a40          VMOV.F32 s1,s0                 ;342
00020a  ee445a03          VMLA.F32 s11,s8,s6             ;336
00020e  eeb00a43          VMOV.F32 s0,s6                 ;342
000212  eeb03a46          VMOV.F32 s6,s12                ;344
000216  ee020a04          VMLA.F32 s0,s4,s8              ;343
00021a  ee013a84          VMLA.F32 s6,s3,s8              ;344
00021e  eef01a47          VMOV.F32 s3,s14                ;347
000222  eef06a65          VMOV.F32 s13,s11               ;336
000226  eef03a45          VMOV.F32 s7,s10
00022a  eeb02a66          VMOV.F32 s4,s13                ;348
00022e  1d24              ADDS     r4,r4,#4
000230  f1ac0c01          SUB      r12,r12,#1
                  |L1.564|
000234  f1bc0f00          CMP      r12,#0                ;327
000238  d1c6              BNE      |L1.456|
;;;351    
;;;352          stageCnt--;
;;;353    
;;;354        }
;;;355    
;;;356        /* The results in the 4 accumulators, store in the destination buffer. */
;;;357        /* y(n) = fN(n) */
;;;358        *pDst++ = fcurr1;
00023a  edc21a00          VSTR     s3,[r2,#0]
;;;359        *pDst++ = fcurr2;
00023e  ed822a01          VSTR     s4,[r2,#4]
;;;360        *pDst++ = fcurr3;
000242  edc22a02          VSTR     s5,[r2,#8]
;;;361        *pDst++ = fcurr4;
000246  edc23a03          VSTR     s7,[r2,#0xc]
00024a  3210              ADDS     r2,r2,#0x10
00024c  f1a80801          SUB      r8,r8,#1
                  |L1.592|
000250  f1b80f00          CMP      r8,#0                 ;161
000254  f47faede          BNE      |L1.20|
;;;362    
;;;363        blkCnt--;
;;;364      }
;;;365    
;;;366      /* If the blockSize is not a multiple of 4, compute any remaining output samples here.    
;;;367       ** No loop unrolling is used. */
;;;368      blkCnt = blockSize % 0x4u;
000258  f0030403          AND      r4,r3,#3
;;;369    
;;;370      while(blkCnt > 0u)
00025c  e02a              B        |L1.692|
;;;371      {
;;;372        /* f0(n) = x(n) */
;;;373        fcurr1 = *pSrc++;
00025e  bf00              NOP      
                  |L1.608|
000260  ecb11a01          VLDM     r1!,{s2}
;;;374    
;;;375        /* Initialize coeff pointer */
;;;376        pk = (pCoeffs);
;;;377    
;;;378        /* Initialize state pointer */
;;;379        px = pState;
;;;380    
;;;381        /* read g2(n) from state buffer */
;;;382        gcurr1 = *px;
000264  edd50a00          VLDR     s1,[r5,#0]
;;;383    
;;;384        /* for sample 1 processing */
;;;385        /* f1(n) = f0(n) +  K1 * g0(n-1) */
;;;386        fnext1 = fcurr1 + ((*pk) * gcurr1);
000268  edd61a00          VLDR     s3,[r6,#0]
;;;387        /* g1(n) = f0(n) * K1  +  g0(n-1) */
;;;388        gnext1 = (fcurr1 * (*pk++)) + gcurr1;
;;;389    
;;;390        /* save g1(n) in state buffer */
;;;391        *px++ = fcurr1;
00026c  1d28              ADDS     r0,r5,#4
00026e  f1060c04          ADD      r12,r6,#4             ;388
000272  eeb00a41          VMOV.F32 s0,s2                 ;386
000276  ed851a00          VSTR     s2,[r5,#0]
00027a  ee010aa0          VMLA.F32 s0,s3,s1              ;386
00027e  ee410a21          VMLA.F32 s1,s2,s3              ;388
;;;392    
;;;393        /* f1(n) is saved in fcurr1    
;;;394           for next stage processing */
;;;395        fcurr1 = fnext1;
;;;396    
;;;397        stageCnt = (numStages - 1u);
000282  1e7b              SUBS     r3,r7,#1
;;;398    
;;;399        /* stage loop */
;;;400        while(stageCnt > 0u)
000284  e011              B        |L1.682|
;;;401        {
;;;402          /* read g2(n) from state buffer */
;;;403          gcurr1 = *px;
000286  bf00              NOP      
                  |L1.648|
000288  edd01a00          VLDR     s3,[r0,#0]
;;;404    
;;;405          /* save g1(n) in state buffer */
;;;406          *px++ = gnext1;
;;;407    
;;;408          /* Sample processing for K2, K3.... */
;;;409          /* f2(n) = f1(n) +  K2 * g1(n-1) */
;;;410          fnext1 = fcurr1 + ((*pk) * gcurr1);
00028c  eeb01a40          VMOV.F32 s2,s0
000290  ece00a01          VSTM     r0!,{s1}              ;406
;;;411          /* g2(n) = f1(n) * K2  +  g1(n-1) */
;;;412          gnext1 = (fcurr1 * (*pk++)) + gcurr1;
000294  eef00a61          VMOV.F32 s1,s3
000298  ecbc2a01          VLDM     r12!,{s4}             ;410
;;;413    
;;;414          /* f1(n) is saved in fcurr1    
;;;415             for next stage processing */
;;;416          fcurr1 = fnext1;
00029c  1e5b              SUBS     r3,r3,#1
00029e  ee021a21          VMLA.F32 s2,s4,s3              ;410
0002a2  ee400a02          VMLA.F32 s1,s0,s4              ;412
0002a6  eeb00a41          VMOV.F32 s0,s2
                  |L1.682|
0002aa  2b00              CMP      r3,#0                 ;400
0002ac  d1ec              BNE      |L1.648|
;;;417    
;;;418          stageCnt--;
;;;419    
;;;420        }
;;;421    
;;;422        /* y(n) = fN(n) */
;;;423        *pDst++ = fcurr1;
0002ae  eca20a01          VSTM     r2!,{s0}
0002b2  1e64              SUBS     r4,r4,#1
                  |L1.692|
0002b4  2c00              CMP      r4,#0                 ;370
0002b6  d1d3              BNE      |L1.608|
;;;424    
;;;425        blkCnt--;
;;;426    
;;;427      }
;;;428    
;;;429    #else
;;;430    
;;;431      /* Run the below code for Cortex-M0 */
;;;432    
;;;433      float32_t fcurr, fnext, gcurr, gnext;          /* temporary variables */
;;;434      uint32_t numStages = S->numStages;             /* Length of the filter */
;;;435      uint32_t blkCnt, stageCnt;                     /* temporary variables for counts */
;;;436    
;;;437      pState = &S->pState[0];
;;;438    
;;;439      blkCnt = blockSize;
;;;440    
;;;441      while(blkCnt > 0u)
;;;442      {
;;;443        /* f0(n) = x(n) */
;;;444        fcurr = *pSrc++;
;;;445    
;;;446        /* Initialize coeff pointer */
;;;447        pk = pCoeffs;
;;;448    
;;;449        /* Initialize state pointer */
;;;450        px = pState;
;;;451    
;;;452        /* read g0(n-1) from state buffer */
;;;453        gcurr = *px;
;;;454    
;;;455        /* for sample 1 processing */
;;;456        /* f1(n) = f0(n) +  K1 * g0(n-1) */
;;;457        fnext = fcurr + ((*pk) * gcurr);
;;;458        /* g1(n) = f0(n) * K1  +  g0(n-1) */
;;;459        gnext = (fcurr * (*pk++)) + gcurr;
;;;460    
;;;461        /* save f0(n) in state buffer */
;;;462        *px++ = fcurr;
;;;463    
;;;464        /* f1(n) is saved in fcurr            
;;;465           for next stage processing */
;;;466        fcurr = fnext;
;;;467    
;;;468        stageCnt = (numStages - 1u);
;;;469    
;;;470        /* stage loop */
;;;471        while(stageCnt > 0u)
;;;472        {
;;;473          /* read g2(n) from state buffer */
;;;474          gcurr = *px;
;;;475    
;;;476          /* save g1(n) in state buffer */
;;;477          *px++ = gnext;
;;;478    
;;;479          /* Sample processing for K2, K3.... */
;;;480          /* f2(n) = f1(n) +  K2 * g1(n-1) */
;;;481          fnext = fcurr + ((*pk) * gcurr);
;;;482          /* g2(n) = f1(n) * K2  +  g1(n-1) */
;;;483          gnext = (fcurr * (*pk++)) + gcurr;
;;;484    
;;;485          /* f1(n) is saved in fcurr1            
;;;486             for next stage processing */
;;;487          fcurr = fnext;
;;;488    
;;;489          stageCnt--;
;;;490    
;;;491        }
;;;492    
;;;493        /* y(n) = fN(n) */
;;;494        *pDst++ = fcurr;
;;;495    
;;;496        blkCnt--;
;;;497    
;;;498      }
;;;499    
;;;500    #endif /*   #ifndef ARM_MATH_CM0_FAMILY */
;;;501    
;;;502    }
0002b8  ecbd8b02          VPOP     {d8}
0002bc  e8bd83f0          POP      {r4-r9,pc}
;;;503    
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\FilteringFunctions\\arm_fir_lattice_f32.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___21_arm_fir_lattice_f32_c_9890ec63____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___21_arm_fir_lattice_f32_c_9890ec63____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___21_arm_fir_lattice_f32_c_9890ec63____REVSH|
#line 144
|__asm___21_arm_fir_lattice_f32_c_9890ec63____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___21_arm_fir_lattice_f32_c_9890ec63____RRX|
#line 300
|__asm___21_arm_fir_lattice_f32_c_9890ec63____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
