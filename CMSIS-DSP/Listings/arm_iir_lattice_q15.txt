; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_iir_lattice_q15.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_iir_lattice_q15.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_iir_lattice_q15.crf src\FilteringFunctions\arm_iir_lattice_q15.c]
                          THUMB

                          AREA ||i.arm_iir_lattice_q15||, CODE, READONLY, ALIGN=2

                  arm_iir_lattice_q15 PROC
;;;70     
;;;71     void arm_iir_lattice_q15(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;72       const arm_iir_lattice_instance_q15 * S,
;;;73       q15_t * pSrc,
;;;74       q15_t * pDst,
;;;75       uint32_t blockSize)
;;;76     {
000004  b084              SUB      sp,sp,#0x10
000006  4682              MOV      r10,r0
;;;77     
;;;78     
;;;79     #ifndef ARM_MATH_CM0_FAMILY
;;;80     
;;;81       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;82     
;;;83       q31_t fcurr, fnext, gcurr = 0, gnext;          /* Temporary variables for lattice stages */
;;;84       q15_t gnext1, gnext2;                          /* Temporary variables for lattice stages */
;;;85       uint32_t stgCnt;                               /* Temporary variables for counts */
;;;86       q63_t acc;                                     /* Accumlator */
;;;87       uint32_t blkCnt, tapCnt;                       /* Temporary variables for counts */
;;;88       q15_t *px1, *px2, *pk, *pv;                    /* temporary pointers for state and coef */
;;;89       uint32_t numStages = S->numStages;             /* number of stages */
000008  8800              LDRH     r0,[r0,#0]
;;;90       q15_t *pState;                                 /* State pointer */
;;;91       q15_t *pStateCurnt;                            /* State current pointer */
;;;92       q15_t out;                                     /* Temporary variable for output */
;;;93       q31_t v;                                       /* Temporary variable for ladder coefficient */
;;;94     #ifdef UNALIGNED_SUPPORT_DISABLE
;;;95     	q15_t v1, v2;
;;;96     #endif
;;;97     
;;;98     
;;;99       blkCnt = blockSize;
00000a  9001              STR      r0,[sp,#4]
00000c  9807              LDR      r0,[sp,#0x1c]
;;;100    
;;;101      pState = &S->pState[0];
00000e  9000              STR      r0,[sp,#0]
000010  f8da0004          LDR      r0,[r10,#4]
;;;102    
;;;103      /* Sample processing */
;;;104      while(blkCnt > 0u)
000014  9002              STR      r0,[sp,#8]
000016  9800              LDR      r0,[sp,#0]            ;76
000018  e0c1              B        |L1.414|
                  |L1.26|
;;;105      {
;;;106        /* Read Sample from input buffer */
;;;107        /* fN(n) = x(n) */
;;;108        fcurr = *pSrc++;
00001a  9805              LDR      r0,[sp,#0x14]
00001c  f9302b02          LDRSH    r2,[r0],#2
;;;109    
;;;110        /* Initialize state read pointer */
;;;111        px1 = pState;
;;;112        /* Initialize state write pointer */
;;;113        px2 = pState;
000020  9005              STR      r0,[sp,#0x14]
;;;114        /* Set accumulator to zero */
;;;115        acc = 0;
;;;116        /* Initialize Ladder coeff pointer */
;;;117        pv = &S->pvCoeffs[0];
;;;118        /* Initialize Reflection coeff pointer */
;;;119        pk = &S->pkCoeffs[0];
;;;120    
;;;121    
;;;122        /* Process sample for first tap */
;;;123        gcurr = *px1++;
000022  9802              LDR      r0,[sp,#8]
000024  f9301b02          LDRSH    r1,[r0],#2
000028  e9da4502          LDRD     r4,r5,[r10,#8]
00002c  4603              MOV      r3,r0
;;;124        /* fN-1(n) = fN(n) - kN * gN-1(n-1) */
;;;125        fnext = fcurr - (((q31_t) gcurr * (*pk)) >> 15);
00002e  f9346b02          LDRSH    r6,[r4],#2
000032  fb16f701          SMULBB   r7,r6,r1
000036  eba232e7          SUB      r2,r2,r7,ASR #15
;;;126        fnext = __SSAT(fnext, 16);
00003a  f302070f          SSAT     r7,#16,r2
;;;127        /* gN(n) = kN * fN-1(n) + gN-1(n-1) */
;;;128        gnext = (((q31_t) fnext * (*pk++)) >> 15) + gcurr;
00003e  437e              MULS     r6,r7,r6
000040  eb0131e6          ADD      r1,r1,r6,ASR #15
;;;129        gnext = __SSAT(gnext, 16);
000044  f301020f          SSAT     r2,#16,r1
;;;130        /* write gN(n) into state for next sample processing */
;;;131        *px2++ = (q15_t) gnext;
000048  f8202c02          STRH     r2,[r0,#-2]
;;;132        /* y(n) += gN(n) * vN  */
;;;133        acc += (q31_t) ((gnext * (*pv++)));
00004c  f9351b02          LDRSH    r1,[r5],#2
;;;134    
;;;135    
;;;136        /* Update f values for next coefficient processing */
;;;137        fcurr = fnext;
;;;138    
;;;139        /* Loop unrolling.  Process 4 taps at a time. */
;;;140        tapCnt = (numStages - 1u) >> 2;
000050  9e01              LDR      r6,[sp,#4]
000052  4351              MULS     r1,r2,r1              ;133
000054  1e76              SUBS     r6,r6,#1
000056  17ca              ASRS     r2,r1,#31             ;133
000058  9603              STR      r6,[sp,#0xc]
00005a  08b6              LSRS     r6,r6,#2
;;;141    
;;;142        while(tapCnt > 0u)
00005c  e05b              B        |L1.278|
;;;143        {
;;;144    
;;;145          /* Process sample for 2nd, 6th ...taps */
;;;146          /* Read gN-2(n-1) from state buffer */
;;;147          gcurr = *px1++;
00005e  bf00              NOP      
                  |L1.96|
000060  f9339b02          LDRSH    r9,[r3],#2
;;;148          /* Process sample for 2nd, 6th .. taps */
;;;149          /* fN-2(n) = fN-1(n) - kN-1 * gN-2(n-1) */
;;;150          fnext = fcurr - (((q31_t) gcurr * (*pk)) >> 15);
000064  f9348b02          LDRSH    r8,[r4],#2
000068  fb18fc09          SMULBB   r12,r8,r9
00006c  eba737ec          SUB      r7,r7,r12,ASR #15
;;;151          fnext = __SSAT(fnext, 16);
000070  f3070b0f          SSAT     r11,#16,r7
;;;152          /* gN-1(n) = kN-1 * fN-2(n) + gN-2(n-1) */
;;;153          gnext = (((q31_t) fnext * (*pk++)) >> 15) + gcurr;
000074  fb08f80b          MUL      r8,r8,r11
000078  eb0937e8          ADD      r7,r9,r8,ASR #15
;;;154          gnext1 = (q15_t) __SSAT(gnext, 16);
00007c  f307070f          SSAT     r7,#16,r7
;;;155          /* write gN-1(n) into state */
;;;156          *px2++ = (q15_t) gnext1;
000080  f8207b02          STRH     r7,[r0],#2
000084  46a1              MOV      r9,r4                 ;153
;;;157    
;;;158    
;;;159          /* Process sample for 3nd, 7th ...taps */
;;;160          /* Read gN-3(n-1) from state */
;;;161          gcurr = *px1++;
000086  f933eb02          LDRSH    lr,[r3],#2
;;;162          /* Process sample for 3rd, 7th .. taps */
;;;163          /* fN-3(n) = fN-2(n) - kN-2 * gN-3(n-1) */
;;;164          fcurr = fnext - (((q31_t) gcurr * (*pk)) >> 15);
00008a  f9b44000          LDRSH    r4,[r4,#0]
00008e  fb14f80e          SMULBB   r8,r4,lr
000092  ebab3ce8          SUB      r12,r11,r8,ASR #15
;;;165          fcurr = __SSAT(fcurr, 16);
000096  f30c0c0f          SSAT     r12,#16,r12
;;;166          /* gN-2(n) = kN-2 * fN-3(n) + gN-3(n-1) */
;;;167          gnext = (((q31_t) fcurr * (*pk++)) >> 15) + gcurr;
00009a  fb04f40c          MUL      r4,r4,r12
00009e  eb0e38e4          ADD      r8,lr,r4,ASR #15
0000a2  f1090402          ADD      r4,r9,#2
;;;168          gnext2 = (q15_t) __SSAT(gnext, 16);
0000a6  f308090f          SSAT     r9,#16,r8
;;;169          /* write gN-2(n) into state */
;;;170          *px2++ = (q15_t) gnext2;
0000aa  f8209b02          STRH     r9,[r0],#2
;;;171    
;;;172          /* Read vN-1 and vN-2 at a time */
;;;173    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;174    
;;;175          v = *__SIMD32(pv)++;
0000ae  f855bb04          LDR      r11,[r5],#4
;;;176    
;;;177    #else
;;;178    
;;;179    	  v1 = *pv++;
;;;180    	  v2 = *pv++;
;;;181    
;;;182    #ifndef ARM_MATH_BIG_ENDIAN
;;;183    
;;;184    	  v = __PKHBT(v1, v2, 16);
;;;185    
;;;186    #else
;;;187    
;;;188    	  v = __PKHBT(v2, v1, 16);
;;;189    
;;;190    #endif	/* 	#ifndef ARM_MATH_BIG_ENDIAN		*/
;;;191    
;;;192    #endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE */
;;;193    
;;;194    
;;;195          /* Pack gN-1(n) and gN-2(n) */
;;;196    
;;;197    #ifndef  ARM_MATH_BIG_ENDIAN
;;;198    
;;;199          gnext = __PKHBT(gnext1, gnext2, 16);
0000b2  eac74709          PKHBT    r7,r7,r9,LSL #16
;;;200    
;;;201    #else
;;;202    
;;;203          gnext = __PKHBT(gnext2, gnext1, 16);
;;;204    
;;;205    #endif /*   #ifndef  ARM_MATH_BIG_ENDIAN    */
;;;206    
;;;207          /* y(n) += gN-1(n) * vN-1  */
;;;208          /* process for gN-5(n) * vN-5, gN-9(n) * vN-9 ... */
;;;209          /* y(n) += gN-2(n) * vN-2  */
;;;210          /* process for gN-6(n) * vN-6, gN-10(n) * vN-10 ... */
;;;211          acc = __SMLALD(gnext, v, acc);
0000b6  fbc712cb          SMLALD   r1,r2,r7,r11
0000ba  4689              MOV      r9,r1
;;;212    
;;;213    
;;;214          /* Process sample for 4th, 8th ...taps */
;;;215          /* Read gN-4(n-1) from state */
;;;216          gcurr = *px1++;
0000bc  f9331b04          LDRSH    r1,[r3],#4
;;;217          /* Process sample for 4th, 8th .. taps */
;;;218          /* fN-4(n) = fN-3(n) - kN-3 * gN-4(n-1) */
;;;219          fnext = fcurr - (((q31_t) gcurr * (*pk)) >> 15);
0000c0  f9347b02          LDRSH    r7,[r4],#2
0000c4  4693              MOV      r11,r2                ;211
0000c6  fb17f201          SMULBB   r2,r7,r1
0000ca  ebac32e2          SUB      r2,r12,r2,ASR #15
;;;220          fnext = __SSAT(fnext, 16);
0000ce  f302020f          SSAT     r2,#16,r2
;;;221          /* gN-3(n) = kN-3 * fN-1(n) + gN-1(n-1) */
;;;222          gnext = (((q31_t) fnext * (*pk++)) >> 15) + gcurr;
0000d2  4357              MULS     r7,r2,r7
0000d4  eb0131e7          ADD      r1,r1,r7,ASR #15
;;;223          gnext1 = (q15_t) __SSAT(gnext, 16);
0000d8  f301010f          SSAT     r1,#16,r1
;;;224          /* write  gN-3(n) for the next sample process */
;;;225          *px2++ = (q15_t) gnext1;
0000dc  f8201b04          STRH     r1,[r0],#4
;;;226    
;;;227    
;;;228          /* Process sample for 5th, 9th ...taps */
;;;229          /* Read gN-5(n-1) from state */
;;;230          gcurr = *px1++;
0000e0  f933cc02          LDRSH    r12,[r3,#-2]
;;;231          /* Process sample for 5th, 9th .. taps */
;;;232          /* fN-5(n) = fN-4(n) - kN-4 * gN-5(n-1) */
;;;233          fcurr = fnext - (((q31_t) gcurr * (*pk)) >> 15);
0000e4  f9348b02          LDRSH    r8,[r4],#2
0000e8  fb18f70c          SMULBB   r7,r8,r12
0000ec  eba232e7          SUB      r2,r2,r7,ASR #15
;;;234          fcurr = __SSAT(fcurr, 16);
0000f0  f302070f          SSAT     r7,#16,r2
;;;235          /* gN-4(n) = kN-4 * fN-5(n) + gN-5(n-1) */
;;;236          gnext = (((q31_t) fcurr * (*pk++)) >> 15) + gcurr;
0000f4  fb08f807          MUL      r8,r8,r7
0000f8  eb0c32e8          ADD      r2,r12,r8,ASR #15
;;;237          gnext2 = (q15_t) __SSAT(gnext, 16);
0000fc  f302020f          SSAT     r2,#16,r2
;;;238          /* write      gN-4(n) for the next sample process */
;;;239          *px2++ = (q15_t) gnext2;
000100  f8202c02          STRH     r2,[r0,#-2]
;;;240    
;;;241          /* Read vN-3 and vN-4 at a time */
;;;242    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;243    
;;;244          v = *__SIMD32(pv)++;
000104  f855cb04          LDR      r12,[r5],#4
;;;245    
;;;246    #else
;;;247    
;;;248    	  v1 = *pv++;
;;;249    	  v2 = *pv++;
;;;250    
;;;251    #ifndef ARM_MATH_BIG_ENDIAN
;;;252    
;;;253    	  v = __PKHBT(v1, v2, 16);
;;;254    
;;;255    #else
;;;256    
;;;257    	  v = __PKHBT(v2, v1, 16);
;;;258    
;;;259    #endif	/* #ifndef ARM_MATH_BIG_ENDIAN	 */
;;;260    
;;;261    #endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE */
;;;262    
;;;263    
;;;264          /* Pack gN-3(n) and gN-4(n) */
;;;265    #ifndef  ARM_MATH_BIG_ENDIAN
;;;266    
;;;267          gnext = __PKHBT(gnext1, gnext2, 16);
000108  eac14802          PKHBT    r8,r1,r2,LSL #16
;;;268    
;;;269    #else
;;;270    
;;;271          gnext = __PKHBT(gnext2, gnext1, 16);
;;;272    
;;;273    #endif /*      #ifndef  ARM_MATH_BIG_ENDIAN    */
;;;274    
;;;275          /* y(n) += gN-4(n) * vN-4  */
;;;276          /* process for gN-8(n) * vN-8, gN-12(n) * vN-12 ... */
;;;277          /* y(n) += gN-3(n) * vN-3  */
;;;278          /* process for gN-7(n) * vN-7, gN-11(n) * vN-11 ... */
;;;279          acc = __SMLALD(gnext, v, acc);
00010c  4649              MOV      r1,r9
00010e  465a              MOV      r2,r11
000110  fbc812cc          SMLALD   r1,r2,r8,r12
000114  1e76              SUBS     r6,r6,#1
                  |L1.278|
000116  2e00              CMP      r6,#0                 ;142
000118  d1a2              BNE      |L1.96|
;;;280    
;;;281          tapCnt--;
;;;282    
;;;283        }
;;;284    
;;;285        fnext = fcurr;
;;;286    
;;;287        /* If the filter length is not a multiple of 4, compute the remaining filter taps */
;;;288        tapCnt = (numStages - 1u) % 0x4u;
00011a  f8ddc00c          LDR      r12,[sp,#0xc]
00011e  463e              MOV      r6,r7                 ;285
000120  f00c0c03          AND      r12,r12,#3
;;;289    
;;;290        while(tapCnt > 0u)
000124  e01d              B        |L1.354|
;;;291        {
;;;292          gcurr = *px1++;
000126  bf00              NOP      
                  |L1.296|
000128  f9339b02          LDRSH    r9,[r3],#2
;;;293          /* Process sample for last taps */
;;;294          fnext = fcurr - (((q31_t) gcurr * (*pk)) >> 15);
00012c  f9348b02          LDRSH    r8,[r4],#2
000130  fb18f609          SMULBB   r6,r8,r9
000134  eba736e6          SUB      r6,r7,r6,ASR #15
;;;295          fnext = __SSAT(fnext, 16);
000138  f306060f          SSAT     r6,#16,r6
;;;296          gnext = (((q31_t) fnext * (*pk++)) >> 15) + gcurr;
00013c  fb08f806          MUL      r8,r8,r6
000140  eb0937e8          ADD      r7,r9,r8,ASR #15
;;;297          gnext = __SSAT(gnext, 16);
000144  f307090f          SSAT     r9,#16,r7
;;;298          /* Output samples for last taps */
;;;299          acc += (q31_t) (((q31_t) gnext * (*pv++)));
000148  f9358b02          LDRSH    r8,[r5],#2
;;;300          *px2++ = (q15_t) gnext;
00014c  f8209b02          STRH     r9,[r0],#2
000150  fb08f809          MUL      r8,r8,r9              ;299
000154  eb180101          ADDS     r1,r8,r1              ;299
000158  eb4272e8          ADC      r2,r2,r8,ASR #31      ;299
;;;301          fcurr = fnext;
00015c  4637              MOV      r7,r6
00015e  f1ac0c01          SUB      r12,r12,#1
                  |L1.354|
000162  f1bc0f00          CMP      r12,#0                ;290
000166  d1df              BNE      |L1.296|
;;;302    
;;;303          tapCnt--;
;;;304        }
;;;305    
;;;306        /* y(n) += g0(n) * v0 */
;;;307        acc += (q31_t) (((q31_t) fnext * (*pv++)));
000168  f9b54000          LDRSH    r4,[r5,#0]
;;;308    
;;;309        out = (q15_t) __SSAT(acc >> 15, 16);
;;;310        *px2++ = (q15_t) fnext;
00016c  8007              STRH     r7,[r0,#0]
00016e  4374              MULS     r4,r6,r4              ;307
000170  1861              ADDS     r1,r4,r1              ;307
000172  eb4273e4          ADC      r3,r2,r4,ASR #31      ;307
000176  ea4f31d1          LSR      r1,r1,#15             ;309
;;;311    
;;;312        /* write out into pDst */
;;;313        *pDst++ = out;
00017a  9806              LDR      r0,[sp,#0x18]
00017c  ea414143          ORR      r1,r1,r3,LSL #17      ;309
000180  f301010f          SSAT     r1,#16,r1             ;309
000184  8001              STRH     r1,[r0,#0]
000186  9806              LDR      r0,[sp,#0x18]
000188  f1000002          ADD      r0,r0,#2
;;;314    
;;;315        /* Advance the state pointer by 4 to process the next group of 4 samples */
;;;316        pState = pState + 1u;
00018c  9006              STR      r0,[sp,#0x18]
00018e  9802              LDR      r0,[sp,#8]
000190  f1000002          ADD      r0,r0,#2
;;;317        blkCnt--;
000194  9002              STR      r0,[sp,#8]
000196  9800              LDR      r0,[sp,#0]
000198  f1a00001          SUB      r0,r0,#1
00019c  9000              STR      r0,[sp,#0]
                  |L1.414|
00019e  2800              CMP      r0,#0                 ;104
0001a0  f47faf3b          BNE      |L1.26|
;;;318    
;;;319      }
;;;320    
;;;321      /* Processing is complete. Now copy last S->numStages samples to start of the buffer    
;;;322         for the preperation of next frame process */
;;;323      /* Points to the start of the state buffer */
;;;324      pStateCurnt = &S->pState[0];
;;;325      pState = &S->pState[blockSize];
0001a4  f8da0004          LDR      r0,[r10,#4]
0001a8  9907              LDR      r1,[sp,#0x1c]
;;;326    
;;;327      stgCnt = (numStages >> 2u);
0001aa  9a01              LDR      r2,[sp,#4]
0001ac  eb000141          ADD      r1,r0,r1,LSL #1       ;325
0001b0  ea4f0292          LSR      r2,r2,#2
;;;328    
;;;329      /* copy data */
;;;330      while(stgCnt > 0u)
0001b4  e009              B        |L1.458|
;;;331      {
;;;332    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;333    
;;;334        *__SIMD32(pStateCurnt)++ = *__SIMD32(pState)++;
0001b6  bf00              NOP      
                  |L1.440|
0001b8  f8513b04          LDR      r3,[r1],#4
0001bc  f8403b04          STR      r3,[r0],#4
;;;335        *__SIMD32(pStateCurnt)++ = *__SIMD32(pState)++;
0001c0  f8513b04          LDR      r3,[r1],#4
0001c4  f8403b04          STR      r3,[r0],#4
0001c8  1e52              SUBS     r2,r2,#1
                  |L1.458|
0001ca  2a00              CMP      r2,#0                 ;330
0001cc  d1f4              BNE      |L1.440|
;;;336    
;;;337    #else
;;;338    
;;;339        *pStateCurnt++ = *pState++;
;;;340        *pStateCurnt++ = *pState++;
;;;341        *pStateCurnt++ = *pState++;
;;;342        *pStateCurnt++ = *pState++;
;;;343    
;;;344    #endif /*	#ifndef UNALIGNED_SUPPORT_DISABLE */
;;;345    
;;;346        /* Decrement the loop counter */
;;;347        stgCnt--;
;;;348    
;;;349      }
;;;350    
;;;351      /* Calculation of count for remaining q15_t data */
;;;352      stgCnt = (numStages) % 0x4u;
0001ce  9a01              LDR      r2,[sp,#4]
0001d0  f0020203          AND      r2,r2,#3
;;;353    
;;;354      /* copy data */
;;;355      while(stgCnt > 0u)
0001d4  e005              B        |L1.482|
;;;356      {
;;;357        *pStateCurnt++ = *pState++;
0001d6  bf00              NOP      
                  |L1.472|
0001d8  f8313b02          LDRH     r3,[r1],#2
0001dc  f8203b02          STRH     r3,[r0],#2
0001e0  1e52              SUBS     r2,r2,#1
                  |L1.482|
0001e2  2a00              CMP      r2,#0                 ;355
0001e4  d1f8              BNE      |L1.472|
;;;358    
;;;359        /* Decrement the loop counter */
;;;360        stgCnt--;
;;;361      }
;;;362    
;;;363    #else
;;;364    
;;;365      /* Run the below code for Cortex-M0 */
;;;366    
;;;367      q31_t fcurr, fnext = 0, gcurr = 0, gnext;      /* Temporary variables for lattice stages */
;;;368      uint32_t stgCnt;                               /* Temporary variables for counts */
;;;369      q63_t acc;                                     /* Accumlator */
;;;370      uint32_t blkCnt, tapCnt;                       /* Temporary variables for counts */
;;;371      q15_t *px1, *px2, *pk, *pv;                    /* temporary pointers for state and coef */
;;;372      uint32_t numStages = S->numStages;             /* number of stages */
;;;373      q15_t *pState;                                 /* State pointer */
;;;374      q15_t *pStateCurnt;                            /* State current pointer */
;;;375      q15_t out;                                     /* Temporary variable for output */
;;;376    
;;;377    
;;;378      blkCnt = blockSize;
;;;379    
;;;380      pState = &S->pState[0];
;;;381    
;;;382      /* Sample processing */
;;;383      while(blkCnt > 0u)
;;;384      {
;;;385        /* Read Sample from input buffer */
;;;386        /* fN(n) = x(n) */
;;;387        fcurr = *pSrc++;
;;;388    
;;;389        /* Initialize state read pointer */
;;;390        px1 = pState;
;;;391        /* Initialize state write pointer */
;;;392        px2 = pState;
;;;393        /* Set accumulator to zero */
;;;394        acc = 0;
;;;395        /* Initialize Ladder coeff pointer */
;;;396        pv = &S->pvCoeffs[0];
;;;397        /* Initialize Reflection coeff pointer */
;;;398        pk = &S->pkCoeffs[0];
;;;399    
;;;400        tapCnt = numStages;
;;;401    
;;;402        while(tapCnt > 0u)
;;;403        {
;;;404          gcurr = *px1++;
;;;405          /* Process sample */
;;;406          /* fN-1(n) = fN(n) - kN * gN-1(n-1) */
;;;407          fnext = fcurr - ((gcurr * (*pk)) >> 15);
;;;408          fnext = __SSAT(fnext, 16);
;;;409          /* gN(n) = kN * fN-1(n) + gN-1(n-1) */
;;;410          gnext = ((fnext * (*pk++)) >> 15) + gcurr;
;;;411          gnext = __SSAT(gnext, 16);
;;;412          /* Output samples */
;;;413          /* y(n) += gN(n) * vN */
;;;414          acc += (q31_t) ((gnext * (*pv++)));
;;;415          /* write gN(n) into state for next sample processing */
;;;416          *px2++ = (q15_t) gnext;
;;;417          /* Update f values for next coefficient processing */
;;;418          fcurr = fnext;
;;;419    
;;;420          tapCnt--;
;;;421        }
;;;422    
;;;423        /* y(n) += g0(n) * v0 */
;;;424        acc += (q31_t) ((fnext * (*pv++)));
;;;425    
;;;426        out = (q15_t) __SSAT(acc >> 15, 16);
;;;427        *px2++ = (q15_t) fnext;
;;;428    
;;;429        /* write out into pDst */
;;;430        *pDst++ = out;
;;;431    
;;;432        /* Advance the state pointer by 1 to process the next group of samples */
;;;433        pState = pState + 1u;
;;;434        blkCnt--;
;;;435    
;;;436      }
;;;437    
;;;438      /* Processing is complete. Now copy last S->numStages samples to start of the buffer           
;;;439         for the preperation of next frame process */
;;;440      /* Points to the start of the state buffer */
;;;441      pStateCurnt = &S->pState[0];
;;;442      pState = &S->pState[blockSize];
;;;443    
;;;444      stgCnt = numStages;
;;;445    
;;;446      /* copy data */
;;;447      while(stgCnt > 0u)
;;;448      {
;;;449        *pStateCurnt++ = *pState++;
;;;450    
;;;451        /* Decrement the loop counter */
;;;452        stgCnt--;
;;;453      }
;;;454    
;;;455    #endif /*   #ifndef ARM_MATH_CM0_FAMILY */
;;;456    
;;;457    }
0001e6  b008              ADD      sp,sp,#0x20
0001e8  e8bd8ff0          POP      {r4-r11,pc}
;;;458    
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\FilteringFunctions\\arm_iir_lattice_q15.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___21_arm_iir_lattice_q15_c_79236d2a____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___21_arm_iir_lattice_q15_c_79236d2a____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___21_arm_iir_lattice_q15_c_79236d2a____REVSH|
#line 144
|__asm___21_arm_iir_lattice_q15_c_79236d2a____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___21_arm_iir_lattice_q15_c_79236d2a____RRX|
#line 300
|__asm___21_arm_iir_lattice_q15_c_79236d2a____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
