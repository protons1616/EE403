; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_conv_q7.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_conv_q7.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_conv_q7.crf src\FilteringFunctions\arm_conv_q7.c]
                          THUMB

                          AREA ||i.arm_conv_q7||, CODE, READONLY, ALIGN=2

                  arm_conv_q7 PROC
;;;75     
;;;76     void arm_conv_q7(
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;77       q7_t * pSrcA,
;;;78       uint32_t srcALen,
;;;79       q7_t * pSrcB,
;;;80       uint32_t srcBLen,
;;;81       q7_t * pDst)
;;;82     {
000004  b099              SUB      sp,sp,#0x64
;;;83     
;;;84     
;;;85     #ifndef ARM_MATH_CM0_FAMILY
;;;86     
;;;87       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;88     
;;;89       q7_t *pIn1;                                    /* inputA pointer */
;;;90       q7_t *pIn2;                                    /* inputB pointer */
;;;91       q7_t *pOut = pDst;                             /* output pointer */
;;;92       q7_t *px;                                      /* Intermediate inputA pointer */
;;;93       q7_t *py;                                      /* Intermediate inputB pointer */
;;;94       q7_t *pSrc1, *pSrc2;                           /* Intermediate pointers */
;;;95       q7_t x0, x1, x2, x3, c0, c1;                   /* Temporary variables to hold state and coefficient values */
;;;96       q31_t sum, acc0, acc1, acc2, acc3;             /* Accumulator */
;;;97       q31_t input1, input2;                          /* Temporary input variables */
;;;98       q15_t in1, in2;                                /* Temporary input variables */
;;;99       uint32_t j, k, count, blkCnt, blockSize1, blockSize2, blockSize3;     /* loop counter */
;;;100    
;;;101      /* The algorithm implementation is based on the lengths of the inputs. */
;;;102      /* srcB is always made to slide across srcA. */
;;;103      /* So srcBLen is always considered as shorter or equal to srcALen */
;;;104      if(srcALen >= srcBLen)
000006  4299              CMP      r1,r3
000008  9c22              LDR      r4,[sp,#0x88]         ;91
00000a  9411              STR      r4,[sp,#0x44]
00000c  d302              BCC      |L1.20|
;;;105      {
;;;106        /* Initialization of inputA pointer */
;;;107        pIn1 = pSrcA;
;;;108    
;;;109        /* Initialization of inputB pointer */
;;;110        pIn2 = pSrcB;
00000e  4691              MOV      r9,r2
000010  900b              STR      r0,[sp,#0x2c]
000012  e004              B        |L1.30|
                  |L1.20|
;;;111      }
;;;112      else
;;;113      {
;;;114        /* Initialization of inputA pointer */
;;;115        pIn1 = pSrcB;
;;;116    
;;;117        /* Initialization of inputB pointer */
;;;118        pIn2 = pSrcA;
000014  4681              MOV      r9,r0
;;;119    
;;;120        /* srcBLen is always considered as shorter or equal to srcALen */
;;;121        j = srcBLen;
000016  4618              MOV      r0,r3
;;;122        srcBLen = srcALen;
000018  460b              MOV      r3,r1
;;;123        srcALen = j;
00001a  4601              MOV      r1,r0
00001c  920b              STR      r2,[sp,#0x2c]
                  |L1.30|
;;;124      }
;;;125    
;;;126      /* conv(x,y) at n = x[n] * y[0] + x[n-1] * y[1] + x[n-2] * y[2] + ...+ x[n-N+1] * y[N -1] */
;;;127      /* The function is internally   
;;;128       * divided into three stages according to the number of multiplications that has to be   
;;;129       * taken place between inputA samples and inputB samples. In the first stage of the   
;;;130       * algorithm, the multiplications increase by one for every iteration.   
;;;131       * In the second stage of the algorithm, srcBLen number of multiplications are done.   
;;;132       * In the third stage of the algorithm, the multiplications decrease by one   
;;;133       * for every iteration. */
;;;134    
;;;135      /* The algorithm is implemented in three stages.   
;;;136         The loop counters of each stage is initiated here. */
;;;137      blockSize1 = srcBLen - 1u;
;;;138      blockSize2 = (srcALen - srcBLen) + 1u;
00001e  1ac8              SUBS     r0,r1,r3
000020  1e5a              SUBS     r2,r3,#1              ;137
000022  9012              STR      r0,[sp,#0x48]
000024  1c40              ADDS     r0,r0,#1
000026  e9cd2013          STRD     r2,r0,[sp,#0x4c]
;;;139      blockSize3 = blockSize1;
;;;140    
;;;141      /* --------------------------   
;;;142       * Initializations of stage1   
;;;143       * -------------------------*/
;;;144    
;;;145      /* sum = x[0] * y[0]   
;;;146       * sum = x[0] * y[1] + x[1] * y[0]   
;;;147       * ....   
;;;148       * sum = x[0] * y[srcBlen - 1] + x[1] * y[srcBlen - 2] +...+ x[srcBLen - 1] * y[0]   
;;;149       */
;;;150    
;;;151      /* In this stage the MAC operations are increased by 1 for every iteration.   
;;;152         The count variable holds the number of MAC operations performed */
;;;153      count = 1u;
00002a  f04f0a01          MOV      r10,#1
;;;154    
;;;155      /* Working pointer of inputA */
;;;156      px = pIn1;
;;;157    
;;;158      /* Working pointer of inputB */
;;;159      py = pIn2;
00002e  4649              MOV      r1,r9
;;;160    
;;;161    
;;;162      /* ------------------------   
;;;163       * Stage1 process   
;;;164       * ----------------------*/
;;;165    
;;;166      /* The first stage starts here */
;;;167      while(blockSize1 > 0u)
000030  980b              LDR      r0,[sp,#0x2c]
000032  e03d              B        |L1.176|
                  |L1.52|
;;;168      {
;;;169        /* Accumulator is made zero for every iteration */
;;;170        sum = 0;
000034  2400              MOVS     r4,#0
;;;171    
;;;172        /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;173        k = count >> 2u;
000036  ea4f079a          LSR      r7,r10,#2
;;;174    
;;;175        /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;176         ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;177        while(k > 0u)
00003a  e01d              B        |L1.120|
                  |L1.60|
;;;178        {
;;;179          /* x[0] , x[1] */
;;;180          in1 = (q15_t) * px++;
00003c  f9105b01          LDRSB    r5,[r0],#1
;;;181          in2 = (q15_t) * px++;
;;;182          input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16u);
;;;183    
;;;184          /* y[srcBLen - 1] , y[srcBLen - 2] */
;;;185          in1 = (q15_t) * py--;
;;;186          in2 = (q15_t) * py--;
000040  f9118c01          LDRSB    r8,[r1,#-1]
000044  f9106b01          LDRSB    r6,[r0],#1            ;181
000048  f366451f          BFI      r5,r6,#16,#16         ;182
00004c  f9916000          LDRSB    r6,[r1,#0]            ;185
;;;187          input2 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16u);
000050  f368461f          BFI      r6,r8,#16,#16
;;;188    
;;;189          /* x[0] * y[srcBLen - 1] */
;;;190          /* x[1] * y[srcBLen - 2] */
;;;191          sum = __SMLAD(input1, input2, sum);
000054  fb254506          SMLAD    r5,r5,r6,r4
;;;192    
;;;193          /* x[2] , x[3] */
;;;194          in1 = (q15_t) * px++;
000058  f9104b02          LDRSB    r4,[r0],#2
;;;195          in2 = (q15_t) * px++;
;;;196          input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16u);
;;;197    
;;;198          /* y[srcBLen - 3] , y[srcBLen - 4] */
;;;199          in1 = (q15_t) * py--;
;;;200          in2 = (q15_t) * py--;
00005c  f911cc03          LDRSB    r12,[r1,#-3]
000060  f9106c01          LDRSB    r6,[r0,#-1]           ;195
000064  f366441f          BFI      r4,r6,#16,#16         ;196
000068  f9116c02          LDRSB    r6,[r1,#-2]           ;199
;;;201          input2 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16u);
00006c  f36c461f          BFI      r6,r12,#16,#16
;;;202    
;;;203          /* x[2] * y[srcBLen - 3] */
;;;204          /* x[3] * y[srcBLen - 4] */
;;;205          sum = __SMLAD(input1, input2, sum);
000070  fb245406          SMLAD    r4,r4,r6,r5
000074  1f09              SUBS     r1,r1,#4
000076  1e7f              SUBS     r7,r7,#1
                  |L1.120|
000078  2f00              CMP      r7,#0                 ;177
00007a  d1df              BNE      |L1.60|
;;;206    
;;;207          /* Decrement the loop counter */
;;;208          k--;
;;;209        }
;;;210    
;;;211        /* If the count is not a multiple of 4, compute any remaining MACs here.   
;;;212         ** No loop unrolling is used. */
;;;213        k = count % 0x4u;
00007c  f00a0503          AND      r5,r10,#3
;;;214    
;;;215        while(k > 0u)
000080  e007              B        |L1.146|
;;;216        {
;;;217          /* Perform the multiply-accumulates */
;;;218          sum += ((q15_t) * px++ * *py--);
000082  bf00              NOP      
                  |L1.132|
000084  f9106b01          LDRSB    r6,[r0],#1
000088  f9117901          LDRSB    r7,[r1],#-1
00008c  fb164407          SMLABB   r4,r6,r7,r4
000090  1e6d              SUBS     r5,r5,#1
                  |L1.146|
000092  2d00              CMP      r5,#0                 ;215
000094  d1f6              BNE      |L1.132|
;;;219    
;;;220          /* Decrement the loop counter */
;;;221          k--;
;;;222        }
;;;223    
;;;224        /* Store the result in the accumulator in the destination buffer. */
;;;225        *pOut++ = (q7_t) (__SSAT(sum >> 7u, 8));
000096  9811              LDR      r0,[sp,#0x44]
000098  f32411c7          SSAT     r1,#8,r4,ASR #7
00009c  7001              STRB     r1,[r0,#0]
00009e  9811              LDR      r0,[sp,#0x44]
;;;226    
;;;227        /* Update the inputA and inputB pointers for next MAC calculation */
;;;228        py = pIn2 + count;
0000a0  eb09010a          ADD      r1,r9,r10
0000a4  1c40              ADDS     r0,r0,#1              ;225
;;;229        px = pIn1;
0000a6  9011              STR      r0,[sp,#0x44]
;;;230    
;;;231        /* Increment the MAC count */
;;;232        count++;
0000a8  980b              LDR      r0,[sp,#0x2c]
0000aa  f10a0a01          ADD      r10,r10,#1
0000ae  1e52              SUBS     r2,r2,#1
                  |L1.176|
0000b0  2a00              CMP      r2,#0                 ;167
0000b2  d1bf              BNE      |L1.52|
;;;233    
;;;234        /* Decrement the loop counter */
;;;235        blockSize1--;
;;;236      }
;;;237    
;;;238      /* --------------------------   
;;;239       * Initializations of stage2   
;;;240       * ------------------------*/
;;;241    
;;;242      /* sum = x[0] * y[srcBLen-1] + x[1] * y[srcBLen-2] +...+ x[srcBLen-1] * y[0]   
;;;243       * sum = x[1] * y[srcBLen-1] + x[2] * y[srcBLen-2] +...+ x[srcBLen] * y[0]   
;;;244       * ....   
;;;245       * sum = x[srcALen-srcBLen-2] * y[srcBLen-1] + x[srcALen] * y[srcBLen-2] +...+ x[srcALen-1] * y[0]   
;;;246       */
;;;247    
;;;248      /* Working pointer of inputA */
;;;249      px = pIn1;
;;;250    
;;;251      /* Working pointer of inputB */
;;;252      pSrc2 = pIn2 + (srcBLen - 1u);
0000b4  eb090103          ADD      r1,r9,r3
0000b8  9117              STR      r1,[sp,#0x5c]
0000ba  1e49              SUBS     r1,r1,#1
;;;253      py = pSrc2;
;;;254    
;;;255      /* count is index by which the pointer pIn1 to be incremented */
;;;256      count = 0u;
;;;257    
;;;258      /* -------------------   
;;;259       * Stage2 process   
;;;260       * ------------------*/
;;;261    
;;;262      /* Stage2 depends on srcBLen as in this stage srcBLen number of MACS are performed.   
;;;263       * So, to loop unroll over blockSize2,   
;;;264       * srcBLen should be greater than or equal to 4 */
;;;265      if(srcBLen >= 4u)
0000bc  9203              STR      r2,[sp,#0xc]
0000be  9115              STR      r1,[sp,#0x54]
0000c0  2b04              CMP      r3,#4
0000c2  d37c              BCC      |L1.446|
;;;266      {
;;;267        /* Loop unroll over blockSize2, by 4 */
;;;268        blkCnt = blockSize2 >> 2u;
0000c4  9a14              LDR      r2,[sp,#0x50]
0000c6  0892              LSRS     r2,r2,#2
;;;269    
;;;270        while(blkCnt > 0u)
0000c8  e08f              B        |L1.490|
;;;271        {
;;;272          /* Set all accumulators to zero */
;;;273          acc0 = 0;
0000ca  bf00              NOP      
                  |L1.204|
;;;274          acc1 = 0;
;;;275          acc2 = 0;
;;;276          acc3 = 0;
;;;277    
;;;278          /* read x[0], x[1], x[2] samples */
;;;279          x0 = *(px++);
0000cc  f9105b01          LDRSB    r5,[r0],#1
0000d0  f04f0c00          MOV      r12,#0                ;273
;;;280          x1 = *(px++);
0000d4  f9104b01          LDRSB    r4,[r0],#1
;;;281          x2 = *(px++);
;;;282    
;;;283          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;284          k = srcBLen >> 2u;
0000d8  089e              LSRS     r6,r3,#2
0000da  f9102b01          LDRSB    r2,[r0],#1            ;281
0000de  46e2              MOV      r10,r12               ;274
0000e0  46e3              MOV      r11,r12               ;275
0000e2  46e0              MOV      r8,r12                ;276
0000e4  f8cd603c          STR.W    r6,[sp,#0x3c]
                  |L1.232|
;;;285    
;;;286          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;287           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;288          do
;;;289          {
;;;290            /* Read y[srcBLen - 1] sample */
;;;291            c0 = *(py--);
0000e8  f9917000          LDRSB    r7,[r1,#0]
;;;292            /* Read y[srcBLen - 2] sample */
;;;293            c1 = *(py--);
0000ec  f9119c01          LDRSB    r9,[r1,#-1]
;;;294    
;;;295            /* Read x[3] sample */
;;;296            x3 = *(px++);
;;;297    
;;;298            /* x[0] and x[1] are packed */
;;;299            in1 = (q15_t) x0;
;;;300            in2 = (q15_t) x1;
;;;301    
;;;302            input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16u);
;;;303    
;;;304            /* y[srcBLen - 1]   and y[srcBLen - 2] are packed */
;;;305            in1 = (q15_t) c0;
;;;306            in2 = (q15_t) c1;
;;;307    
;;;308            input2 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16u);
;;;309    
;;;310            /* acc0 += x[0] * y[srcBLen - 1] + x[1] * y[srcBLen - 2]  */
;;;311            acc0 = __SMLAD(input1, input2, acc0);
;;;312    
;;;313            /* x[1] and x[2] are packed */
;;;314            in1 = (q15_t) x1;
;;;315            in2 = (q15_t) x2;
;;;316    
;;;317            input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16u);
;;;318    
;;;319            /* acc1 += x[1] * y[srcBLen - 1] + x[2] * y[srcBLen - 2]  */
;;;320            acc1 = __SMLAD(input1, input2, acc1);
;;;321    
;;;322            /* x[2] and x[3] are packed */
;;;323            in1 = (q15_t) x2;
;;;324            in2 = (q15_t) x3;
;;;325    
;;;326            input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16u);
;;;327    
;;;328            /* acc2 += x[2] * y[srcBLen - 1] + x[3] * y[srcBLen - 2]  */
;;;329            acc2 = __SMLAD(input1, input2, acc2);
;;;330    
;;;331            /* Read x[4] sample */
;;;332            x0 = *(px++);
;;;333    
;;;334            /* x[3] and x[4] are packed */
;;;335            in1 = (q15_t) x3;
;;;336            in2 = (q15_t) x0;
;;;337    
;;;338            input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16u);
;;;339    
;;;340            /* acc3 += x[3] * y[srcBLen - 1] + x[4] * y[srcBLen - 2]  */
;;;341            acc3 = __SMLAD(input1, input2, acc3);
;;;342    
;;;343            /* Read y[srcBLen - 3] sample */
;;;344            c0 = *(py--);
;;;345            /* Read y[srcBLen - 4] sample */
;;;346            c1 = *(py--);
;;;347    
;;;348            /* Read x[5] sample */
;;;349            x1 = *(px++);
;;;350    
;;;351            /* x[2] and x[3] are packed */
;;;352            in1 = (q15_t) x2;
;;;353            in2 = (q15_t) x3;
;;;354    
;;;355            input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16u);
;;;356    
;;;357            /* y[srcBLen - 3] and y[srcBLen - 4] are packed */
;;;358            in1 = (q15_t) c0;
;;;359            in2 = (q15_t) c1;
;;;360    
;;;361            input2 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16u);
;;;362    
;;;363            /* acc0 += x[2] * y[srcBLen - 3] + x[3] * y[srcBLen - 4]  */
;;;364            acc0 = __SMLAD(input1, input2, acc0);
;;;365    
;;;366            /* x[3] and x[4] are packed */
;;;367            in1 = (q15_t) x3;
;;;368            in2 = (q15_t) x0;
;;;369    
;;;370            input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16u);
;;;371    
;;;372            /* acc1 += x[3] * y[srcBLen - 3] + x[4] * y[srcBLen - 4]  */
;;;373            acc1 = __SMLAD(input1, input2, acc1);
;;;374    
;;;375            /* x[4] and x[5] are packed */
;;;376            in1 = (q15_t) x0;
;;;377            in2 = (q15_t) x1;
;;;378    
;;;379            input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16u);
;;;380    
;;;381            /* acc2 += x[4] * y[srcBLen - 3] + x[5] * y[srcBLen - 4]  */
;;;382            acc2 = __SMLAD(input1, input2, acc2);
;;;383    
;;;384            /* Read x[6] sample */
;;;385            x2 = *(px++);
;;;386    
;;;387            /* x[5] and x[6] are packed */
;;;388            in1 = (q15_t) x1;
;;;389            in2 = (q15_t) x2;
;;;390    
;;;391            input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16u);
;;;392    
;;;393            /* acc3 += x[5] * y[srcBLen - 3] + x[6] * y[srcBLen - 4]  */
;;;394            acc3 = __SMLAD(input1, input2, acc3);
;;;395    
;;;396          } while(--k);
;;;397    
;;;398          /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.   
;;;399           ** No loop unrolling is used. */
;;;400          k = srcBLen % 0x4u;
;;;401    
;;;402          while(k > 0u)
;;;403          {
;;;404            /* Read y[srcBLen - 5] sample */
;;;405            c0 = *(py--);
;;;406    
;;;407            /* Read x[7] sample */
;;;408            x3 = *(px++);
;;;409    
;;;410            /* Perform the multiply-accumulates */
;;;411            /* acc0 +=  x[4] * y[srcBLen - 5] */
;;;412            acc0 += ((q15_t) x0 * c0);
;;;413            /* acc1 +=  x[5] * y[srcBLen - 5] */
;;;414            acc1 += ((q15_t) x1 * c0);
;;;415            /* acc2 +=  x[6] * y[srcBLen - 5] */
;;;416            acc2 += ((q15_t) x2 * c0);
;;;417            /* acc3 +=  x[7] * y[srcBLen - 5] */
;;;418            acc3 += ((q15_t) x3 * c0);
;;;419    
;;;420            /* Reuse the present samples for the next MAC */
;;;421            x0 = x1;
;;;422            x1 = x2;
;;;423            x2 = x3;
;;;424    
;;;425            /* Decrement the loop counter */
;;;426            k--;
;;;427          }
;;;428    
;;;429    
;;;430          /* Store the result in the accumulator in the destination buffer. */
;;;431          *pOut++ = (q7_t) (__SSAT(acc0 >> 7u, 8));
;;;432          *pOut++ = (q7_t) (__SSAT(acc1 >> 7u, 8));
;;;433          *pOut++ = (q7_t) (__SSAT(acc2 >> 7u, 8));
;;;434          *pOut++ = (q7_t) (__SSAT(acc3 >> 7u, 8));
;;;435    
;;;436          /* Increment the pointer pIn1 index, count by 4 */
;;;437          count += 4u;
;;;438    
;;;439          /* Update the inputA and inputB pointers for next MAC calculation */
;;;440          px = pIn1 + count;
;;;441          py = pSrc2;
;;;442    
;;;443          /* Decrement the loop counter */
;;;444          blkCnt--;
;;;445        }
;;;446    
;;;447        /* If the blockSize2 is not a multiple of 4, compute any remaining output samples here.   
;;;448         ** No loop unrolling is used. */
;;;449        blkCnt = blockSize2 % 0x4u;
;;;450    
;;;451        while(blkCnt > 0u)
;;;452        {
;;;453          /* Accumulator is made zero for every iteration */
;;;454          sum = 0;
;;;455    
;;;456          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;457          k = srcBLen >> 2u;
;;;458    
;;;459          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;460           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;461          while(k > 0u)
;;;462          {
;;;463    
;;;464            /* Reading two inputs of SrcA buffer and packing */
;;;465            in1 = (q15_t) * px++;
;;;466            in2 = (q15_t) * px++;
;;;467            input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16u);
;;;468    
;;;469            /* Reading two inputs of SrcB buffer and packing */
;;;470            in1 = (q15_t) * py--;
;;;471            in2 = (q15_t) * py--;
;;;472            input2 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16u);
;;;473    
;;;474            /* Perform the multiply-accumulates */
;;;475            sum = __SMLAD(input1, input2, sum);
;;;476    
;;;477            /* Reading two inputs of SrcA buffer and packing */
;;;478            in1 = (q15_t) * px++;
;;;479            in2 = (q15_t) * px++;
;;;480            input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16u);
;;;481    
;;;482            /* Reading two inputs of SrcB buffer and packing */
;;;483            in1 = (q15_t) * py--;
;;;484            in2 = (q15_t) * py--;
;;;485            input2 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16u);
;;;486    
;;;487            /* Perform the multiply-accumulates */
;;;488            sum = __SMLAD(input1, input2, sum);
;;;489    
;;;490            /* Decrement the loop counter */
;;;491            k--;
;;;492          }
;;;493    
;;;494          /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.   
;;;495           ** No loop unrolling is used. */
;;;496          k = srcBLen % 0x4u;
;;;497    
;;;498          while(k > 0u)
;;;499          {
;;;500            /* Perform the multiply-accumulates */
;;;501            sum += ((q15_t) * px++ * *py--);
;;;502    
;;;503            /* Decrement the loop counter */
;;;504            k--;
;;;505          }
;;;506    
;;;507          /* Store the result in the accumulator in the destination buffer. */
;;;508          *pOut++ = (q7_t) (__SSAT(sum >> 7u, 8));
;;;509    
;;;510          /* Increment the pointer pIn1 index, count by 1 */
;;;511          count++;
;;;512    
;;;513          /* Update the inputA and inputB pointers for next MAC calculation */
;;;514          px = pIn1 + count;
;;;515          py = pSrc2;
;;;516    
;;;517          /* Decrement the loop counter */
;;;518          blkCnt--;
;;;519        }
;;;520      }
;;;521      else
;;;522      {
;;;523        /* If the srcBLen is not a multiple of 4,   
;;;524         * the blockSize2 loop cannot be unrolled by 4 */
;;;525        blkCnt = blockSize2;
;;;526    
;;;527        while(blkCnt > 0u)
;;;528        {
;;;529          /* Accumulator is made zero for every iteration */
;;;530          sum = 0;
;;;531    
;;;532          /* srcBLen number of MACS should be performed */
;;;533          k = srcBLen;
;;;534    
;;;535          while(k > 0u)
;;;536          {
;;;537            /* Perform the multiply-accumulate */
;;;538            sum += ((q15_t) * px++ * *py--);
;;;539    
;;;540            /* Decrement the loop counter */
;;;541            k--;
;;;542          }
;;;543    
;;;544          /* Store the result in the accumulator in the destination buffer. */
;;;545          *pOut++ = (q7_t) (__SSAT(sum >> 7u, 8));
;;;546    
;;;547          /* Increment the MAC count */
;;;548          count++;
;;;549    
;;;550          /* Update the inputA and inputB pointers for next MAC calculation */
;;;551          px = pIn1 + count;
;;;552          py = pSrc2;
;;;553    
;;;554          /* Decrement the loop counter */
;;;555          blkCnt--;
;;;556        }
;;;557      }
;;;558    
;;;559    
;;;560      /* --------------------------   
;;;561       * Initializations of stage3   
;;;562       * -------------------------*/
;;;563    
;;;564      /* sum += x[srcALen-srcBLen+1] * y[srcBLen-1] + x[srcALen-srcBLen+2] * y[srcBLen-2] +...+ x[srcALen-1] * y[1]   
;;;565       * sum += x[srcALen-srcBLen+2] * y[srcBLen-1] + x[srcALen-srcBLen+3] * y[srcBLen-2] +...+ x[srcALen-1] * y[2]   
;;;566       * ....   
;;;567       * sum +=  x[srcALen-2] * y[srcBLen-1] + x[srcALen-1] * y[srcBLen-2]   
;;;568       * sum +=  x[srcALen-1] * y[srcBLen-1]   
;;;569       */
;;;570    
;;;571      /* In this stage the MAC operations are decreased by 1 for every iteration.   
;;;572         The blockSize3 variable holds the number of MAC operations performed */
;;;573    
;;;574      /* Working pointer of inputA */
;;;575      pSrc1 = pIn1 + (srcALen - (srcBLen - 1u));
;;;576      px = pSrc1;
;;;577    
;;;578      /* Working pointer of inputB */
;;;579      pSrc2 = pIn2 + (srcBLen - 1u);
;;;580      py = pSrc2;
;;;581    
;;;582      /* -------------------   
;;;583       * Stage3 process   
;;;584       * ------------------*/
;;;585    
;;;586      while(blockSize3 > 0u)
;;;587      {
;;;588        /* Accumulator is made zero for every iteration */
;;;589        sum = 0;
;;;590    
;;;591        /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;592        k = blockSize3 >> 2u;
;;;593    
;;;594        /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;595         ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;596        while(k > 0u)
;;;597        {
;;;598          /* Reading two inputs, x[srcALen - srcBLen + 1] and x[srcALen - srcBLen + 2] of SrcA buffer and packing */
;;;599          in1 = (q15_t) * px++;
;;;600          in2 = (q15_t) * px++;
;;;601          input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16u);
;;;602    
;;;603          /* Reading two inputs, y[srcBLen - 1] and y[srcBLen - 2] of SrcB buffer and packing */
;;;604          in1 = (q15_t) * py--;
;;;605          in2 = (q15_t) * py--;
;;;606          input2 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16u);
;;;607    
;;;608          /* sum += x[srcALen - srcBLen + 1] * y[srcBLen - 1] */
;;;609          /* sum += x[srcALen - srcBLen + 2] * y[srcBLen - 2] */
;;;610          sum = __SMLAD(input1, input2, sum);
;;;611    
;;;612          /* Reading two inputs, x[srcALen - srcBLen + 3] and x[srcALen - srcBLen + 4] of SrcA buffer and packing */
;;;613          in1 = (q15_t) * px++;
;;;614          in2 = (q15_t) * px++;
;;;615          input1 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16u);
;;;616    
;;;617          /* Reading two inputs, y[srcBLen - 3] and y[srcBLen - 4] of SrcB buffer and packing */
;;;618          in1 = (q15_t) * py--;
;;;619          in2 = (q15_t) * py--;
;;;620          input2 = ((q31_t) in1 & 0x0000FFFF) | ((q31_t) in2 << 16u);
;;;621    
;;;622          /* sum += x[srcALen - srcBLen + 3] * y[srcBLen - 3] */
;;;623          /* sum += x[srcALen - srcBLen + 4] * y[srcBLen - 4] */
;;;624          sum = __SMLAD(input1, input2, sum);
;;;625    
;;;626          /* Decrement the loop counter */
;;;627          k--;
;;;628        }
;;;629    
;;;630        /* If the blockSize3 is not a multiple of 4, compute any remaining MACs here.   
;;;631         ** No loop unrolling is used. */
;;;632        k = blockSize3 % 0x4u;
;;;633    
;;;634        while(k > 0u)
;;;635        {
;;;636          /* Perform the multiply-accumulates */
;;;637          sum += ((q15_t) * px++ * *py--);
;;;638    
;;;639          /* Decrement the loop counter */
;;;640          k--;
;;;641        }
;;;642    
;;;643        /* Store the result in the accumulator in the destination buffer. */
;;;644        *pOut++ = (q7_t) (__SSAT(sum >> 7u, 8));
;;;645    
;;;646        /* Update the inputA and inputB pointers for next MAC calculation */
;;;647        px = ++pSrc1;
;;;648        py = pSrc2;
;;;649    
;;;650        /* Decrement the loop counter */
;;;651        blockSize3--;
;;;652      }
;;;653    
;;;654    #else
;;;655    
;;;656      /* Run the below code for Cortex-M0 */
;;;657    
;;;658      q7_t *pIn1 = pSrcA;                            /* input pointer */
;;;659      q7_t *pIn2 = pSrcB;                            /* coefficient pointer */
;;;660      q31_t sum;                                     /* Accumulator */
;;;661      uint32_t i, j;                                 /* loop counter */
;;;662    
;;;663      /* Loop to calculate output of convolution for output length number of times */
;;;664      for (i = 0; i < (srcALen + srcBLen - 1); i++)
;;;665      {
;;;666        /* Initialize sum with zero to carry on MAC operations */
;;;667        sum = 0;
;;;668    
;;;669        /* Loop to perform MAC operations according to convolution equation */
;;;670        for (j = 0; j <= i; j++)
;;;671        {
;;;672          /* Check the array limitations */
;;;673          if(((i - j) < srcBLen) && (j < srcALen))
;;;674          {
;;;675            /* z[i] += x[i-j] * y[j] */
;;;676            sum += (q15_t) pIn1[j] * (pIn2[i - j]);
;;;677          }
;;;678        }
;;;679    
;;;680        /* Store the output in the destination buffer */
;;;681        pDst[i] = (q7_t) __SSAT((sum >> 7u), 8u);
;;;682      }
;;;683    
;;;684    #endif /*   #ifndef ARM_MATH_CM0_FAMILY        */
;;;685    
;;;686    }
0000f0  f8cd9060          STR      r9,[sp,#0x60]
0000f4  f1a10902          SUB      r9,r1,#2
0000f8  f8cd9028          STR      r9,[sp,#0x28]         ;296
0000fc  f8dd9060          LDR      r9,[sp,#0x60]         ;308
000100  f9106b01          LDRSB    r6,[r0],#1            ;296
000104  4686              MOV      lr,r0                 ;296
000106  f364451f          BFI      r5,r4,#16,#16         ;302
00010a  f369471f          BFI      r7,r9,#16,#16         ;308
00010e  fb25cc07          SMLAD    r12,r5,r7,r12         ;311
000112  f362441f          BFI      r4,r2,#16,#16         ;317
000116  fb24aa07          SMLAD    r10,r4,r7,r10         ;320
00011a  4610              MOV      r0,r2                 ;320
00011c  f366401f          BFI      r0,r6,#16,#16         ;326
000120  fb20bb07          SMLAD    r11,r0,r7,r11         ;329
000124  f8cdc024          STR      r12,[sp,#0x24]        ;332
000128  f99e5000          LDRSB    r5,[lr,#0]            ;332
00012c  4634              MOV      r4,r6                 ;335
00012e  f10e0001          ADD      r0,lr,#1              ;332
000132  f365441f          BFI      r4,r5,#16,#16         ;338
000136  fb248807          SMLAD    r8,r4,r7,r8           ;341
00013a  f8dd9028          LDR      r9,[sp,#0x28]         ;344
00013e  f911cc03          LDRSB    r12,[r1,#-3]          ;346
000142  f9104b01          LDRSB    r4,[r0],#1            ;349
000146  f9997000          LDRSB    r7,[r9,#0]            ;344
00014a  f366421f          BFI      r2,r6,#16,#16         ;355
00014e  f36c471f          BFI      r7,r12,#16,#16        ;361
000152  f8ddc024          LDR      r12,[sp,#0x24]        ;364
000156  fb22cc07          SMLAD    r12,r2,r7,r12         ;364
00015a  f365461f          BFI      r6,r5,#16,#16         ;370
00015e  fb26aa07          SMLAD    r10,r6,r7,r10         ;373
000162  462a              MOV      r2,r5                 ;379
000164  f364421f          BFI      r2,r4,#16,#16         ;379
000168  fb22bb07          SMLAD    r11,r2,r7,r11         ;382
00016c  f9102b01          LDRSB    r2,[r0],#1            ;385
000170  4626              MOV      r6,r4                 ;388
000172  f362461f          BFI      r6,r2,#16,#16         ;391
000176  fb268807          SMLAD    r8,r6,r7,r8           ;394
00017a  9e0f              LDR      r6,[sp,#0x3c]         ;396
00017c  f1a10104          SUB      r1,r1,#4              ;396
000180  1e76              SUBS     r6,r6,#1              ;396
000182  960f              STR      r6,[sp,#0x3c]         ;396
000184  d1b0              BNE      |L1.232|
000186  f0030603          AND      r6,r3,#3              ;400
00018a  e010              B        |L1.430|
                  |L1.396|
00018c  f9116901          LDRSB    r6,[r1],#-1           ;405
000190  f9107b01          LDRSB    r7,[r0],#1            ;408
000194  fb05cc06          MLA      r12,r5,r6,r12         ;412
000198  fb04aa06          MLA      r10,r4,r6,r10         ;414
00019c  fb12bb06          SMLABB   r11,r2,r6,r11         ;416
0001a0  fb178806          SMLABB   r8,r7,r6,r8           ;418
0001a4  4625              MOV      r5,r4                 ;421
0001a6  4614              MOV      r4,r2                 ;422
0001a8  463a              MOV      r2,r7                 ;423
0001aa  f1a90601          SUB      r6,r9,#1              ;426
                  |L1.430|
0001ae  ea5f0906          MOVS     r9,r6                 ;400
0001b2  d1eb              BNE      |L1.396|
0001b4  9811              LDR      r0,[sp,#0x44]         ;431
0001b6  f32c11c7          SSAT     r1,#8,r12,ASR #7      ;431
0001ba  7001              STRB     r1,[r0,#0]            ;431
0001bc  e000              B        |L1.448|
                  |L1.446|
0001be  e05e              B        |L1.638|
                  |L1.448|
0001c0  9811              LDR      r0,[sp,#0x44]         ;432
0001c2  f32a11c7          SSAT     r1,#8,r10,ASR #7      ;432
0001c6  7041              STRB     r1,[r0,#1]            ;432
0001c8  f32b11c7          SSAT     r1,#8,r11,ASR #7      ;433
0001cc  7081              STRB     r1,[r0,#2]            ;433
0001ce  f32811c7          SSAT     r1,#8,r8,ASR #7       ;434
0001d2  70c1              STRB     r1,[r0,#3]            ;434
0001d4  1d00              ADDS     r0,r0,#4              ;434
0001d6  9011              STR      r0,[sp,#0x44]         ;437
0001d8  9803              LDR      r0,[sp,#0xc]          ;437
0001da  1d00              ADDS     r0,r0,#4              ;437
0001dc  9003              STR      r0,[sp,#0xc]          ;440
0001de  9903              LDR      r1,[sp,#0xc]          ;440
0001e0  980b              LDR      r0,[sp,#0x2c]         ;440
0001e2  4408              ADD      r0,r0,r1              ;440
0001e4  e9dd1215          LDRD     r1,r2,[sp,#0x54]      ;440
0001e8  1e52              SUBS     r2,r2,#1              ;440
                  |L1.490|
0001ea  9216              STR      r2,[sp,#0x58]         ;268
0001ec  2a00              CMP      r2,#0                 ;268
0001ee  f47faf6d          BNE      |L1.204|
0001f2  9a14              LDR      r2,[sp,#0x50]         ;449
0001f4  f0020703          AND      r7,r2,#3              ;449
0001f8  e03e              B        |L1.632|
                  |L1.506|
0001fa  2200              MOVS     r2,#0                 ;454
0001fc  089e              LSRS     r6,r3,#2              ;457
0001fe  e01d              B        |L1.572|
                  |L1.512|
000200  f9104b01          LDRSB    r4,[r0],#1            ;465
000204  f9118c01          LDRSB    r8,[r1,#-1]           ;471
000208  f9105b01          LDRSB    r5,[r0],#1            ;466
00020c  f365441f          BFI      r4,r5,#16,#16         ;467
000210  f9915000          LDRSB    r5,[r1,#0]            ;470
000214  f368451f          BFI      r5,r8,#16,#16         ;472
000218  fb242405          SMLAD    r4,r4,r5,r2           ;475
00021c  f9102b02          LDRSB    r2,[r0],#2            ;478
000220  f911cc03          LDRSB    r12,[r1,#-3]          ;484
000224  f9105c01          LDRSB    r5,[r0,#-1]           ;479
000228  f365421f          BFI      r2,r5,#16,#16         ;480
00022c  f9115c02          LDRSB    r5,[r1,#-2]           ;483
000230  f36c451f          BFI      r5,r12,#16,#16        ;485
000234  fb224205          SMLAD    r2,r2,r5,r4           ;488
000238  1f09              SUBS     r1,r1,#4              ;488
00023a  1e76              SUBS     r6,r6,#1              ;488
                  |L1.572|
00023c  2e00              CMP      r6,#0                 ;461
00023e  d1df              BNE      |L1.512|
000240  f0030403          AND      r4,r3,#3              ;496
000244  e007              B        |L1.598|
000246  bf00              NOP                            ;501
                  |L1.584|
000248  f9105b01          LDRSB    r5,[r0],#1            ;501
00024c  f9116901          LDRSB    r6,[r1],#-1           ;501
000250  fb152206          SMLABB   r2,r5,r6,r2           ;501
000254  1e64              SUBS     r4,r4,#1              ;501
                  |L1.598|
000256  2c00              CMP      r4,#0                 ;498
000258  d1f6              BNE      |L1.584|
00025a  9811              LDR      r0,[sp,#0x44]         ;508
00025c  f32211c7          SSAT     r1,#8,r2,ASR #7       ;508
000260  7001              STRB     r1,[r0,#0]            ;508
000262  9811              LDR      r0,[sp,#0x44]         ;508
000264  1c40              ADDS     r0,r0,#1              ;508
000266  9011              STR      r0,[sp,#0x44]         ;511
000268  9803              LDR      r0,[sp,#0xc]          ;511
00026a  1c40              ADDS     r0,r0,#1              ;511
00026c  9003              STR      r0,[sp,#0xc]          ;514
00026e  9903              LDR      r1,[sp,#0xc]          ;514
000270  980b              LDR      r0,[sp,#0x2c]         ;514
000272  1e7f              SUBS     r7,r7,#1              ;515
000274  4408              ADD      r0,r0,r1              ;514
000276  9915              LDR      r1,[sp,#0x54]         ;515
                  |L1.632|
000278  2f00              CMP      r7,#0                 ;451
00027a  d1be              BNE      |L1.506|
00027c  e01e              B        |L1.700|
                  |L1.638|
00027e  9c14              LDR      r4,[sp,#0x50]         ;527
000280  e01a              B        |L1.696|
                  |L1.642|
000282  2500              MOVS     r5,#0                 ;530
000284  461a              MOV      r2,r3                 ;533
000286  e006              B        |L1.662|
                  |L1.648|
000288  f9106b01          LDRSB    r6,[r0],#1            ;538
00028c  f9117901          LDRSB    r7,[r1],#-1           ;538
000290  fb165507          SMLABB   r5,r6,r7,r5           ;538
000294  1e52              SUBS     r2,r2,#1              ;538
                  |L1.662|
000296  2a00              CMP      r2,#0                 ;535
000298  d1f6              BNE      |L1.648|
00029a  9811              LDR      r0,[sp,#0x44]         ;545
00029c  f32511c7          SSAT     r1,#8,r5,ASR #7       ;545
0002a0  7001              STRB     r1,[r0,#0]            ;545
0002a2  9811              LDR      r0,[sp,#0x44]         ;545
0002a4  1c40              ADDS     r0,r0,#1              ;545
0002a6  9011              STR      r0,[sp,#0x44]         ;548
0002a8  9803              LDR      r0,[sp,#0xc]          ;548
0002aa  1c40              ADDS     r0,r0,#1              ;548
0002ac  9003              STR      r0,[sp,#0xc]          ;551
0002ae  9903              LDR      r1,[sp,#0xc]          ;551
0002b0  980b              LDR      r0,[sp,#0x2c]         ;551
0002b2  1e64              SUBS     r4,r4,#1              ;552
0002b4  4408              ADD      r0,r0,r1              ;551
0002b6  9915              LDR      r1,[sp,#0x54]         ;552
                  |L1.696|
0002b8  2c00              CMP      r4,#0                 ;527
0002ba  d1e2              BNE      |L1.642|
                  |L1.700|
0002bc  990b              LDR      r1,[sp,#0x2c]         ;575
0002be  9812              LDR      r0,[sp,#0x48]         ;575
0002c0  9c17              LDR      r4,[sp,#0x5c]         ;576
0002c2  1843              ADDS     r3,r0,r1              ;575
0002c4  1c5b              ADDS     r3,r3,#1              ;575
0002c6  1e64              SUBS     r4,r4,#1              ;576
0002c8  4618              MOV      r0,r3                 ;576
0002ca  4621              MOV      r1,r4                 ;580
0002cc  9a13              LDR      r2,[sp,#0x4c]         ;586
0002ce  e03d              B        |L1.844|
                  |L1.720|
0002d0  9d13              LDR      r5,[sp,#0x4c]         ;592
0002d2  2200              MOVS     r2,#0                 ;589
0002d4  08ae              LSRS     r6,r5,#2              ;592
0002d6  e01d              B        |L1.788|
                  |L1.728|
0002d8  f9105b01          LDRSB    r5,[r0],#1            ;599
0002dc  f991c000          LDRSB    r12,[r1,#0]           ;604
0002e0  f9107b01          LDRSB    r7,[r0],#1            ;600
0002e4  f9118c01          LDRSB    r8,[r1,#-1]           ;605
0002e8  f367451f          BFI      r5,r7,#16,#16         ;601
0002ec  f3684c1f          BFI      r12,r8,#16,#16        ;606
0002f0  fb25250c          SMLAD    r5,r5,r12,r2          ;610
0002f4  f9102b02          LDRSB    r2,[r0],#2            ;613
0002f8  f9117c02          LDRSB    r7,[r1,#-2]           ;618
0002fc  f910cc01          LDRSB    r12,[r0,#-1]          ;614
000300  f36c421f          BFI      r2,r12,#16,#16        ;615
000304  f911cc03          LDRSB    r12,[r1,#-3]          ;619
000308  f36c471f          BFI      r7,r12,#16,#16        ;620
00030c  fb225207          SMLAD    r2,r2,r7,r5           ;624
000310  1f09              SUBS     r1,r1,#4              ;624
000312  1e76              SUBS     r6,r6,#1              ;624
                  |L1.788|
000314  2e00              CMP      r6,#0                 ;596
000316  d1df              BNE      |L1.728|
000318  9d13              LDR      r5,[sp,#0x4c]         ;632
00031a  f0050503          AND      r5,r5,#3              ;632
00031e  e006              B        |L1.814|
                  |L1.800|
000320  f9106b01          LDRSB    r6,[r0],#1            ;637
000324  f9117901          LDRSB    r7,[r1],#-1           ;637
000328  fb162207          SMLABB   r2,r6,r7,r2           ;637
00032c  1e6d              SUBS     r5,r5,#1              ;637
                  |L1.814|
00032e  2d00              CMP      r5,#0                 ;634
000330  d1f6              BNE      |L1.800|
000332  9811              LDR      r0,[sp,#0x44]         ;644
000334  f32211c7          SSAT     r1,#8,r2,ASR #7       ;644
000338  7001              STRB     r1,[r0,#0]            ;644
00033a  9811              LDR      r0,[sp,#0x44]         ;644
00033c  9a13              LDR      r2,[sp,#0x4c]         ;651
00033e  1c40              ADDS     r0,r0,#1              ;644
000340  9011              STR      r0,[sp,#0x44]         ;647
000342  1c58              ADDS     r0,r3,#1              ;647
000344  1e52              SUBS     r2,r2,#1              ;651
000346  4603              MOV      r3,r0                 ;647
000348  4621              MOV      r1,r4                 ;648
00034a  9213              STR      r2,[sp,#0x4c]         ;651
                  |L1.844|
00034c  2a00              CMP      r2,#0                 ;586
00034e  d1bf              BNE      |L1.720|
000350  b019              ADD      sp,sp,#0x64
000352  e8bd8ff0          POP      {r4-r11,pc}
;;;687    
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\FilteringFunctions\\arm_conv_q7.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_arm_conv_q7_c_eb987386____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___13_arm_conv_q7_c_eb987386____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_arm_conv_q7_c_eb987386____REVSH|
#line 144
|__asm___13_arm_conv_q7_c_eb987386____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___13_arm_conv_q7_c_eb987386____RRX|
#line 300
|__asm___13_arm_conv_q7_c_eb987386____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
