; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_fir_sparse_q31.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_fir_sparse_q31.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_fir_sparse_q31.crf src\FilteringFunctions\arm_fir_sparse_q31.c]
                          THUMB

                          AREA ||i.arm_circularRead_f32||, CODE, READONLY, ALIGN=2

                  arm_circularRead_f32 PROC
;;;6193      */
;;;6194     static __INLINE void arm_circularRead_f32(
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;6195     int32_t * circBuffer,
;;;6196     int32_t L,
;;;6197     int32_t * readOffset,
;;;6198     int32_t bufferInc,
;;;6199     int32_t * dst,
;;;6200     int32_t * dst_base,
;;;6201     int32_t dst_length,
;;;6202     int32_t dstInc,
;;;6203     uint32_t blockSize)
;;;6204     {
000004  ac07              ADD      r4,sp,#0x1c
000006  e9dd960a          LDRD     r9,r6,[sp,#0x28]
00000a  e89410a0          LDM      r4,{r5,r7,r12}
00000e  6814              LDR      r4,[r2,#0]
;;;6205       uint32_t i = 0u;
;;;6206       int32_t rOffset, dst_end;
;;;6207   
;;;6208       /* Copy the value of Index pointer that points
;;;6209        * to the current location from where the input samples to be read */
;;;6210       rOffset = *readOffset;
;;;6211       dst_end = (int32_t) (dst_base + dst_length);
000010  eb070c8c          ADD      r12,r7,r12,LSL #2
000014  e00e              B        |L1.52|
;;;6212   
;;;6213       /* Loop over the blockSize */
;;;6214       i = blockSize;
;;;6215   
;;;6216       while(i > 0u)
;;;6217       {
;;;6218         /* copy the sample from the circular buffer to the destination buffer */
;;;6219         *dst = circBuffer[rOffset];
000016  bf00              NOP      
                  |L1.24|
000018  f8508024          LDR      r8,[r0,r4,LSL #2]
;;;6220   
;;;6221         /* Update the input pointer */
;;;6222         dst += dstInc;
00001c  f8c58000          STR      r8,[r5,#0]
000020  eb050589          ADD      r5,r5,r9,LSL #2
;;;6223   
;;;6224         if(dst == (int32_t *) dst_end)
000024  4565              CMP      r5,r12
000026  d100              BNE      |L1.42|
;;;6225         {
;;;6226           dst = dst_base;
000028  463d              MOV      r5,r7
                  |L1.42|
;;;6227         }
;;;6228   
;;;6229         /* Circularly update rOffset.  Watch out for positive and negative value  */
;;;6230         rOffset += bufferInc;
00002a  441c              ADD      r4,r4,r3
;;;6231   
;;;6232         if(rOffset >= L)
00002c  428c              CMP      r4,r1
00002e  db00              BLT      |L1.50|
;;;6233         {
;;;6234           rOffset -= L;
000030  1a64              SUBS     r4,r4,r1
                  |L1.50|
000032  1e76              SUBS     r6,r6,#1
                  |L1.52|
000034  2e00              CMP      r6,#0                 ;6216
000036  d1ef              BNE      |L1.24|
;;;6235         }
;;;6236   
;;;6237         /* Decrement the loop counter */
;;;6238         i--;
;;;6239       }
;;;6240   
;;;6241       /* Update the index pointer */
;;;6242       *readOffset = rOffset;
000038  6014              STR      r4,[r2,#0]
;;;6243     }
00003a  e8bd83f0          POP      {r4-r9,pc}
;;;6244   
                          ENDP


                          AREA ||i.arm_fir_sparse_q31||, CODE, READONLY, ALIGN=1

                  arm_fir_sparse_q31 PROC
;;;65     
;;;66     void arm_fir_sparse_q31(
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;67       arm_fir_sparse_instance_q31 * S,
;;;68       q31_t * pSrc,
;;;69       q31_t * pDst,
;;;70       q31_t * pScratchIn,
;;;71       uint32_t blockSize)
;;;72     {
000004  4606              MOV      r6,r0
000006  b08b              SUB      sp,sp,#0x2c
000008  4693              MOV      r11,r2
;;;73     
;;;74       q31_t *pState = S->pState;                     /* State pointer */
00000a  9d14              LDR      r5,[sp,#0x50]
;;;75       q31_t *pCoeffs = S->pCoeffs;                   /* Coefficient pointer */
00000c  e9d09001          LDRD     r9,r0,[r0,#4]
;;;76       q31_t *px;                                     /* Scratch buffer pointer */
;;;77       q31_t *py = pState;                            /* Temporary pointers for state buffer */
;;;78       q31_t *pb = pScratchIn;                        /* Temporary pointers for scratch buffer */
;;;79       q31_t *pOut;                                   /* Destination pointer */
;;;80       q63_t out;                                     /* Temporary output variable */
;;;81       int32_t *pTapDelay = S->pTapDelay;             /* Pointer to the array containing offset of the non-zero tap values. */
;;;82       uint32_t delaySize = S->maxDelay + blockSize;  /* state length */
000010  89b2              LDRH     r2,[r6,#0xc]
;;;83       uint16_t numTaps = S->numTaps;                 /* Filter order */
000012  f8d6e010          LDR      lr,[r6,#0x10]
000016  eb020a05          ADD      r10,r2,r5             ;82
00001a  8832              LDRH     r2,[r6,#0]
;;;84       int32_t readIndex;                             /* Read index of the state buffer */
;;;85       uint32_t tapCnt, blkCnt;                       /* loop counters */
;;;86       q31_t coeff = *pCoeffs++;                      /* Read the first coefficient value */
00001c  9209              STR      r2,[sp,#0x24]
00001e  c880              LDM      r0!,{r7}
;;;87       q31_t in;
;;;88     
;;;89     
;;;90       /* BlockSize of Input samples are copied into the state buffer */
;;;91       /* StateIndex points to the starting position to write in the state buffer */
;;;92       arm_circularWrite_f32((int32_t *) py, delaySize, &S->stateIndex, 1,
000020  9008              STR      r0,[sp,#0x20]
000022  2001              MOVS     r0,#1
000024  9001              STR      r0,[sp,#4]
000026  9000              STR      r0,[sp,#0]
000028  46cc              MOV      r12,r9                ;77
00002a  461c              MOV      r4,r3                 ;78
00002c  f1060802          ADD      r8,r6,#2
000030  8870              LDRH     r0,[r6,#2]
000032  462a              MOV      r2,r5
000034  e00c              B        |L2.80|
                  |L2.54|
000036  680b              LDR      r3,[r1,#0]            ;72
000038  f84c3020          STR      r3,[r12,r0,LSL #2]    ;72
00003c  9b00              LDR      r3,[sp,#0]            ;72
00003e  eb010183          ADD      r1,r1,r3,LSL #2       ;72
000042  9b01              LDR      r3,[sp,#4]            ;72
000044  4418              ADD      r0,r0,r3              ;72
000046  4550              CMP      r0,r10                ;72
000048  db01              BLT      |L2.78|
00004a  eba0000a          SUB      r0,r0,r10             ;72
                  |L2.78|
00004e  1e52              SUBS     r2,r2,#1              ;72
                  |L2.80|
000050  2a00              CMP      r2,#0                 ;72
000052  d1f0              BNE      |L2.54|
000054  f8a80000          STRH     r0,[r8,#0]            ;72
;;;93                             (int32_t *) pSrc, 1, blockSize);
;;;94     
;;;95       /* Read Index, from where the state buffer should be read, is calculated. */
;;;96       readIndex = (int32_t) (S->stateIndex - blockSize) - *pTapDelay++;
000058  8870              LDRH     r0,[r6,#2]
00005a  f10e0804          ADD      r8,lr,#4
00005e  1b41              SUBS     r1,r0,r5
000060  f8de0000          LDR      r0,[lr,#0]
000064  1a08              SUBS     r0,r1,r0
;;;97     
;;;98       /* Wraparound of readIndex */
;;;99       if(readIndex < 0)
000066  9005              STR      r0,[sp,#0x14]
000068  d501              BPL      |L2.110|
;;;100      {
;;;101        readIndex += (int32_t) delaySize;
00006a  4450              ADD      r0,r0,r10
00006c  9005              STR      r0,[sp,#0x14]
                  |L2.110|
;;;102      }
;;;103    
;;;104      /* Working pointer for state buffer is updated */
;;;105      py = pState;
;;;106    
;;;107      /* blockSize samples are read from the state buffer */
;;;108      arm_circularRead_f32((int32_t *) py, delaySize, &readIndex, 1,
00006e  2101              MOVS     r1,#1
000070  e9cd5102          STRD     r5,r1,[sp,#8]
000074  460b              MOV      r3,r1
000076  4660              MOV      r0,r12                ;105
000078  9401              STR      r4,[sp,#4]
00007a  aa05              ADD      r2,sp,#0x14
00007c  4651              MOV      r1,r10
00007e  9504              STR      r5,[sp,#0x10]
000080  9400              STR      r4,[sp,#0]
000082  f7fffffe          BL       arm_circularRead_f32
;;;109                           (int32_t *) pb, (int32_t *) pb, blockSize, 1,
;;;110                           blockSize);
;;;111    
;;;112      /* Working pointer for the scratch buffer of state values */
;;;113      px = pb;
;;;114    
;;;115      /* Working pointer for scratch buffer of output values */
;;;116      pOut = pDst;
;;;117    
;;;118    
;;;119    #ifndef ARM_MATH_CM0_FAMILY
;;;120    
;;;121      /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;122    
;;;123      /* Loop over the blockSize. Unroll by a factor of 4.    
;;;124       * Compute 4 Multiplications at a time. */
;;;125      blkCnt = blockSize >> 2;
000086  08aa              LSRS     r2,r5,#2
000088  4620              MOV      r0,r4                 ;113
00008a  4659              MOV      r1,r11                ;116
;;;126    
;;;127      while(blkCnt > 0u)
00008c  9207              STR      r2,[sp,#0x1c]
00008e  e014              B        |L2.186|
                  |L2.144|
;;;128      {
;;;129        /* Perform Multiplications and store in the destination buffer */
;;;130        *pOut++ = (q31_t) (((q63_t) * px++ * coeff) >> 32);
000090  c808              LDM      r0!,{r3}
000092  fb53f307          SMMUL    r3,r3,r7
000096  c108              STM      r1!,{r3}
;;;131        *pOut++ = (q31_t) (((q63_t) * px++ * coeff) >> 32);
000098  c808              LDM      r0!,{r3}
00009a  fb53f307          SMMUL    r3,r3,r7
00009e  c108              STM      r1!,{r3}
;;;132        *pOut++ = (q31_t) (((q63_t) * px++ * coeff) >> 32);
0000a0  f8503b08          LDR      r3,[r0],#8
0000a4  fb53f307          SMMUL    r3,r3,r7
0000a8  f8413b08          STR      r3,[r1],#8
;;;133        *pOut++ = (q31_t) (((q63_t) * px++ * coeff) >> 32);
0000ac  f8503c04          LDR      r3,[r0,#-4]
0000b0  fb53f307          SMMUL    r3,r3,r7
0000b4  f8413c04          STR      r3,[r1,#-4]
0000b8  1e52              SUBS     r2,r2,#1
                  |L2.186|
0000ba  2a00              CMP      r2,#0                 ;127
0000bc  d1e8              BNE      |L2.144|
;;;134    
;;;135        /* Decrement the loop counter */
;;;136        blkCnt--;
;;;137      }
;;;138    
;;;139      /* If the blockSize is not a multiple of 4,    
;;;140       * compute the remaining samples */
;;;141      blkCnt = blockSize % 0x4u;
0000be  f0050203          AND      r2,r5,#3
;;;142    
;;;143      while(blkCnt > 0u)
0000c2  9206              STR      r2,[sp,#0x18]
0000c4  e004              B        |L2.208|
                  |L2.198|
;;;144      {
;;;145        /* Perform Multiplications and store in the destination buffer */
;;;146        *pOut++ = (q31_t) (((q63_t) * px++ * coeff) >> 32);
0000c6  c808              LDM      r0!,{r3}
0000c8  fb53f307          SMMUL    r3,r3,r7
0000cc  c108              STM      r1!,{r3}
0000ce  1e52              SUBS     r2,r2,#1
                  |L2.208|
0000d0  2a00              CMP      r2,#0                 ;143
0000d2  d1f8              BNE      |L2.198|
;;;147    
;;;148        /* Decrement the loop counter */
;;;149        blkCnt--;
;;;150      }
;;;151    
;;;152      /* Load the coefficient value and    
;;;153       * increment the coefficient buffer for the next set of state values */
;;;154      coeff = *pCoeffs++;
0000d4  9808              LDR      r0,[sp,#0x20]
0000d6  c880              LDM      r0!,{r7}
;;;155    
;;;156      /* Read Index, from where the state buffer should be read, is calculated. */
;;;157      readIndex = (int32_t) (S->stateIndex - blockSize) - *pTapDelay++;
0000d8  9008              STR      r0,[sp,#0x20]
0000da  8870              LDRH     r0,[r6,#2]
0000dc  1b41              SUBS     r1,r0,r5
0000de  f8d80000          LDR      r0,[r8,#0]
0000e2  1a08              SUBS     r0,r1,r0
0000e4  f1080104          ADD      r1,r8,#4
;;;158    
;;;159      /* Wraparound of readIndex */
;;;160      if(readIndex < 0)
0000e8  910a              STR      r1,[sp,#0x28]
0000ea  9005              STR      r0,[sp,#0x14]
0000ec  d501              BPL      |L2.242|
;;;161      {
;;;162        readIndex += (int32_t) delaySize;
0000ee  4450              ADD      r0,r0,r10
0000f0  9005              STR      r0,[sp,#0x14]
                  |L2.242|
;;;163      }
;;;164    
;;;165      /* Loop over the number of taps. */
;;;166      tapCnt = (uint32_t) numTaps - 2u;
0000f2  9809              LDR      r0,[sp,#0x24]
0000f4  1e80              SUBS     r0,r0,#2
;;;167    
;;;168      while(tapCnt > 0u)
0000f6  e04c              B        |L2.402|
                  |L2.248|
;;;169      {
;;;170        /* Working pointer for state buffer is updated */
;;;171        py = pState;
;;;172    
;;;173        /* blockSize samples are read from the state buffer */
;;;174        arm_circularRead_f32((int32_t *) py, delaySize, &readIndex, 1,
0000f8  f7fffffe          BL       arm_circularRead_f32
;;;175                             (int32_t *) pb, (int32_t *) pb, blockSize, 1,
;;;176                             blockSize);
;;;177    
;;;178        /* Working pointer for the scratch buffer of state values */
;;;179        px = pb;
0000fc  4621              MOV      r1,r4
;;;180    
;;;181        /* Working pointer for scratch buffer of output values */
;;;182        pOut = pDst;
0000fe  4658              MOV      r0,r11
;;;183    
;;;184        /* Loop over the blockSize. Unroll by a factor of 4.    
;;;185         * Compute 4 MACS at a time. */
;;;186        blkCnt = blockSize >> 2;
;;;187    
;;;188        while(blkCnt > 0u)
000100  9a07              LDR      r2,[sp,#0x1c]
000102  e023              B        |L2.332|
                  |L2.260|
;;;189        {
;;;190          out = *pOut;
;;;191          out += ((q63_t) * px++ * coeff) >> 32;
000104  f851cb04          LDR      r12,[r1],#4
000108  6803              LDR      r3,[r0,#0]
00010a  fb8c8c07          SMULL    r8,r12,r12,r7
00010e  eb1c0303          ADDS     r3,r12,r3
;;;192          *pOut++ = (q31_t) (out);
;;;193    
;;;194          out = *pOut;
000112  6003              STR      r3,[r0,#0]
;;;195          out += ((q63_t) * px++ * coeff) >> 32;
000114  f851cb04          LDR      r12,[r1],#4
000118  6843              LDR      r3,[r0,#4]
00011a  fb8c8c07          SMULL    r8,r12,r12,r7
00011e  eb1c0303          ADDS     r3,r12,r3
;;;196          *pOut++ = (q31_t) (out);
;;;197    
;;;198          out = *pOut;
000122  6043              STR      r3,[r0,#4]
;;;199          out += ((q63_t) * px++ * coeff) >> 32;
000124  f851cb04          LDR      r12,[r1],#4
000128  6883              LDR      r3,[r0,#8]
00012a  fb8c8c07          SMULL    r8,r12,r12,r7
00012e  eb1c0303          ADDS     r3,r12,r3
;;;200          *pOut++ = (q31_t) (out);
;;;201    
;;;202          out = *pOut;
000132  6083              STR      r3,[r0,#8]
;;;203          out += ((q63_t) * px++ * coeff) >> 32;
000134  f851cb04          LDR      r12,[r1],#4
000138  68c3              LDR      r3,[r0,#0xc]
00013a  fb8c8c07          SMULL    r8,r12,r12,r7
00013e  eb1c0303          ADDS     r3,r12,r3
;;;204          *pOut++ = (q31_t) (out);
000142  60c3              STR      r3,[r0,#0xc]
000144  f1000010          ADD      r0,r0,#0x10
000148  f1a20201          SUB      r2,r2,#1
                  |L2.332|
00014c  2a00              CMP      r2,#0                 ;188
00014e  d1d9              BNE      |L2.260|
;;;205    
;;;206          /* Decrement the loop counter */
;;;207          blkCnt--;
;;;208        }
;;;209    
;;;210        /* If the blockSize is not a multiple of 4,    
;;;211         * compute the remaining samples */
;;;212        blkCnt = blockSize % 0x4u;
;;;213    
;;;214        while(blkCnt > 0u)
000150  9a06              LDR      r2,[sp,#0x18]
000152  e009              B        |L2.360|
                  |L2.340|
;;;215        {
;;;216          /* Perform Multiply-Accumulate */
;;;217          out = *pOut;
;;;218          out += ((q63_t) * px++ * coeff) >> 32;
000154  f851cb04          LDR      r12,[r1],#4
000158  6803              LDR      r3,[r0,#0]
00015a  fb8c8c07          SMULL    r8,r12,r12,r7
00015e  eb1c0303          ADDS     r3,r12,r3
;;;219          *pOut++ = (q31_t) (out);
000162  c008              STM      r0!,{r3}
000164  f1a20201          SUB      r2,r2,#1
                  |L2.360|
000168  2a00              CMP      r2,#0                 ;214
00016a  d1f3              BNE      |L2.340|
;;;220    
;;;221          /* Decrement the loop counter */
;;;222          blkCnt--;
;;;223        }
;;;224    
;;;225        /* Load the coefficient value and    
;;;226         * increment the coefficient buffer for the next set of state values */
;;;227        coeff = *pCoeffs++;
00016c  9808              LDR      r0,[sp,#0x20]
00016e  c880              LDM      r0!,{r7}
;;;228    
;;;229        /* Read Index, from where the state buffer should be read, is calculated. */
;;;230        readIndex = (int32_t) (S->stateIndex - blockSize) - *pTapDelay++;
000170  9008              STR      r0,[sp,#0x20]
000172  8870              LDRH     r0,[r6,#2]
000174  eba00105          SUB      r1,r0,r5
000178  980a              LDR      r0,[sp,#0x28]
00017a  6800              LDR      r0,[r0,#0]
00017c  1a08              SUBS     r0,r1,r0
00017e  9005              STR      r0,[sp,#0x14]
000180  990a              LDR      r1,[sp,#0x28]
000182  f1010104          ADD      r1,r1,#4
;;;231    
;;;232        /* Wraparound of readIndex */
;;;233        if(readIndex < 0)
000186  910a              STR      r1,[sp,#0x28]
000188  d501              BPL      |L2.398|
;;;234        {
;;;235          readIndex += (int32_t) delaySize;
00018a  4450              ADD      r0,r0,r10
00018c  9005              STR      r0,[sp,#0x14]
                  |L2.398|
;;;236        }
;;;237    
;;;238        /* Decrement the tap loop counter */
;;;239        tapCnt--;
00018e  9809              LDR      r0,[sp,#0x24]
000190  1e40              SUBS     r0,r0,#1
                  |L2.402|
;;;240      }
;;;241    	
;;;242    	/* Compute last tap without the final read of pTapDelay */
;;;243    	
;;;244    	/* Working pointer for state buffer is updated */
;;;245    	py = pState;
;;;246    
;;;247    	/* blockSize samples are read from the state buffer */
;;;248    	arm_circularRead_f32((int32_t *) py, delaySize, &readIndex, 1,
000192  f04f0101          MOV      r1,#1
000196  e9cd5102          STRD     r5,r1,[sp,#8]
00019a  9009              STR      r0,[sp,#0x24]         ;168
00019c  2800              CMP      r0,#0                 ;168
00019e  460b              MOV      r3,r1
0001a0  4648              MOV      r0,r9                 ;245
0001a2  9401              STR      r4,[sp,#4]
0001a4  aa05              ADD      r2,sp,#0x14
0001a6  4651              MOV      r1,r10
0001a8  9504              STR      r5,[sp,#0x10]
0001aa  9400              STR      r4,[sp,#0]
0001ac  d1a4              BNE      |L2.248|
0001ae  f7fffffe          BL       arm_circularRead_f32
;;;249    											 (int32_t *) pb, (int32_t *) pb, blockSize, 1,
;;;250    											 blockSize);
;;;251    
;;;252    	/* Working pointer for the scratch buffer of state values */
;;;253    	px = pb;
;;;254    
;;;255    	/* Working pointer for scratch buffer of output values */
;;;256    	pOut = pDst;
0001b2  4658              MOV      r0,r11
;;;257    
;;;258    	/* Loop over the blockSize. Unroll by a factor of 4.    
;;;259    	 * Compute 4 MACS at a time. */
;;;260    	blkCnt = blockSize >> 2;
;;;261    
;;;262    	while(blkCnt > 0u)
0001b4  9907              LDR      r1,[sp,#0x1c]
0001b6  e01d              B        |L2.500|
                  |L2.440|
;;;263    	{
;;;264    		out = *pOut;
;;;265    		out += ((q63_t) * px++ * coeff) >> 32;
0001b8  6823              LDR      r3,[r4,#0]
0001ba  6802              LDR      r2,[r0,#0]
0001bc  fb835307          SMULL    r5,r3,r3,r7
0001c0  189a              ADDS     r2,r3,r2
;;;266    		*pOut++ = (q31_t) (out);
;;;267    
;;;268    		out = *pOut;
0001c2  6002              STR      r2,[r0,#0]
;;;269    		out += ((q63_t) * px++ * coeff) >> 32;
0001c4  6863              LDR      r3,[r4,#4]
0001c6  6842              LDR      r2,[r0,#4]
0001c8  fb835307          SMULL    r5,r3,r3,r7
0001cc  189a              ADDS     r2,r3,r2
;;;270    		*pOut++ = (q31_t) (out);
;;;271    
;;;272    		out = *pOut;
0001ce  6042              STR      r2,[r0,#4]
;;;273    		out += ((q63_t) * px++ * coeff) >> 32;
0001d0  68a3              LDR      r3,[r4,#8]
0001d2  6882              LDR      r2,[r0,#8]
0001d4  fb835307          SMULL    r5,r3,r3,r7
0001d8  189a              ADDS     r2,r3,r2
;;;274    		*pOut++ = (q31_t) (out);
;;;275    
;;;276    		out = *pOut;
0001da  6082              STR      r2,[r0,#8]
;;;277    		out += ((q63_t) * px++ * coeff) >> 32;
0001dc  68e3              LDR      r3,[r4,#0xc]
0001de  68c2              LDR      r2,[r0,#0xc]
0001e0  fb835307          SMULL    r5,r3,r3,r7
0001e4  189a              ADDS     r2,r3,r2
;;;278    		*pOut++ = (q31_t) (out);
0001e6  60c2              STR      r2,[r0,#0xc]
0001e8  f1040410          ADD      r4,r4,#0x10           ;277
0001ec  f1000010          ADD      r0,r0,#0x10
0001f0  f1a10101          SUB      r1,r1,#1
                  |L2.500|
0001f4  2900              CMP      r1,#0                 ;262
0001f6  d1df              BNE      |L2.440|
;;;279    
;;;280    		/* Decrement the loop counter */
;;;281    		blkCnt--;
;;;282    	}
;;;283    
;;;284    	/* If the blockSize is not a multiple of 4,    
;;;285    	 * compute the remaining samples */
;;;286    	blkCnt = blockSize % 0x4u;
;;;287    
;;;288    	while(blkCnt > 0u)
0001f8  9a06              LDR      r2,[sp,#0x18]
0001fa  e007              B        |L2.524|
                  |L2.508|
;;;289    	{
;;;290    		/* Perform Multiply-Accumulate */
;;;291    		out = *pOut;
;;;292    		out += ((q63_t) * px++ * coeff) >> 32;
0001fc  cc08              LDM      r4!,{r3}
0001fe  6801              LDR      r1,[r0,#0]
000200  fb835307          SMULL    r5,r3,r3,r7
000204  1859              ADDS     r1,r3,r1
;;;293    		*pOut++ = (q31_t) (out);
000206  c002              STM      r0!,{r1}
000208  f1a20201          SUB      r2,r2,#1
                  |L2.524|
00020c  2a00              CMP      r2,#0                 ;288
00020e  d1f5              BNE      |L2.508|
;;;294    
;;;295    		/* Decrement the loop counter */
;;;296    		blkCnt--;
;;;297    	}	
;;;298    
;;;299      /* Working output pointer is updated */
;;;300      pOut = pDst;
000210  4658              MOV      r0,r11
;;;301    
;;;302      /* Output is converted into 1.31 format. */
;;;303      /* Loop over the blockSize. Unroll by a factor of 4.    
;;;304       * process 4 output samples at a time. */
;;;305      blkCnt = blockSize >> 2;
;;;306    
;;;307      while(blkCnt > 0u)
000212  9907              LDR      r1,[sp,#0x1c]
000214  e011              B        |L2.570|
                  |L2.534|
;;;308      {
;;;309        in = *pOut << 1;
000216  6802              LDR      r2,[r0,#0]
000218  0052              LSLS     r2,r2,#1
;;;310        *pOut++ = in;
00021a  c004              STM      r0!,{r2}
;;;311        in = *pOut << 1;
00021c  c804              LDM      r0!,{r2}
00021e  0052              LSLS     r2,r2,#1
;;;312        *pOut++ = in;
000220  f8402c04          STR      r2,[r0,#-4]
;;;313        in = *pOut << 1;
000224  f8502b08          LDR      r2,[r0],#8
000228  0052              LSLS     r2,r2,#1
;;;314        *pOut++ = in;
00022a  f8402c08          STR      r2,[r0,#-8]
;;;315        in = *pOut << 1;
00022e  f8502c04          LDR      r2,[r0,#-4]
000232  0052              LSLS     r2,r2,#1
;;;316        *pOut++ = in;
000234  f8402c04          STR      r2,[r0,#-4]
000238  1e49              SUBS     r1,r1,#1
                  |L2.570|
00023a  2900              CMP      r1,#0                 ;307
00023c  d1eb              BNE      |L2.534|
;;;317    
;;;318        /* Decrement the loop counter */
;;;319        blkCnt--;
;;;320      }
;;;321    
;;;322      /* If the blockSize is not a multiple of 4,    
;;;323       * process the remaining output samples */
;;;324      blkCnt = blockSize % 0x4u;
;;;325    
;;;326      while(blkCnt > 0u)
00023e  9906              LDR      r1,[sp,#0x18]
000240  e003              B        |L2.586|
                  |L2.578|
;;;327      {
;;;328        in = *pOut << 1;
000242  6802              LDR      r2,[r0,#0]
000244  0052              LSLS     r2,r2,#1
;;;329        *pOut++ = in;
000246  c004              STM      r0!,{r2}
000248  1e49              SUBS     r1,r1,#1
                  |L2.586|
00024a  2900              CMP      r1,#0                 ;326
00024c  d1f9              BNE      |L2.578|
;;;330    
;;;331        /* Decrement the loop counter */
;;;332        blkCnt--;
;;;333      }
;;;334    
;;;335    #else
;;;336    
;;;337      /* Run the below code for Cortex-M0 */
;;;338      blkCnt = blockSize;
;;;339    
;;;340      while(blkCnt > 0u)
;;;341      {
;;;342        /* Perform Multiplications and store in the destination buffer */
;;;343        *pOut++ = (q31_t) (((q63_t) * px++ * coeff) >> 32);
;;;344    
;;;345        /* Decrement the loop counter */
;;;346        blkCnt--;
;;;347      }
;;;348    
;;;349      /* Load the coefficient value and           
;;;350       * increment the coefficient buffer for the next set of state values */
;;;351      coeff = *pCoeffs++;
;;;352    
;;;353      /* Read Index, from where the state buffer should be read, is calculated. */
;;;354      readIndex = (int32_t) (S->stateIndex - blockSize) - *pTapDelay++;
;;;355    
;;;356      /* Wraparound of readIndex */
;;;357      if(readIndex < 0)
;;;358      {
;;;359        readIndex += (int32_t) delaySize;
;;;360      }
;;;361    
;;;362      /* Loop over the number of taps. */
;;;363      tapCnt = (uint32_t) numTaps - 2u;
;;;364    
;;;365      while(tapCnt > 0u)
;;;366      {
;;;367        /* Working pointer for state buffer is updated */
;;;368        py = pState;
;;;369    
;;;370        /* blockSize samples are read from the state buffer */
;;;371        arm_circularRead_f32((int32_t *) py, delaySize, &readIndex, 1,
;;;372                             (int32_t *) pb, (int32_t *) pb, blockSize, 1,
;;;373                             blockSize);
;;;374    
;;;375        /* Working pointer for the scratch buffer of state values */
;;;376        px = pb;
;;;377    
;;;378        /* Working pointer for scratch buffer of output values */
;;;379        pOut = pDst;
;;;380    
;;;381        blkCnt = blockSize;
;;;382    
;;;383        while(blkCnt > 0u)
;;;384        {
;;;385          /* Perform Multiply-Accumulate */
;;;386          out = *pOut;
;;;387          out += ((q63_t) * px++ * coeff) >> 32;
;;;388          *pOut++ = (q31_t) (out);
;;;389    
;;;390          /* Decrement the loop counter */
;;;391          blkCnt--;
;;;392        }
;;;393    
;;;394        /* Load the coefficient value and           
;;;395         * increment the coefficient buffer for the next set of state values */
;;;396        coeff = *pCoeffs++;
;;;397    
;;;398        /* Read Index, from where the state buffer should be read, is calculated. */
;;;399        readIndex = (int32_t) (S->stateIndex - blockSize) - *pTapDelay++;
;;;400    
;;;401        /* Wraparound of readIndex */
;;;402        if(readIndex < 0)
;;;403        {
;;;404          readIndex += (int32_t) delaySize;
;;;405        }
;;;406    
;;;407        /* Decrement the tap loop counter */
;;;408        tapCnt--;
;;;409      }
;;;410    	
;;;411    	/* Compute last tap without the final read of pTapDelay */	
;;;412    	
;;;413    	/* Working pointer for state buffer is updated */
;;;414    	py = pState;
;;;415    
;;;416    	/* blockSize samples are read from the state buffer */
;;;417    	arm_circularRead_f32((int32_t *) py, delaySize, &readIndex, 1,
;;;418    											 (int32_t *) pb, (int32_t *) pb, blockSize, 1,
;;;419    											 blockSize);
;;;420    
;;;421    	/* Working pointer for the scratch buffer of state values */
;;;422    	px = pb;
;;;423    
;;;424    	/* Working pointer for scratch buffer of output values */
;;;425    	pOut = pDst;
;;;426    
;;;427    	blkCnt = blockSize;
;;;428    
;;;429    	while(blkCnt > 0u)
;;;430    	{
;;;431    		/* Perform Multiply-Accumulate */
;;;432    		out = *pOut;
;;;433    		out += ((q63_t) * px++ * coeff) >> 32;
;;;434    		*pOut++ = (q31_t) (out);
;;;435    
;;;436    		/* Decrement the loop counter */
;;;437    		blkCnt--;
;;;438    	}
;;;439    
;;;440      /* Working output pointer is updated */
;;;441      pOut = pDst;
;;;442    
;;;443      /* Output is converted into 1.31 format. */
;;;444      blkCnt = blockSize;
;;;445    
;;;446      while(blkCnt > 0u)
;;;447      {
;;;448        in = *pOut << 1;
;;;449        *pOut++ = in;
;;;450    
;;;451        /* Decrement the loop counter */
;;;452        blkCnt--;
;;;453      }
;;;454    
;;;455    #endif /*   #ifndef ARM_MATH_CM0_FAMILY */
;;;456    
;;;457    }
00024e  b00b              ADD      sp,sp,#0x2c
000250  e8bd8ff0          POP      {r4-r11,pc}
;;;458    
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\FilteringFunctions\\arm_fir_sparse_q31.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___20_arm_fir_sparse_q31_c_deb9463b____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___20_arm_fir_sparse_q31_c_deb9463b____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___20_arm_fir_sparse_q31_c_deb9463b____REVSH|
#line 144
|__asm___20_arm_fir_sparse_q31_c_deb9463b____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___20_arm_fir_sparse_q31_c_deb9463b____RRX|
#line 300
|__asm___20_arm_fir_sparse_q31_c_deb9463b____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
