; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_correlate_q15.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_correlate_q15.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_correlate_q15.crf src\FilteringFunctions\arm_correlate_q15.c]
                          THUMB

                          AREA ||i.arm_correlate_q15||, CODE, READONLY, ALIGN=2

                  arm_correlate_q15 PROC
;;;78     
;;;79     void arm_correlate_q15(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;80       q15_t * pSrcA,
;;;81       uint32_t srcALen,
;;;82       q15_t * pSrcB,
;;;83       uint32_t srcBLen,
;;;84       q15_t * pDst)
;;;85     {
000004  b09c              SUB      sp,sp,#0x70
;;;86     
;;;87     #if (defined(ARM_MATH_CM4) || defined(ARM_MATH_CM3)) && !defined(UNALIGNED_SUPPORT_DISABLE)
;;;88     
;;;89       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;90     
;;;91       q15_t *pIn1;                                   /* inputA pointer               */
;;;92       q15_t *pIn2;                                   /* inputB pointer               */
;;;93       q15_t *pOut = pDst;                            /* output pointer               */
;;;94       q63_t sum, acc0, acc1, acc2, acc3;             /* Accumulators                  */
;;;95       q15_t *px;                                     /* Intermediate inputA pointer  */
;;;96       q15_t *py;                                     /* Intermediate inputB pointer  */
;;;97       q15_t *pSrc1;                                  /* Intermediate pointers        */
;;;98       q31_t x0, x1, x2, x3, c0;                      /* temporary variables for holding input and coefficient values */
;;;99       uint32_t j, k = 0u, count, blkCnt, outBlockSize, blockSize1, blockSize2, blockSize3;  /* loop counter                 */
;;;100      int32_t inc = 1;                               /* Destination address modifier */
000006  2401              MOVS     r4,#1
;;;101    
;;;102    
;;;103      /* The algorithm implementation is based on the lengths of the inputs. */
;;;104      /* srcB is always made to slide across srcA. */
;;;105      /* So srcBLen is always considered as shorter or equal to srcALen */
;;;106      /* But CORR(x, y) is reverse of CORR(y, x) */
;;;107      /* So, when srcBLen > srcALen, output pointer is made to point to the end of the output buffer */
;;;108      /* and the destination pointer modifier, inc is set to -1 */
;;;109      /* If srcALen > srcBLen, zero pad has to be done to srcB to make the two inputs of same length */
;;;110      /* But to improve the performance,   
;;;111       * we include zeroes in the output instead of zero padding either of the the inputs*/
;;;112      /* If srcALen > srcBLen,   
;;;113       * (srcALen - srcBLen) zeroes has to included in the starting of the output buffer */
;;;114      /* If srcALen < srcBLen,   
;;;115       * (srcALen - srcBLen) zeroes has to included in the ending of the output buffer */
;;;116      if(srcALen >= srcBLen)
000008  940e              STR      r4,[sp,#0x38]
00000a  9d1d              LDR      r5,[sp,#0x74]
00000c  9929              LDR      r1,[sp,#0xa4]         ;100
;;;117      {
;;;118        /* Initialization of inputA pointer */
;;;119        pIn1 = (pSrcA);
;;;120    
;;;121        /* Initialization of inputB pointer */
;;;122        pIn2 = (pSrcB);
;;;123    
;;;124        /* Number of output samples is calculated */
;;;125        outBlockSize = (2u * srcALen) - 1u;
00000e  1ea4              SUBS     r4,r4,#2
000010  429d              CMP      r5,r3                 ;116
000012  d30a              BCC      |L1.42|
000014  9219              STR      r2,[sp,#0x64]
000016  9014              STR      r0,[sp,#0x50]
000018  eb040045          ADD      r0,r4,r5,LSL #1
;;;126    
;;;127        /* When srcALen > srcBLen, zero padding is done to srcB   
;;;128         * to make their lengths equal.   
;;;129         * Instead, (outBlockSize - (srcALen + srcBLen - 1))   
;;;130         * number of output samples are made zero */
;;;131        j = outBlockSize - (srcALen + (srcBLen - 1u));
00001c  18ea              ADDS     r2,r5,r3
00001e  1a80              SUBS     r0,r0,r2
000020  1c40              ADDS     r0,r0,#1
;;;132    
;;;133        /* Updating the pointer position to non zero value */
;;;134        pOut += j;
000022  eb010040          ADD      r0,r1,r0,LSL #1
000026  900d              STR      r0,[sp,#0x34]
000028  e00a              B        |L1.64|
                  |L1.42|
;;;135    
;;;136      }
;;;137      else
;;;138      {
;;;139        /* Initialization of inputA pointer */
;;;140        pIn1 = (pSrcB);
;;;141    
;;;142        /* Initialization of inputB pointer */
;;;143        pIn2 = (pSrcA);
;;;144    
;;;145        /* srcBLen is always considered as shorter or equal to srcALen */
;;;146        j = srcBLen;
00002a  9214              STR      r2,[sp,#0x50]
00002c  9019              STR      r0,[sp,#0x64]
00002e  4618              MOV      r0,r3
;;;147        srcBLen = srcALen;
000030  462b              MOV      r3,r5
;;;148        srcALen = j;
;;;149    
;;;150        /* CORR(x, y) = Reverse order(CORR(y, x)) */
;;;151        /* Hence set the destination pointer to point to the last output sample */
;;;152        pOut = pDst + ((srcALen + srcBLen) - 2u);
000032  901d              STR      r0,[sp,#0x74]
000034  4418              ADD      r0,r0,r3
000036  eb010040          ADD      r0,r1,r0,LSL #1
00003a  1f00              SUBS     r0,r0,#4
00003c  e9cd040d          STRD     r0,r4,[sp,#0x34]
                  |L1.64|
;;;153    
;;;154        /* Destination address modifier is set to -1 */
;;;155        inc = -1;
;;;156    
;;;157      }
;;;158    
;;;159      /* The function is internally   
;;;160       * divided into three parts according to the number of multiplications that has to be   
;;;161       * taken place between inputA samples and inputB samples. In the first part of the   
;;;162       * algorithm, the multiplications increase by one for every iteration.   
;;;163       * In the second part of the algorithm, srcBLen number of multiplications are done.   
;;;164       * In the third part of the algorithm, the multiplications decrease by one   
;;;165       * for every iteration.*/
;;;166      /* The algorithm is implemented in three stages.   
;;;167       * The loop counters of each stage is initiated here. */
;;;168      blockSize1 = srcBLen - 1u;
;;;169      blockSize2 = srcALen - (srcBLen - 1u);
000040  981d              LDR      r0,[sp,#0x74]
000042  1e5d              SUBS     r5,r3,#1              ;168
000044  1ac0              SUBS     r0,r0,r3
;;;170      blockSize3 = blockSize1;
;;;171    
;;;172      /* --------------------------   
;;;173       * Initializations of stage1   
;;;174       * -------------------------*/
;;;175    
;;;176      /* sum = x[0] * y[srcBlen - 1]   
;;;177       * sum = x[0] * y[srcBlen - 2] + x[1] * y[srcBlen - 1]   
;;;178       * ....   
;;;179       * sum = x[0] * y[0] + x[1] * y[1] +...+ x[srcBLen - 1] * y[srcBLen - 1]   
;;;180       */
;;;181    
;;;182      /* In this stage the MAC operations are increased by 1 for every iteration.   
;;;183         The count variable holds the number of MAC operations performed */
;;;184      count = 1u;
000046  1c40              ADDS     r0,r0,#1
000048  e9cd501a          STRD     r5,r0,[sp,#0x68]
;;;185    
;;;186      /* Working pointer of inputA */
;;;187      px = pIn1;
;;;188    
;;;189      /* Working pointer of inputB */
;;;190      pSrc1 = pIn2 + (srcBLen - 1u);
00004c  9819              LDR      r0,[sp,#0x64]
00004e  2601              MOVS     r6,#1                 ;184
000050  eb000443          ADD      r4,r0,r3,LSL #1
000054  1ea4              SUBS     r4,r4,#2
000056  46a1              MOV      r9,r4
;;;191      py = pSrc1;
;;;192    
;;;193      /* ------------------------   
;;;194       * Stage1 process   
;;;195       * ----------------------*/
;;;196    
;;;197      /* The first loop starts here */
;;;198      while(blockSize1 > 0u)
000058  9a14              LDR      r2,[sp,#0x50]
00005a  e02f              B        |L1.188|
                  |L1.92|
00005c  2000              MOVS     r0,#0
00005e  4601              MOV      r1,r0
;;;199      {
;;;200        /* Accumulator is made zero for every iteration */
;;;201        sum = 0;
;;;202    
;;;203        /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;204        k = count >> 2;
000060  08b7              LSRS     r7,r6,#2
;;;205    
;;;206        /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;207         ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;208        while(k > 0u)
000062  e00c              B        |L1.126|
                  |L1.100|
;;;209        {
;;;210          /* x[0] * y[srcBLen - 4] , x[1] * y[srcBLen - 3] */
;;;211          sum = __SMLALD(*__SIMD32(px)++, *__SIMD32(py)++, sum);
000064  f8528b04          LDR      r8,[r2],#4
000068  f854cb04          LDR      r12,[r4],#4
00006c  fbc801cc          SMLALD   r0,r1,r8,r12
;;;212          /* x[3] * y[srcBLen - 1] , x[2] * y[srcBLen - 2] */
;;;213          sum = __SMLALD(*__SIMD32(px)++, *__SIMD32(py)++, sum);
000070  f8528b04          LDR      r8,[r2],#4
000074  f854cb04          LDR      r12,[r4],#4
000078  fbc801cc          SMLALD   r0,r1,r8,r12
00007c  1e7f              SUBS     r7,r7,#1
                  |L1.126|
00007e  2f00              CMP      r7,#0                 ;208
000080  d1f0              BNE      |L1.100|
;;;214    
;;;215          /* Decrement the loop counter */
;;;216          k--;
;;;217        }
;;;218    
;;;219        /* If the count is not a multiple of 4, compute any remaining MACs here.   
;;;220         ** No loop unrolling is used. */
;;;221        k = count % 0x4u;
000082  f0060703          AND      r7,r6,#3
;;;222    
;;;223        while(k > 0u)
000086  e006              B        |L1.150|
                  |L1.136|
;;;224        {
;;;225          /* Perform the multiply-accumulates */
;;;226          /* x[0] * y[srcBLen - 1] */
;;;227          sum = __SMLALD(*px++, *py++, sum);
000088  f9328b02          LDRSH    r8,[r2],#2
00008c  f934cb02          LDRSH    r12,[r4],#2
000090  fbc801cc          SMLALD   r0,r1,r8,r12
000094  1e7f              SUBS     r7,r7,#1
                  |L1.150|
000096  2f00              CMP      r7,#0                 ;223
000098  d1f6              BNE      |L1.136|
;;;228    
;;;229          /* Decrement the loop counter */
;;;230          k--;
;;;231        }
;;;232    
;;;233        /* Store the result in the accumulator in the destination buffer. */
;;;234        *pOut = (q15_t) (__SSAT((sum >> 15), 16));
00009a  0bc0              LSRS     r0,r0,#15
00009c  ea404041          ORR      r0,r0,r1,LSL #17
0000a0  f300010f          SSAT     r1,#16,r0
0000a4  980d              LDR      r0,[sp,#0x34]
;;;235        /* Destination pointer is updated according to the address modifier, inc */
;;;236        pOut += inc;
;;;237    
;;;238        /* Update the inputA and inputB pointers for next MAC calculation */
;;;239        py = pSrc1 - count;
0000a6  eba90446          SUB      r4,r9,r6,LSL #1
;;;240        px = pIn1;
0000aa  1e6d              SUBS     r5,r5,#1
0000ac  8001              STRH     r1,[r0,#0]            ;234
0000ae  e9dd100d          LDRD     r1,r0,[sp,#0x34]      ;234
0000b2  eb010040          ADD      r0,r1,r0,LSL #1       ;236
0000b6  9a14              LDR      r2,[sp,#0x50]
0000b8  900d              STR      r0,[sp,#0x34]
0000ba  1c76              ADDS     r6,r6,#1
                  |L1.188|
0000bc  2d00              CMP      r5,#0                 ;198
0000be  d1cd              BNE      |L1.92|
;;;241    
;;;242        /* Increment the MAC count */
;;;243        count++;
;;;244    
;;;245        /* Decrement the loop counter */
;;;246        blockSize1--;
;;;247      }
;;;248    
;;;249      /* --------------------------   
;;;250       * Initializations of stage2   
;;;251       * ------------------------*/
;;;252    
;;;253      /* sum = x[0] * y[0] + x[1] * y[1] +...+ x[srcBLen-1] * y[srcBLen-1]   
;;;254       * sum = x[1] * y[0] + x[2] * y[1] +...+ x[srcBLen] * y[srcBLen-1]   
;;;255       * ....   
;;;256       * sum = x[srcALen-srcBLen-2] * y[0] + x[srcALen-srcBLen-1] * y[1] +...+ x[srcALen-1] * y[srcBLen-1]   
;;;257       */
;;;258    
;;;259      /* Working pointer of inputA */
;;;260      px = pIn1;
;;;261    
;;;262      /* Working pointer of inputB */
;;;263      py = pIn2;
;;;264    
;;;265      /* count is index by which the pointer pIn1 to be incremented */
;;;266      count = 0u;
0000c0  2000              MOVS     r0,#0
0000c2  f8dd9064          LDR      r9,[sp,#0x64]
;;;267    
;;;268      /* -------------------   
;;;269       * Stage2 process   
;;;270       * ------------------*/
;;;271    
;;;272      /* Stage2 depends on srcBLen as in this stage srcBLen number of MACS are performed.   
;;;273       * So, to loop unroll over blockSize2,   
;;;274       * srcBLen should be greater than or equal to 4, to loop unroll the srcBLen loop */
;;;275      if(srcBLen >= 4u)
0000c6  900f              STR      r0,[sp,#0x3c]
0000c8  2b04              CMP      r3,#4
0000ca  d37d              BCC      |L1.456|
;;;276      {
;;;277        /* Loop unroll over blockSize2, by 4 */
;;;278        blkCnt = blockSize2 >> 2u;
0000cc  981b              LDR      r0,[sp,#0x6c]
0000ce  0880              LSRS     r0,r0,#2
;;;279    
;;;280        while(blkCnt > 0u)
0000d0  e0f2              B        |L1.696|
                  |L1.210|
0000d2  2100              MOVS     r1,#0
;;;281        {
;;;282          /* Set all accumulators to zero */
;;;283          acc0 = 0;
;;;284          acc1 = 0;
0000d4  910a              STR      r1,[sp,#0x28]
;;;285          acc2 = 0;
;;;286          acc3 = 0;
;;;287    
;;;288          /* read x[0], x[1] samples */
;;;289          x0 = *__SIMD32(px);
0000d6  9112              STR      r1,[sp,#0x48]
0000d8  f8527b02          LDR      r7,[r2],#2
;;;290          /* read x[1], x[2] samples */
;;;291          x1 = _SIMD32_OFFSET(px + 1);
;;;292    	  px += 2u;
;;;293    
;;;294          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;295          k = srcBLen >> 2u;
0000dc  089d              LSRS     r5,r3,#2
0000de  f8524b02          LDR      r4,[r2],#2            ;291
0000e2  468b              MOV      r11,r1                ;283
0000e4  4688              MOV      r8,r1                 ;283
0000e6  468e              MOV      lr,r1                 ;285
0000e8  468a              MOV      r10,r1                ;285
0000ea  4608              MOV      r0,r1                 ;285
0000ec  f8cd5014          STR.W    r5,[sp,#0x14]
                  |L1.240|
;;;296    
;;;297          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;298           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;299          do
;;;300          {
;;;301            /* Read the first two inputB samples using SIMD:   
;;;302             * y[0] and y[1] */
;;;303            c0 = *__SIMD32(py)++;
0000f0  f859cb04          LDR      r12,[r9],#4
;;;304    
;;;305            /* acc0 +=  x[0] * y[0] + x[1] * y[1] */
;;;306            acc0 = __SMLALD(x0, c0, acc0);
0000f4  9d0a              LDR      r5,[sp,#0x28]
0000f6  465e              MOV      r6,r11
0000f8  fbc756cc          SMLALD   r5,r6,r7,r12
0000fc  46ab              MOV      r11,r5
;;;307    
;;;308            /* acc1 +=  x[1] * y[0] + x[2] * y[1] */
;;;309            acc1 = __SMLALD(x1, c0, acc1);
0000fe  9d12              LDR      r5,[sp,#0x48]
000100  960b              STR      r6,[sp,#0x2c]
000102  fbc485cc          SMLALD   r8,r5,r4,r12
;;;310    
;;;311            /* Read x[2], x[3] */
;;;312            x2 = *__SIMD32(px);
000106  9512              STR      r5,[sp,#0x48]
000108  f8527b02          LDR      r7,[r2],#2
;;;313    
;;;314            /* Read x[3], x[4] */
;;;315            x3 = _SIMD32_OFFSET(px + 1);
;;;316    
;;;317            /* acc2 +=  x[2] * y[0] + x[3] * y[1] */
;;;318            acc2 = __SMLALD(x2, c0, acc2);
00010c  4675              MOV      r5,lr
00010e  f8524b02          LDR      r4,[r2],#2            ;315
000112  4656              MOV      r6,r10
000114  fbc756cc          SMLALD   r5,r6,r7,r12
000118  46aa              MOV      r10,r5
00011a  46b6              MOV      lr,r6
;;;319    
;;;320            /* acc3 +=  x[3] * y[0] + x[4] * y[1] */
;;;321            acc3 = __SMLALD(x3, c0, acc3);
00011c  fbc401cc          SMLALD   r0,r1,r4,r12
;;;322    
;;;323            /* Read y[2] and y[3] */
;;;324            c0 = *__SIMD32(py)++;
000120  f859cb04          LDR      r12,[r9],#4
;;;325    
;;;326            /* acc0 +=  x[2] * y[2] + x[3] * y[3] */
;;;327            acc0 = __SMLALD(x2, c0, acc0);
000124  9e0b              LDR      r6,[sp,#0x2c]
000126  465d              MOV      r5,r11
000128  fbc756cc          SMLALD   r5,r6,r7,r12
;;;328    
;;;329            /* acc1 +=  x[3] * y[2] + x[4] * y[3] */
;;;330            acc1 = __SMLALD(x3, c0, acc1);
00012c  950a              STR      r5,[sp,#0x28]
00012e  9d12              LDR      r5,[sp,#0x48]
000130  46b3              MOV      r11,r6                ;327
000132  fbc485cc          SMLALD   r8,r5,r4,r12
;;;331    
;;;332            /* Read x[4], x[5] */
;;;333            x0 = _SIMD32_OFFSET(px + 2);
000136  9512              STR      r5,[sp,#0x48]
000138  f8527b04          LDR      r7,[r2],#4
;;;334    
;;;335            /* Read x[5], x[6] */
;;;336            x1 = _SIMD32_OFFSET(px + 3);
;;;337    
;;;338    		px += 4u;
;;;339    
;;;340            /* acc2 +=  x[4] * y[2] + x[5] * y[3] */
;;;341            acc2 = __SMLALD(x0, c0, acc2);
00013c  4655              MOV      r5,r10
00013e  f8524c02          LDR      r4,[r2,#-2]           ;336
000142  4676              MOV      r6,lr
000144  fbc756cc          SMLALD   r5,r6,r7,r12
000148  46ae              MOV      lr,r5
00014a  46b2              MOV      r10,r6
;;;342    
;;;343            /* acc3 +=  x[5] * y[2] + x[6] * y[3] */
;;;344            acc3 = __SMLALD(x1, c0, acc3);
00014c  fbc401cc          SMLALD   r0,r1,r4,r12
;;;345    
;;;346          } while(--k);
000150  9d05              LDR      r5,[sp,#0x14]
000152  1e6d              SUBS     r5,r5,#1
000154  9505              STR      r5,[sp,#0x14]
000156  d1cb              BNE      |L1.240|
;;;347    
;;;348          /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.   
;;;349           ** No loop unrolling is used. */
;;;350          k = srcBLen % 0x4u;
000158  f0030503          AND      r5,r3,#3
;;;351    
;;;352          if(k == 1u)
00015c  2d01              CMP      r5,#1
00015e  d004              BEQ      |L1.362|
;;;353          {
;;;354            /* Read y[4] */
;;;355            c0 = *py;
;;;356    #ifdef  ARM_MATH_BIG_ENDIAN
;;;357    
;;;358            c0 = c0 << 16u;
;;;359    
;;;360    #else
;;;361    
;;;362            c0 = c0 & 0x0000FFFF;
;;;363    
;;;364    #endif /*      #ifdef  ARM_MATH_BIG_ENDIAN     */
;;;365            /* Read x[7] */
;;;366            x3 = *__SIMD32(px);
;;;367    		px++;
;;;368    
;;;369            /* Perform the multiply-accumulates */
;;;370            acc0 = __SMLALD(x0, c0, acc0);
;;;371            acc1 = __SMLALD(x1, c0, acc1);
;;;372            acc2 = __SMLALDX(x1, c0, acc2);
;;;373            acc3 = __SMLALDX(x3, c0, acc3);
;;;374          }
;;;375    
;;;376          if(k == 2u)
000160  2d02              CMP      r5,#2
000162  d01a              BEQ      |L1.410|
;;;377          {
;;;378            /* Read y[4], y[5] */
;;;379            c0 = *__SIMD32(py);
;;;380    
;;;381            /* Read x[7], x[8] */
;;;382            x3 = *__SIMD32(px);
;;;383    
;;;384            /* Read x[9] */
;;;385            x2 = _SIMD32_OFFSET(px + 1);
;;;386    		px += 2u;
;;;387    
;;;388            /* Perform the multiply-accumulates */
;;;389            acc0 = __SMLALD(x0, c0, acc0);
;;;390            acc1 = __SMLALD(x1, c0, acc1);
;;;391            acc2 = __SMLALD(x3, c0, acc2);
;;;392            acc3 = __SMLALD(x2, c0, acc3);
;;;393          }
;;;394    
;;;395          if(k == 3u)
000164  2d03              CMP      r5,#3
000166  d033              BEQ      |L1.464|
000168  e071              B        |L1.590|
                  |L1.362|
00016a  f8b95000          LDRH     r5,[r9,#0]            ;355
00016e  f8d2c000          LDR      r12,[r2,#0]           ;366
000172  9a0a              LDR      r2,[sp,#0x28]         ;370
000174  b2ad              UXTH     r5,r5                 ;362
000176  465e              MOV      r6,r11                ;370
000178  fbc726c5          SMLALD   r2,r6,r7,r5           ;370
00017c  920a              STR      r2,[sp,#0x28]         ;371
00017e  9a12              LDR      r2,[sp,#0x48]         ;371
000180  46b3              MOV      r11,r6                ;370
000182  fbc482c5          SMLALD   r8,r2,r4,r5           ;371
000186  9212              STR      r2,[sp,#0x48]         ;372
000188  4672              MOV      r2,lr                 ;372
00018a  4656              MOV      r6,r10                ;372
00018c  fbc426d5          SMLALDX  r2,r6,r4,r5           ;372
000190  4696              MOV      lr,r2                 ;372
000192  46b2              MOV      r10,r6                ;372
000194  fbcc01d5          SMLALDX  r0,r1,r12,r5          ;373
000198  e059              B        |L1.590|
                  |L1.410|
00019a  f8d95000          LDR      r5,[r9,#0]            ;379
00019e  f8d2c000          LDR      r12,[r2,#0]           ;382
0001a2  f8d29002          LDR      r9,[r2,#2]            ;385
0001a6  9a0a              LDR      r2,[sp,#0x28]         ;389
0001a8  465e              MOV      r6,r11                ;389
0001aa  fbc726c5          SMLALD   r2,r6,r7,r5           ;389
0001ae  920a              STR      r2,[sp,#0x28]         ;390
0001b0  9a12              LDR      r2,[sp,#0x48]         ;390
0001b2  46b3              MOV      r11,r6                ;389
0001b4  fbc482c5          SMLALD   r8,r2,r4,r5           ;390
0001b8  9212              STR      r2,[sp,#0x48]         ;391
0001ba  4674              MOV      r4,lr                 ;391
0001bc  4652              MOV      r2,r10                ;391
0001be  fbcc42c5          SMLALD   r4,r2,r12,r5          ;391
0001c2  46a6              MOV      lr,r4                 ;391
0001c4  4692              MOV      r10,r2                ;391
0001c6  e000              B        |L1.458|
                  |L1.456|
0001c8  e0ce              B        |L1.872|
                  |L1.458|
0001ca  fbc901c5          SMLALD   r0,r1,r9,r5           ;392
0001ce  e03e              B        |L1.590|
                  |L1.464|
;;;396          {
;;;397            /* Read y[4], y[5] */
;;;398            c0 = *__SIMD32(py)++;
0001d0  f8596b04          LDR      r6,[r9],#4
;;;399    
;;;400            /* Read x[7], x[8] */
;;;401            x3 = *__SIMD32(px);
0001d4  f8cd9010          STR      r9,[sp,#0x10]
0001d8  f8d29000          LDR      r9,[r2,#0]
;;;402    
;;;403            /* Read x[9] */
;;;404            x2 = _SIMD32_OFFSET(px + 1);
0001dc  f8cd9054          STR      r9,[sp,#0x54]
0001e0  f8d29002          LDR      r9,[r2,#2]
;;;405    
;;;406            /* Perform the multiply-accumulates */
;;;407            acc0 = __SMLALD(x0, c0, acc0);
0001e4  f8ddc028          LDR      r12,[sp,#0x28]
0001e8  f8cd901c          STR      r9,[sp,#0x1c]         ;404
0001ec  f8cd904c          STR      r9,[sp,#0x4c]
0001f0  465d              MOV      r5,r11
0001f2  fbc7c5c6          SMLALD   r12,r5,r7,r6
;;;408            acc1 = __SMLALD(x1, c0, acc1);
0001f6  9f12              LDR      r7,[sp,#0x48]
0001f8  46e3              MOV      r11,r12               ;407
0001fa  fbc487c6          SMLALD   r8,r7,r4,r6
;;;409            acc2 = __SMLALD(x3, c0, acc2);
0001fe  9712              STR      r7,[sp,#0x48]
000200  f8dd9054          LDR      r9,[sp,#0x54]
000204  46f4              MOV      r12,lr
000206  4657              MOV      r7,r10
000208  fbc9c7c6          SMLALD   r12,r7,r9,r6
;;;410            acc3 = __SMLALD(x2, c0, acc3);
00020c  f8dd901c          LDR      r9,[sp,#0x1c]
000210  46e2              MOV      r10,r12               ;409
000212  46be              MOV      lr,r7                 ;409
000214  fbc901c6          SMLALD   r0,r1,r9,r6
;;;411    
;;;412            c0 = (*py);
000218  f8dd9010          LDR      r9,[sp,#0x10]
00021c  9103              STR      r1,[sp,#0xc]
;;;413    
;;;414            /* Read y[6] */
;;;415    #ifdef  ARM_MATH_BIG_ENDIAN
;;;416    
;;;417            c0 = c0 << 16u;
;;;418    #else
;;;419    
;;;420            c0 = c0 & 0x0000FFFF;
;;;421    #endif /*      #ifdef  ARM_MATH_BIG_ENDIAN     */
;;;422            /* Read x[10] */
;;;423            x3 = _SIMD32_OFFSET(px + 2);
00021e  6852              LDR      r2,[r2,#4]
000220  f8b91000          LDRH     r1,[r9,#0]            ;412
;;;424    		px += 3u;
;;;425    
;;;426            /* Perform the multiply-accumulates */
;;;427            acc0 = __SMLALDX(x1, c0, acc0);
000224  46dc              MOV      r12,r11
000226  b28e              UXTH     r6,r1                 ;420
000228  fbc4c5d6          SMLALDX  r12,r5,r4,r6
00022c  e9dd7912          LDRD     r7,r9,[sp,#0x48]
000230  46ab              MOV      r11,r5
000232  f8cdc028          STR      r12,[sp,#0x28]
;;;428            acc1 = __SMLALD(x2, c0, acc1);
000236  fbc987c6          SMLALD   r8,r7,r9,r6
;;;429            acc2 = __SMLALDX(x2, c0, acc2);
00023a  9712              STR      r7,[sp,#0x48]
00023c  46d4              MOV      r12,r10
00023e  4677              MOV      r7,lr
000240  fbc9c7d6          SMLALDX  r12,r7,r9,r6
;;;430            acc3 = __SMLALDX(x3, c0, acc3);
000244  9903              LDR      r1,[sp,#0xc]
000246  46e6              MOV      lr,r12                ;429
000248  46ba              MOV      r10,r7                ;429
00024a  fbc201d6          SMLALDX  r0,r1,r2,r6
                  |L1.590|
;;;431          }
;;;432    
;;;433          /* Store the result in the accumulator in the destination buffer. */
;;;434          *pOut = (q15_t) (__SSAT(acc0 >> 15, 16));
00024e  9c0a              LDR      r4,[sp,#0x28]
;;;435          /* Destination pointer is updated according to the address modifier, inc */
;;;436          pOut += inc;
;;;437    
;;;438          *pOut = (q15_t) (__SSAT(acc1 >> 15, 16));
;;;439          pOut += inc;
;;;440    
;;;441          *pOut = (q15_t) (__SSAT(acc2 >> 15, 16));
;;;442          pOut += inc;
;;;443    
;;;444          *pOut = (q15_t) (__SSAT(acc3 >> 15, 16));
000250  0bc0              LSRS     r0,r0,#15
000252  0be2              LSRS     r2,r4,#15             ;434
000254  ea42424b          ORR      r2,r2,r11,LSL #17     ;434
000258  f302040f          SSAT     r4,#16,r2             ;434
00025c  9a0d              LDR      r2,[sp,#0x34]         ;434
00025e  ea404041          ORR      r0,r0,r1,LSL #17
000262  f300000f          SSAT     r0,#16,r0
000266  8014              STRH     r4,[r2,#0]            ;434
000268  e9dd240d          LDRD     r2,r4,[sp,#0x34]      ;434
00026c  eb020444          ADD      r4,r2,r4,LSL #1       ;436
000270  9a12              LDR      r2,[sp,#0x48]         ;438
000272  0455              LSLS     r5,r2,#17             ;438
000274  ea4532d8          ORR      r2,r5,r8,LSR #15      ;438
000278  f302020f          SSAT     r2,#16,r2             ;438
00027c  8022              STRH     r2,[r4,#0]            ;438
00027e  9a0e              LDR      r2,[sp,#0x38]         ;439
000280  eb040242          ADD      r2,r4,r2,LSL #1       ;439
000284  ea4f34de          LSR      r4,lr,#15             ;441
000288  ea44444a          ORR      r4,r4,r10,LSL #17     ;441
00028c  f304040f          SSAT     r4,#16,r4             ;441
000290  8014              STRH     r4,[r2,#0]            ;441
000292  9c0e              LDR      r4,[sp,#0x38]         ;442
000294  eb020244          ADD      r2,r2,r4,LSL #1       ;442
000298  8010              STRH     r0,[r2,#0]
;;;445          pOut += inc;
00029a  980e              LDR      r0,[sp,#0x38]
00029c  eb020040          ADD      r0,r2,r0,LSL #1
;;;446    
;;;447          /* Increment the count by 4 as 4 output values are computed */
;;;448          count += 4u;
0002a0  900d              STR      r0,[sp,#0x34]
0002a2  980f              LDR      r0,[sp,#0x3c]
0002a4  1d00              ADDS     r0,r0,#4
;;;449    
;;;450          /* Update the inputA and inputB pointers for next MAC calculation */
;;;451          px = pIn1 + count;
0002a6  900f              STR      r0,[sp,#0x3c]
0002a8  990f              LDR      r1,[sp,#0x3c]
0002aa  9814              LDR      r0,[sp,#0x50]
;;;452          py = pIn2;
;;;453    
;;;454          /* Decrement the loop counter */
;;;455          blkCnt--;
0002ac  f8dd9064          LDR      r9,[sp,#0x64]
0002b0  eb000241          ADD      r2,r0,r1,LSL #1       ;451
0002b4  9817              LDR      r0,[sp,#0x5c]
0002b6  1e40              SUBS     r0,r0,#1
                  |L1.696|
0002b8  9017              STR      r0,[sp,#0x5c]         ;278
0002ba  2800              CMP      r0,#0                 ;278
0002bc  f47faf09          BNE      |L1.210|
;;;456        }
;;;457    
;;;458        /* If the blockSize2 is not a multiple of 4, compute any remaining output samples here.   
;;;459         ** No loop unrolling is used. */
;;;460        blkCnt = blockSize2 % 0x4u;
0002c0  981b              LDR      r0,[sp,#0x6c]
0002c2  f0000603          AND      r6,r0,#3
;;;461    
;;;462        while(blkCnt > 0u)
0002c6  e04c              B        |L1.866|
                  |L1.712|
0002c8  2100              MOVS     r1,#0
0002ca  4608              MOV      r0,r1
;;;463        {
;;;464          /* Accumulator is made zero for every iteration */
;;;465          sum = 0;
;;;466    
;;;467          /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;468          k = srcBLen >> 2u;
0002cc  089d              LSRS     r5,r3,#2
;;;469    
;;;470          /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;471           ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;472          while(k > 0u)
0002ce  e021              B        |L1.788|
                  |L1.720|
;;;473          {
;;;474            /* Perform the multiply-accumulates */
;;;475            sum += ((q63_t) * px++ * *py++);
0002d0  f9b24000          LDRSH    r4,[r2,#0]
0002d4  f9397b02          LDRSH    r7,[r9],#2
0002d8  fb847407          SMULL    r7,r4,r4,r7
0002dc  1879              ADDS     r1,r7,r1
0002de  4144              ADCS     r4,r4,r0
;;;476            sum += ((q63_t) * px++ * *py++);
0002e0  f9b20002          LDRSH    r0,[r2,#2]
0002e4  f9397b02          LDRSH    r7,[r9],#2
0002e8  fb807007          SMULL    r7,r0,r0,r7
0002ec  1879              ADDS     r1,r7,r1
0002ee  4160              ADCS     r0,r0,r4
;;;477            sum += ((q63_t) * px++ * *py++);
0002f0  f9b24004          LDRSH    r4,[r2,#4]
0002f4  f9397b02          LDRSH    r7,[r9],#2
0002f8  fb847407          SMULL    r7,r4,r4,r7
0002fc  1879              ADDS     r1,r7,r1
0002fe  4144              ADCS     r4,r4,r0
;;;478            sum += ((q63_t) * px++ * *py++);
000300  f9b20006          LDRSH    r0,[r2,#6]
000304  f9397b02          LDRSH    r7,[r9],#2
000308  3208              ADDS     r2,r2,#8
00030a  fb807007          SMULL    r7,r0,r0,r7
00030e  1879              ADDS     r1,r7,r1
000310  4160              ADCS     r0,r0,r4
000312  1e6d              SUBS     r5,r5,#1
                  |L1.788|
000314  2d00              CMP      r5,#0                 ;472
000316  d1db              BNE      |L1.720|
;;;479    
;;;480            /* Decrement the loop counter */
;;;481            k--;
;;;482          }
;;;483    
;;;484          /* If the srcBLen is not a multiple of 4, compute any remaining MACs here.   
;;;485           ** No loop unrolling is used. */
;;;486          k = srcBLen % 0x4u;
000318  f0030403          AND      r4,r3,#3
;;;487    
;;;488          while(k > 0u)
00031c  e009              B        |L1.818|
;;;489          {
;;;490            /* Perform the multiply-accumulates */
;;;491            sum += ((q63_t) * px++ * *py++);
00031e  bf00              NOP      
                  |L1.800|
000320  f9325b02          LDRSH    r5,[r2],#2
000324  f9397b02          LDRSH    r7,[r9],#2
000328  fb857507          SMULL    r7,r5,r5,r7
00032c  1879              ADDS     r1,r7,r1
00032e  4168              ADCS     r0,r0,r5
000330  1e64              SUBS     r4,r4,#1
                  |L1.818|
000332  2c00              CMP      r4,#0                 ;488
000334  d1f4              BNE      |L1.800|
;;;492    
;;;493            /* Decrement the loop counter */
;;;494            k--;
;;;495          }
;;;496    
;;;497          /* Store the result in the accumulator in the destination buffer. */
;;;498          *pOut = (q15_t) (__SSAT(sum >> 15, 16));
000336  0442              LSLS     r2,r0,#17
000338  ea4230d1          ORR      r0,r2,r1,LSR #15
00033c  f300010f          SSAT     r1,#16,r0
000340  980d              LDR      r0,[sp,#0x34]
000342  8001              STRH     r1,[r0,#0]
000344  e9dd100d          LDRD     r1,r0,[sp,#0x34]
;;;499          /* Destination pointer is updated according to the address modifier, inc */
;;;500          pOut += inc;
000348  eb010040          ADD      r0,r1,r0,LSL #1
;;;501    
;;;502          /* Increment count by 1, as one output value is computed */
;;;503          count++;
00034c  900d              STR      r0,[sp,#0x34]
00034e  980f              LDR      r0,[sp,#0x3c]
000350  1c40              ADDS     r0,r0,#1
;;;504    
;;;505          /* Update the inputA and inputB pointers for next MAC calculation */
;;;506          px = pIn1 + count;
000352  900f              STR      r0,[sp,#0x3c]
000354  990f              LDR      r1,[sp,#0x3c]
000356  9814              LDR      r0,[sp,#0x50]
;;;507          py = pIn2;
000358  f8dd9064          LDR      r9,[sp,#0x64]
00035c  eb000241          ADD      r2,r0,r1,LSL #1       ;506
000360  1e76              SUBS     r6,r6,#1
                  |L1.866|
000362  2e00              CMP      r6,#0                 ;462
000364  d1b0              BNE      |L1.712|
000366  e028              B        |L1.954|
                  |L1.872|
;;;508    
;;;509          /* Decrement the loop counter */
;;;510          blkCnt--;
;;;511        }
;;;512      }
;;;513      else
;;;514      {
;;;515        /* If the srcBLen is not a multiple of 4,   
;;;516         * the blockSize2 loop cannot be unrolled by 4 */
;;;517        blkCnt = blockSize2;
;;;518    
;;;519        while(blkCnt > 0u)
000368  9c1b              LDR      r4,[sp,#0x6c]
00036a  e024              B        |L1.950|
                  |L1.876|
00036c  2100              MOVS     r1,#0
00036e  4608              MOV      r0,r1
;;;520        {
;;;521          /* Accumulator is made zero for every iteration */
;;;522          sum = 0;
;;;523    
;;;524          /* Loop over srcBLen */
;;;525          k = srcBLen;
000370  461d              MOV      r5,r3
;;;526    
;;;527          while(k > 0u)
000372  e008              B        |L1.902|
                  |L1.884|
;;;528          {
;;;529            /* Perform the multiply-accumulate */
;;;530            sum += ((q63_t) * px++ * *py++);
000374  f9326b02          LDRSH    r6,[r2],#2
000378  f9397b02          LDRSH    r7,[r9],#2
00037c  fb867607          SMULL    r7,r6,r6,r7
000380  1879              ADDS     r1,r7,r1
000382  4170              ADCS     r0,r0,r6
000384  1e6d              SUBS     r5,r5,#1
                  |L1.902|
000386  2d00              CMP      r5,#0                 ;527
000388  d1f4              BNE      |L1.884|
;;;531    
;;;532            /* Decrement the loop counter */
;;;533            k--;
;;;534          }
;;;535    
;;;536          /* Store the result in the accumulator in the destination buffer. */
;;;537          *pOut = (q15_t) (__SSAT(sum >> 15, 16));
00038a  0442              LSLS     r2,r0,#17
00038c  ea4230d1          ORR      r0,r2,r1,LSR #15
000390  990d              LDR      r1,[sp,#0x34]
000392  f300000f          SSAT     r0,#16,r0
000396  8008              STRH     r0,[r1,#0]
000398  e9dd010d          LDRD     r0,r1,[sp,#0x34]
;;;538          /* Destination pointer is updated according to the address modifier, inc */
;;;539          pOut += inc;
00039c  eb000041          ADD      r0,r0,r1,LSL #1
;;;540    
;;;541          /* Increment the MAC count */
;;;542          count++;
0003a0  900d              STR      r0,[sp,#0x34]
0003a2  980f              LDR      r0,[sp,#0x3c]
0003a4  1c40              ADDS     r0,r0,#1
;;;543    
;;;544          /* Update the inputA and inputB pointers for next MAC calculation */
;;;545          px = pIn1 + count;
0003a6  900f              STR      r0,[sp,#0x3c]
0003a8  990f              LDR      r1,[sp,#0x3c]
0003aa  9814              LDR      r0,[sp,#0x50]
;;;546          py = pIn2;
0003ac  f8dd9064          LDR      r9,[sp,#0x64]
0003b0  eb000241          ADD      r2,r0,r1,LSL #1       ;545
0003b4  1e64              SUBS     r4,r4,#1
                  |L1.950|
0003b6  2c00              CMP      r4,#0                 ;519
0003b8  d1d8              BNE      |L1.876|
                  |L1.954|
;;;547    
;;;548          /* Decrement the loop counter */
;;;549          blkCnt--;
;;;550        }
;;;551      }
;;;552    
;;;553      /* --------------------------   
;;;554       * Initializations of stage3   
;;;555       * -------------------------*/
;;;556    
;;;557      /* sum += x[srcALen-srcBLen+1] * y[0] + x[srcALen-srcBLen+2] * y[1] +...+ x[srcALen-1] * y[srcBLen-1]   
;;;558       * sum += x[srcALen-srcBLen+2] * y[0] + x[srcALen-srcBLen+3] * y[1] +...+ x[srcALen-1] * y[srcBLen-1]   
;;;559       * ....   
;;;560       * sum +=  x[srcALen-2] * y[0] + x[srcALen-1] * y[1]   
;;;561       * sum +=  x[srcALen-1] * y[0]   
;;;562       */
;;;563    
;;;564      /* In this stage the MAC operations are decreased by 1 for every iteration.   
;;;565         The count variable holds the number of MAC operations performed */
;;;566      count = srcBLen - 1u;
;;;567    
;;;568      /* Working pointer of inputA */
;;;569      pSrc1 = (pIn1 + srcALen) - (srcBLen - 1u);
0003ba  991d              LDR      r1,[sp,#0x74]
0003bc  9814              LDR      r0,[sp,#0x50]
0003be  1e5c              SUBS     r4,r3,#1              ;566
0003c0  eb000041          ADD      r0,r0,r1,LSL #1
0003c4  eba00243          SUB      r2,r0,r3,LSL #1
0003c8  1c92              ADDS     r2,r2,#2
0003ca  4617              MOV      r7,r2
;;;570      px = pSrc1;
;;;571    
;;;572      /* Working pointer of inputB */
;;;573      py = pIn2;
;;;574    
;;;575      /* -------------------   
;;;576       * Stage3 process   
;;;577       * ------------------*/
;;;578    
;;;579      while(blockSize3 > 0u)
0003cc  981a              LDR      r0,[sp,#0x68]
0003ce  e031              B        |L1.1076|
                  |L1.976|
0003d0  2000              MOVS     r0,#0
0003d2  4601              MOV      r1,r0
;;;580      {
;;;581        /* Accumulator is made zero for every iteration */
;;;582        sum = 0;
;;;583    
;;;584        /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;585        k = count >> 2u;
0003d4  08a3              LSRS     r3,r4,#2
;;;586    
;;;587        /* First part of the processing with loop unrolling.  Compute 4 MACs at a time.   
;;;588         ** a second loop below computes MACs for the remaining 1 to 3 samples. */
;;;589        while(k > 0u)
0003d6  e00c              B        |L1.1010|
                  |L1.984|
;;;590        {
;;;591          /* Perform the multiply-accumulates */
;;;592          /* sum += x[srcALen - srcBLen + 4] * y[3] , sum += x[srcALen - srcBLen + 3] * y[2] */
;;;593          sum = __SMLALD(*__SIMD32(px)++, *__SIMD32(py)++, sum);
0003d8  f8525b04          LDR      r5,[r2],#4
0003dc  f8596b04          LDR      r6,[r9],#4
0003e0  fbc501c6          SMLALD   r0,r1,r5,r6
;;;594          /* sum += x[srcALen - srcBLen + 2] * y[1] , sum += x[srcALen - srcBLen + 1] * y[0] */
;;;595          sum = __SMLALD(*__SIMD32(px)++, *__SIMD32(py)++, sum);
0003e4  f8525b04          LDR      r5,[r2],#4
0003e8  f8596b04          LDR      r6,[r9],#4
0003ec  fbc501c6          SMLALD   r0,r1,r5,r6
0003f0  1e5b              SUBS     r3,r3,#1
                  |L1.1010|
0003f2  2b00              CMP      r3,#0                 ;589
0003f4  d1f0              BNE      |L1.984|
;;;596    
;;;597          /* Decrement the loop counter */
;;;598          k--;
;;;599        }
;;;600    
;;;601        /* If the count is not a multiple of 4, compute any remaining MACs here.   
;;;602         ** No loop unrolling is used. */
;;;603        k = count % 0x4u;
0003f6  f0040303          AND      r3,r4,#3
;;;604    
;;;605        while(k > 0u)
0003fa  e006              B        |L1.1034|
                  |L1.1020|
;;;606        {
;;;607          /* Perform the multiply-accumulates */
;;;608          sum = __SMLALD(*px++, *py++, sum);
0003fc  f9326b02          LDRSH    r6,[r2],#2
000400  f9395b02          LDRSH    r5,[r9],#2
000404  fbc601c5          SMLALD   r0,r1,r6,r5
000408  1e5b              SUBS     r3,r3,#1
                  |L1.1034|
00040a  2b00              CMP      r3,#0                 ;605
00040c  d1f6              BNE      |L1.1020|
;;;609    
;;;610          /* Decrement the loop counter */
;;;611          k--;
;;;612        }
;;;613    
;;;614        /* Store the result in the accumulator in the destination buffer. */
;;;615        *pOut = (q15_t) (__SSAT((sum >> 15), 16));
00040e  0bc0              LSRS     r0,r0,#15
000410  ea404041          ORR      r0,r0,r1,LSL #17
000414  f300010f          SSAT     r1,#16,r0
000418  980d              LDR      r0,[sp,#0x34]
;;;616        /* Destination pointer is updated according to the address modifier, inc */
;;;617        pOut += inc;
;;;618    
;;;619        /* Update the inputA and inputB pointers for next MAC calculation */
;;;620        px = ++pSrc1;
00041a  1cba              ADDS     r2,r7,#2
00041c  4617              MOV      r7,r2
00041e  8001              STRH     r1,[r0,#0]            ;615
000420  e9dd010d          LDRD     r0,r1,[sp,#0x34]      ;615
000424  eb000041          ADD      r0,r0,r1,LSL #1       ;617
000428  900d              STR      r0,[sp,#0x34]
00042a  e9dd9019          LDRD     r9,r0,[sp,#0x64]
00042e  1e40              SUBS     r0,r0,#1
;;;621        py = pIn2;
;;;622    
;;;623        /* Decrement the MAC count */
;;;624        count--;
;;;625    
;;;626        /* Decrement the loop counter */
;;;627        blockSize3--;
000430  1e64              SUBS     r4,r4,#1
000432  901a              STR      r0,[sp,#0x68]
                  |L1.1076|
000434  2800              CMP      r0,#0                 ;579
000436  d1cb              BNE      |L1.976|
;;;628      }
;;;629    
;;;630    #else
;;;631    
;;;632    /* Run the below code for Cortex-M0 */
;;;633    
;;;634      q15_t *pIn1 = pSrcA;                           /* inputA pointer               */
;;;635      q15_t *pIn2 = pSrcB + (srcBLen - 1u);          /* inputB pointer               */
;;;636      q63_t sum;                                     /* Accumulators                  */
;;;637      uint32_t i = 0u, j;                            /* loop counters */
;;;638      uint32_t inv = 0u;                             /* Reverse order flag */
;;;639      uint32_t tot = 0u;                             /* Length */
;;;640    
;;;641      /* The algorithm implementation is based on the lengths of the inputs. */
;;;642      /* srcB is always made to slide across srcA. */
;;;643      /* So srcBLen is always considered as shorter or equal to srcALen */
;;;644      /* But CORR(x, y) is reverse of CORR(y, x) */
;;;645      /* So, when srcBLen > srcALen, output pointer is made to point to the end of the output buffer */
;;;646      /* and a varaible, inv is set to 1 */
;;;647      /* If lengths are not equal then zero pad has to be done to  make the two   
;;;648       * inputs of same length. But to improve the performance, we include zeroes   
;;;649       * in the output instead of zero padding either of the the inputs*/
;;;650      /* If srcALen > srcBLen, (srcALen - srcBLen) zeroes has to included in the   
;;;651       * starting of the output buffer */
;;;652      /* If srcALen < srcBLen, (srcALen - srcBLen) zeroes has to included in the  
;;;653       * ending of the output buffer */
;;;654      /* Once the zero padding is done the remaining of the output is calcualted  
;;;655       * using convolution but with the shorter signal time shifted. */
;;;656    
;;;657      /* Calculate the length of the remaining sequence */
;;;658      tot = ((srcALen + srcBLen) - 2u);
;;;659    
;;;660      if(srcALen > srcBLen)
;;;661      {
;;;662        /* Calculating the number of zeros to be padded to the output */
;;;663        j = srcALen - srcBLen;
;;;664    
;;;665        /* Initialise the pointer after zero padding */
;;;666        pDst += j;
;;;667      }
;;;668    
;;;669      else if(srcALen < srcBLen)
;;;670      {
;;;671        /* Initialization to inputB pointer */
;;;672        pIn1 = pSrcB;
;;;673    
;;;674        /* Initialization to the end of inputA pointer */
;;;675        pIn2 = pSrcA + (srcALen - 1u);
;;;676    
;;;677        /* Initialisation of the pointer after zero padding */
;;;678        pDst = pDst + tot;
;;;679    
;;;680        /* Swapping the lengths */
;;;681        j = srcALen;
;;;682        srcALen = srcBLen;
;;;683        srcBLen = j;
;;;684    
;;;685        /* Setting the reverse flag */
;;;686        inv = 1;
;;;687    
;;;688      }
;;;689    
;;;690      /* Loop to calculate convolution for output length number of times */
;;;691      for (i = 0u; i <= tot; i++)
;;;692      {
;;;693        /* Initialize sum with zero to carry on MAC operations */
;;;694        sum = 0;
;;;695    
;;;696        /* Loop to perform MAC operations according to convolution equation */
;;;697        for (j = 0u; j <= i; j++)
;;;698        {
;;;699          /* Check the array limitations */
;;;700          if((((i - j) < srcBLen) && (j < srcALen)))
;;;701          {
;;;702            /* z[i] += x[i-j] * y[j] */
;;;703            sum += ((q31_t) pIn1[j] * pIn2[-((int32_t) i - j)]);
;;;704          }
;;;705        }
;;;706        /* Store the output in the destination buffer */
;;;707        if(inv == 1)
;;;708          *pDst-- = (q15_t) __SSAT((sum >> 15u), 16u);
;;;709        else
;;;710          *pDst++ = (q15_t) __SSAT((sum >> 15u), 16u);
;;;711      }
;;;712    
;;;713    #endif /*#if (defined(ARM_MATH_CM4) || defined(ARM_MATH_CM3)) && !defined(UNALIGNED_SUPPORT_DISABLE) */
;;;714    
;;;715    }
000438  b020              ADD      sp,sp,#0x80
00043a  e8bd8ff0          POP      {r4-r11,pc}
;;;716    
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\FilteringFunctions\\arm_correlate_q15.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_correlate_q15_c_3c6b17d6____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___19_arm_correlate_q15_c_3c6b17d6____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_correlate_q15_c_3c6b17d6____REVSH|
#line 144
|__asm___19_arm_correlate_q15_c_3c6b17d6____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_correlate_q15_c_3c6b17d6____RRX|
#line 300
|__asm___19_arm_correlate_q15_c_3c6b17d6____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
