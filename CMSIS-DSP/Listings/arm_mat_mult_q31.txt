; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_mat_mult_q31.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_mat_mult_q31.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_mat_mult_q31.crf src\MatrixFunctions\arm_mat_mult_q31.c]
                          THUMB

                          AREA ||i.arm_mat_mult_q31||, CODE, READONLY, ALIGN=2

                  arm_mat_mult_q31 PROC
;;;77     
;;;78     arm_status arm_mat_mult_q31(
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;79       const arm_matrix_instance_q31 * pSrcA,
;;;80       const arm_matrix_instance_q31 * pSrcB,
;;;81       arm_matrix_instance_q31 * pDst)
;;;82     {
000004  b088              SUB      sp,sp,#0x20
;;;83       q31_t *pIn1 = pSrcA->pData;                    /* input data matrix pointer A */
;;;84       q31_t *pIn2 = pSrcB->pData;                    /* input data matrix pointer B */
;;;85       q31_t *pInA = pSrcA->pData;                    /* input data matrix pointer A */
;;;86       q31_t *pOut = pDst->pData;                     /* output data matrix pointer */
000006  6851              LDR      r1,[r2,#4]
000008  6845              LDR      r5,[r0,#4]
;;;87       q31_t *px;                                     /* Temporary output data matrix pointer */
;;;88       q63_t sum;                                     /* Accumulator */
;;;89       uint16_t numRowsA = pSrcA->numRows;            /* number of rows of input matrix A    */
00000a  9107              STR      r1,[sp,#0x1c]
;;;90       uint16_t numColsB = pSrcB->numCols;            /* number of columns of input matrix B */
00000c  9a09              LDR      r2,[sp,#0x24]
;;;91       uint16_t numColsA = pSrcA->numCols;            /* number of columns of input matrix A */
00000e  f8b0b002          LDRH     r11,[r0,#2]
000012  8801              LDRH     r1,[r0,#0]            ;89
000014  8853              LDRH     r3,[r2,#2]            ;90
;;;92     
;;;93     #ifndef ARM_MATH_CM0_FAMILY
;;;94     
;;;95       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;96     
;;;97       uint16_t col, i = 0u, j, row = numRowsA, colCnt;      /* loop counters */
;;;98       arm_status status;                             /* status of matrix multiplication */
;;;99       q31_t a0, a1, a2, a3, b0, b1, b2, b3;
;;;100    
;;;101    #ifdef ARM_MATH_MATRIX_CHECK
;;;102    
;;;103    
;;;104      /* Check for matrix mismatch condition */
;;;105      if((pSrcA->numCols != pSrcB->numRows) ||
;;;106         (pSrcA->numRows != pDst->numRows) || (pSrcB->numCols != pDst->numCols))
;;;107      {
;;;108        /* Set status as ARM_MATH_SIZE_MISMATCH */
;;;109        status = ARM_MATH_SIZE_MISMATCH;
;;;110      }
;;;111      else
;;;112    #endif /*    #ifdef ARM_MATH_MATRIX_CHECK    */
;;;113    
;;;114      {
;;;115        /* The following loop performs the dot-product of each row in pSrcA with each column in pSrcB */
;;;116        /* row loop */
;;;117        do
;;;118        {
;;;119          /* Output pointer is set to starting address of the row being processed */
;;;120          px = pOut + i;
;;;121    
;;;122          /* For every row wise process, the column loop counter is to be initiated */
;;;123          col = numColsB;
;;;124    
;;;125          /* For every row wise process, the pIn2 pointer is set    
;;;126           ** to the starting address of the pSrcB data */
;;;127          pIn2 = pSrcB->pData;
;;;128    
;;;129          j = 0u;
;;;130    
;;;131          /* column loop */
;;;132          do
;;;133          {
;;;134            /* Set the variable sum, that acts as accumulator, to zero */
;;;135            sum = 0;
;;;136    
;;;137            /* Initiate the pointer pIn1 to point to the starting address of pInA */
;;;138            pIn1 = pInA;
;;;139    
;;;140            /* Apply loop unrolling and compute 4 MACs simultaneously. */
;;;141            colCnt = numColsA >> 2;
000016  ea4f009b          LSR      r0,r11,#2
00001a  e9cd1005          STRD     r1,r0,[sp,#0x14]
00001e  f04f0e00          MOV      lr,#0                 ;97
                  |L1.34|
000022  9807              LDR      r0,[sp,#0x1c]         ;120
000024  461f              MOV      r7,r3                 ;123
000026  eb000a8e          ADD      r10,r0,lr,LSL #2      ;120
00002a  9809              LDR      r0,[sp,#0x24]         ;127
00002c  f04f0900          MOV      r9,#0                 ;129
000030  6844              LDR      r4,[r0,#4]            ;129
                  |L1.50|
000032  2200              MOVS     r2,#0                 ;129
000034  4610              MOV      r0,r2                 ;129
000036  4629              MOV      r1,r5                 ;138
;;;142    
;;;143    
;;;144            /* matrix multiplication */
;;;145            while(colCnt > 0u)
000038  9e06              LDR      r6,[sp,#0x18]
00003a  e03b              B        |L1.180|
                  |L1.60|
;;;146            {
;;;147              /* c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n) */
;;;148              /* Perform the multiply-accumulates */
;;;149              b0 = *pIn2;
00003c  f8d4c000          LDR      r12,[r4,#0]
;;;150              pIn2 += numColsB;
;;;151    
;;;152              a0 = *pIn1++;
000040  f8cdc010          STR      r12,[sp,#0x10]
000044  f8518b04          LDR      r8,[r1],#4
;;;153              a1 = *pIn1++;
000048  f8cd800c          STR      r8,[sp,#0xc]
00004c  eb040483          ADD      r4,r4,r3,LSL #2       ;150
000050  f851cb04          LDR      r12,[r1],#4
;;;154    
;;;155              b1 = *pIn2;
000054  f8cdc008          STR      r12,[sp,#8]
000058  f8d48000          LDR      r8,[r4,#0]
;;;156              pIn2 += numColsB;
00005c  eb040483          ADD      r4,r4,r3,LSL #2
;;;157              b2 = *pIn2;
000060  f8cd8004          STR      r8,[sp,#4]
000064  f8d48000          LDR      r8,[r4,#0]
;;;158              pIn2 += numColsB;
000068  f8cd8000          STR      r8,[sp,#0]
00006c  e9dd8c03          LDRD     r8,r12,[sp,#0xc]
;;;159    
;;;160              sum += (q63_t) a0 *b0;
000070  fbc8200c          SMLAL    r2,r0,r8,r12
000074  e9dd8c01          LDRD     r8,r12,[sp,#4]
;;;161              sum += (q63_t) a1 *b1;
000078  fbcc2008          SMLAL    r2,r0,r12,r8
;;;162    
;;;163              a2 = *pIn1++;
00007c  f851cb04          LDR      r12,[r1],#4
;;;164              a3 = *pIn1++;
000080  f8cdc00c          STR      r12,[sp,#0xc]
000084  f851cb04          LDR      r12,[r1],#4
000088  eb040483          ADD      r4,r4,r3,LSL #2       ;158
;;;165    
;;;166              b3 = *pIn2;
00008c  f8cdc008          STR      r12,[sp,#8]
000090  f8d48000          LDR      r8,[r4,#0]
;;;167              pIn2 += numColsB;
;;;168    
;;;169              sum += (q63_t) a2 *b2;
000094  f8cd8004          STR      r8,[sp,#4]
000098  f8ddc00c          LDR      r12,[sp,#0xc]
00009c  f8dd8000          LDR      r8,[sp,#0]
;;;170              sum += (q63_t) a3 *b3;
0000a0  1e76              SUBS     r6,r6,#1
0000a2  fbcc2008          SMLAL    r2,r0,r12,r8          ;169
0000a6  e9dd8c01          LDRD     r8,r12,[sp,#4]        ;169
0000aa  fbcc2008          SMLAL    r2,r0,r12,r8
0000ae  eb040483          ADD      r4,r4,r3,LSL #2       ;167
;;;171    
;;;172              /* Decrement the loop counter */
;;;173              colCnt--;
0000b2  b2b6              UXTH     r6,r6
                  |L1.180|
0000b4  2e00              CMP      r6,#0                 ;145
0000b6  d1c1              BNE      |L1.60|
;;;174            }
;;;175    
;;;176            /* If the columns of pSrcA is not a multiple of 4, compute any remaining output samples here.    
;;;177             ** No loop unrolling is used. */
;;;178            colCnt = numColsA % 0x4u;
0000b8  f00b0603          AND      r6,r11,#3
;;;179    
;;;180            while(colCnt > 0u)
0000bc  e00e              B        |L1.220|
;;;181            {
;;;182              /* c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n) */
;;;183              /* Perform the multiply-accumulates */
;;;184              sum += (q63_t) * pIn1++ * *pIn2;
0000be  bf00              NOP      
                  |L1.192|
0000c0  f8d48000          LDR      r8,[r4,#0]
0000c4  f851cb04          LDR      r12,[r1],#4
;;;185              pIn2 += numColsB;
0000c8  eb040483          ADD      r4,r4,r3,LSL #2
0000cc  fb8c8c08          SMULL    r8,r12,r12,r8         ;184
0000d0  eb180202          ADDS     r2,r8,r2              ;184
0000d4  eb4c0000          ADC      r0,r12,r0             ;184
0000d8  1e76              SUBS     r6,r6,#1
;;;186    
;;;187              /* Decrement the loop counter */
;;;188              colCnt--;
0000da  b2b6              UXTH     r6,r6
                  |L1.220|
0000dc  2e00              CMP      r6,#0                 ;180
0000de  d1ef              BNE      |L1.192|
;;;189            }
;;;190    
;;;191            /* Convert the result from 2.62 to 1.31 format and store in destination buffer */
;;;192            *px++ = (q31_t) (sum >> 31);
0000e0  0041              LSLS     r1,r0,#1
0000e2  ea4170d2          ORR      r0,r1,r2,LSR #31
0000e6  f84a0b04          STR      r0,[r10],#4
;;;193    
;;;194            /* Update the pointer pIn2 to point to the  starting address of the next column */
;;;195            j++;
0000ea  f1090001          ADD      r0,r9,#1
0000ee  fa1ff980          UXTH     r9,r0
;;;196            pIn2 = (pSrcB->pData) + j;
0000f2  9809              LDR      r0,[sp,#0x24]
0000f4  1e7f              SUBS     r7,r7,#1
;;;197    
;;;198            /* Decrement the column loop counter */
;;;199            col--;
0000f6  043f              LSLS     r7,r7,#16
0000f8  6841              LDR      r1,[r0,#4]            ;196
0000fa  0c3f              LSRS     r7,r7,#16
0000fc  eb010489          ADD      r4,r1,r9,LSL #2       ;196
;;;200    
;;;201          } while(col > 0u);
000100  d197              BNE      |L1.50|
;;;202    
;;;203    #else
;;;204    
;;;205      /* Run the below code for Cortex-M0 */
;;;206    
;;;207      q31_t *pInB = pSrcB->pData;                    /* input data matrix pointer B */
;;;208      uint16_t col, i = 0u, row = numRowsA, colCnt;  /* loop counters */
;;;209      arm_status status;                             /* status of matrix multiplication */
;;;210    
;;;211    
;;;212    #ifdef ARM_MATH_MATRIX_CHECK
;;;213    
;;;214      /* Check for matrix mismatch condition */
;;;215      if((pSrcA->numCols != pSrcB->numRows) ||
;;;216         (pSrcA->numRows != pDst->numRows) || (pSrcB->numCols != pDst->numCols))
;;;217      {
;;;218        /* Set status as ARM_MATH_SIZE_MISMATCH */
;;;219        status = ARM_MATH_SIZE_MISMATCH;
;;;220      }
;;;221      else
;;;222    #endif /*    #ifdef ARM_MATH_MATRIX_CHECK    */
;;;223    
;;;224      {
;;;225        /* The following loop performs the dot-product of each row in pSrcA with each column in pSrcB */
;;;226        /* row loop */
;;;227        do
;;;228        {
;;;229          /* Output pointer is set to starting address of the row being processed */
;;;230          px = pOut + i;
;;;231    
;;;232          /* For every row wise process, the column loop counter is to be initiated */
;;;233          col = numColsB;
;;;234    
;;;235          /* For every row wise process, the pIn2 pointer is set          
;;;236           ** to the starting address of the pSrcB data */
;;;237          pIn2 = pSrcB->pData;
;;;238    
;;;239          /* column loop */
;;;240          do
;;;241          {
;;;242            /* Set the variable sum, that acts as accumulator, to zero */
;;;243            sum = 0;
;;;244    
;;;245            /* Initiate the pointer pIn1 to point to the starting address of pInA */
;;;246            pIn1 = pInA;
;;;247    
;;;248            /* Matrix A columns number of MAC operations are to be performed */
;;;249            colCnt = numColsA;
;;;250    
;;;251            /* matrix multiplication */
;;;252            while(colCnt > 0u)
;;;253            {
;;;254              /* c(m,n) = a(1,1)*b(1,1) + a(1,2) * b(2,1) + .... + a(m,p)*b(p,n) */
;;;255              /* Perform the multiply-accumulates */
;;;256              sum += (q63_t) * pIn1++ * *pIn2;
;;;257              pIn2 += numColsB;
;;;258    
;;;259              /* Decrement the loop counter */
;;;260              colCnt--;
;;;261            }
;;;262    
;;;263            /* Convert the result from 2.62 to 1.31 format and store in destination buffer */
;;;264            *px++ = (q31_t) clip_q63_to_q31(sum >> 31);
;;;265    
;;;266            /* Decrement the column loop counter */
;;;267            col--;
;;;268    
;;;269            /* Update the pointer pIn2 to point to the  starting address of the next column */
;;;270            pIn2 = pInB + (numColsB - col);
;;;271    
;;;272          } while(col > 0u);
;;;273    
;;;274    #endif
;;;275    
;;;276          /* Update the pointer pInA to point to the  starting address of the next row */
;;;277          i = i + numColsB;
000102  eb0e0003          ADD      r0,lr,r3
000106  fa1ffe80          UXTH     lr,r0
;;;278          pInA = pInA + numColsA;
;;;279    
;;;280          /* Decrement the row loop counter */
;;;281          row--;
00010a  9805              LDR      r0,[sp,#0x14]
00010c  eb05058b          ADD      r5,r5,r11,LSL #2      ;278
000110  1e40              SUBS     r0,r0,#1
000112  0400              LSLS     r0,r0,#16
000114  0c00              LSRS     r0,r0,#16
;;;282    
;;;283        } while(row > 0u);
000116  9005              STR      r0,[sp,#0x14]
000118  d183              BNE      |L1.34|
;;;284    
;;;285        /* set status as ARM_MATH_SUCCESS */
;;;286        status = ARM_MATH_SUCCESS;
;;;287      }
;;;288      /* Return to application */
;;;289      return (status);
;;;290    }
00011a  b00b              ADD      sp,sp,#0x2c
00011c  e8bd8ff0          POP      {r4-r11,pc}
;;;291    
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\MatrixFunctions\\arm_mat_mult_q31.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_mat_mult_q31_c_50491542____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___18_arm_mat_mult_q31_c_50491542____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_mat_mult_q31_c_50491542____REVSH|
#line 144
|__asm___18_arm_mat_mult_q31_c_50491542____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___18_arm_mat_mult_q31_c_50491542____RRX|
#line 300
|__asm___18_arm_mat_mult_q31_c_50491542____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
