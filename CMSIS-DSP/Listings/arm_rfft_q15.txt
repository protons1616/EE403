; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_rfft_q15.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_rfft_q15.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_rfft_q15.crf src\TransformFunctions\arm_rfft_q15.c]
                          THUMB

                          AREA ||i.arm_rfft_q15||, CODE, READONLY, ALIGN=2

                  arm_rfft_q15 PROC
;;;86     
;;;87     void arm_rfft_q15(
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;88         const arm_rfft_instance_q15 * S,
;;;89         q15_t * pSrc,
;;;90         q15_t * pDst)
;;;91     {
000004  4604              MOV      r4,r0
;;;92         const arm_cfft_instance_q15 *S_CFFT = S->pCfft;
;;;93         uint32_t i;
;;;94         uint32_t L2 = S->fftLenReal >> 1;
000006  6947              LDR      r7,[r0,#0x14]
000008  4615              MOV      r5,r2                 ;91
00000a  6800              LDR      r0,[r0,#0]
;;;95     
;;;96         /* Calculation of RIFFT of input */
;;;97         if(S->ifftFlagR == 1u)
00000c  7922              LDRB     r2,[r4,#4]
00000e  0846              LSRS     r6,r0,#1              ;94
000010  4688              MOV      r8,r1                 ;91
000012  2a01              CMP      r2,#1
000014  d00e              BEQ      |L1.52|
;;;98         {
;;;99             /*  Real IFFT core process */
;;;100            arm_split_rifft_q15(pSrc, L2, S->pTwiddleAReal,
;;;101                                S->pTwiddleBReal, pDst, S->twidCoefRModifier);
;;;102            
;;;103            /* Complex IFFT process */
;;;104            arm_cfft_q15(S_CFFT, pDst, S->ifftFlagR, S->bitReverseFlagR);
;;;105            
;;;106            for(i=0;i<S->fftLenReal;i++)
;;;107            {
;;;108                pDst[i] = pDst[i] << 1;
;;;109            }
;;;110        }
;;;111        else
;;;112        {
;;;113            /* Calculation of RFFT of input */
;;;114            
;;;115            /* Complex FFT process */
;;;116            arm_cfft_q15(S_CFFT, pSrc, S->ifftFlagR, S->bitReverseFlagR);
000016  7963              LDRB     r3,[r4,#5]
000018  4638              MOV      r0,r7
00001a  f7fffffe          BL       arm_cfft_q15
;;;117    
;;;118            /*  Real FFT core process */
;;;119            arm_split_rfft_q15(pSrc, L2, S->pTwiddleAReal,
00001e  68a0              LDR      r0,[r4,#8]
000020  4631              MOV      r1,r6
000022  e9cd5000          STRD     r5,r0,[sp,#0]
000026  e9d42303          LDRD     r2,r3,[r4,#0xc]
00002a  4640              MOV      r0,r8
00002c  f7fffffe          BL       arm_split_rfft_q15
                  |L1.48|
;;;120                                S->pTwiddleBReal, pDst, S->twidCoefRModifier);
;;;121        }
;;;122    }
000030  e8bd81fc          POP      {r2-r8,pc}
                  |L1.52|
000034  68a0              LDR      r0,[r4,#8]            ;100
000036  4631              MOV      r1,r6                 ;100
000038  e9cd5000          STRD     r5,r0,[sp,#0]         ;100
00003c  e9d42303          LDRD     r2,r3,[r4,#0xc]       ;100
000040  4640              MOV      r0,r8                 ;100
000042  f7fffffe          BL       arm_split_rifft_q15
000046  7963              LDRB     r3,[r4,#5]            ;104
000048  7922              LDRB     r2,[r4,#4]            ;104
00004a  4629              MOV      r1,r5                 ;104
00004c  4638              MOV      r0,r7                 ;104
00004e  f7fffffe          BL       arm_cfft_q15
000052  2000              MOVS     r0,#0                 ;106
000054  e006              B        |L1.100|
000056  bf00              NOP                            ;108
                  |L1.88|
000058  f8351010          LDRH     r1,[r5,r0,LSL #1]     ;108
00005c  0049              LSLS     r1,r1,#1              ;108
00005e  f8251010          STRH     r1,[r5,r0,LSL #1]     ;108
000062  1c40              ADDS     r0,r0,#1              ;108
                  |L1.100|
000064  6821              LDR      r1,[r4,#0]            ;106
000066  4281              CMP      r1,r0                 ;106
000068  d8f6              BHI      |L1.88|
00006a  e7e1              B        |L1.48|
;;;123    
                          ENDP


                          AREA ||i.arm_split_rfft_q15||, CODE, READONLY, ALIGN=2

                  arm_split_rfft_q15 PROC
;;;139    
;;;140    void arm_split_rfft_q15(
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;141        q15_t * pSrc,
;;;142        uint32_t fftLen,
;;;143        q15_t * pATable,
;;;144        q15_t * pBTable,
;;;145        q15_t * pDst,
;;;146        uint32_t modifier)
;;;147    {
000004  468e              MOV      lr,r1
000006  e9ddab0d          LDRD     r10,r11,[sp,#0x34]
;;;148        uint32_t i;                                    /* Loop Counter */
;;;149        q31_t outR, outI;                              /* Temporary variables for output */
;;;150        q15_t *pCoefA, *pCoefB;                        /* Temporary pointers for twiddle factors */
;;;151        q15_t *pSrc1, *pSrc2;
;;;152    #ifndef ARM_MATH_CM0_FAMILY
;;;153        q15_t *pD1, *pD2;
;;;154    #endif
;;;155    
;;;156        //  pSrc[2u * fftLen] = pSrc[0]; 
;;;157        //  pSrc[(2u * fftLen) + 1u] = pSrc[1]; 
;;;158    
;;;159        pCoefA = &pATable[modifier * 2u];
00000a  eb02058b          ADD      r5,r2,r11,LSL #2
;;;160        pCoefB = &pBTable[modifier * 2u];
00000e  eb03068b          ADD      r6,r3,r11,LSL #2
;;;161    
;;;162        pSrc1 = &pSrc[2];
;;;163        pSrc2 = &pSrc[(2u * fftLen) - 2u];
000012  eb00048e          ADD      r4,r0,lr,LSL #2
000016  1d03              ADDS     r3,r0,#4              ;162
;;;164    
;;;165    #ifndef ARM_MATH_CM0_FAMILY
;;;166    
;;;167        /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;168        i = 1u;
;;;169        pD1 = pDst + 2;
;;;170        pD2 = pDst + (4u * fftLen) - 2;
000018  eb0a02ce          ADD      r2,r10,lr,LSL #3
00001c  4681              MOV      r9,r0                 ;147
00001e  1f12              SUBS     r2,r2,#4
000020  1f24              SUBS     r4,r4,#4
000022  f10a0004          ADD      r0,r10,#4
;;;171    
;;;172        for(i = fftLen - 1; i > 0; i--)
000026  1e49              SUBS     r1,r1,#1
000028  d030              BEQ      |L2.140|
;;;173        {
;;;174            /*    
;;;175            outR = (pSrc[2 * i] * pATable[2 * i] - pSrc[2 * i + 1] * pATable[2 * i + 1]    
;;;176            + pSrc[2 * n - 2 * i] * pBTable[2 * i] +    
;;;177            pSrc[2 * n - 2 * i + 1] * pBTable[2 * i + 1]);    
;;;178            */
;;;179    
;;;180            /* outI = (pIn[2 * i + 1] * pATable[2 * i] + pIn[2 * i] * pATable[2 * i + 1] +    
;;;181            pIn[2 * n - 2 * i] * pBTable[2 * i + 1] -    
;;;182            pIn[2 * n - 2 * i + 1] * pBTable[2 * i]); */
;;;183    
;;;184    
;;;185    #ifndef ARM_MATH_BIG_ENDIAN
;;;186    
;;;187            /* pSrc[2 * i] * pATable[2 * i] - pSrc[2 * i + 1] * pATable[2 * i + 1] */
;;;188            outR = __SMUSD(*__SIMD32(pSrc1), *__SIMD32(pCoefA));
00002a  bf00              NOP      
                  |L2.44|
00002c  f853cb04          LDR      r12,[r3],#4
000030  f8cdc008          STR      r12,[sp,#8]
000034  f8d58000          LDR      r8,[r5,#0]
000038  f8cd8004          STR      r8,[sp,#4]
00003c  fb4cf808          SMUSD    r8,r12,r8
;;;189    
;;;190    #else
;;;191    
;;;192            /* -(pSrc[2 * i + 1] * pATable[2 * i + 1] - pSrc[2 * i] * pATable[2 * i]) */
;;;193            outR = -(__SMUSD(*__SIMD32(pSrc1), *__SIMD32(pCoefA)));
;;;194    
;;;195    #endif /*      #ifndef ARM_MATH_BIG_ENDIAN     */
;;;196    
;;;197            /* pSrc[2 * n - 2 * i] * pBTable[2 * i] +    
;;;198            pSrc[2 * n - 2 * i + 1] * pBTable[2 * i + 1]) */
;;;199            outR = __SMLAD(*__SIMD32(pSrc2), *__SIMD32(pCoefB), outR) >> 16u;
000040  f8547904          LDR      r7,[r4],#-4
000044  f8d6c000          LDR      r12,[r6,#0]
000048  f8cdc000          STR      r12,[sp,#0]
00004c  fb278c0c          SMLAD    r12,r7,r12,r8
000050  ea4f4c1c          LSR      r12,r12,#16
000054  f8cdc00c          STR      r12,[sp,#0xc]
;;;200    
;;;201            /* pIn[2 * n - 2 * i] * pBTable[2 * i + 1] -    
;;;202            pIn[2 * n - 2 * i + 1] * pBTable[2 * i] */
;;;203    
;;;204    #ifndef ARM_MATH_BIG_ENDIAN
;;;205    
;;;206            outI = __SMUSDX(*__SIMD32(pSrc2)--, *__SIMD32(pCoefB));
000058  f8ddc000          LDR      r12,[sp,#0]
00005c  fb47f71c          SMUSDX   r7,r7,r12
000060  e9dd8c01          LDRD     r8,r12,[sp,#4]
;;;207    
;;;208    #else
;;;209    
;;;210            outI = __SMUSDX(*__SIMD32(pCoefB), *__SIMD32(pSrc2)--);
;;;211    
;;;212    #endif /*      #ifndef ARM_MATH_BIG_ENDIAN     */
;;;213    
;;;214            /* (pIn[2 * i + 1] * pATable[2 * i] + pIn[2 * i] * pATable[2 * i + 1] */
;;;215            outI = __SMLADX(*__SIMD32(pSrc1)++, *__SIMD32(pCoefA), outI);
000064  fb2c7718          SMLADX   r7,r12,r8,r7
;;;216    
;;;217            /* write output */
;;;218            *pD1++ = (q15_t) outR;
000068  f8ddc00c          LDR      r12,[sp,#0xc]
00006c  f820cb02          STRH     r12,[r0],#2
;;;219            *pD1++ = outI >> 16u;
000070  143f              ASRS     r7,r7,#16
000072  f8207b02          STRH     r7,[r0],#2
;;;220    
;;;221            /* write complex conjugate output */
;;;222            pD2[0] = (q15_t) outR;
000076  f822cb02          STRH     r12,[r2],#2
;;;223            pD2[1] = -(outI >> 16u);
00007a  427f              RSBS     r7,r7,#0
00007c  f8227906          STRH     r7,[r2],#-6
;;;224            pD2 -= 2;
;;;225    
;;;226            /* update coefficient pointer */
;;;227            pCoefB = pCoefB + (2u * modifier);
000080  eb06068b          ADD      r6,r6,r11,LSL #2
;;;228            pCoefA = pCoefA + (2u * modifier);
000084  eb05058b          ADD      r5,r5,r11,LSL #2
000088  1e49              SUBS     r1,r1,#1
00008a  d1cf              BNE      |L2.44|
                  |L2.140|
;;;229        }
;;;230    
;;;231        pDst[2u * fftLen] = (pSrc[0] - pSrc[1]) >> 1;
00008c  f9b91000          LDRSH    r1,[r9,#0]
000090  f9b90002          LDRSH    r0,[r9,#2]
000094  1a08              SUBS     r0,r1,r0
000096  1042              ASRS     r2,r0,#1
;;;232        pDst[(2u * fftLen) + 1u] = 0;
000098  eb0a018e          ADD      r1,r10,lr,LSL #2
00009c  f82a202e          STRH     r2,[r10,lr,LSL #2]    ;231
0000a0  2000              MOVS     r0,#0
0000a2  8048              STRH     r0,[r1,#2]
;;;233    
;;;234        pDst[0] = (pSrc[0] + pSrc[1]) >> 1;
0000a4  f9b92000          LDRSH    r2,[r9,#0]
0000a8  f9b91002          LDRSH    r1,[r9,#2]
0000ac  4411              ADD      r1,r1,r2
0000ae  104a              ASRS     r2,r1,#1
0000b0  f8aa2000          STRH     r2,[r10,#0]
;;;235        pDst[1] = 0;
0000b4  f8aa0002          STRH     r0,[r10,#2]
;;;236    
;;;237    #else
;;;238    
;;;239        /* Run the below code for Cortex-M0 */
;;;240        i = 1u;
;;;241    
;;;242        while(i < fftLen)
;;;243        {
;;;244            /*    
;;;245            outR = (pSrc[2 * i] * pATable[2 * i] - pSrc[2 * i + 1] * pATable[2 * i + 1]    
;;;246            + pSrc[2 * n - 2 * i] * pBTable[2 * i] +    
;;;247            pSrc[2 * n - 2 * i + 1] * pBTable[2 * i + 1]);    
;;;248            */
;;;249    
;;;250            outR = *pSrc1 * *pCoefA;
;;;251            outR = outR - (*(pSrc1 + 1) * *(pCoefA + 1));
;;;252            outR = outR + (*pSrc2 * *pCoefB);
;;;253            outR = (outR + (*(pSrc2 + 1) * *(pCoefB + 1))) >> 16;
;;;254    
;;;255    
;;;256            /* outI = (pIn[2 * i + 1] * pATable[2 * i] + pIn[2 * i] * pATable[2 * i + 1] +    
;;;257            pIn[2 * n - 2 * i] * pBTable[2 * i + 1] -    
;;;258            pIn[2 * n - 2 * i + 1] * pBTable[2 * i]);   
;;;259            */
;;;260    
;;;261            outI = *pSrc2 * *(pCoefB + 1);
;;;262            outI = outI - (*(pSrc2 + 1) * *pCoefB);
;;;263            outI = outI + (*(pSrc1 + 1) * *pCoefA);
;;;264            outI = outI + (*pSrc1 * *(pCoefA + 1));
;;;265    
;;;266            /* update input pointers */
;;;267            pSrc1 += 2u;
;;;268            pSrc2 -= 2u;
;;;269    
;;;270            /* write output */
;;;271            pDst[2u * i] = (q15_t) outR;
;;;272            pDst[(2u * i) + 1u] = outI >> 16u;
;;;273    
;;;274            /* write complex conjugate output */
;;;275            pDst[(4u * fftLen) - (2u * i)] = (q15_t) outR;
;;;276            pDst[((4u * fftLen) - (2u * i)) + 1u] = -(outI >> 16u);
;;;277    
;;;278            /* update coefficient pointer */
;;;279            pCoefB = pCoefB + (2u * modifier);
;;;280            pCoefA = pCoefA + (2u * modifier);
;;;281    
;;;282            i++;
;;;283        }
;;;284    
;;;285        pDst[2u * fftLen] = (pSrc[0] - pSrc[1]) >> 1;
;;;286        pDst[(2u * fftLen) + 1u] = 0;
;;;287    
;;;288        pDst[0] = (pSrc[0] + pSrc[1]) >> 1;
;;;289        pDst[1] = 0;
;;;290    
;;;291    #endif /* #ifndef ARM_MATH_CM0_FAMILY */
;;;292    }
0000b8  e8bd8fff          POP      {r0-r11,pc}
;;;293    
                          ENDP


                          AREA ||i.arm_split_rifft_q15||, CODE, READONLY, ALIGN=2

                  arm_split_rifft_q15 PROC
;;;305    */
;;;306    void arm_split_rifft_q15(
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;307        q15_t * pSrc,
;;;308        uint32_t fftLen,
;;;309        q15_t * pATable,
;;;310        q15_t * pBTable,
;;;311        q15_t * pDst,
;;;312        uint32_t modifier)
;;;313    {
;;;314        uint32_t i;                                    /* Loop Counter */
;;;315        q31_t outR, outI;                              /* Temporary variables for output */
;;;316        q15_t *pCoefA, *pCoefB;                        /* Temporary pointers for twiddle factors */
;;;317        q15_t *pSrc1, *pSrc2;
;;;318        q15_t *pDst1 = &pDst[0];
;;;319    
;;;320        pCoefA = &pATable[0];
;;;321        pCoefB = &pBTable[0];
;;;322    
;;;323        pSrc1 = &pSrc[0];
;;;324        pSrc2 = &pSrc[2u * fftLen];
000004  eb000581          ADD      r5,r0,r1,LSL #2
000008  e9dd4b09          LDRD     r4,r11,[sp,#0x24]     ;313
00000c  e01e              B        |L3.76|
;;;325    
;;;326    #ifndef ARM_MATH_CM0_FAMILY
;;;327    
;;;328        /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;329        i = fftLen;
;;;330    
;;;331        while(i > 0u)
;;;332        {
;;;333            /*    
;;;334            outR = (pIn[2 * i] * pATable[2 * i] + pIn[2 * i + 1] * pATable[2 * i + 1] +    
;;;335            pIn[2 * n - 2 * i] * pBTable[2 * i] -    
;;;336            pIn[2 * n - 2 * i + 1] * pBTable[2 * i + 1]);    
;;;337    
;;;338            outI = (pIn[2 * i + 1] * pATable[2 * i] - pIn[2 * i] * pATable[2 * i + 1] -    
;;;339            pIn[2 * n - 2 * i] * pBTable[2 * i + 1] -    
;;;340            pIn[2 * n - 2 * i + 1] * pBTable[2 * i]);    
;;;341            */
;;;342    
;;;343    
;;;344    #ifndef ARM_MATH_BIG_ENDIAN
;;;345    
;;;346            /* pIn[2 * n - 2 * i] * pBTable[2 * i] -    
;;;347            pIn[2 * n - 2 * i + 1] * pBTable[2 * i + 1]) */
;;;348            outR = __SMUSD(*__SIMD32(pSrc2), *__SIMD32(pCoefB));
00000e  bf00              NOP      
                  |L3.16|
000010  f855c904          LDR      r12,[r5],#-4
000014  f8d39000          LDR      r9,[r3,#0]
000018  fb4cf809          SMUSD    r8,r12,r9
;;;349    
;;;350    #else
;;;351    
;;;352            /* -(-pIn[2 * n - 2 * i] * pBTable[2 * i] +  
;;;353            pIn[2 * n - 2 * i + 1] * pBTable[2 * i + 1])) */
;;;354            outR = -(__SMUSD(*__SIMD32(pSrc2), *__SIMD32(pCoefB)));
;;;355    
;;;356    #endif /*      #ifndef ARM_MATH_BIG_ENDIAN     */
;;;357    
;;;358            /* pIn[2 * i] * pATable[2 * i] + pIn[2 * i + 1] * pATable[2 * i + 1] +    
;;;359            pIn[2 * n - 2 * i] * pBTable[2 * i] */
;;;360            outR = __SMLAD(*__SIMD32(pSrc1), *__SIMD32(pCoefA), outR) >> 16u;
00001c  f8506b04          LDR      r6,[r0],#4
000020  6817              LDR      r7,[r2,#0]
000022  fb268807          SMLAD    r8,r6,r7,r8
000026  ea4f4a18          LSR      r10,r8,#16
;;;361    
;;;362            /*    
;;;363            -pIn[2 * n - 2 * i] * pBTable[2 * i + 1] +    
;;;364            pIn[2 * n - 2 * i + 1] * pBTable[2 * i] */
;;;365            outI = __SMUADX(*__SIMD32(pSrc2)--, *__SIMD32(pCoefB));
00002a  fb2cfc19          SMUADX   r12,r12,r9
;;;366    
;;;367            /* pIn[2 * i + 1] * pATable[2 * i] - pIn[2 * i] * pATable[2 * i + 1] */
;;;368    
;;;369    #ifndef ARM_MATH_BIG_ENDIAN
;;;370    
;;;371            outI = __SMLSDX(*__SIMD32(pCoefA), *__SIMD32(pSrc1)++, -outI);
00002e  f1cc0c00          RSB      r12,r12,#0
000032  fb47c616          SMLSDX   r6,r7,r6,r12
;;;372    
;;;373    #else
;;;374    
;;;375            outI = __SMLSDX(*__SIMD32(pSrc1)++, *__SIMD32(pCoefA), -outI);
;;;376    
;;;377    #endif /*      #ifndef ARM_MATH_BIG_ENDIAN     */
;;;378            /* write output */
;;;379    
;;;380    #ifndef ARM_MATH_BIG_ENDIAN
;;;381    
;;;382            *__SIMD32(pDst1)++ = __PKHBT(outR, (outI >> 16u), 16);
000036  f36f060f          BFC      r6,#0,#16
00003a  eaca0606          PKHBT    r6,r10,r6
00003e  f8446b04          STR      r6,[r4],#4
;;;383    
;;;384    #else
;;;385    
;;;386            *__SIMD32(pDst1)++ = __PKHBT((outI >> 16u), outR, 16);
;;;387    
;;;388    #endif /*      #ifndef ARM_MATH_BIG_ENDIAN     */
;;;389    
;;;390            /* update coefficient pointer */
;;;391            pCoefB = pCoefB + (2u * modifier);
000042  eb03038b          ADD      r3,r3,r11,LSL #2
;;;392            pCoefA = pCoefA + (2u * modifier);
000046  eb02028b          ADD      r2,r2,r11,LSL #2
00004a  1e49              SUBS     r1,r1,#1
                  |L3.76|
00004c  2900              CMP      r1,#0                 ;331
00004e  d1df              BNE      |L3.16|
;;;393    
;;;394            i--;
;;;395        }
;;;396    #else
;;;397        /* Run the below code for Cortex-M0 */
;;;398        i = fftLen;
;;;399    
;;;400        while(i > 0u)
;;;401        {
;;;402            /*    
;;;403            outR = (pIn[2 * i] * pATable[2 * i] + pIn[2 * i + 1] * pATable[2 * i + 1] +    
;;;404            pIn[2 * n - 2 * i] * pBTable[2 * i] -    
;;;405            pIn[2 * n - 2 * i + 1] * pBTable[2 * i + 1]);    
;;;406            */
;;;407    
;;;408            outR = *pSrc2 * *pCoefB;
;;;409            outR = outR - (*(pSrc2 + 1) * *(pCoefB + 1));
;;;410            outR = outR + (*pSrc1 * *pCoefA);
;;;411            outR = (outR + (*(pSrc1 + 1) * *(pCoefA + 1))) >> 16;
;;;412    
;;;413            /*   
;;;414            outI = (pIn[2 * i + 1] * pATable[2 * i] - pIn[2 * i] * pATable[2 * i + 1] -   
;;;415            pIn[2 * n - 2 * i] * pBTable[2 * i + 1] -   
;;;416            pIn[2 * n - 2 * i + 1] * pBTable[2 * i]);   
;;;417            */
;;;418    
;;;419            outI = *(pSrc1 + 1) * *pCoefA;
;;;420            outI = outI - (*pSrc1 * *(pCoefA + 1));
;;;421            outI = outI - (*pSrc2 * *(pCoefB + 1));
;;;422            outI = outI - (*(pSrc2 + 1) * *(pCoefB));
;;;423    
;;;424            /* update input pointers */
;;;425            pSrc1 += 2u;
;;;426            pSrc2 -= 2u;
;;;427    
;;;428            /* write output */
;;;429            *pDst1++ = (q15_t) outR;
;;;430            *pDst1++ = (q15_t) (outI >> 16);
;;;431    
;;;432            /* update coefficient pointer */
;;;433            pCoefB = pCoefB + (2u * modifier);
;;;434            pCoefA = pCoefA + (2u * modifier);
;;;435    
;;;436            i--;
;;;437        }
;;;438    #endif /* #ifndef ARM_MATH_CM0_FAMILY */
;;;439    }
000050  e8bd8ff0          POP      {r4-r11,pc}
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\TransformFunctions\\arm_rfft_q15.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_arm_rfft_q15_c_65c19725____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___14_arm_rfft_q15_c_65c19725____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_arm_rfft_q15_c_65c19725____REVSH|
#line 144
|__asm___14_arm_rfft_q15_c_65c19725____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___14_arm_rfft_q15_c_65c19725____RRX|
#line 300
|__asm___14_arm_rfft_q15_c_65c19725____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
