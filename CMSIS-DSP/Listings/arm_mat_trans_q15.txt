; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_mat_trans_q15.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_mat_trans_q15.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_mat_trans_q15.crf src\MatrixFunctions\arm_mat_trans_q15.c]
                          THUMB

                          AREA ||i.arm_mat_trans_q15||, CODE, READONLY, ALIGN=2

                  arm_mat_trans_q15 PROC
;;;59     
;;;60     arm_status arm_mat_trans_q15(
000000  b5f0              PUSH     {r4-r7,lr}
;;;61       const arm_matrix_instance_q15 * pSrc,
;;;62       arm_matrix_instance_q15 * pDst)
;;;63     {
;;;64       q15_t *pSrcA = pSrc->pData;                    /* input data matrix pointer */
;;;65       q15_t *pOut = pDst->pData;                     /* output data matrix pointer */
;;;66       uint16_t nRows = pSrc->numRows;                /* number of nRows */
000002  8802              LDRH     r2,[r0,#0]
;;;67       uint16_t nColumns = pSrc->numCols;             /* number of nColumns */
000004  f8b0e002          LDRH     lr,[r0,#2]
;;;68       uint16_t col, row = nRows, i = 0u;             /* row and column loop counters */
;;;69       arm_status status;                             /* status of matrix transpose */
;;;70     
;;;71     #ifndef ARM_MATH_CM0_FAMILY
;;;72     
;;;73       /* Run the below code for Cortex-M4 and Cortex-M3 */
;;;74     #ifndef UNALIGNED_SUPPORT_DISABLE
;;;75     
;;;76       q31_t in;                                      /* variable to hold temporary output  */
;;;77     
;;;78     #else
;;;79     
;;;80       q15_t in;
;;;81     
;;;82     #endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE	*/
;;;83     
;;;84     #ifdef ARM_MATH_MATRIX_CHECK
;;;85     
;;;86     
;;;87       /* Check for matrix mismatch condition */
;;;88       if((pSrc->numRows != pDst->numCols) || (pSrc->numCols != pDst->numRows))
;;;89       {
;;;90         /* Set status as ARM_MATH_SIZE_MISMATCH */
;;;91         status = ARM_MATH_SIZE_MISMATCH;
;;;92       }
;;;93       else
;;;94     #endif /*      #ifdef ARM_MATH_MATRIX_CHECK    */
;;;95     
;;;96       {
;;;97         /* Matrix transpose by exchanging the rows with columns */
;;;98         /* row loop     */
;;;99         do
;;;100        {
;;;101    
;;;102          /* Apply loop unrolling and exchange the columns with row elements */
;;;103          col = nColumns >> 2u;
000008  6843              LDR      r3,[r0,#4]
00000a  4614              MOV      r4,r2                 ;68
00000c  2600              MOVS     r6,#0                 ;68
00000e  ea4f0c9e          LSR      r12,lr,#2
                  |L1.18|
;;;104    
;;;105          /* The pointer pOut is set to starting address of the column being processed */
;;;106          pOut = pDst->pData + i;
000012  6848              LDR      r0,[r1,#4]
000014  4665              MOV      r5,r12                ;103
000016  eb000046          ADD      r0,r0,r6,LSL #1
;;;107    
;;;108          /* First part of the processing with loop unrolling.  Compute 4 outputs at a time.    
;;;109           ** a second loop below computes the remaining 1 to 3 samples. */
;;;110          while(col > 0u)
00001a  e013              B        |L1.68|
                  |L1.28|
;;;111          {
;;;112    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;113    
;;;114            /* Read two elements from the row */
;;;115            in = *__SIMD32(pSrcA)++;
00001c  f8537b04          LDR      r7,[r3],#4
;;;116    
;;;117            /* Unpack and store one element in the destination */
;;;118    #ifndef ARM_MATH_BIG_ENDIAN
;;;119    
;;;120            *pOut = (q15_t) in;
000020  8007              STRH     r7,[r0,#0]
;;;121    
;;;122    #else
;;;123    
;;;124            *pOut = (q15_t) ((in & (q31_t) 0xffff0000) >> 16);
;;;125    
;;;126    #endif /*    #ifndef ARM_MATH_BIG_ENDIAN    */
;;;127    
;;;128            /* Update the pointer pOut to point to the next row of the transposed matrix */
;;;129            pOut += nRows;
000022  eb000042          ADD      r0,r0,r2,LSL #1
;;;130    
;;;131            /* Unpack and store the second element in the destination */
;;;132    
;;;133    #ifndef ARM_MATH_BIG_ENDIAN
;;;134    
;;;135            *pOut = (q15_t) ((in & (q31_t) 0xffff0000) >> 16);
000026  143f              ASRS     r7,r7,#16
000028  8007              STRH     r7,[r0,#0]
;;;136    
;;;137    #else
;;;138    
;;;139            *pOut = (q15_t) in;
;;;140    
;;;141    #endif /*    #ifndef ARM_MATH_BIG_ENDIAN    */
;;;142    
;;;143            /* Update the pointer pOut to point to the next row of the transposed matrix */
;;;144            pOut += nRows;
00002a  eb000742          ADD      r7,r0,r2,LSL #1
;;;145    
;;;146            /* Read two elements from the row */
;;;147    #ifndef ARM_MATH_BIG_ENDIAN
;;;148    
;;;149            in = *__SIMD32(pSrcA)++;
00002e  f8530b04          LDR      r0,[r3],#4
;;;150    
;;;151    #else
;;;152    
;;;153            in = *__SIMD32(pSrcA)++;
;;;154    
;;;155    #endif /*    #ifndef ARM_MATH_BIG_ENDIAN    */
;;;156    
;;;157            /* Unpack and store one element in the destination */
;;;158    #ifndef ARM_MATH_BIG_ENDIAN
;;;159    
;;;160            *pOut = (q15_t) in;
000032  8038              STRH     r0,[r7,#0]
;;;161    
;;;162    #else
;;;163    
;;;164            *pOut = (q15_t) ((in & (q31_t) 0xffff0000) >> 16);
;;;165    
;;;166    #endif /*    #ifndef ARM_MATH_BIG_ENDIAN    */
;;;167    
;;;168            /* Update the pointer pOut to point to the next row of the transposed matrix */
;;;169            pOut += nRows;
;;;170    
;;;171            /* Unpack and store the second element in the destination */
;;;172    #ifndef ARM_MATH_BIG_ENDIAN
;;;173    
;;;174            *pOut = (q15_t) ((in & (q31_t) 0xffff0000) >> 16);
000034  1400              ASRS     r0,r0,#16
000036  eb070742          ADD      r7,r7,r2,LSL #1       ;169
;;;175    
;;;176    #else
;;;177    
;;;178            *pOut = (q15_t) in;
;;;179    
;;;180    #endif /*    #ifndef ARM_MATH_BIG_ENDIAN    */
;;;181    
;;;182    #else	 
;;;183            /* Read one element from the row */
;;;184            in = *pSrcA++;
;;;185    
;;;186            /* Store one element in the destination */
;;;187            *pOut = in;
;;;188     
;;;189            /* Update the pointer px to point to the next row of the transposed matrix */
;;;190            pOut += nRows;
;;;191    
;;;192            /* Read one element from the row */
;;;193            in = *pSrcA++;
;;;194    
;;;195            /* Store one element in the destination */
;;;196            *pOut = in;
;;;197     
;;;198            /* Update the pointer px to point to the next row of the transposed matrix */
;;;199            pOut += nRows;
;;;200    
;;;201            /* Read one element from the row */
;;;202            in = *pSrcA++;
;;;203    
;;;204            /* Store one element in the destination */
;;;205            *pOut = in;
;;;206     
;;;207            /* Update the pointer px to point to the next row of the transposed matrix */
;;;208            pOut += nRows;
;;;209    
;;;210            /* Read one element from the row */
;;;211            in = *pSrcA++;
;;;212    
;;;213            /* Store one element in the destination */
;;;214            *pOut = in;
;;;215    
;;;216    #endif	/*	#ifndef UNALIGNED_SUPPORT_DISABLE	*/
;;;217    
;;;218            /* Update the pointer pOut to point to the next row of the transposed matrix */
;;;219            pOut += nRows;
00003a  1e6d              SUBS     r5,r5,#1
00003c  8038              STRH     r0,[r7,#0]            ;174
00003e  eb070042          ADD      r0,r7,r2,LSL #1
;;;220    
;;;221            /* Decrement the column loop counter */
;;;222            col--;
000042  b2ad              UXTH     r5,r5
                  |L1.68|
000044  2d00              CMP      r5,#0                 ;110
000046  d1e9              BNE      |L1.28|
;;;223          }
;;;224    
;;;225          /* Perform matrix transpose for last 3 samples here. */
;;;226          col = nColumns % 0x4u;
000048  f00e0503          AND      r5,lr,#3
;;;227    
;;;228    #else
;;;229    
;;;230      /* Run the below code for Cortex-M0 */
;;;231    
;;;232    #ifdef ARM_MATH_MATRIX_CHECK
;;;233    
;;;234      /* Check for matrix mismatch condition */
;;;235      if((pSrc->numRows != pDst->numCols) || (pSrc->numCols != pDst->numRows))
;;;236      {
;;;237        /* Set status as ARM_MATH_SIZE_MISMATCH */
;;;238        status = ARM_MATH_SIZE_MISMATCH;
;;;239      }
;;;240      else
;;;241    #endif /*    #ifdef ARM_MATH_MATRIX_CHECK    */
;;;242    
;;;243      {
;;;244        /* Matrix transpose by exchanging the rows with columns */
;;;245        /* row loop     */
;;;246        do
;;;247        {
;;;248          /* The pointer pOut is set to starting address of the column being processed */
;;;249          pOut = pDst->pData + i;
;;;250    
;;;251          /* Initialize column loop counter */
;;;252          col = nColumns;
;;;253    
;;;254    #endif /* #ifndef ARM_MATH_CM0_FAMILY */
;;;255    
;;;256          while(col > 0u)
00004c  e007              B        |L1.94|
;;;257          {
;;;258            /* Read and store the input element in the destination */
;;;259            *pOut = *pSrcA++;
00004e  bf00              NOP      
                  |L1.80|
000050  f8337b02          LDRH     r7,[r3],#2
000054  8007              STRH     r7,[r0,#0]
;;;260    
;;;261            /* Update the pointer pOut to point to the next row of the transposed matrix */
;;;262            pOut += nRows;
000056  1e6d              SUBS     r5,r5,#1
000058  eb000042          ADD      r0,r0,r2,LSL #1
;;;263    
;;;264            /* Decrement the column loop counter */
;;;265            col--;
00005c  b2ad              UXTH     r5,r5
                  |L1.94|
00005e  2d00              CMP      r5,#0                 ;256
000060  d1f6              BNE      |L1.80|
000062  1c76              ADDS     r6,r6,#1              ;256
;;;266          }
;;;267    
;;;268          i++;
000064  1e64              SUBS     r4,r4,#1
;;;269    
;;;270          /* Decrement the row loop counter */
;;;271          row--;
000066  0424              LSLS     r4,r4,#16
000068  b2b6              UXTH     r6,r6                 ;268
00006a  0c24              LSRS     r4,r4,#16
;;;272    
;;;273        } while(row > 0u);
00006c  d1d1              BNE      |L1.18|
;;;274    
;;;275        /* set status as ARM_MATH_SUCCESS */
;;;276        status = ARM_MATH_SUCCESS;
00006e  2000              MOVS     r0,#0
;;;277      }
;;;278      /* Return to application */
;;;279      return (status);
;;;280    }
000070  bdf0              POP      {r4-r7,pc}
;;;281    
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\MatrixFunctions\\arm_mat_trans_q15.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_mat_trans_q15_c_e2cdbcaf____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___19_arm_mat_trans_q15_c_e2cdbcaf____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_mat_trans_q15_c_e2cdbcaf____REVSH|
#line 144
|__asm___19_arm_mat_trans_q15_c_e2cdbcaf____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_arm_mat_trans_q15_c_e2cdbcaf____RRX|
#line 300
|__asm___19_arm_mat_trans_q15_c_e2cdbcaf____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
