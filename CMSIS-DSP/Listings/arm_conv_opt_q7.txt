; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\arm_conv_opt_q7.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\arm_conv_opt_q7.d --cpu=Cortex-M4.fp --apcs=interwork -O3 --diag_suppress=9931 -I.\inc -I"C:\Users\emh203\Google Drive\Teaching\EE403W\Spring 2017\Labs\Lab 4\CMSIS-DSP\RTE\_CMSIS_DSP_4_5_O3" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.0\Device\ARM\ARMCM4\Include -IC:\Keil_v5\ARM\CMSIS\Include -D__UVISION_VERSION=522 -DARMCM4_FP -D__FPU_PRESENT=1 -DARM_MATH_CM4 -D__CC_ARM --omf_browse=.\objects\arm_conv_opt_q7.crf src\FilteringFunctions\arm_conv_opt_q7.c]
                          THUMB

                          AREA ||i.arm_conv_opt_q7||, CODE, READONLY, ALIGN=2

                  arm_conv_opt_q7 PROC
;;;78     
;;;79     void arm_conv_opt_q7(
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;80       q7_t * pSrcA,
;;;81       uint32_t srcALen,
;;;82       q7_t * pSrcB,
;;;83       uint32_t srcBLen,
;;;84       q7_t * pDst,
;;;85       q15_t * pScratch1,
;;;86       q15_t * pScratch2)
;;;87     {
000004  b085              SUB      sp,sp,#0x14
000006  460f              MOV      r7,r1
000008  461d              MOV      r5,r3
;;;88     
;;;89       q15_t *pScr2, *pScr1;                          /* Intermediate pointers for scratch pointers */
;;;90       q15_t x4;                                      /* Temporary input variable */
;;;91       q7_t *pIn1, *pIn2;                             /* inputA and inputB pointer */
;;;92       uint32_t j, k, blkCnt, tapCnt;                 /* loop counter */
;;;93       q7_t *px;                                      /* Temporary input1 pointer */
;;;94       q15_t *py;                                     /* Temporary input2 pointer */
;;;95       q31_t acc0, acc1, acc2, acc3;                  /* Accumulator */
;;;96       q31_t x1, x2, x3, y1;                          /* Temporary input variables */
;;;97       q7_t *pOut = pDst;                             /* output pointer */
00000a  9c10              LDR      r4,[sp,#0x40]
00000c  990e              LDR      r1,[sp,#0x38]
;;;98       q7_t out0, out1, out2, out3;                   /* temporary variables */
;;;99     
;;;100      /* The algorithm implementation is based on the lengths of the inputs. */
;;;101      /* srcB is always made to slide across srcA. */
;;;102      /* So srcBLen is always considered as shorter or equal to srcALen */
;;;103      if(srcALen >= srcBLen)
00000e  9100              STR      r1,[sp,#0]
000010  42af              CMP      r7,r5
000012  d301              BCC      |L1.24|
;;;104      {
;;;105        /* Initialization of inputA pointer */
;;;106        pIn1 = pSrcA;
000014  4606              MOV      r6,r0
;;;107    
;;;108        /* Initialization of inputB pointer */
;;;109        pIn2 = pSrcB;
000016  e003              B        |L1.32|
                  |L1.24|
;;;110      }
;;;111      else
;;;112      {
;;;113        /* Initialization of inputA pointer */
;;;114        pIn1 = pSrcB;
000018  4616              MOV      r6,r2
;;;115    
;;;116        /* Initialization of inputB pointer */
;;;117        pIn2 = pSrcA;
;;;118    
;;;119        /* srcBLen is always considered as shorter or equal to srcALen */
;;;120        j = srcBLen;
;;;121        srcBLen = srcALen;
00001a  463d              MOV      r5,r7
00001c  4602              MOV      r2,r0                 ;117
;;;122        srcALen = j;
00001e  461f              MOV      r7,r3
                  |L1.32|
;;;123      }
;;;124    
;;;125      /* pointer to take end of scratch2 buffer */
;;;126      pScr2 = pScratch2;
;;;127    
;;;128      /* points to smaller length sequence */
;;;129      px = pIn2 + srcBLen - 1;
000020  1951              ADDS     r1,r2,r5
;;;130    
;;;131      /* Apply loop unrolling and do 4 Copies simultaneously. */
;;;132      k = srcBLen >> 2u;
000022  08aa              LSRS     r2,r5,#2
000024  4620              MOV      r0,r4                 ;126
000026  1e49              SUBS     r1,r1,#1
;;;133    
;;;134      /* First part of the processing with loop unrolling copies 4 data points at a time.       
;;;135       ** a second loop below copies for the remaining 1 to 3 samples. */
;;;136      while(k > 0u)
000028  9204              STR      r2,[sp,#0x10]
00002a  e011              B        |L1.80|
                  |L1.44|
;;;137      {
;;;138        /* copy second buffer in reversal manner */
;;;139        x4 = (q15_t) * px--;
00002c  f991c000          LDRSB    r12,[r1,#0]
;;;140        *pScr2++ = x4;
000030  f820cb02          STRH     r12,[r0],#2
;;;141        x4 = (q15_t) * px--;
000034  f911cc01          LDRSB    r12,[r1,#-1]
;;;142        *pScr2++ = x4;
000038  f820cb02          STRH     r12,[r0],#2
;;;143        x4 = (q15_t) * px--;
00003c  f911cc02          LDRSB    r12,[r1,#-2]
;;;144        *pScr2++ = x4;
000040  f820cb04          STRH     r12,[r0],#4
;;;145        x4 = (q15_t) * px--;
000044  f9113c03          LDRSB    r3,[r1,#-3]
;;;146        *pScr2++ = x4;
000048  1f09              SUBS     r1,r1,#4
00004a  f8203c02          STRH     r3,[r0,#-2]
00004e  1e52              SUBS     r2,r2,#1
                  |L1.80|
000050  2a00              CMP      r2,#0                 ;136
000052  d1eb              BNE      |L1.44|
;;;147    
;;;148        /* Decrement the loop counter */
;;;149        k--;
;;;150      }
;;;151    
;;;152      /* If the count is not a multiple of 4, copy remaining samples here.       
;;;153       ** No loop unrolling is used. */
;;;154      k = srcBLen % 0x4u;
000054  f0050203          AND      r2,r5,#3
;;;155    
;;;156      while(k > 0u)
000058  9203              STR      r2,[sp,#0xc]
00005a  e004              B        |L1.102|
                  |L1.92|
;;;157      {
;;;158        /* copy second buffer in reversal manner for remaining samples */
;;;159        x4 = (q15_t) * px--;
00005c  f9113901          LDRSB    r3,[r1],#-1
;;;160        *pScr2++ = x4;
000060  f8203b02          STRH     r3,[r0],#2
000064  1e52              SUBS     r2,r2,#1
                  |L1.102|
000066  2a00              CMP      r2,#0                 ;156
000068  d1f8              BNE      |L1.92|
;;;161    
;;;162        /* Decrement the loop counter */
;;;163        k--;
;;;164      }
;;;165    
;;;166      /* Initialze temporary scratch pointer */
;;;167      pScr1 = pScratch1;
;;;168    
;;;169      /* Fill (srcBLen - 1u) zeros in scratch buffer */
;;;170      arm_fill_q15(0, pScr1, (srcBLen - 1u));
00006a  f8dd803c          LDR      r8,[sp,#0x3c]
00006e  1e6a              SUBS     r2,r5,#1
000070  4641              MOV      r1,r8
000072  2000              MOVS     r0,#0
000074  f7fffffe          BL       arm_fill_q15
;;;171    
;;;172      /* Update temporary scratch pointer */
;;;173      pScr1 += (srcBLen - 1u);
000078  eb080145          ADD      r1,r8,r5,LSL #1
;;;174    
;;;175      /* Copy (srcALen) samples in scratch buffer */
;;;176      /* Apply loop unrolling and do 4 Copies simultaneously. */
;;;177      k = srcALen >> 2u;
00007c  08b8              LSRS     r0,r7,#2
00007e  1e89              SUBS     r1,r1,#2
;;;178    
;;;179      /* First part of the processing with loop unrolling copies 4 data points at a time.       
;;;180       ** a second loop below copies for the remaining 1 to 3 samples. */
;;;181      while(k > 0u)
000080  e011              B        |L1.166|
;;;182      {
;;;183        /* copy second buffer in reversal manner */
;;;184        x4 = (q15_t) * pIn1++;
000082  bf00              NOP      
                  |L1.132|
000084  f9162b01          LDRSB    r2,[r6],#1
;;;185        *pScr1++ = x4;
000088  f8212b02          STRH     r2,[r1],#2
;;;186        x4 = (q15_t) * pIn1++;
00008c  f9162b01          LDRSB    r2,[r6],#1
;;;187        *pScr1++ = x4;
000090  f8212b02          STRH     r2,[r1],#2
;;;188        x4 = (q15_t) * pIn1++;
000094  f9162b02          LDRSB    r2,[r6],#2
;;;189        *pScr1++ = x4;
000098  f8212b04          STRH     r2,[r1],#4
;;;190        x4 = (q15_t) * pIn1++;
00009c  f9162c01          LDRSB    r2,[r6,#-1]
;;;191        *pScr1++ = x4;
0000a0  f8212c02          STRH     r2,[r1,#-2]
0000a4  1e40              SUBS     r0,r0,#1
                  |L1.166|
0000a6  2800              CMP      r0,#0                 ;181
0000a8  d1ec              BNE      |L1.132|
;;;192    
;;;193        /* Decrement the loop counter */
;;;194        k--;
;;;195      }
;;;196    
;;;197      /* If the count is not a multiple of 4, copy remaining samples here.       
;;;198       ** No loop unrolling is used. */
;;;199      k = srcALen % 0x4u;
0000aa  f0070003          AND      r0,r7,#3
;;;200    
;;;201      while(k > 0u)
0000ae  e004              B        |L1.186|
                  |L1.176|
;;;202      {
;;;203        /* copy second buffer in reversal manner for remaining samples */
;;;204        x4 = (q15_t) * pIn1++;
0000b0  f9162b01          LDRSB    r2,[r6],#1
;;;205        *pScr1++ = x4;
0000b4  f8212b02          STRH     r2,[r1],#2
0000b8  1e40              SUBS     r0,r0,#1
                  |L1.186|
0000ba  2800              CMP      r0,#0                 ;201
0000bc  d1f8              BNE      |L1.176|
;;;206    
;;;207        /* Decrement the loop counter */
;;;208        k--;
;;;209      }
;;;210    
;;;211    #ifndef UNALIGNED_SUPPORT_DISABLE
;;;212    
;;;213      /* Fill (srcBLen - 1u) zeros at end of scratch buffer */
;;;214      arm_fill_q15(0, pScr1, (srcBLen - 1u));
0000be  1e6a              SUBS     r2,r5,#1
0000c0  f7fffffe          BL       arm_fill_q15
;;;215    
;;;216      /* Update pointer */
;;;217      pScr1 += (srcBLen - 1u);
;;;218    
;;;219    #else
;;;220    
;;;221      /* Apply loop unrolling and do 4 Copies simultaneously. */
;;;222      k = (srcBLen - 1u) >> 2u;
;;;223    
;;;224      /* First part of the processing with loop unrolling copies 4 data points at a time.       
;;;225       ** a second loop below copies for the remaining 1 to 3 samples. */
;;;226      while(k > 0u)
;;;227      {
;;;228        /* copy second buffer in reversal manner */
;;;229        *pScr1++ = 0;
;;;230        *pScr1++ = 0;
;;;231        *pScr1++ = 0;
;;;232        *pScr1++ = 0;
;;;233    
;;;234        /* Decrement the loop counter */
;;;235        k--;
;;;236      }
;;;237    
;;;238      /* If the count is not a multiple of 4, copy remaining samples here.       
;;;239       ** No loop unrolling is used. */
;;;240      k = (srcBLen - 1u) % 0x4u;
;;;241    
;;;242      while(k > 0u)
;;;243      {
;;;244        /* copy second buffer in reversal manner for remaining samples */
;;;245        *pScr1++ = 0;
;;;246    
;;;247        /* Decrement the loop counter */
;;;248        k--;
;;;249      }
;;;250    
;;;251    #endif
;;;252    
;;;253      /* Temporary pointer for scratch2 */
;;;254      py = pScratch2;
;;;255    
;;;256      /* Initialization of pIn2 pointer */
;;;257      pIn2 = (q7_t *) py;
;;;258    
;;;259      pScr2 = py;
;;;260    
;;;261      /* Actual convolution process starts here */
;;;262      blkCnt = (srcALen + srcBLen - 1u) >> 2;
0000c4  1978              ADDS     r0,r7,r5
0000c6  1e40              SUBS     r0,r0,#1
0000c8  e9cd4001          STRD     r4,r0,[sp,#4]
0000cc  ea4f0e90          LSR      lr,r0,#2
;;;263    
;;;264      while(blkCnt > 0)
0000d0  e069              B        |L1.422|
                  |L1.210|
;;;265      {
;;;266        /* Initialze temporary scratch pointer as scratch1 */
;;;267        pScr1 = pScratch1;
;;;268    
;;;269        /* Clear Accumlators */
;;;270        acc0 = 0;
;;;271        acc1 = 0;
;;;272        acc2 = 0;
;;;273        acc3 = 0;
;;;274    
;;;275        /* Read two samples from scratch1 buffer */
;;;276        x1 = *__SIMD32(pScr1)++;
0000d2  9f0f              LDR      r7,[sp,#0x3c]
0000d4  2200              MOVS     r2,#0                 ;270
0000d6  4613              MOV      r3,r2                 ;271
0000d8  f8571b04          LDR      r1,[r7],#4
0000dc  4694              MOV      r12,r2                ;272
;;;277    
;;;278        /* Read next two samples from scratch1 buffer */
;;;279        x2 = *__SIMD32(pScr1)++;
0000de  f8570b04          LDR      r0,[r7],#4
0000e2  46bb              MOV      r11,r7
0000e4  4616              MOV      r6,r2                 ;273
;;;280    
;;;281        tapCnt = (srcBLen) >> 2u;
;;;282    
;;;283        while(tapCnt > 0u)
0000e6  9f04              LDR      r7,[sp,#0x10]
0000e8  e023              B        |L1.306|
;;;284        {
;;;285    
;;;286          /* Read four samples from smaller buffer */
;;;287          y1 = _SIMD32_OFFSET(pScr2);
0000ea  bf00              NOP      
                  |L1.236|
0000ec  f8547b04          LDR      r7,[r4],#4
;;;288    
;;;289          /* multiply and accumlate */
;;;290          acc0 = __SMLAD(x1, y1, acc0);
0000f0  fb212207          SMLAD    r2,r1,r7,r2
;;;291          acc2 = __SMLAD(x2, y1, acc2);
0000f4  fb20cc07          SMLAD    r12,r0,r7,r12
;;;292    
;;;293          /* pack input data */
;;;294    #ifndef ARM_MATH_BIG_ENDIAN
;;;295          x3 = __PKHBT(x2, x1, 0);
0000f8  eac00101          PKHBT    r1,r0,r1
;;;296    #else
;;;297          x3 = __PKHBT(x1, x2, 0);
;;;298    #endif
;;;299    
;;;300          /* multiply and accumlate */
;;;301          acc1 = __SMLADX(x3, y1, acc1);
0000fc  fb213917          SMLADX   r9,r1,r7,r3
;;;302    
;;;303          /* Read next two samples from scratch1 buffer */
;;;304          x1 = *__SIMD32(pScr1)++;
000100  f8db1000          LDR      r1,[r11,#0]
000104  f10b0804          ADD      r8,r11,#4
;;;305    
;;;306          /* pack input data */
;;;307    #ifndef ARM_MATH_BIG_ENDIAN
;;;308          x3 = __PKHBT(x1, x2, 0);
000108  eac10300          PKHBT    r3,r1,r0
;;;309    #else
;;;310          x3 = __PKHBT(x2, x1, 0);
;;;311    #endif
;;;312    
;;;313          acc3 = __SMLADX(x3, y1, acc3);
00010c  fb236717          SMLADX   r7,r3,r7,r6
;;;314    
;;;315          /* Read four samples from smaller buffer */
;;;316          y1 = _SIMD32_OFFSET(pScr2 + 2u);
000110  f8546b04          LDR      r6,[r4],#4
;;;317    
;;;318          acc0 = __SMLAD(x2, y1, acc0);
000114  fb202206          SMLAD    r2,r0,r6,r2
;;;319    
;;;320          acc2 = __SMLAD(x1, y1, acc2);
000118  fb21cc06          SMLAD    r12,r1,r6,r12
;;;321    
;;;322          acc1 = __SMLADX(x3, y1, acc1);
00011c  fb239316          SMLADX   r3,r3,r6,r9
;;;323    
;;;324          x2 = *__SIMD32(pScr1)++;
000120  f8580b04          LDR      r0,[r8],#4
000124  46c3              MOV      r11,r8
;;;325    
;;;326    #ifndef ARM_MATH_BIG_ENDIAN
;;;327          x3 = __PKHBT(x2, x1, 0);
000126  eac00801          PKHBT    r8,r0,r1
;;;328    #else
;;;329          x3 = __PKHBT(x1, x2, 0);
;;;330    #endif
;;;331    
;;;332          acc3 = __SMLADX(x3, y1, acc3);
00012a  fb287616          SMLADX   r6,r8,r6,r7
;;;333    
;;;334          pScr2 += 4u;
;;;335    
;;;336    
;;;337          /* Decrement the loop counter */
;;;338          tapCnt--;
00012e  f1aa0701          SUB      r7,r10,#1
                  |L1.306|
000132  ea5f0a07          MOVS     r10,r7                ;281
000136  d1d9              BNE      |L1.236|
;;;339        }
;;;340    
;;;341    
;;;342    
;;;343        /* Update scratch pointer for remaining samples of smaller length sequence */
;;;344        pScr1 -= 4u;
000138  f1ab0808          SUB      r8,r11,#8
;;;345    
;;;346    
;;;347        /* apply same above for remaining samples of smaller length sequence */
;;;348        tapCnt = (srcBLen) & 3u;
;;;349    
;;;350        while(tapCnt > 0u)
00013c  9803              LDR      r0,[sp,#0xc]
00013e  e012              B        |L1.358|
                  |L1.320|
;;;351        {
;;;352    
;;;353          /* accumlate the results */
;;;354          acc0 += (*pScr1++ * *pScr2);
000140  f8387b02          LDRH     r7,[r8],#2
000144  f8341b02          LDRH     r1,[r4],#2
000148  fb172201          SMLABB   r2,r7,r1,r2
;;;355          acc1 += (*pScr1++ * *pScr2);
00014c  f8b87000          LDRH     r7,[r8,#0]
000150  fb173301          SMLABB   r3,r7,r1,r3
;;;356          acc2 += (*pScr1++ * *pScr2);
000154  f8b87002          LDRH     r7,[r8,#2]
000158  fb17cc01          SMLABB   r12,r7,r1,r12
;;;357          acc3 += (*pScr1++ * *pScr2++);
00015c  f8b87004          LDRH     r7,[r8,#4]
000160  fb176601          SMLABB   r6,r7,r1,r6
000164  1e40              SUBS     r0,r0,#1
                  |L1.358|
000166  2800              CMP      r0,#0                 ;350
000168  d1ea              BNE      |L1.320|
;;;358    
;;;359          pScr1 -= 3u;
;;;360    
;;;361          /* Decrement the loop counter */
;;;362          tapCnt--;
;;;363        }
;;;364    
;;;365        blkCnt--;
;;;366    
;;;367        /* Store the result in the accumulator in the destination buffer. */
;;;368        out0 = (q7_t) (__SSAT(acc0 >> 7u, 8));
00016a  f32210c7          SSAT     r0,#8,r2,ASR #7
;;;369        out1 = (q7_t) (__SSAT(acc1 >> 7u, 8));
00016e  f32311c7          SSAT     r1,#8,r3,ASR #7
;;;370        out2 = (q7_t) (__SSAT(acc2 >> 7u, 8));
;;;371        out3 = (q7_t) (__SSAT(acc3 >> 7u, 8));
;;;372    
;;;373        *__SIMD32(pOut)++ = __PACKq7(out0, out1, out2, out3);
000172  f64f74ff          MOV      r4,#0xffff
000176  b2c0              UXTB     r0,r0
000178  ea042101          AND      r1,r4,r1,LSL #8
00017c  f32c12c7          SSAT     r2,#8,r12,ASR #7      ;370
000180  4308              ORRS     r0,r0,r1
000182  b2d1              UXTB     r1,r2
000184  f32613c7          SSAT     r3,#8,r6,ASR #7       ;371
000188  ea404001          ORR      r0,r0,r1,LSL #16
00018c  ea406103          ORR      r1,r0,r3,LSL #24
000190  9800              LDR      r0,[sp,#0]
000192  f1ae0e01          SUB      lr,lr,#1              ;365
000196  6001              STR      r1,[r0,#0]
000198  9800              LDR      r0,[sp,#0]
;;;374    
;;;375        /* Initialization of inputB pointer */
;;;376        pScr2 = py;
;;;377    
;;;378        pScratch1 += 4u;
00019a  9c01              LDR      r4,[sp,#4]
00019c  1d00              ADDS     r0,r0,#4              ;373
00019e  9000              STR      r0,[sp,#0]            ;376
0001a0  980f              LDR      r0,[sp,#0x3c]
0001a2  3008              ADDS     r0,r0,#8
0001a4  900f              STR      r0,[sp,#0x3c]
                  |L1.422|
0001a6  f1be0f00          CMP      lr,#0                 ;264
0001aa  d192              BNE      |L1.210|
;;;379    
;;;380      }
;;;381    
;;;382    
;;;383      blkCnt = (srcALen + srcBLen - 1u) & 0x3;
0001ac  9802              LDR      r0,[sp,#8]
0001ae  f0000203          AND      r2,r0,#3
;;;384    
;;;385      /* Calculate convolution for remaining samples of Bigger length sequence */
;;;386      while(blkCnt > 0)
0001b2  e02a              B        |L1.522|
                  |L1.436|
;;;387      {
;;;388        /* Initialze temporary scratch pointer as scratch1 */
;;;389        pScr1 = pScratch1;
;;;390    
;;;391        /* Clear Accumlators */
;;;392        acc0 = 0;
0001b4  2100              MOVS     r1,#0
;;;393    
;;;394        tapCnt = (srcBLen) >> 1u;
0001b6  086b              LSRS     r3,r5,#1
;;;395    
;;;396        while(tapCnt > 0u)
0001b8  980f              LDR      r0,[sp,#0x3c]
0001ba  e00c              B        |L1.470|
                  |L1.444|
;;;397        {
;;;398          acc0 += (*pScr1++ * *pScr2++);
0001bc  f8307b02          LDRH     r7,[r0],#2
0001c0  f8346b02          LDRH     r6,[r4],#2
0001c4  fb171106          SMLABB   r1,r7,r6,r1
;;;399          acc0 += (*pScr1++ * *pScr2++);
0001c8  f8307b02          LDRH     r7,[r0],#2
0001cc  f8346b02          LDRH     r6,[r4],#2
0001d0  fb171106          SMLABB   r1,r7,r6,r1
0001d4  1e5b              SUBS     r3,r3,#1
                  |L1.470|
0001d6  2b00              CMP      r3,#0                 ;396
0001d8  d1f0              BNE      |L1.444|
;;;400    
;;;401          /* Decrement the loop counter */
;;;402          tapCnt--;
;;;403        }
;;;404    
;;;405        tapCnt = (srcBLen) & 1u;
0001da  f0050301          AND      r3,r5,#1
;;;406    
;;;407        /* apply same above for remaining samples of smaller length sequence */
;;;408        while(tapCnt > 0u)
0001de  e006              B        |L1.494|
                  |L1.480|
;;;409        {
;;;410    
;;;411          /* accumlate the results */
;;;412          acc0 += (*pScr1++ * *pScr2++);
0001e0  f8307b02          LDRH     r7,[r0],#2
0001e4  f8346b02          LDRH     r6,[r4],#2
0001e8  fb171106          SMLABB   r1,r7,r6,r1
0001ec  1e5b              SUBS     r3,r3,#1
                  |L1.494|
0001ee  2b00              CMP      r3,#0                 ;408
0001f0  d1f6              BNE      |L1.480|
;;;413    
;;;414          /* Decrement the loop counter */
;;;415          tapCnt--;
;;;416        }
;;;417    
;;;418        blkCnt--;
;;;419    
;;;420        /* Store the result in the accumulator in the destination buffer. */
;;;421        *pOut++ = (q7_t) (__SSAT(acc0 >> 7u, 8));
0001f2  9800              LDR      r0,[sp,#0]
0001f4  f32111c7          SSAT     r1,#8,r1,ASR #7
0001f8  7001              STRB     r1,[r0,#0]
0001fa  9800              LDR      r0,[sp,#0]
;;;422    
;;;423        /* Initialization of inputB pointer */
;;;424        pScr2 = py;
;;;425    
;;;426        pScratch1 += 1u;
0001fc  9c01              LDR      r4,[sp,#4]
0001fe  1c40              ADDS     r0,r0,#1              ;421
000200  9000              STR      r0,[sp,#0]            ;424
000202  980f              LDR      r0,[sp,#0x3c]
000204  1c80              ADDS     r0,r0,#2
000206  1e52              SUBS     r2,r2,#1
000208  900f              STR      r0,[sp,#0x3c]
                  |L1.522|
00020a  2a00              CMP      r2,#0                 ;386
00020c  d1d2              BNE      |L1.436|
;;;427    
;;;428      }
;;;429    
;;;430    }
00020e  b005              ADD      sp,sp,#0x14
000210  e8bd8ff0          POP      {r4-r11,pc}
;;;431    
                          ENDP


;*** Start embedded assembler ***

#line 1 "src\\FilteringFunctions\\arm_conv_opt_q7.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___17_arm_conv_opt_q7_c_efaa8f5c____REV16|
#line 129 ".\\inc\\core_cmInstr.h"
|__asm___17_arm_conv_opt_q7_c_efaa8f5c____REV16| PROC
#line 130

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___17_arm_conv_opt_q7_c_efaa8f5c____REVSH|
#line 144
|__asm___17_arm_conv_opt_q7_c_efaa8f5c____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___17_arm_conv_opt_q7_c_efaa8f5c____RRX|
#line 300
|__asm___17_arm_conv_opt_q7_c_efaa8f5c____RRX| PROC
#line 301

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
